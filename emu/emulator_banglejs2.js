

// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module != 'undefined' ? Module : {};

// See https://caniuse.com/mdn-javascript_builtins_object_assign

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// {{PRE_JSES}}

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

// Attempt to auto-detect the environment
var ENVIRONMENT_IS_WEB = typeof window == 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
var ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (Module['ENVIRONMENT']) {
  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');
}

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary,
    setWindowTitle;

// Normally we don't log exceptions but instead let them bubble out the top
// level where the embedding environment (e.g. the browser) can handle
// them.
// However under v8 and node we sometimes exit the process direcly in which case
// its up to use us to log the exception before exiting.
// If we fix https://github.com/emscripten-core/emscripten/issues/15080
// this may no longer be needed under node.
function logExceptionOnExit(e) {
  if (e instanceof ExitStatus) return;
  let toLog = e;
  if (e && typeof e == 'object' && e.stack) {
    toLog = [e, e.stack];
  }
  err('exiting due to exception: ' + toLog);
}

var fs;
var nodePath;
var requireNodeFS;

if (ENVIRONMENT_IS_NODE) {
  if (!(typeof process == 'object' && typeof require == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');
  if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = require('path').dirname(scriptDirectory) + '/';
  } else {
    scriptDirectory = __dirname + '/';
  }

// include: node_shell_read.js


requireNodeFS = () => {
  // Use nodePath as the indicator for these not being initialized,
  // since in some environments a global fs may have already been
  // created.
  if (!nodePath) {
    fs = require('fs');
    nodePath = require('path');
  }
};

read_ = function shell_read(filename, binary) {
  var ret = tryParseAsDataURI(filename);
  if (ret) {
    return binary ? ret : ret.toString();
  }
  requireNodeFS();
  filename = nodePath['normalize'](filename);
  return fs.readFileSync(filename, binary ? undefined : 'utf8');
};

readBinary = (filename) => {
  var ret = read_(filename, true);
  if (!ret.buffer) {
    ret = new Uint8Array(ret);
  }
  assert(ret.buffer);
  return ret;
};

readAsync = (filename, onload, onerror) => {
  var ret = tryParseAsDataURI(filename);
  if (ret) {
    onload(ret);
  }
  requireNodeFS();
  filename = nodePath['normalize'](filename);
  fs.readFile(filename, function(err, data) {
    if (err) onerror(err);
    else onload(data.buffer);
  });
};

// end include: node_shell_read.js
  if (process['argv'].length > 1) {
    thisProgram = process['argv'][1].replace(/\\/g, '/');
  }

  arguments_ = process['argv'].slice(2);

  if (typeof module != 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });

  // Without this older versions of node (< v15) will log unhandled rejections
  // but return 0, which is not normally the desired behaviour.  This is
  // not be needed with node v15 and about because it is now the default
  // behaviour:
  // See https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode
  process['on']('unhandledRejection', function(reason) { throw reason; });

  quit_ = (status, toThrow) => {
    if (keepRuntimeAlive()) {
      process['exitCode'] = status;
      throw toThrow;
    }
    logExceptionOnExit(toThrow);
    process['exit'](status);
  };

  Module['inspect'] = function () { return '[Emscripten Module object]'; };

} else
if (ENVIRONMENT_IS_SHELL) {

  if ((typeof process == 'object' && typeof require === 'function') || typeof window == 'object' || typeof importScripts == 'function') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  if (typeof read != 'undefined') {
    read_ = function shell_read(f) {
      const data = tryParseAsDataURI(f);
      if (data) {
        return intArrayToString(data);
      }
      return read(f);
    };
  }

  readBinary = function readBinary(f) {
    let data;
    data = tryParseAsDataURI(f);
    if (data) {
      return data;
    }
    if (typeof readbuffer == 'function') {
      return new Uint8Array(readbuffer(f));
    }
    data = read(f, 'binary');
    assert(typeof data == 'object');
    return data;
  };

  readAsync = function readAsync(f, onload, onerror) {
    setTimeout(() => onload(readBinary(f)), 0);
  };

  if (typeof scriptArgs != 'undefined') {
    arguments_ = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    arguments_ = arguments;
  }

  if (typeof quit == 'function') {
    quit_ = (status, toThrow) => {
      logExceptionOnExit(toThrow);
      quit(status);
    };
  }

  if (typeof print != 'undefined') {
    // Prefer to use print/printErr where they exist, as they usually work better.
    if (typeof console == 'undefined') console = /** @type{!Console} */({});
    console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);
    console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr != 'undefined' ? printErr : print);
  }

} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (typeof document != 'undefined' && document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
  // they are removed because they could contain a slash.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }

  if (!(typeof window == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');

  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {
// include: web_or_worker_shell_read.js


  read_ = (url) => {
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
    } catch (err) {
      var data = tryParseAsDataURI(url);
      if (data) {
        return intArrayToString(data);
      }
      throw err;
    }
  }

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = (url) => {
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
      } catch (err) {
        var data = tryParseAsDataURI(url);
        if (data) {
          return data;
        }
        throw err;
      }
    };
  }

  readAsync = (url, onload, onerror) => {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = () => {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      var data = tryParseAsDataURI(url);
      if (data) {
        onload(data.buffer);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  }

// end include: web_or_worker_shell_read.js
  }

  setWindowTitle = (title) => document.title = title;
} else
{
  throw new Error('environment detection error');
}

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
Object.assign(Module, moduleOverrides);
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;
checkIncomingModuleAPI();

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];legacyModuleProp('arguments', 'arguments_');

if (Module['thisProgram']) thisProgram = Module['thisProgram'];legacyModuleProp('thisProgram', 'thisProgram');

if (Module['quit']) quit_ = Module['quit'];legacyModuleProp('quit', 'quit_');

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// Assertions on removed incoming Module JS APIs.
assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['read'] == 'undefined', 'Module.read option was removed (modify read_ in JS)');
assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');
assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');
legacyModuleProp('read', 'read_');
legacyModuleProp('readAsync', 'readAsync');
legacyModuleProp('readBinary', 'readBinary');
legacyModuleProp('setWindowTitle', 'setWindowTitle');
var IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';
var PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';
var WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';
var NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';
function alignMemory() { abort('`alignMemory` is now a library function and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line'); }

assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");




var STACK_ALIGN = 16;
var POINTER_SIZE = 4;

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': case 'u8': return 1;
    case 'i16': case 'u16': return 2;
    case 'i32': case 'u32': return 4;
    case 'i64': case 'u64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length - 1] === '*') {
        return POINTER_SIZE;
      } else if (type[0] === 'i') {
        const bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}

// include: runtime_functions.js


// This gives correct answers for everything less than 2^{14} = 16384
// I hope nobody is contemplating functions with 16384 arguments...
function uleb128Encode(n) {
  assert(n < 16384);
  if (n < 128) {
    return [n];
  }
  return [(n % 128) | 128, n >> 7];
}

// Converts a signature like 'vii' into a description of the wasm types, like
// { parameters: ['i32', 'i32'], results: [] }.
function sigToWasmTypes(sig) {
  var typeNames = {
    'i': 'i32',
    'j': 'i64',
    'f': 'f32',
    'd': 'f64',
    'p': 'i32',
  };
  var type = {
    parameters: [],
    results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
  };
  for (var i = 1; i < sig.length; ++i) {
    assert(sig[i] in typeNames, 'invalid signature char: ' + sig[i]);
    type.parameters.push(typeNames[sig[i]]);
  }
  return type;
}

// Wraps a JS function as a wasm function with a given signature.
function convertJsFunctionToWasm(func, sig) {
  return func;
}

var freeTableIndexes = [];

// Weak map of functions in the table to their indexes, created on first use.
var functionsInTableMap;

function getEmptyTableSlot() {
  // Reuse a free index if there is one, otherwise grow.
  if (freeTableIndexes.length) {
    return freeTableIndexes.pop();
  }
  // Grow the table
  try {
    wasmTable.grow(1);
  } catch (err) {
    if (!(err instanceof RangeError)) {
      throw err;
    }
    throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
  }
  return wasmTable.length - 1;
}

function updateTableMap(offset, count) {
  for (var i = offset; i < offset + count; i++) {
    var item = getWasmTableEntry(i);
    // Ignore null values.
    if (item) {
      functionsInTableMap.set(item, i);
    }
  }
}

/**
 * Add a function to the table.
 * 'sig' parameter is required if the function being added is a JS function.
 * @param {string=} sig
 */
function addFunction(func, sig) {
  assert(typeof func != 'undefined');

  // Check if the function is already in the table, to ensure each function
  // gets a unique index. First, create the map if this is the first use.
  if (!functionsInTableMap) {
    functionsInTableMap = new WeakMap();
    updateTableMap(0, wasmTable.length);
  }
  if (functionsInTableMap.has(func)) {
    return functionsInTableMap.get(func);
  }

  // It's not in the table, add it now.

  var ret = getEmptyTableSlot();

  // Set the new value.
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    setWasmTableEntry(ret, func);
  } catch (err) {
    if (!(err instanceof TypeError)) {
      throw err;
    }
    assert(typeof sig != 'undefined', 'Missing signature argument to addFunction: ' + func);
    var wrapped = convertJsFunctionToWasm(func, sig);
    setWasmTableEntry(ret, wrapped);
  }

  functionsInTableMap.set(func, ret);

  return ret;
}

function removeFunction(index) {
  functionsInTableMap.delete(getWasmTableEntry(index));
  freeTableIndexes.push(index);
}

// end include: runtime_functions.js
// include: runtime_debug.js


function legacyModuleProp(prop, newName) {
  if (!Object.getOwnPropertyDescriptor(Module, prop)) {
    Object.defineProperty(Module, prop, {
      configurable: true,
      get: function() {
        abort('Module.' + prop + ' has been replaced with plain ' + newName + ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)');
      }
    });
  }
}

function ignoredModuleProp(prop) {
  if (Object.getOwnPropertyDescriptor(Module, prop)) {
    abort('`Module.' + prop + '` was supplied but `' + prop + '` not included in INCOMING_MODULE_JS_API');
  }
}

function unexportedMessage(sym, isFSSybol) {
  var msg = "'" + sym + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";
  if (isFSSybol) {
    msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';
  }
  return msg;
}

function unexportedRuntimeSymbol(sym, isFSSybol) {
  if (!Object.getOwnPropertyDescriptor(Module, sym)) {
    Object.defineProperty(Module, sym, {
      configurable: true,
      get: function() {
        abort(unexportedMessage(sym, isFSSybol));
      }
    });
  }
}

function unexportedRuntimeFunction(sym, isFSSybol) {
  if (!Object.getOwnPropertyDescriptor(Module, sym)) {
    Module[sym] = () => abort(unexportedMessage(sym, isFSSybol));
  }
}

// end include: runtime_debug.js
var tempRet0 = 0;
var setTempRet0 = (value) => { tempRet0 = value; };
var getTempRet0 = () => tempRet0;



// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var wasmBinary;
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];legacyModuleProp('wasmBinary', 'wasmBinary');
var noExitRuntime = Module['noExitRuntime'] || true;legacyModuleProp('noExitRuntime', 'noExitRuntime');

// include: wasm2js.js


// wasm2js.js - enough of a polyfill for the WebAssembly object so that we can load
// wasm2js code that way.

// Emit "var WebAssembly" if definitely using wasm2js. Otherwise, in MAYBE_WASM2JS
// mode, we can't use a "var" since it would prevent normal wasm from working.
/** @suppress{duplicate, const} */
var
WebAssembly = {
  // Note that we do not use closure quoting (this['buffer'], etc.) on these
  // functions, as they are just meant for internal use. In other words, this is
  // not a fully general polyfill.
  /** @constructor */
  Memory: function(opts) {
    this.buffer = new ArrayBuffer(opts['initial'] * 65536);
  },

  Module: function(binary) {
    // TODO: use the binary and info somehow - right now the wasm2js output is embedded in
    // the main JS
  },

  /** @constructor */
  Instance: function(module, info) {
    // TODO: use the module and info somehow - right now the wasm2js output is embedded in
    // the main JS
    // This will be replaced by the actual wasm2js code.
    this.exports = (
// EMSCRIPTEN_START_ASM
function instantiate(asmLibraryArg) {
function Table(ret) {
  // grow method not included; table is not growable
  ret.set = function(i, func) {
    this[i] = func;
  };
  ret.get = function(i) {
    return this[i];
  };
  return ret;
}

  var bufferView;
  var base64ReverseLookup = new Uint8Array(123/*'z'+1*/);
  for (var i = 25; i >= 0; --i) {
    base64ReverseLookup[48+i] = 52+i; // '0-9'
    base64ReverseLookup[65+i] = i; // 'A-Z'
    base64ReverseLookup[97+i] = 26+i; // 'a-z'
  }
  base64ReverseLookup[43] = 62; // '+'
  base64ReverseLookup[47] = 63; // '/'
  /** @noinline Inlining this function would mean expanding the base64 string 4x times in the source code, which Closure seems to be happy to do. */
  function base64DecodeToExistingUint8Array(uint8Array, offset, b64) {
    var b1, b2, i = 0, j = offset, bLength = b64.length, end = offset + (bLength*3>>2) - (b64[bLength-2] == '=') - (b64[bLength-1] == '=');
    for (; i < bLength; i += 4) {
      b1 = base64ReverseLookup[b64.charCodeAt(i+1)];
      b2 = base64ReverseLookup[b64.charCodeAt(i+2)];
      uint8Array[j++] = base64ReverseLookup[b64.charCodeAt(i)] << 2 | b1 >> 4;
      if (j < end) uint8Array[j++] = b1 << 4 | b2 >> 2;
      if (j < end) uint8Array[j++] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i+3)];
    }
  }
function initActiveSegments(imports) {
  base64DecodeToExistingUint8Array(bufferView, 1024, "lLcB");
  base64DecodeToExistingUint8Array(bufferView, 1040, "MAAAAC5ib290MA==");
  base64DecodeToExistingUint8Array(bufferView, 1072, "CmV2YWwocmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWQo0Q1ib290dXBkYXRlLmpzKSk72QIAAC5ib290Y2Rl");
  base64DecodeToExistingUint8Array(bufferView, 1152, "CqxzPXJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRDHNldHRpbmcuanNvbiwxKaB7fTsKoyhnbG9iYWwuX19GSUxFX1+eIXMuY2xvY2tIYXNXaWRnZXRzKXtsb2FkKCk7sNElQ2xvY2sgaGFzIG5vIHdpZGdldHMsIGNhbid0IGZhc3QgbG9hZDt9CqxfY2xrQXBwPXJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkKHMuY2xvY2spOwqjKCFfY2xrQXBwKXtfY2xrQXBwPXJlcXVpcmUo0QdTdG9yYWdlKS5saXN0KC9cLmluZm8kLykubWFwKGZpbGWie65hcHA9cmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWRKU09OKGZpbGUsMSk7oyhhcHCeYXBwLnR5cGWK0QVjbG9jayl7q2FwcDt9fSkuZmlsdGVyKHiieCkuc29ydCgoYSxiKaJhLnNvcnRvcmRlci1iLnNvcnRvcmRlcilbMF07oyhfY2xrQXBwKXtzLmNsb2NrPV9jbGtBcHAuc3JjO19jbGtBcHA9cmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWQoX2Nsa0FwcC5zcmMpO3MuY2xvY2tIYXNXaWRnZXRzPV9jbGtBcHAuaW5jbHVkZXMo0RJCYW5nbGUubG9hZFdpZGdldHMpO3JlcXVpcmUo0QdTdG9yYWdlKS53cml0ZUpTT04o0QxzZXR0aW5nLmpzb24scyk7fX0KvnM7CqMoIV9jbGtBcHApX2Nsa0FwcD1gRS5zaG93TWVzc2FnZSgiTm8gQ2xvY2sgRm91bmQiKTtzZXRXYXRjaCgoKT0+e0JhbmdsZS5zaG93TGF1bmNoZXIoKTt9LCBnbG9iYWwuQlROMnx8QlROLCB7cmVwZWF0OmZhbHNlLGVkZ2U6ImZhbGxpbmcifSk7YDsKZXZhbChfY2xrQXBwKTsKvl9jbGtBcHA7////Cx0AAGJvb3R1cGRhdGUuanM=");
  base64DecodeToExistingUint8Array(bufferView, 1916, "e0Uuc2hvd01lc3NhZ2Uo0RFVcGRhdGluZyBib290MC4uLik7rXM9cmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWRKU09OKNEMc2V0dGluZy5qc29uLDEpoHt9O65GV1ZFUlNJT049cGFyc2VGbG9hdChwcm9jZXNzLmVudi5WRVJTSU9OLnJlcGxhY2Uo0QF2LCIiKS5yZXBsYWNlKC9cLihcZFxkKSQvLNEELjAkMSkpO65ERUJVRz1zLmJvb3REZWJ1ZzutYm9vdD0iIixib290UG9zdD0iIjujKERFQlVHKXtib290ltETdmFyIF90bT1EYXRlLm5vdygpCjtib290UG9zdJbRC2RlbGV0ZSBfdG07O32jKEZXVkVSU0lPTjwyMTYpe0Uuc2hvd01lc3NhZ2Uo0SxQbGVhc2UgdXBkYXRlIEJhbmdsZS5qcyBmaXJtd2FyZQoKQ3VycmVudCA9ICtwcm9jZXNzLmVudi5WRVJTSU9OLHt0aXRsZTrRBUVSUk9SfSk7sLhFcnJvcijRDE9sZCBmaXJtd2FyZSk7fa1DUkM9RS5DUkMzMihyZXF1aXJlKNEHU3RvcmFnZSkucmVhZCjRDHNldHRpbmcuanNvbikpK3JlcXVpcmUo0QdTdG9yYWdlKS5oYXNoKC9cLmpzJC8pK0UuQ1JDMzIocHJvY2Vzcy5lbnYuR0lUX0NPTU1JVCk7Ym9vdJZgaWYoRS5DUkMzMihyZXF1aXJlKCdTdG9yYWdlJykucmVhZCgnc2V0dGluZy5qc29uJykpK3JlcXVpcmUoJ1N0b3JhZ2UnKS5oYXNoKC9cXC5qcyQvKStFLkNSQzMyKHByb2Nlc3MuZW52LkdJVF9DT01NSVQpIT0ke0NSQ30pYDtib290lmB7ZXZhbChyZXF1aXJlKCdTdG9yYWdlJykucmVhZCgnYm9vdHVwZGF0ZS5qcycpKTt9ZWxzZXtcbmA7Ym9vdJZgRS5zZXRGbGFncyh7cHJldG9rZW5pc2U6MX0pO1xuYDtib290lmB2YXIgYmxlU2VydmljZXMgPSB7fSwgYmxlU2VydmljZU9wdGlvbnMgPSB7IHVhcnQgOiB0cnVlfTtcbmA7Ym9vdFBvc3SWYE5SRi5zZXRTZXJ2aWNlcyhibGVTZXJ2aWNlcyxibGVTZXJ2aWNlT3B0aW9ucyk7ZGVsZXRlIGJsZVNlcnZpY2VzLGJsZVNlcnZpY2VPcHRpb25zO1xuYDujKHMuYmxljbUpewqjKHMuSElEKXujKHMuSElEitEDam95KWJvb3SWYEJhbmdsZS5ISUQgPSBFLnRvVWludDhBcnJheShhdG9iKCJCUUVKQktFQkNRR2hBQVVKR1FFcEJSVUFKUUdWQlhVQmdRS1ZBM1VCZ1FNRkFRa3dDVEVWZ1NWL2RRaVZBb0VDd01BPSIpKTtgO6SjKHMuSElEitEDY29tKWJvb3SWYEJhbmdsZS5ISUQgPSBFLnRvVWludDhBcnJheShhdG9iKCJCUUVKQXFFQmhRRUpBYUVBQlFrWkFTa0ZGUUFsQVpVRmRRR0JBcFVCZFFPQkF3VUJDVEFKTVFrNEZZRWxmM1VJbFFPQkJnVU1DamdDRllFbGYzVUlsUUdCQnNEQUJRRUpCcUVCaFFJRkJ4bmdLZWNWQUNVQmRRR1ZDSUVDZFFpVkFZRUJHUUFwY3hVQUpYT1ZCWFVJZ1FEQSIpKTtgpKMocy5ISUSK0QJrYilib290lmBCYW5nbGUuSElEID0gRS50b1VpbnQ4QXJyYXkoYXRvYigiQlFFSkJxRUJCUWNaNENubkZRQWxBWFVCbFFpQkFwVUJkUWlCQVpVRmRRRUZDQmtCS1FXUkFwVUJkUU9SQVpVR2RRZ1ZBQ1Z6QlFjWkFDbHpnUUFKQlJVQUp2OEFkUWlWQXJFQ3dBPT0iKSk7YKRib290lmBCYW5nbGUuSElEID0gRS50b1VpbnQ4QXJyYXkoYXRvYigiQlFFSkJxRUJoUUlGQnhuZ0tlY1ZBQ1VCZFFHVkNJRUNsUUYxQ0lFQmxRVjFBUVVJR1FFcEJaRUNsUUYxQTVFQmxRWjFDQlVBSlhNRkJ4a0FLWE9CQUFrRkZRQW0vd0IxQ0pVQ3NRTEFCUXdKQWFFQmhRRVZBQ1VCZFFHVkFRbTFnUUlKdG9FQ0NiZUJBZ200Z1FJSnpZRUNDZUtCQWducGdRSUo2b0VDd0E9PSIpKTtgO2Jvb3SWYGJsZVNlcnZpY2VPcHRpb25zLmhpZD1CYW5nbGUuSElEO1xuYDt9Cn2jKHMuYmxlcmVwbIu1KXsKoyhzLmxvZ5EyKXtib290lmBfREJHTE9HPXJlcXVpcmUoIlN0b3JhZ2UiKS5vcGVuKCJsb2cudHh0IiwiYSIpOwpMb29wYmFja0Iub24oJ2RhdGEnLGZ1bmN0aW9uKGQpIHtfREJHTE9HLndyaXRlKGQpOyR7KHMubG9nijMpP9ESVGVybWluYWwud3JpdGUoZCk7OiIifX0pOwpMb29wYmFja0Euc2V0Q29uc29sZSh0cnVlKTtcbmA7Cn2koyhzLmxvZ4oxKWJvb3SWYFRlcm1pbmFsLnNldENvbnNvbGUodHJ1ZSk7XG5gO6Rib290lmBFLnNldENvbnNvbGUobnVsbCx7Zm9yY2U6dHJ1ZX0pO1xuYDtib290lmAKQmx1ZXRvb3RoLmxpbmU9IiI7CkJsdWV0b290aC5vbignZGF0YScsZnVuY3Rpb24oZCkgewogIGxldCBsID0gKEJsdWV0b290aC5saW5lICsgZCkuc3BsaXQoL1tcXG5cXHJdLyk7CiAgQmx1ZXRvb3RoLmxpbmUgPSBsLnBvcCgpOwogIGwuZm9yRWFjaChuPT5CbHVldG9vdGguZW1pdCgibGluZSIsbikpOwp9KTsKQmx1ZXRvb3RoLm9uKCdsaW5lJyxmdW5jdGlvbihsKSB7CiAgaWYgKGwuc3RhcnRzV2l0aCgnXHgxMCcpKSBsPWwuc2xpY2UoMSk7CiAgaWYgKGwuc3RhcnRzV2l0aCgnR0IoeycpICYmIGwuZW5kc1dpdGgoJ30pJykgJiYgZ2xvYmFsLkdCKQogICAgdHJ5IHsgZ2xvYmFsLkdCKEpTT04ucGFyc2UobC5zbGljZSgzLC0xKSkpOyB9IGNhdGNoKGUpIHt9Cn0pO1xuYDt9pHujKHMubG9nkTIpYm9vdJZgX0RCR0xPRz1yZXF1aXJlKCJTdG9yYWdlIikub3BlbigibG9nLnR4dCIsImEiKTsKTG9vcGJhY2tCLm9uKCdkYXRhJyxmdW5jdGlvbihkKSB7X0RCR0xPRy53cml0ZShkKTskeyhzLmxvZ4ozKT/RElRlcm1pbmFsLndyaXRlKGQpOzoiIn19KTsKaWYgKCFOUkYuZ2V0U2VjdXJpdHlTdGF0dXMoKS5jb25uZWN0ZWQpIExvb3BiYWNrQS5zZXRDb25zb2xlKCk7XG5gO6SjKHMubG9nijEpYm9vdJZgaWYgKCFOUkYuZ2V0U2VjdXJpdHlTdGF0dXMoKS5jb25uZWN0ZWQpIFRlcm1pbmFsLnNldENvbnNvbGUoKTtcbmA7pGJvb3SWYEJsdWV0b290aC5zZXRDb25zb2xlKHRydWUpO1xuYDt9oyhzLmJsZYu1KWJvb3SWYGlmICghTlJGLmdldFNlY3VyaXR5U3RhdHVzKCkuY29ubmVjdGVkKSBOUkYuc2xlZXAoKTtcbmA7oyhzLnRpbWVvdXSNtylib290lmBCYW5nbGUuc2V0TENEVGltZW91dCgke3MudGltZW91dH0pO1xuYDujKCFzLnRpbWVvdXQpYm9vdJZgQmFuZ2xlLnNldExDRFBvd2VyKDEpO1xuYDtib290lmBFLnNldFRpbWVab25lKCR7cy50aW1lem9uZX0pO2A7oyhzLmxvZylib290lmBFLm9uKCdlcnJvckZsYWcnLCBmdW5jdGlvbihlcnJvckZsYWdzKSB7CiAgZy5yZXNldCgxKS5zZXRDb2xvcigiI2ZmMDAwMCIpLnNldEZvbnQoIjZ4OCIpLnNldEZvbnRBbGlnbigwLDEpLmRyYXdTdHJpbmcoZXJyb3JGbGFncyxnLmdldFdpZHRoKCkvMixnLmdldEhlaWdodCgpLTEpLmZsaXAoKTsKICBwcmludCgiSW50ZXJwcmV0ZXIgZXJyb3I6IiwgZXJyb3JGbGFncyk7CiAgRS5nZXRFcnJvckZsYWdzKCk7Cn0pO1xuYDujKGdsb2JhbC5zYXZlKWJvb3SWYGdsb2JhbC5zYXZlID0gZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcigiWW91IGNhbid0IHVzZSBzYXZlKCkgb24gQmFuZ2xlLmpzIHdpdGhvdXQgb3ZlcndyaXRpbmcgdGhlIGJvb3Rsb2FkZXIhIik7IH1cbmA7oyhzLm9wdGlvbnMpYm9vdJZgQmFuZ2xlLnNldE9wdGlvbnMoJHtFLnRvSlMocy5vcHRpb25zKX0pO1xuYDujKHMuYnJpZ2h0bmVzc55zLmJyaWdodG5lc3OMMSlib290lmBCYW5nbGUuc2V0TENEQnJpZ2h0bmVzcygke3MuYnJpZ2h0bmVzc30pO1xuYDujKHMuYmxlcHJpdmFjeaAocy5wYXNza2V5jbeecy5wYXNza2V5Lmxlbmd0aIo2KSl7rXBhc3NrZXk9cy5wYXNza2V5P2BwYXNza2V5OiR7RS50b0pTKHMucGFzc2tleS50b1N0cmluZygpKX0sZGlzcGxheToxLG1pdG06MSxgOiIiO61wcml2YWN5PXMuYmxlcHJpdmFjeT9gcHJpdmFjeToke0UudG9KUyhzLmJsZXByaXZhY3kpfSxgOiIiO2Jvb3SWYE5SRi5zZXRTZWN1cml0eSh7JHtwYXNza2V5fSR7cHJpdmFjeX19KTtcbmA7faMocy5ibGVuYW1li7UpYm9vdJZgTlJGLnNldEFkdmVydGlzaW5nKHt9LHtzaG93TmFtZTpmYWxzZX0pO1xuYDujKHMud2hpdGVsaXN0niFzLndoaXRlbGlzdF9kaXNhYmxlZClib290lmBOUkYub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbihhZGRyKSB7IGlmICghTlJGLmlnbm9yZVdoaXRlbGlzdCkgeyBsZXQgd2hpdGVsaXN0ID0gKHJlcXVpcmUoJ1N0b3JhZ2UnKS5yZWFkSlNPTignc2V0dGluZy5qc29uJywxKXx8e30pLndoaXRlbGlzdDsgaWYgKE5SRi5yZXNvbHZlQWRkcmVzcyAhPT0gdW5kZWZpbmVkKSB7IGxldCByZXNvbHZlZEFkZHIgPSBOUkYucmVzb2x2ZUFkZHJlc3MoYWRkcik7IGlmIChyZXNvbHZlZEFkZHIgIT09IHVuZGVmaW5lZCkgYWRkciA9IHJlc29sdmVkQWRkciArICIgKHJlc29sdmVkKSI7IH0gaWYgKCF3aGl0ZWxpc3QuaW5jbHVkZXMoYWRkcikpIE5SRi5kaXNjb25uZWN0KCk7IH19KTtcbmA7oyhzLnJvdGF0ZSlib290lmBnLnNldFJvdGF0aW9uKCR7cy5yb3RhdGUmM30sJHtzLnJvdGF0ZZIyfSk7XG5gYm9vdJZgQmFuZ2xlLmxvYWRXaWRnZXRzPWZ1bmN0aW9uKCl7aWYoIWdsb2JhbC5XSURHRVRTKWV2YWwocmVxdWlyZSgiU3RvcmFnZSIpLnJlYWQoIi53aWRjYWNoZSIpKX07XG5gO75CYW5nbGUuc2hvd0Nsb2NrO6MoIUJhbmdsZS5zaG93Q2xvY2spYm9vdJZgQmFuZ2xlLnNob3dDbG9jayA9ICgpPT57bG9hZCgiLmJvb3RjZGUiKX07XG5gO75CYW5nbGUubG9hZDujKCFCYW5nbGUubG9hZClib290lmBCYW5nbGUubG9hZCA9IGxvYWQ7XG5gO6MoREVCVUcpYm9vdJZgcHJpbnQoIi5ib290MCIsMHwoRGF0ZS5ub3coKS1fdG0pLCJtcyIpO190bT1EYXRlLm5vdygpO1xuYK1ib290RmlsZXM9cmVxdWlyZSjRB1N0b3JhZ2UpLmxpc3QoL1wuYm9vdFwuanMkLykuc29ydCgoYSxiKaJ7rWdldFByaW9yaXR5PS8uKlwuKFxkKylcLmJvb3RcLmpzJC87rWFQcmlvcml0eT1hLm1hdGNoKGdldFByaW9yaXR5KTutYlByaW9yaXR5PWIubWF0Y2goZ2V0UHJpb3JpdHkpO6MoYVByaW9yaXR5nmJQcmlvcml0eSl7q3BhcnNlSW50KGFQcmlvcml0eVsxXSktcGFyc2VJbnQoYlByaW9yaXR5WzFdKTt9pKMoYVByaW9yaXR5niFiUHJpb3JpdHkpe6stMTt9pKMoIWFQcmlvcml0eZ5iUHJpb3JpdHkpe6sxO32rYYpiPzA6KGE+Yj8xOi0xKTt9KTtib290UG9zdJbRAX07rWZpbGVPZmZzZXQsZmlsZVNpemU7rW91dHB1dEZpbGU9KGRzdCxzcmMscHJlLHBvc3QponvRA3JhbTujKERFQlVHKXujKGRzdClyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGUoZHN0LGAvLyR7c3JjfVxuYCxmaWxlT2Zmc2V0KTtmaWxlT2Zmc2V0ljIrc3JjLmxlbmd0aCsxO32jKHByZSl7oyhkc3QpcmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlKGRzdCxwcmUsZmlsZU9mZnNldCk7ZmlsZU9mZnNldJZwcmUubGVuZ3RoO32tZj1yZXF1aXJlKNEHU3RvcmFnZSkucmVhZChzcmMpO6Moc3JjLmVuZHNXaXRoKNEKY2xraW5mby5qcymeZlswXYzRASgpe2Y9YGV2YWwocmVxdWlyZSgnU3RvcmFnZScpLnJlYWQoJHtFLnRvSlMoc3JjKX0pKWA7faMoZHN0KXutbGVuPWYubGVuZ3RoO61vZmZzZXQ9MDumKGxlbil7rWNodW5rPU1hdGgubWluKGxlbiwyMDQ4KTtyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGUoZHN0LGYuc3Vic3RyKG9mZnNldCxjaHVuayksZmlsZU9mZnNldCk7ZmlsZU9mZnNldJZjaHVuaztvZmZzZXSWY2h1bms7bGVul2NodW5rO319pGZpbGVPZmZzZXSWZi5sZW5ndGg7oyhkc3QpcmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlKGRzdCxwb3N0LGZpbGVPZmZzZXQpO2ZpbGVPZmZzZXSWcG9zdC5sZW5ndGg7oyhERUJVRyl7oyhkc3QpcmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlKGRzdCxgcHJpbnQoJHtFLnRvSlMoc3JjKX0sMHwoRGF0ZS5ub3coKS1fdG0pLCJtcyIpO190bT1EYXRlLm5vdygpO1xuYCxmaWxlT2Zmc2V0KTtmaWxlT2Zmc2V0ljQ4K0UudG9KUyhzcmMpLmxlbmd0aDt9fTutb3V0cHV0RmlsZUNvbXBsZXRlPShkc3QsZm4pontvdXRwdXRGaWxlKGRzdCxmbiwiIizRAjsKKTt9O2ZpbGVPZmZzZXQ9Ym9vdC5sZW5ndGgrYm9vdFBvc3QubGVuZ3RoO2Jvb3RGaWxlcy5mb3JFYWNoKGZuom91dHB1dEZpbGVDb21wbGV0ZSi3LGZuKSk7ZmlsZVNpemU9ZmlsZU9mZnNldDtyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGUo0QYuYm9vdDAsYm9vdCwwLGZpbGVTaXplKTtmaWxlT2Zmc2V0PWJvb3QubGVuZ3RoO2Jvb3RGaWxlcy5mb3JFYWNoKGZuom91dHB1dEZpbGVDb21wbGV0ZSjRBi5ib290MCxmbikpO3JlcXVpcmUo0QdTdG9yYWdlKS53cml0ZSjRBi5ib290MCxib290UG9zdCxmaWxlT2Zmc2V0KTu+Ym9vdCxib290UG9zdCxib290RmlsZXM7rXdpZGdldEZpbGVzPXJlcXVpcmUo0QdTdG9yYWdlKS5saXN0KC9cLndpZFwuanMkLyk7rXdpZGdldD1gLy8gTWFkZSBieSBib290dXBkYXRlLmpzXG5nbG9iYWwuV0lER0VUUz17fTtgLHdpZGdldFBvc3Q9YHZhciBXPVdJREdFVFM7V0lER0VUUz17fTsKT2JqZWN0LmtleXMoVykuc29ydCgoYSxiKT0+KDB8V1tiXS5zb3J0b3JkZXIpLSgwfFdbYV0uc29ydG9yZGVyKSkuZm9yRWFjaChrPT5XSURHRVRTW2tdPVdba10pO2A7oyhERUJVRyl3aWRnZXSW0RN2YXIgX3RtPURhdGUubm93KCk7O291dHB1dEZpbGVDb21wbGV0ZT0oZHN0LGZuKaJ7b3V0cHV0RmlsZShkc3QsZm4s0QR0cnl7LGB9Y2F0Y2goZSl7cHJpbnQoJHtFLnRvSlMoZm4pfSxlLGUuc3RhY2spfVxuYCk7fTtmaWxlT2Zmc2V0PXdpZGdldC5sZW5ndGgrd2lkZ2V0UG9zdC5sZW5ndGg7d2lkZ2V0RmlsZXMuZm9yRWFjaChmbqJvdXRwdXRGaWxlQ29tcGxldGUotyxmbikpO2ZpbGVTaXplPWZpbGVPZmZzZXQ7cmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlKNEJLndpZGNhY2hlLHdpZGdldCwwLGZpbGVTaXplKTtmaWxlT2Zmc2V0PXdpZGdldC5sZW5ndGg7d2lkZ2V0RmlsZXMuZm9yRWFjaChmbqJvdXRwdXRGaWxlQ29tcGxldGUo0Qkud2lkY2FjaGUsZm4pKTtyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGUo0Qkud2lkY2FjaGUsd2lkZ2V0UG9zdCxmaWxlT2Zmc2V0KTu+d2lkZ2V0LHdpZGdldFBvc3Qsd2lkZ2V0RmlsZXM7rWNpRmlsZXM9cmVxdWlyZSjRB1N0b3JhZ2UpLmxpc3QoL1wuY2xraW5mb1wuanMkLyk7rWNpPWAvLyBNYWRlIGJ5IGJvb3R1cGRhdGUuanNcbmA7oyhERUJVRyljaZbRE3ZhciBfdG09RGF0ZS5ub3coKTs7b3V0cHV0RmlsZUNvbXBsZXRlPShkc3QsZm4pontvdXRwdXRGaWxlKGRzdCxmbizRC3RyeXtsZXQgZm49LGA7bGV0IGE9Zm4oKSxiPW1lbnUuZmluZCh4PT54Lm5hbWU9PT1hLm5hbWUpO2lmKGIpYi5pdGVtcz1iLml0ZW1zLmNvbmNhdChhLml0ZW1zKWVsc2UgbWVudT1tZW51LmNvbmNhdChhKTt9Y2F0Y2goZSl7cHJpbnQoJHtFLnRvSlMoZm4pfSxlLGUuc3RhY2spfVxuYCk7fTtmaWxlT2Zmc2V0PWNpLmxlbmd0aDtjaUZpbGVzLmZvckVhY2goZm6ib3V0cHV0RmlsZUNvbXBsZXRlKLcsZm4pKTtmaWxlU2l6ZT1maWxlT2Zmc2V0O3JlcXVpcmUo0QdTdG9yYWdlKS53cml0ZSjRDS5jbGtpbmZvY2FjaGUsY2ksMCxmaWxlU2l6ZSk7ZmlsZU9mZnNldD1jaS5sZW5ndGg7Y2lGaWxlcy5mb3JFYWNoKGZuom91dHB1dEZpbGVDb21wbGV0ZSjRDS5jbGtpbmZvY2FjaGUsZm4pKTu+Y2ksY2lGaWxlcztFLnNob3dNZXNzYWdlKNEMUmVsb2FkaW5nLi4uKTt9ZXZhbChyZXF1aXJlKNEHU3RvcmFnZSkucmVhZCjRBi5ib290MCkpO/++AAAAYm9vdC5pbmZv");
  base64DecodeToExistingUint8Array(bufferView, 9384, "eyJpZCI6ImJvb3QiLCJuYW1lIjoiQm9vdGxvYWRlciIsInR5cGUiOiJib290bG9hZGVyIiwic29ydG9yZGVyIjotMTAsInZlcnNpb24iOiIwLjY1IiwidGFncyI6InRvb2wsc3lzdGVtIiwiZmlsZXMiOiJib290LmluZm8sLmJvb3QwLC5ib290Y2RlLGJvb3R1cGRhdGUuanMiLCJkYXRhIjoiLndpZGNhY2hlLC5jbGtpbmZvY2FjaGUiff//dwcAAGxhdW5jaC5hcHAuanM=");
  base64DecodeToExistingUint8Array(bufferView, 9608, "e61zPXJlcXVpcmUo0QdTdG9yYWdlKTutc2NhbGV2YWw9MTutdmVjdG9ydmFsPTIwO61mb250PWcuZ2V0Rm9udHMoKS5pbmNsdWRlcyjRBTEyeDIwKT/RBTEyeDIwOtEFNng4OjI7rXNldHRpbmdzPU9iamVjdC5hc3NpZ24oe3Nob3dDbG9ja3M6tCxmdWxsc2NyZWVuOrV9LHMucmVhZEpTT04o0QtsYXVuY2guanNvbiy0KaB7fSk7oyjRCnZlY3RvcnNpemW5c2V0dGluZ3MpdmVjdG9ydmFsPXBhcnNlSW50KHNldHRpbmdzLnZlY3RvcnNpemUpO6Mo0QRmb250uXNldHRpbmdzKXujKHNldHRpbmdzLmZvbnSK0QZWZWN0b3Ipe3NjYWxldmFsPXZlY3RvcnZhbC8yMDtmb250PdEGVmVjdG9yKyh2ZWN0b3J2YWwpLnRvU3RyaW5nKCk7faR7Zm9udD1zZXR0aW5ncy5mb250O3NjYWxldmFsPShmb250LnNwbGl0KNEBeClbMV0pLzIwO319rWxhdW5jaENhY2hlPXMucmVhZEpTT04o0RFsYXVuY2guY2FjaGUuanNvbiy0KaB7fTutbGF1bmNoSGFzaD1yZXF1aXJlKNEHU3RvcmFnZSkuaGFzaCgvXC5pbmZvLyk7oyhsYXVuY2hDYWNoZS5oYXNojGxhdW5jaEhhc2gpe2xhdW5jaENhY2hlPXtoYXNoOmxhdW5jaEhhc2gsYXBwczpzLmxpc3QoL1wuaW5mbyQvKS5tYXAoYXBwonusYT1zLnJlYWRKU09OKGFwcCwxKTurYZ57bmFtZTphLm5hbWUsdHlwZTphLnR5cGUsaWNvbjphLmljb24sc29ydG9yZGVyOmEuc29ydG9yZGVyLHNyYzphLnNyY307fSkuZmlsdGVyKGFwcKJhcHCeKGFwcC50eXBlitEDYXBwoChhcHAudHlwZYrRBWNsb2NrnnNldHRpbmdzLnNob3dDbG9ja3MpoCFhcHAudHlwZSkpLnNvcnQoKGEsYimie6xuPSgwfGEuc29ydG9yZGVyKS0oMHxiLnNvcnRvcmRlcik7oyhuKatuO6MoYS5uYW1lPGIubmFtZSmrLTE7oyhhLm5hbWU+Yi5uYW1lKasxO6swO30pfTtzLndyaXRlSlNPTijREWxhdW5jaC5jYWNoZS5qc29uLGxhdW5jaENhY2hlKTt9rWFwcHM9bGF1bmNoQ2FjaGUuYXBwczujKCFzZXR0aW5ncy5mdWxsc2NyZWVuKUJhbmdsZS5sb2FkV2lkZ2V0cygpO65kcmF3TWVudT0oKaJ7RS5zaG93U2Nyb2xsZXIoe2g6NjQqc2NhbGV2YWwsYzphcHBzLmxlbmd0aCxkcmF3OihpLHIponusYXBwPWFwcHNbaV07oyghYXBwKas7Zy5jbGVhclJlY3QoKHIueCksKHIueSksKHIueCtyLnctMSksKHIueStyLmgtMSkpO2cuc2V0Rm9udChmb250KS5zZXRGb250QWxpZ24oLTEsMCkuZHJhd1N0cmluZyhhcHAubmFtZSw2NCpzY2FsZXZhbCxyLnkrKDMyKnNjYWxldmFsKSk7oyhhcHAuaWNvbil7oyghYXBwLmltZylhcHAuaW1nPXMucmVhZChhcHAuaWNvbik7sXtnLmRyYXdJbWFnZShhcHAuaW1nLDgqc2NhbGV2YWwsci55Kyg4KnNjYWxldmFsKSx7c2NhbGU6c2NhbGV2YWx9KTt9Y2F0Y2goZSl7fX19LHNlbGVjdDpponusYXBwPWFwcHNbaV07oyghYXBwKas7oyghYXBwLnNyY6ByZXF1aXJlKNEHU3RvcmFnZSkucmVhZChhcHAuc3JjKYu3KXtFLnNob3dTY3JvbGxlcigpO0Uuc2hvd01lc3NhZ2Uo0RRBcHAgU291cmNlCk5vdCBmb3VuZCk7c2V0VGltZW91dChkcmF3TWVudSwyMDAwKTt9pHtsb2FkKGFwcC5zcmMpO319LGJhY2s6QmFuZ2xlLnNob3dDbG9jayxyZW1vdmU6KCmie6MobG9ja1RpbWVvdXQpY2xlYXJUaW1lb3V0KGxvY2tUaW1lb3V0KTtCYW5nbGUucmVtb3ZlTGlzdGVuZXIo0QRsb2NrLGxvY2tIYW5kbGVyKTt9fSk7Zy5mbGlwKCk7QmFuZ2xlLnNldExvY2tlZCi1KTutbG9ja1RpbWVvdXQ7rWxvY2tIYW5kbGVyPaoobG9ja2VkKXujKGxvY2tUaW1lb3V0KWNsZWFyVGltZW91dChsb2NrVGltZW91dCk7bG9ja1RpbWVvdXQ9tzujKGxvY2tlZClsb2NrVGltZW91dD1zZXRUaW1lb3V0KEJhbmdsZS5zaG93Q2xvY2ssMTAwMDApO31CYW5nbGUub24o0QRsb2NrLGxvY2tIYW5kbGVyKTt9O2RyYXdNZW51KCk7oyghc2V0dGluZ3MuZnVsbHNjcmVlbilCYW5nbGUuZHJhd1dpZGdldHMoKTt9//ACAABsYXVuY2guc2V0dGluZ3MuanM=");
  base64DecodeToExistingUint8Array(bufferView, 11552, "KKooYmFjayl7rXNldHRpbmdzPU9iamVjdC5hc3NpZ24oe3Nob3dDbG9ja3M6tCxmdWxsc2NyZWVuOrV9LHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRC2xhdW5jaC5qc29uLLQpoHt9KTutZm9udHM9Zy5nZXRGb250cygpO6pzYXZlKGtleSx2YWx1ZSl7c2V0dGluZ3Nba2V5XT12YWx1ZTtyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGUo0QtsYXVuY2guanNvbixzZXR0aW5ncyk7fa5hcHBNZW51PXsiIjp70QV0aXRsZTrRCExhdW5jaGVyfSzRBjwgQmFjazpiYWNrLNEERm9udDp7dmFsdWU6Zm9udHMuaW5jbHVkZXMoc2V0dGluZ3MuZm9udCk/Zm9udHMuaW5kZXhPZihzZXR0aW5ncy5mb250KTpmb250cy5pbmRleE9mKNEFMTJ4MjApLG1pbjowLG1heDpmb250cy5sZW5ndGgtMSxzdGVwOjEsd3JhcDq0LG9uY2hhbmdlOihtKaJ7c2F2ZSjRBGZvbnQsZm9udHNbbV0pfSxmb3JtYXQ6dqJmb250c1t2XX0s0RBWZWN0b3IgRm9udCBTaXplOnt2YWx1ZTpzZXR0aW5ncy52ZWN0b3JzaXploDEwLG1pbjoxMCxtYXg6MjAsc3RlcDoxLHdyYXA6tCxvbmNoYW5nZToobSmie3NhdmUo0Qp2ZWN0b3JzaXplLG0pfX0s0QtTaG93IENsb2Nrczp7dmFsdWU6c2V0dGluZ3Muc2hvd0Nsb2Nrc4q0LG9uY2hhbmdlOihtKaJ7c2F2ZSjRCnNob3dDbG9ja3MsbSl9fSzRCkZ1bGxzY3JlZW46e3ZhbHVlOnNldHRpbmdzLmZ1bGxzY3JlZW6KtCxvbmNoYW5nZToobSmie3NhdmUo0QpmdWxsc2NyZWVuLG0pfX19O0Uuc2hvd01lbnUoYXBwTWVudSk7fSnkAAAAbGF1bmNoLmluZm8=");
  base64DecodeToExistingUint8Array(bufferView, 12336, "eyJpZCI6ImxhdW5jaCIsIm5hbWUiOiJMYXVuY2hlciIsInR5cGUiOiJsYXVuY2giLCJzcmMiOiJsYXVuY2guYXBwLmpzIiwic29ydG9yZGVyIjotMTAsInZlcnNpb24iOiIwLjIxIiwidGFncyI6InRvb2wsc3lzdGVtLGxhdW5jaGVyIiwiZmlsZXMiOiJsYXVuY2guaW5mbyxsYXVuY2guYXBwLmpzLGxhdW5jaC5zZXR0aW5ncy5qcyIsImRhdGEiOiJsYXVuY2guanNvbixsYXVuY2guY2FjaGUuanNvbiJ9ExQAAGFudG9uY2xrLmFwcC5qcw==");
  base64DecodeToExistingUint8Array(bufferView, 12596, "CkdyYXBoaWNzLnByb3RvdHlwZS5zZXRGb250QW50b249qihzY2FsZSl7Zy5zZXRGb250Q3VzdG9tKNL8EA==");
  base64DecodeToExistingUint8Array(bufferView, 12682, "B/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+AAAAAAAAAAB/+");
  base64DecodeToExistingUint8Array(bufferView, 12850, "OAAAAAAAAAAAD+AAAAAAAAAAA/+AAAAAAAAAAf/+AAAAAAAAAH//+AAAAAAAAB///+AAAAAAAA////+AAAAAAAP////+AAAAAAD/////+AAAAAA//////+AAAAAf//////+AAAAH///////+AAAB////////+AAA/////////+AAP/////////8AD/////////+AAD/////////gAAD////////4AAAD///////+AAAAD///////AAAAAD//////wAAAAAD/////8AAAAAAD////+AAAAAAAD////gAAAAAAAD///4AAAAAAAAD//+AAAAAAAAAD//AAAAAAAAAAD/wAAAAAAAAAAD8=");
  base64DecodeToExistingUint8Array(bufferView, 13125, "gA==");
  base64DecodeToExistingUint8Array(bufferView, 13156, "P/////8AAAAAH///////wAAAAf///////8AAAB/////////AAAD/////////gAAH/////////wAAP/////////4AAf/////////8AA//////////+AA//////////+AA//////////+AB///////////AB///////////AB///////////AB///////////AD//wAAAAAH//gD//AAAAAAB//gD/+AAAAAAA//gD/+AAAAAAA//gD/+AAAAAAA//gD//AAAAAAB//gD///////////gB///////////AB///////////AB///////////AB///////////AA//////////+AA//////////+AAf/////////8AAf/////////8AAP/////////4AAH/////////wAAD/////////gAAA////////+AAAAP///////4AAAAB///////g=");
  base64DecodeToExistingUint8Array(bufferView, 13535, "D/4AAAAAAAAAAD/4AAAAAAAAAAH/4AAAAAAAAAAH/4AAAAAAAAAAH/wAAAAAAAAAAP/wAAAAAAAAAAP/gAAAAAAAAAAf/AAAAAAAAAAA//////////4AB//////////4AD//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4AP//////////4A==");
  base64DecodeToExistingUint8Array(bufferView, 13799, "B/+AAAAAf4AAA//+AAAAH/4AAD//+AAAAf/4AAP//+AAAB//4AAf//+AAAH//4AA///+AAAP//4AB///+AAA///4AD///+AAB///4AD///+AAD///4AH///+AAH///4AH///+AAf///4AH///+AA////4AP///+AB////4AP///+AH////4AP///+AP////4AP/8AAAf////4AP/4AAB/////4AP/4AAD/////4AP/4AAP///P/4AP/4AA///8P/4AP/8AP///4P/4AP///////wP/4AP///////AP/4AP//////+AP/4AH//////8AP/4AH//////4AP/4AH//////gAP/4AD//////AAP/4AD/////+AAP/4AB/////4AAP/4AA/////wAAP/4AAf////AAAP/4AAP///8AAAP/4AAD///wAAAP/4AAA///AAAAP/4AAAD/g==");
  base64DecodeToExistingUint8Array(bufferView, 14173, "H/4AAAAAP/AAAH//wAAAA//AAAH//8AAAD//AAAH///AAAH//AAAH///gAAP//AAAH///wAAf//AAAH///4AA///AAAH///4AA///AAAH///8AB///AAAH///8AB///AAAH///+AB///AAAH///+AD///AAAH///+AD///AAAH///+AD///D/8AB///AD//gD/8AAD//AD/+AD/8AAB//AD/+AH/+AAB//AD/+AH/+AAB//AD/+AP//AAD//AD//Af//wAH//AD//////////+AD//////////+AD//////////+AD//////////+AB//////////8AB//////////8AA//////////8AA//////////4AAf/////////wAAf///7/////gAAP///5/////AAAD///w////+AAAB///gf///4AAAAf/+AH///AAAAAA/gAAf/w==");
  base64DecodeToExistingUint8Array(bufferView, 14544, "D/wAAAAAAAAAA//wAAAAAAAAAP//wAAAAAAAAB///wAAAAAAAAf///wAAAAAAAH////wAAAAAAA/////wAAAAAAP/////wAAAAAB//////wAAAAAf//////wAAAAH///////wAAAA////////wAAAP////////wAAA///////H/wAAA//////wH/wAAA/////8AH/wAAA/////AAH/wAAA////gAAH/wAAA///4AAAH/wAAA//+AAAAH/wAAA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gA///////////gAAAAAAAAH/4AAAAAAAAAAH/wAAAAAAAAAAH/wAAAAAAAAAAH/w");
  base64DecodeToExistingUint8Array(bufferView, 14943, "B//8AAA/////+B///AAA/////+B///wAA/////+B///4AA/////+B///8AA/////+B///8AA/////+B///+AA/////+B////AA/////+B////AA/////+B////AA/////+B////gA/////+B////gA/////+B////gA/////+A////gA//gP/gAAB//wA//gf/AAAA//wA//gf/AAAAf/wA//g//AAAAf/wA//g//AAAA//wA//g//gAAA//wA//g//+AAP//wA//g////////gA//g////////gA//g////////gA//g////////gA//g////////AA//gf///////AA//gf//////+AA//gP//////+AA//gH//////8AA//gD//////4AA//gB//////wAA//gA//////AAAAAAAH////8AAAAAAAA////A==");
  base64DecodeToExistingUint8Array(bufferView, 15320, "A//////4AAAAAf///////gAAAB////////4AAAH////////+AAAf/////////AAA//////////gAB//////////wAB//////////4AD//////////4AD//////////4AH//////////8AH//////////8AH//////////8AH//////////8AH//////////+AP/8AA/+AAH/+AP/4AB/8AAD/+AP/4AB/8AAD/+AP/4AD/8AAD/+AP/4AD/+AAH/+AP/8AD//gA//+AP//8D//////+AH//+D//////8AH//+D//////8AH//+D//////8AH//+D//////8AD//+D//////4AD//+B//////4AB//+B//////wAB//+A//////gAA//+A//////AAAf/+Af////+AAAP/+AP////8AAAD/+AD////wAAAAf+AA///+AAAAAAAAAB//A=");
  base64DecodeToExistingUint8Array(bufferView, 15699, "//AAAAAAAAAAA//gAAAAAAAAAA//gAAAAAAAAAA//gAAAAAAADgA//gAAAAAAP/gA//gAAAAAH//gA//gAAAAB///gA//gAAAAP///gA//gAAAD////gA//gAAAf////gA//gAAB/////gA//gAAP/////gA//gAB//////gA//gAH//////gA//gA///////gA//gD///////gA//gf///////gA//h////////gA//n////////gA//////////gAA/////////AAAA////////wAAAA///////4AAAAA///////AAAAAA//////4AAAAAA//////AAAAAAA/////4AAAAAAA/////AAAAAAAA////8AAAAAAAA////gAAAAAAAA///+AAAAAAAAA///4AAAAAAAAA///AAAAAAAAAA//4AAAAAAAAAA/+");
  base64DecodeToExistingUint8Array(bufferView, 16080, "D//gB///wAAAAP//4H///+AAAA///8P////gAAB///+f////4AAD///+/////8AAH/////////+AAH//////////AAP//////////gAP//////////gAf//////////gAf//////////wAf//////////wAf//////////wA///////////wA//4D//wAB//4A//wB//gAA//4A//gA//gAAf/4A//gA//AAAf/4A//gA//gAAf/4A//wB//gAA//4A///P//8AH//4Af//////////wAf//////////wAf//////////wAf//////////wAf//////////gAP//////////gAP//////////AAH//////////AAD/////////+AAD///+/////8AAB///8f////wAAAf//4P////AAAAH//wD///8AAAAA/+AAf//A=");
  base64DecodeToExistingUint8Array(bufferView, 16461, "H//gAAAAAAAAB///+AA/+AAAAP////gA//wAAAf////wA//4AAB/////4A//8AAD/////8A//+AAD/////+A///AAH/////+A///AAP//////A///gAP//////A///gAf//////A///wAf//////A///wAf//////A///wAf//////A///wA///////AB//4A//4AD//AAP/4A//gAB//AAP/4A//gAA//AAP/4A//gAA/+AAP/4A//gAB/8AAP/4A//wAB/8AAf/4Af//////////wAf//////////wAf//////////wAf//////////wAf//////////wAP//////////gAP//////////gAH//////////AAH/////////+AAD/////////8AAB/////////4AAAf////////wAAAP////////AAAAB///////4AAAAAD/////w==");
  base64DecodeToExistingUint8Array(bufferView, 16841, "H/wAAf/AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//AAAAAAP/wAA//");
  base64DecodeToExistingUint8Array(bufferView, 17005, "LDQ2LNENEiAnGicnJycnJycnEyw3OCsoc2NhbGWPOCkrKDGPMTYpKTt9O3utZHJhd1RpbWVvdXQ7rWRyYXc9qigpe6x4PWcuZ2V0V2lkdGgoKS8yO6x5PWcuZ2V0SGVpZ2h0KCkvMjtnLnJlc2V0KCkuY2xlYXJSZWN0KEJhbmdsZS5hcHBSZWN0KTusZGF0ZT24RGF0ZSgpO6x0aW1lU3RyPXJlcXVpcmUo0QZsb2NhbGUpLnRpbWUoZGF0ZSwxKTtnLnNldEZvbnRBbGlnbigwLDApLnNldEZvbnQo0QVBbnRvbikuZHJhd1N0cmluZyh0aW1lU3RyLHgseSk7rGRhdGVTdHI9cmVxdWlyZSjRBmxvY2FsZSkuZGF0ZShkYXRlLDApLnRvVXBwZXJDYXNlKCkr0QEKK3JlcXVpcmUo0QZsb2NhbGUpLmRvdyhkYXRlLDApLnRvVXBwZXJDYXNlKCk7Zy5zZXRGb250QWxpZ24oMCwwKS5zZXRGb250KNEDNng4LDIpLmRyYXdTdHJpbmcoZGF0ZVN0cix4LHkrNDgpO6MoZHJhd1RpbWVvdXQpY2xlYXJUaW1lb3V0KGRyYXdUaW1lb3V0KTtkcmF3VGltZW91dD1zZXRUaW1lb3V0KKooKXtkcmF3VGltZW91dD23O2RyYXcoKTt9LDYwMDAwLShEYXRlLm5vdygpJTYwMDAwKSk7fTtCYW5nbGUuc2V0VUkoe21vZGU60QVjbG9jayxyZW1vdmU6qigpe6MoZHJhd1RpbWVvdXQpY2xlYXJUaW1lb3V0KGRyYXdUaW1lb3V0KTtkcmF3VGltZW91dD23O75HcmFwaGljcy5wcm90b3R5cGUuc2V0Rm9udEFudG9uO319KTtCYW5nbGUubG9hZFdpZGdldHMoKTtkcmF3KCk7c2V0VGltZW91dChCYW5nbGUuZHJhd1dpZGdldHMsMCk7ff9DAgAAYW50b25jbGsuaW1n");
  base64DecodeToExistingUint8Array(bufferView, 17768, "MDAC//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////6v/q///+r6qqr///AP9Av//0DwAAC//5AP0Av//QDwAAC//AAMAAv/0ADwAAC//AAMAAtV0AD1VQD//BAMEAoA0AD//QD//vAO8AsA7wD//AH///AP8AoA/wD//AL///AP8Av//wD/8AP///AP8Av//wD/8Av///AP8Av//wD/0A////AP8Av//wD/wA////AP8Av//wD/wC////AP8AsV/wD/AD////AP8AoA/wD/AH////AP8AsA/wD/AL////AP8AoA/wD+AL////AP8Av//wD9AP////AP8Av//wD8AP////AP8Av//wD8AP////AP8Av//wD8Av////AP8A///wD4Av///////////////////////////////////62tr/66v/r56vv//6297//vv/+qvuv///r9v/6/v/rrq/v//66v//q+v/q66ub//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////7gAAABhbnRvbmNsay5pbmZv");
  base64DecodeToExistingUint8Array(bufferView, 18380, "eyJpZCI6ImFudG9uY2xrIiwibmFtZSI6IkFudG9uIENsb2NrIiwidHlwZSI6ImNsb2NrIiwic3JjIjoiYW50b25jbGsuYXBwLmpzIiwiaWNvbiI6ImFudG9uY2xrLmltZyIsInZlcnNpb24iOiIwLjExIiwidGFncyI6ImNsb2NrIiwiZmlsZXMiOiJhbnRvbmNsay5pbmZvLGFudG9uY2xrLmFwcC5qcyxhbnRvbmNsay5pbWcifZArAABhYm91dC5hcHAuanM=");
  base64DecodeToExistingUint8Array(bufferView, 18596, "QmFuZ2xlLmxvYWRXaWRnZXRzKCk7CkJhbmdsZS5kcmF3V2lkZ2V0cygpOwqsVz1nLmdldFdpZHRoKCksSD1nLmdldEhlaWdodCgpOwqsRU5WPXByb2Nlc3MuZW52OwqsTUVNPXByb2Nlc3MubWVtb3J5KCk7CqxzPXJlcXVpcmUo0QdTdG9yYWdlKTsKrGltZz3SGySwjAOSbZLroNjADYAAAAAcAcZJHEkSQACCYYYHEMgAMh0AUkhsAcX0c/TSQFQLoO3MOACJY7HCSAAZsDzoJbbbbaSSAHiE7br9cMPADCQQQSBhgD5VbbbAQACCDASbYBlllMWi0wgMAD28HnbQAlSdcC3ACACIbE7DbCj5sCaJIAfgBBSQAcyQ7b/rpNjYbCCCCCEHn/5JHEkAQACWbYSHFJMspgUUUEAMD/30c/TSQegLoO7MAAAJY7HCSD67MbzoJAfttJSAAH6JJAAAAMMAC0SQSQAAADaSHEgAcACCYYsAMoMsugAAAQMNJBAIAAAAAcDgAC7AAAABAMMMMMDAAggAAyABhBQAADiKieAAgAYAGoSSSQAccYaGHEgcddrroANhtJIJwQfNQENtAJJJAAAAAcC20MMMMAAJAMMMMDXgYYYAEQQBhBYEAgOJDzgACjDEhhCSSJLiDjaSHEgDiKc08ADXAChOSQAEJIABJBCKSbZJAcAUAAAbAAAACi2ii4nAAggAESBhgAAkgigIjzgAW3bEkLgSRtgQQc8AHEgAB9KqpJDXAUJwQQAAJIAAAACCCYAK2//3WAaATAf8C2gUUbbAYYAAEQQNgAAkkC0AjYbD23DDB/gCbYAf/nkBHSTREAc08q3bWhPgACgUJKFgJICCSbAK0AAVahaATIJICi22i5vYYAAAAyAAAAAkkAUIDDDD0UAbW3j22HkCD88RHbZP8ALroqim4J3ySSwAQBNAIACCCYUK2ycVrAaATASQAAANu63AYAgEgAAAAAmaEhgADADfnECDbbj23k8ADgARHJIz7iQASKQWjOj7ba8k8BmAIIQCCbYK2AC20a8bAEkAAAYAMYYYbEEEAAAkEEySQgBJAADn7YQTTNv22f8Afi4BHW2j8CfiSSSAJ4D222wAQAAAJIAAAAAC2ACigAYAAEADHAYAMYYYAAgEgAAgEEySQ/9BSQAfnECcYsPgAASQBC5BG1JXgAQASSQBOjDgAAAABKMMUJIAAABACAC2gCgAAEgC+AYMMbYYAAAAAbAkEAmSE8lIbYJLAAAJPNvgQQCAYK5BC3LXgeQDCSCB0AbgBAAADTMMUIALbAMMASe2gfX0C3YDLAYBgYYAAAAADAAAAAEwkf9BAAAIYABIVgDgOMCDAK4IC1LWgAAEkQQNttttttgACJNu2pUJthBBAAC20BusUAYBAAbYYYYbAAABDDAAACSEgaYtMiQLAMALg8gAAACABC5AC0k2gAAEAyf8kgAgwAQQAAMMULbUCgMMAAAAABusC7ZJEkAAgAAAAAAADAYAACSAASQ0rqIIMMAAD48ANsAbYC4IC0lWgiilITPskAAESASAAAMMULDAAABAIIAAABusAUBBAgAkgApy7gAAIbAAf+Sf8aaNpKRIBkFgAngAOsAYUC4BAUo0AC2kmZe8E0EgyQQQAAMMULbAkkgBRRAAAAAUWgBJAyCEgAAAAAAAIAAD8fj8cABkroQcDggAAAAANsNgUC4AIWu2jAUEzJ0gEAAESAbbYAAASzfAAtsBRRAAAEkAJBIAUiCDyTz+SfwAAJoAAn/gAahBFiQT8EH/4AYAABgAC0DABW927YAmZOgAEgAgwDAADAACCCf/gsAARQAAAEAhAIBWXAcD7bb777cADAf8HEkBgQCAccAccAB3bDbYQAMAAAAACqjujAEpJ0gADjgAAAYbYAAASQD/8sAACAADgEAhJIBW7YADqrrrrpcSTAf8EggNsOCCfgWibAAxYYYYQABgAAAAS2wd2gCNOnAAAQAAAAYAABttiAcjgsV0ccLYAEEBAJKWjCQDtvvvvt8QDAf8ggBttoCQADWwYYBJYSbASBsQcQAADE60WknN08AADjgAAADbAABgAAEktsMMfgIYAEkBAKSUAdwD/3332/0SQJoAkgANsGiCW7YCbAZJaCYYTzgf/8AAAJAAAiFGnigIDzgAJJLAABhigAcjgAV0AAJIkkkkkmSUDCQAMABgAYAQABtgwgABgACCXbUAYYZJCSAASaADjhJJJIgQEZp08CCSD+JJIkoYAANgccJAAAdcAABgAAAAEySgDCQAMAMBDXAQAMUCCAAAAAMvba0DYDAICCAgTzgIcBbLZIugiZumCBiCCSK20koBgAAAcdWoGBJJL+QgYDDDEmSgAAAAMBgBAYAf8O6iSAQSDYBq7a2gAACKDAEEAAAH/hJJJAkETJ3zhhCSAAJJIkokkmSQcdAICdLpL+RjDDDDHmSgDBhgMPZBAAYdcMUOWAQCDDFWXa0CSASSQkAjAAAGSBJJJAuiZPn+AIgMAMAAJJJBBD/8f8JACBYBL+QjbDbDEmSgDBgAN7YIACCD8MAMUAQCDYIszyWgGACeAEACCBAAABJJJAkTJ0/zggAMMMdcAAAAABJIAAANsAABL+RjDDDAHmQ0ABhgN7YAAQYQcBtiUACQDDNl//0EGAT/wYYBtgAAAYARsAiZOwSAEkANhgfoAANsAAAAAAwhjbDbDaQjDDDDAkk0AAAAMPAACAYCAAAQVgAAAAQszyWkGACeAEkCCAAIAAARhkTJ0iAgSQecAAJJAbbMFImWUgktAYDADaQAAAAAApIgAf8AMBgBIcxu1uHiQAAADAUlgAAEGAZZZZYADAAAAAQRsCZOnCE4QQSQYnAAADZhsACUAgwtvTDbASQQCCckkpIgDgDgMAMAIcySSSHgcAAABIZMkkiAiAAAAAATzzzwbYCBhzJ0TaYkAEecaTBAIDZhgAAAnEgAAADAASQSCD87YskgCgCgAAAWSwCQJJIcAcAAEk9g54gSQAAAY4SRAAAAbYASSaSEGTbEAAJIGQgAADAASCAAAgAf+SEkASQQSAk7U0AAWMOUAAYCyACAbZYAAADDEk6AssgAANvgHECBAQCQbYAQSJwgAQAAACSLQAAIAAAAQSAAAgAf+SEkDjgQCADYW0AAWRyUAYYYQACQbLbgcngAAkWgNsAD8APgY4CJAQQCbYAyaOSQnTD/gAKKDAIABSSSSSAAAAAf+SEkAcAAAAbAAMAAByR4AYYYAAAQZbYAgAAIAEnAVgAAAMMAAJABliQSZBATKUgE3TX/gACDAMBJIf//ySAAAAADgQAgJeQbgTzYBsCCSOMbADDAAAeQJJIcAcSSQEkgXBgAcBiSSB5gsgABZJCQSEAEkASAAAYCBhgSAEkkiQAAACgAAAAABeAc4/8DAAD//hjYAADjjjjgC2hJcAQQQElAQZgAcAACBBhhlgABdFQR2AAAiCCMAACYBtgQAAAAADZuT2gXgQc20cCbTTwAgAAkkgAbJJDjjgcAAChACAAAAByAQDAAcAACAKSAAAABJCZSmAAAgSNtsAAABhkSATwf8AYDAWpWgAccEDYc4gRYAAA+SSSBARAQCcccAUBIBvZBACNhhht8cAACAAQbAADAETJwiAAACCMIMARJABACATwSQAYYQxWoABf2kjAbgJCIAAA+f//gCRCCCDgdZUBAB/YAABwASQADpJJCAAQYEkcACaSEAAAASCDvjzzoAdcSDyQD/gbAEVWgABccEDZJJBIQAAA+EkkhCICSCHkMAMBJbn1BACNJCIAAJAJf8AQDEAAEDGQx0YDYAYAMCf+IDBDAAAAf/8YYEVVIABcUAACigAgAAACSSACSSACCCcejbCgDDAAAABxACIABpVpEkCSbEgAGFGFOvbDDDDAgjzzocAAcAAACSAYDQxWoABAAAAC2igAACID//gDgAAAAAHmDDCAQYQAUCCNIAJACpMJc8AAAEAAFF0hR3bDDDbAIAedIIIIAAAAQQQAAAGpAEm7YABiiihAAQBAkkhJJAADjjgADDAkiSABtjBxANsAVh0Ac8AAAEACEmkBLDU3YDDAADNsAARRDAAD2CDgAAS2gAGgEAMMAAccACIABef8C2gAAAAAAYAEAQAAMBCNCBgAAQQQAAAAAcBtp8gkjAAgAC2gAbZgEkyRD/gfgQD8AQgAAEmiEINsAcDAACBADjkkDbAAABtgAAAkIQIBhgBwBhkEkDbADAAADrhtvrgjDADAACigIKhJAkxRCSC28AcBtgAAbECgAIMAAD/gAAIgidSRttgAAMMNtttgBRAAACEABt8HkQQQYY47rgBt0AAkZJCgAC2gJKhJEgAADAC2j/gADgAAYYlttoBsADjgAggghAEhsABgAMMO2228cQAAYD5CRK8HkAAADHHFJC1t2gAgBJDAACgCIK1BA///jAC2+CcDDhIAYYAAD8cAAgAAAEAgjiSQAAAPgBtj///vsRc2SA7yBIgAC2gAIA7Trittu4AgBJAAACjCAATQE8kngNh/wQT9thJAYYAAcDkAAiCCBBAkgEkkgAABgA8i222/8TOMQABSREsAOuiSJAwABtttttgjAAAeAMCaAAY4AMABgNtjiCDgABAAbALwD8cD8kQQAIAQRIAC20AAMD/htttjgAgCCAgGQku2u2jbBA6YByOOORgAAAAeQljTAMTQAH/8gBsAASZEAJIAAALwCCAD8KqoCCAaZIAUACgWhg8gAAAf8cpcgDgCQAuYOAACQgiSZyS2yR7DAAAfwkMABsAAAAAAAAAACTI2ABIWj/rwSywBMBVYYTAHFICjbAUN2gAAAAAcfhHgW2Qz/YiDCWWWGNsTJttttt4DACCCNgBsMBgAAAAAAAAIJZG3ChBC3gIQSywD8AobYYAAhLCjAYUgt0IJAAAccACAChSQD8ybaQQCQjgAOkAAADYJLCCCMMQBgAAAAABABBtpJAAgigICj8IQCOAD8AAHEDAABICjAYcccAIIABLwAMCACgwz+0DDDAUAADwAUgO+sAAIIAQwNjHADAMMAABIJC2oIW0kgBhhjgIQCOAEkEcDAcYABICjbAEAEBIJABfgBgTyihEmQAbDDYQAAAAAEAO+sAAJIAGEMQgwAAskEABBBDbAAJIgsMMMP/gABtgEkACgCjAABICjAC8ccAAAAD+CbAD+igkBABYbYYUAAAAAggO+sCUoIB31sDHAAAshgMAAD8AAAW0ghgAAAAAAAAAbZVE+/gAABJgXAUBAAAAAACAQDACe2hEhIJbADYfjgAAAMAO+uCUsCmxykAQCGAskEAAAccEkkyQAc8AAAedJABh7ZVGm+8AABI4a2gAADgcAcEgABACf/gkBBBDbbAccYYYYBgMeueUiiiySgAAAgAAAAABgf8AAAf+SHkIEQElIIBsSRJE2/0fAAAgAQDzgccAADAEAAIJIeBH9ABAAAAf/7ADAIAAASSUsWgWUDAACAAMIAAPsccf//yTbc8AAAedBIBsSRVGm+8D6CBbaSCSAf8AQDYgAAAAQQAkD/+cAAcW24YDAhCgATiUsCwSiPAQAgANRAAMAAACCCAAAAAAAAAAJIBhgBVE2/gfCCBAQQTzgcccAfAEAAAACACgnl8fATj0AAAAB4CgATW0ACCCCDCCCGBtJBJBgDUHjjgD/gP///sAABABEAgBIAAAAQAA8wAAAAAD/yEgAf8CSSAYDs8DALji0AAAAjCgAT20SATQD/AQAABtBABAMbWiTTbDyQASSQAAJAaTEsgJAA+AAASTnwBLJttgCbQADpLiCCDbb/sDbbj0ACCQBhi4AQW2bQCDDASKQf+Sf8BPsBIYbDDbzwAAQACRAICaFkgJCSSSSQbY8gAJJhhgQbCAfJJcAAAYDnkDYocOtjDDAjCgAeSCbQAYYYAIAYnTedBBgBADbbbb/wAARhiSABMTSSQAySSSSQcbASJIJtvzzbaT5IJLgCAADs8fAIABgbAAAMCgENZASAAYYYAIASTTf8IMAAAAAAADyQMQRti2CQogCCAEGSSSSQf7AS1UBzR//N7/5AJLgQASQAARAaANtgDbcAegAdBAICSSYAIILAAAAW15gbCgAAABABtyRhgmAREACAQ8cgAASQcYAS1UD8fzwMOT5BJLgSAST/gAAAAAHUiTAACgFgQBIAIIAABJAAAgA1VtjAC1sAALoNhsAAAkSAAAAAAgAgAASQAAASJAD//gATAD5JJLgQASTjggEEgka2ADccegDgBtpAIIAIAAAdJEEW1hjAC1sAddddtigCgAAAAAAAAEnAAASQAAAAAAD//gAQYN9JJcSSAAD/gAAAgsGwjDADAC2gdtoAABBJBAMDhMsBAADABt2gALoAMCgCgAAAAFIgAADAAASQAEgAIJI/8gAQZtv//gC6gNgDggEEghmAjbAAgCjgAEAATxAIBCsAJMMJKQAbBuIgABD/gYUUEkAAAH8jgDjAACSQAEHbIIAkkgAQZtvj/gDLByOSAgEAAAMkCSABAC0AAGgCCCJJIBMDhAAIIAAABvWAADjzjDUUEEAAAFIgAADbbYSQAEgkoJDkngAABhv8DgAshyPTAgEAAABjgABDCC8AAEAQAARJABMdJf8JKDQABspgEAD/j/CgEEAAAAAADAAMxBKRAEGSJIDgDgAAABsf8AAAByOSAEgAAQAMAAAc8C2gBACAAACAAC0AAYAIIDQPhtsAGvAAb/ccggAAAIACACBmIIIIAEgAAAD//gAgiZMDgAAAANgAALgACSABiAQAAAAIJe8AAD+fz+TxDbAIKTQdhtsAGtgDDYJIAADBAMBASQMwIIJAABIMBgAN7AAkzJgAAAAQANj/8cIASSQAMSAAggEIKuugAAefyefxbbAAAAAAAAAEG1iCACSSDjgAMUMACAAAcMAAAIAMNsBh4YY4gAAAAACSAW0DjocCSSCANyAAgggoIAAAAAeTzyf9bHYBuSSSSSSEkECCACf+D/yAC6gD/gAAdhjAUIAMBgBh4YY4gAlpDAQQQUAD8dASSQcQAAADDDbBAAAAAAefzyTxbbYB57bbbbbAADgYV2e+D/yJ3fVqSAIAdhjAUBJsAAAN4aYYQABhDACSAW3DjDACSSAADbbbbDDAAAAAAD8QAAABbbYBsQA8gf8CeACCOuf+D//gC6gBJAAD8MYAW0AAAAQAbTnSQAhpAAQQQUDbbCjASSQcDYAAAAAAYAAAADYT/yujbDYBh1j/jgDj/gCCV2SSD/kgMUMCgSSQCgUQSSQRMDYMCc6CCAlhDAAAAUDDDDAACSAAAAf/jDDAZ5tsADYTzx1jYAYAMYI8jgfiebAAEkAAD/khAMBCgAAAUCQSSSSSMSRgDkASQAAAf8AAaYAAAC6gAQAAf/jgfDAAbbbYAD8T/yujCaUW2+UgDjjgAYEEEcAAAgBAAIAChtgCpUUTSSTRMbMAAAAAW0JIAcAATTgIIAAAD8AAcAfgfbDBZ5tsAD6SVUaCbbW0USQAAf8AAbEgEEACQyAIAH/+h5gUCAUQaSZyMRoEmAAAW0JIDgAAaYVBBDCKDiTYcIDgfDDBACAAAX6SIoYQaaUUUBBBINsAAYEEEkACAiJIkkkmhtipUAQQDTNxMPIEQQAANsJIfZJAQQIIIABFD+BhhVD/jAABYCCAADaSVUYQaSTrgBIBBMAAAAAAcCusAAAAACSShgUCG20QN5tyN/IEjCAC22gDgBADDDABAACKAARsIAIbbEBJJCQAf/eSCQb/4CCKABABINsW0AAADi2sADADAAAChipVm6wQN5txMPIEYQAAEnzkkZIBABdLaQUAdiQAAf///8ABW2CAd+SSSSTyCCDrgSBhBNACsDrj/iu0AAEEDASCgUChm23wN4ByMBoECAAQEnzkkBAAMMFLaQWi8PgeiySSSQQBUCAQf8AAAAD/iSANhgAAAMACthRHEgAAAAGEYYQCipQBm6zxgAMRNBMEQTaCHnznkBAACgZLaQUUdjgei////8QBUUACQBsBABAEiQBgMAD/8Akitjr7bASSAAEEDAfi0CgBm23xgAMSMIJoCabQH/z/kAAAAAMAAAUAcMUi2gAAASQBW0ACCBhhBBAgCCANhgDycAgW0AAHEpKSNgABAEECgQABtgTwNgBxMIIO2y4AAAABJIAAAAD/f8UAdgGiigAAAREkgAACQBsbIIbEiTEmAADyeAkgABtgABCSAMCSAAEgAAcgAAEkAAAAAIJCgKhhhjbD/8AAAAD7ccAAAa4ADLAAUSEAAAACAAAbbbbAADEgIDj/yAAjjgBrxBCAACSicCgccf8////f8f8f8f8cVKhthjAAkkkkgAD/f8AbAW0AhZAAACEAf/0CCAAAbbAAAmIIIAAAC0kgABhgBJSAABgIAMAAAAkkkgDAAAAAAAACgKhhhjbYAAAAAADvd8DMYa4cbLAAACEkDgAWQAAADa2gAkEkkAAD0CgQARt6QNhsBtgAYbbAMP8//gAAMMBhgJIC2i2ySSDD////gADvN8DAYABCBAAAACEAD8WiAAAADagUNsUAXbbCi20QQQAbQYYYABiSAYAYNhuSAIAhgAvjsAAC7C4QQCDABtttgABvNtgbAAAYcAAUACEADhJYYgkADagVgAWi0DAUCgACCAAAC222gBjiQYAAMMOaBBAACgBtjBAC7XASSCC222222kn8AAA4gCsMgAAW0CEBjgIbYEFJDaihgAUUUDWgcW20AAAAUSSQUBgSAff7gACSAYABgAgADBAC64ZgAWjbbf///kn3gADbAWhg8gcUUWawDhJYYAFEjYAANsUUUDAaADjgAAAUCbbaCgQSD///8EkEjDMMEEAADRACgABgMABtt2222kn+2jY4nasM8gcAW2IUBgMAAABJASSQAB0UUDAaAcccdcC0TJprQUCQD///8DgyHDCAAAFtnBACgABgOgUABttttpL3gDHAHZAAkgDbUWFYMBgbbbAkgQQQNsUAUPAaADjjjoACbuuv6CgAD8fj8ccEgagCtsMAMX4C2gNhsWgAAAD+SIIcT/b/kpKT8gDYYCAABhgAADFrASCQD/gABhgBgcccddjid2WV+CgDD/gf8AAbYAW0BgMYMX5JBAAAAAAcg8cfaJAASff///gAkgC7ACAkAAIAbbFbgDbABdAABgAQQDjjrpgCZ2SV6CgAYf//gADADADgBgMAMAZJAQQACAAAAAAfSIIQSTf///gbngC4YBtkAABAYbFrAAIAD9AAAMAhg8ccddiiZOytaC7AYD/8NMZKt4ACSAFtkSRJASQACAAQAQAfaJKeSf//+3bAkgCbABhlBJJABjAkgAIAQAAAYBkCAHjjrhiiDJ1rCCgbbAAAKoYCgYceSAAAD+fgAQQACAADbAQeSAAQT/+f/20AAACAABthBACANsAADgIFbYYAZhgDPcccddgUQZNYQUbNtgAANMBKtgCAcMMDf///AQQACAAAAAAANthhP/yT//gAAAB2gAkpBIAAAAEkgAg45YYAYMABtjjjrhiiiDPCSwANtgAAAbZABgcceW0D+TyfgHwCCAAAJAIAMABhd/+f/bSSSSBEBAggbAYEkAEAgAhG7TDbAMADPcccdtgAUQYQEEANt8kgg65KtgAAeCgb+SSf4HwCSAAlAIIDNthod/+f+SbbbbEApAgzAAYGEAEggEwfcZ7CRCAAADjjjgUAWiCagjANt88kg7YAAADACCgDfyT/AAWWWWUkgIIYYAAAf/+f/bAAAAEEJAAQYSYEkWgAAEiiijHCA+gB12gISQUUUATDAAbAAckggkEAAAbYCMMAb+f4AAEEEECCBeLf/EjXf/////gAAAEgJAMSTSYEAWoAEgcJIfbCSDDgUMIIecCigCgYAAAADAW20YAAAAYYCSSSSf+22sAMAAAABfqc+FK2/////6aZtgEEJBljYAYAAAIAEiipKiiQQAAAMUJISdttsAWKAAAAwQAUDbAAAD+rqASQADgAAUEEQCSAQeCEmJHXf////zzRxgEAgMssAAAACQIAEAcJIcICQEEcAkoINsUCsAAQSCQgyQAUAYAAAC+roMTwBgY84UAAQCCARSI44glt/////6aZtgAAAFlkDbASCCJBBACjCgBAIEgcEgIgMAUVgDYYQQQ0wQAUAYBBBi2pLDSQMMAcAUIIRiCBweAnEgB9v////zjQEkD0UAsgAACCCQAIKQScAcAKikH8kkkkNsWsNLDDQAQAjAAUCSBJNkmYHDCCNsYg4UEkRiSBwAAf8GltsAAAMACYhAcWgAEcySQQCCAACCSCCASAQNsbbbY++8V0IDDDAEkkgAAAAABBBkGAHbCCNsAAAAMABsANgBSDgUWSMAAcOATQhAD0UAAEySAACAQACQQQAEkkkOvYYbY++8UChIMAMEkkAAZYAACgAEmAHDAAAAAABE/yBhhhgBaDgUiKNsMNuQSZBJAAAAASSSAAAACAAAACCAACCNvbbbY++9sNsANhsEkkAAKIAACigGGTlgMf8IAIIE/yBsANgBSDgEWSMMAMOCTSBBCSAAAYAAAYAEmDYAAcQcAAQAXYADU++8NsBgMMNgEBgAZYAACgSQD8ANj//oIIBE/yBJAAABttgAC2sAMMPACaBJACSSQBgMAUZIiQYAABKSQCCAD7bbw3/8BgMMMABsEBgBtgAACi/+AD8NjjjocIIAkkVAUASQBgAyBKsMMMNJAwSQHgADAYAMCi5YggYAABbSQDjgAWi0EkBJtpBgMAAbFhhhhgACiz//wcBgPjjoDoBAAEVAUAQCBtggRKsMMBtAEihBgSAYABgBgUJYkHAAABKSQAgiRAMAANtptoADYAAAFtthtiAC23vvwAAAD//r/oIAAEVAUAQCBhggS2hsACBIggYAEAAAAYAMMMf8kEAAADgDgAECKAUABJOJpqEAGB2gEAAAAW0AACf+AAC2gf8JBIBAgEVJUASQBskyAkgEkSBEAipIDiAAABgNhh+cAAAccAAf8AgiRAFAABONNOEAGBioEAADa22gAB3xgkACgD7ZJbLAEgW0W0QCBhgADngECCAAAQIAGSAAAYAMAMf8AAAccAAAAAACKCgMABNxxxmGGB2oIf8DCyygABvNggAUAAYAIYBDjDjDjDjDhtgAAkgEGSQAAAJI//gAABgB29BAAAAAAYAAAD8Af4AQABNuONiCCBoJIkkDa22gABhhggAAAD4YAYDBtuAQkwwAAAAADbAEkCACDn/8n/gAAYAAX8IAAAAZZZZYsj8YfgCgBBBttsAQCSJID/8DCWWAABhFgkADcAfYAAbBtsAAbbAAbbAAA4gAAAAQQ8kkk/ySQARSW8IkgAADDDDAsgAYkkYAAIkBJBgAAAAIAgADYSQAABohgEAD8AcUAAAAMAADAAbbCc4AAQAAABfgTn8kknyeQUSKAAL/gAADDHDAsgAYkHgAAAggBBvsDABJBgAACACSABEgQEAAD/gAAAAcccSfyADYAiAACCABAAfiAAAAkkz/y0SRIAC2pIkAYAYAACAAiEgQAAg4IbgYAAYXNti4CACAAIgG0kAADjgQADkiCASfyAYDCAgzcQAJAAASQABt7bSeQUQBBDXABAgjDHDCSCSSQAJgAAghABgDDDABBgYAiACSBEAGgAAAACiaCjGCSASfyAANjmGD4QAAAW0AAfhgZKSSQAgIIIa4JAggAAACgDbbYAAAAAkBJDgAbYACjMAYCAACAgki0AAAAAAQIDyAQAAAAACgVAM9yCABAUUBAAAMSSSeAHEBBADXAAkDbeAkUCSSQAXBABAAYAPsDABBQQCgCSCSAUSSgYO2iigBZIAIBAAAAAAcBBgDGCAbAW0NtsABgAT/8AgAIAAAAAkg6T8kCgACAAchSRAAAAEkAAAYSAYwgAAACuwm3DO0UUUVJJBJBACRD/0CgQAYZVCTUAAWugBtgASeAHEW0AD8cAEEbiQhJDgQAAABBBAIIUWi0AUWwS0AAAAAV0QwDAN2iigBBIIIJACaAkhsCSQbaqgbbAAOu2ipIkQAIAgWSgAAcAEY4TggAACSQAACJKAIIAgAgAAAAAAAAf/8WgUUAZttgAAAAIAIBABSBJBJfgAYaqwTYBINu+igAEQBNBt2Sgj8dAAAAJACSSAAAAACQSAAAUkA0YbYYBgABgcBBAUUADBkkAASCQEgADjjhBBBfpJJJVSTHBdSC22pIEQBBBh20Ej8AAAABALD9fjDzgACCCABAUgg0YYAYAMAOScAQBgBjDBkAf8QQQgAAAEkBJBIAECIGqwTYhJTyiigEEQIAJt0A7EgJIAABbIDpLgCKAACACABAUgE0YAYYAMMPacYQYPsAYBkEc8QQQgAAACABABBAGQQFVQTHBBSCiipIkyAUBgUWEklJJAABAICSSADzgACACAIIUgA3YbYbABhjTcDbBcAf/pkkf8QAQEgAAccBABIAGCQE7rGltZ0hlaWdodD1nLmltYWdlTWV0cmljcyhpbWcpLmhlaWdodDusaW1nU2Nyb2xsPU1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSppbWdIZWlnaHQpO2cuY2xlYXIoMSkuc2V0Rm9udCjRBDZ4MTUpLnNldEZvbnRBbGlnbigwLDApO2cuZHJhd1N0cmluZyhFTlYuVkVSU0lPTivRAiAgK05SRi5nZXRBZGRyZXNzKCksZy5nZXRXaWR0aCgpLzIsMTcxKTtnLmRyYXdJbWFnZShpbWcsMCwyNCk7qmdldFZlcnNpb24obmFtZSxmaWxlKXusaj1zLnJlYWRKU09OKGZpbGUsMSk7rHY9KNEGb2JqZWN0ir9qKT9qLnZlcnNpb246tTurdj8obmFtZSvRASArKHY/0QF2K3Y60QdVbmtub3duKSk60QNOTyArbmFtZTt9rGxvZ289RS50b0FycmF5QnVmZmVyKNHVPBwBAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gAAAAAAAD/w+AAAAQAHA4hAAAAQAMAMhAAAAQAYBmhAAAAQAYBGiAAAAQAQCD/H74+R4wGDhoKJCSEwEDgoKJCT8wFDgoKJCSAwHDhoKJCSEQHj/H6I+R4YHmAAAACAAYEGAAABCAAMEMAAAA8AAHA4AAAAAAAD/wAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gAAAAAAAB/gKTusaW1hZ2VUb3A9MjQ7qmRyYXdJbmZvKCl7Zy5yZXNldCgpLmNsZWFyUmVjdChCYW5nbGUuYXBwUmVjdCk7Zy5kcmF3SW1hZ2UobG9nbyxXLTYwLDI0KTtnLnNldEZvbnQo0QM0eDYpLnNldEZvbnRBbGlnbigwLDApLmRyYXdTdHJpbmco0QxCQU5HTEVKUy5DT00sVy0zMCw1Nik7rGg9OCx5PTI0LWg7Zy5zZXRGb250KNEDNng4KS5zZXRGb250QWxpZ24oLTEsLTEpO2cuZHJhd1N0cmluZyjRE1Bvd2VyZWQgYnkgRXNwcnVpbm8sMCx5ljQraCk7Zy5kcmF3U3RyaW5nKNEIVmVyc2lvbiArRU5WLlZFUlNJT04sMCx5lmgpO2cuZHJhd1N0cmluZyjRB0NvbW1pdCArRU5WLkdJVF9DT01NSVQsMCx5lmgpO2dldFZlcnNpb24o0QpCb290bG9hZGVyLNEJYm9vdC5pbmZvKTtnZXRWZXJzaW9uKNEITGF1bmNoZXIs0QtsYXVuY2guaW5mbyk7Z2V0VmVyc2lvbijRCFNldHRpbmdzLNEMc2V0dGluZy5pbmZvKTtnLmRyYXdTdHJpbmcoTUVNLnRvdGFsK9EIIEpTIFZhcnMsMCx5lmgpO2cuZHJhd1N0cmluZyjRCVN0b3JhZ2U6ICsocmVxdWlyZSjRB1N0b3JhZ2UpLmdldEZyZWUoKZIxMCkr0QZrIGZyZWUsMCx5lmgpO6MoRU5WLlNUT1JBR0UpZy5kcmF3U3RyaW5nKNEJICAgICAgICAgKyhFTlYuU1RPUkFHRZIxMCkr0QdrIHRvdGFsLDAseZZoKTujKEVOVi5TUElGTEFTSClnLmRyYXdTdHJpbmco0QtTUEkgRmxhc2g6ICsoRU5WLlNQSUZMQVNIkjEwKSvRAWssMCx5lmgpO2ltYWdlVG9wPXkraDtpbWdTY3JvbGw9aW1nSGVpZ2h0LWltYWdlVG9wO2cucmVzZXQoKS5zZXRGb250KNEENngxNSkuc2V0Rm9udEFsaWduKDAsMCk7Zy5kcmF3U3RyaW5nKEVOVi5WRVJTSU9OK9ECICArTlJGLmdldEFkZHJlc3MoKSxnLmdldFdpZHRoKCkvMiwxNzEpO2RyYXdJbWFnZSgpO3NldEludGVydmFsKKooKXtkcmF3SW1hZ2UoKTtnLmZsaXAoKTtpbWdTY3JvbGw9KGltZ1Njcm9sbCsxKSVpbWdIZWlnaHQ7fSwyMCk7fapkcmF3SW1hZ2UoKXtnLnNldENsaXBSZWN0KDAsaW1hZ2VUb3AsVy0xLEgtMTQpO2cuZHJhd0ltYWdlKGltZywwLGltYWdlVG9wLWltZ1Njcm9sbCk7Zy5kcmF3SW1hZ2UoaW1nLDAsaW1hZ2VUb3AraW1nSGVpZ2h0LWltZ1Njcm9sbCk7Zy5zZXRDbGlwUmVjdCgwLDAsVy0xLEgtMSk7fXNldFRpbWVvdXQoZHJhd0luZm8sMTAwMCk7QmFuZ2xlLnNldFVJKHttb2RlOtEGY3VzdG9tLGJhY2s6bG9hZH0pOwQJAABhYm91dC5pbWc=");
  base64DecodeToExistingUint8Array(bufferView, 29780, "MDCI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+VVVVVVVVVVVV/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/lVVVVVVVVVVVVVV/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+VVVVVVVVVVVVVVVVVVVVVf7+/v7+/v7+/v4QEP7+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVVVVVVVVVVVVVVVX+/v7+/v7+/hAQEBD+/v7+/v7+/v7+/v7+/v7+/lVVVVVVVVVVVVVVVVVVVVVVVVVV/v7+/v7+/hAQEBD+/v7+/v7+/v7+/v7+/v7+VVVVVVVVVVVVVVVVVVVVVVVVVVVVVf7+/v7+/v4QEP7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/lVVVVVVVVVVVVVVVVVVVXmjeVVVVVVVVVVV/v7+EBAQEBD+/v7+/v7+/v7+/v7+/lVVVVVVVVVVVVVVVVV5o87OznlVVVVVVVVV/v7+EBAQEBD+/v7+/v7+/v7+/v7+VVVVVVVVVVVVVVVVVXnIzs7Ozsd5VVVVVVVVVf7+EBAQEBD+/v7+/v7+/v7+/v7+VVVVVVVVVVVVVVV5o87Ozs7Ozs6jVVVVVVVVVf7+/v4QEBD+/v7+/v7+/v7+/v7+VVVVVVVVVVVVeaPOzs7Ozs7Ozs7Oo1VVVVVVVf7+/v4QEBD+/v7+/v7+/v7+/v7+VVVVVVVVVVWjyM7Ozs7Ozs7Ozs7OzlVVVVVVVf7+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVecfOzs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVzs7Ozs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVzs7OeXnOzs7Ozs55ec7OzlVVVVVVVVX+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVzs7OeXnOzs7Ozs55ec7OzlVVVVVVVVX+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVzs7Ozs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v4QEBD+/v7+/v7+/v7+/v5VVVVVVVVVzs7Ozs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVzs7Ozs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVzc7Ozs7Ozs7Ozs7Ozs7OzlVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVec7Ozs7Ozs7Ozs7Ozs7OeVVVVVVVVVX+/v7+/v7+/v7+/v7+/v7+/v5VVVVVVVVVT53Ozs7Ozs7Ozs7Ozs55T1VVVVVVVf7+/v7+/v7+/v7+/v7+/v7+/v7+VVVVVVVVT095x87Ozs7Ozs7Ox3lPT1VVVVX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5VVVVVT09PxsbHx83Nx8fGxk9PT1VVVf7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+VVVVT09PxsbGxsbGxsbGxk9PT1VV/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5VVjMPx8bGxsbGxsbGxw8zVlX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5lZQ8PgMbGxsbGxsbGgA8PZWX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+ZWVlZToPOc3GxsbGxsbNOQ86ZWVlZf7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v5lZWVlZToPD87Nx8bGx83ODw86ZWVlZWX+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/mVlZWVlZWUPD4HOzs7Ozs5dDw9lZWVlZWVl/v7+/v7+/v7+/v7+/v7+/v7+/v7+ZWVlZWVlZWU6Dw+kzs7OzqQPDzplZWVlZWVlZf7+/v7+/v7+/v7+/v7+/v7+/v7+ZWVlZWVlZWVlEA8PXc7OXQ8PEGVlZWVlZWVlZf7+/v7+/v7+/v7+/v7+/v7+/v5lZWVlZWVlZWVlQQ8PDw8PDw8QQWVlZWVlZWVlZWX+/v7+/v7+/v7+/v7+/v7+/v5lZWVlZWVlZWVlZWU6Dw8PDzplZWVlZWVlZWVlZWX+/v7+/v7+/v7+/v7+/v7+/mVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl/v7+/v7+/v7+/v7+/v7+/mVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl/v7+/v7+/v7+/v7+/v7+/mVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl/v7+/v7+/v7+/v7+/v7+/mVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/qYAAABhYm91dC5pbmZv");
  base64DecodeToExistingUint8Array(bufferView, 32120, "eyJpZCI6ImFib3V0IiwibmFtZSI6IkFib3V0Iiwic3JjIjoiYWJvdXQuYXBwLmpzIiwiaWNvbiI6ImFib3V0LmltZyIsInNvcnRvcmRlciI6LTQsInZlcnNpb24iOiIwLjE1IiwidGFncyI6InRvb2wsc3lzdGVtIiwiZmlsZXMiOiJhYm91dC5pbmZvLGFib3V0LmFwcC5qcyxhYm91dC5pbWciff//BAEAAHdpZGxvY2sud2lkLmpz");
  base64DecodeToExistingUint8Array(bufferView, 32320, "QmFuZ2xlLm9uKNEEbG9jayyqKCl7V0lER0VUU1vRBGxvY2tdLndpZHRoPUJhbmdsZS5pc0xvY2tlZCgpPzE2OjE7QmFuZ2xlLmRyYXdXaWRnZXRzKCk7fSk7CldJREdFVFNb0QRsb2NrXT17YXJlYTrRAnRsLHNvcnRvcmRlcjoxMCx3aWR0aDpCYW5nbGUuaXNMb2NrZWQoKT8xNjoxLGRyYXc6qih3KXujKEJhbmdsZS5pc0xvY2tlZCgpKWcucmVzZXQoKS5kcmF3SW1hZ2Uo0R8OEAEf4P/DAwwMMDDAx/+///h/4f+H/z/8//P//9/+LHcueCsxLHcueSs0KTt9fTuBAAAAd2lkbG9jay5pbmZv");
  base64DecodeToExistingUint8Array(bufferView, 32612, "eyJpZCI6IndpZGxvY2siLCJuYW1lIjoiTG9jayBXaWRnZXQiLCJ0eXBlIjoid2lkZ2V0IiwidmVyc2lvbiI6IjAuMDgiLCJ0YWdzIjoid2lkZ2V0LGxvY2siLCJmaWxlcyI6IndpZGxvY2suaW5mbyx3aWRsb2NrLndpZC5qcyJ9////MAMAAHdpZGJhdC53aWQuanM=");
  base64DecodeToExistingUint8Array(bufferView, 32776, "e0JhbmdsZS5vbijRCGNoYXJnaW5nLKooY2hhcmdpbmcpe6MoY2hhcmdpbmcpQmFuZ2xlLmJ1enooKTtXSURHRVRTW9EDYmF0XS5kcmF3KCk7Zy5mbGlwKCk7fSk7rWJhdHRlcnlJbnRlcnZhbD1CYW5nbGUuaXNMQ0RPbigpP3NldEludGVydmFsKCgpoldJREdFVFNb0QNiYXRdLmRyYXcoKSw2MDAwMCk6tztCYW5nbGUub24o0QhsY2RQb3dlciyqKG9uKXujKG9uKXtXSURHRVRTW9EDYmF0XS5kcmF3KCk7oyghYmF0dGVyeUludGVydmFsKWJhdHRlcnlJbnRlcnZhbD1zZXRJbnRlcnZhbCgoKaJXSURHRVRTW9EDYmF0XS5kcmF3KCksNjAwMDApO32ke6MoYmF0dGVyeUludGVydmFsKXtjbGVhckludGVydmFsKGJhdHRlcnlJbnRlcnZhbCk7YmF0dGVyeUludGVydmFsPbc7fX19KTtXSURHRVRTW9EDYmF0XT17YXJlYTrRAnRyLHdpZHRoOjQwLGRyYXc6qigpe6x4Pa8ueCx5Pa8ueTtnLnJlc2V0KCkuc2V0Q29sb3IoZy50aGVtZS5mZykuZmlsbFJlY3QoeCx5KzIseCszNSx5KzIxKS5jbGVhclJlY3QoeCsyLHkrNCx4KzMzLHkrMTkpLmZpbGxSZWN0KHgrMzYseSsxMCx4KzM5LHkrMTQpO6xiYXR0ZXJ5PUUuZ2V0QmF0dGVyeSgpO6MoYmF0dGVyeTwyMClnLnNldENvbG9yKNEEI2YwMCk7pKMoYmF0dGVyeTw0MClnLnNldENvbG9yKGcudGhlbWUuZGFyaz/RBCNmZjA60QQjZjgwKTukZy5zZXRDb2xvcijRBCMwZjApO2cuZmlsbFJlY3QoeCs0LHkrNix4KzQrYmF0dGVyeSoyNy8xMDAseSsxNyk7oyhCYW5nbGUuaXNDaGFyZ2luZygpKWcucmVzZXQoKS5kcmF3SW1hZ2Uo0R0UCoEAAcAADwAA/AAH8Ph/w/4fD+AAPwAA8AADgCx4KzgseSs3KTt9fTt9igAAAHdpZGJhdC5pbmZv");
  base64DecodeToExistingUint8Array(bufferView, 33624, "eyJpZCI6IndpZGJhdCIsIm5hbWUiOiJCYXR0ZXJ5IExldmVsIFdpZGdldCIsInR5cGUiOiJ3aWRnZXQiLCJ2ZXJzaW9uIjoiMC4xMiIsInRhZ3MiOiJ3aWRnZXQsYmF0dGVyeSIsImZpbGVzIjoid2lkYmF0LmluZm8sd2lkYmF0LndpZC5qcyJ9///AAQAAd2lkYnQud2lkLmpz");
  base64DecodeToExistingUint8Array(bufferView, 33796, "V0lER0VUU1vRCWJsdWV0b290aF09e2FyZWE60QJ0cix3aWR0aDoxNSxkcmF3OqooKXtnLnJlc2V0KCk7oyhOUkYuZ2V0U2VjdXJpdHlTdGF0dXMoKS5jb25uZWN0ZWQpe6MoZy5nZXRCZ0NvbG9yKCmLMzEpe2cuc2V0Q29sb3Io0QQjMGZmKTt9pHtnLnNldENvbG9yKChnLmdldEJQUCgpPjgpP9EEIzA3ZjooZy50aGVtZS5kYXJrP9EEIzBmZjrRBCMwMGYpKTt9faR7Zy5zZXRDb2xvcihnLnRoZW1lLmRhcms/0QQjNjY2OtEEIzk5OSk7fWcuZHJhd0ltYWdlKNEfCxQBBgDgFgJgR4jZMawfAcA4D4NYybEYIwTAsBwDACwyK68ueCwyK68ueSk7fSxjaGFuZ2VkOqooKXtXSURHRVRTW9EJYmx1ZXRvb3RoXS5kcmF3KCk7fX07TlJGLm9uKNEHY29ubmVjdCxXSURHRVRTW9EJYmx1ZXRvb3RoXS5jaGFuZ2VkKTtOUkYub24o0QpkaXNjb25uZWN0LFdJREdFVFNb0QlibHVldG9vdGhdLmNoYW5nZWQpO4UAAAB3aWRidC5pbmZv");
  base64DecodeToExistingUint8Array(bufferView, 34276, "eyJpZCI6IndpZGJ0IiwibmFtZSI6IkJsdWV0b290aCBXaWRnZXQiLCJ0eXBlIjoid2lkZ2V0IiwidmVyc2lvbiI6IjAuMDkiLCJ0YWdzIjoid2lkZ2V0LGJsdWV0b290aCIsImZpbGVzIjoid2lkYnQuaW5mbyx3aWRidC53aWQuanMiff////wAAAB3aWRpZC53aWQuanM=");
  base64DecodeToExistingUint8Array(bufferView, 34444, "KCgponuqZHJhdygpe6xpZD1OUkYuZ2V0QWRkcmVzcygpLnN1YnN0cigpLnN1YnN0cigxMikuc3BsaXQo0QE6KTtnLnJlc2V0KCkuc2V0Q29sb3IoZy50aGVtZS5kYXJrP9EEIzBmZjrRBCMwMGYpLnNldEZvbnQo0QM2eDgsMSk7Zy5kcmF3U3RyaW5nKGlkWzBdLK8ueCsyLK8ueSs0LLQpO2cuZHJhd1N0cmluZyhpZFsxXSyvLngrMiyvLnkrMTQstCk7fVdJREdFVFNb0QV3aWRpZF09e2FyZWE60QJ0cix3aWR0aDoxNixkcmF3OmRyYXd9O30pKCk7igAAAHdpZGlkLmluZm8=");
  base64DecodeToExistingUint8Array(bufferView, 34728, "eyJpZCI6IndpZGlkIiwibmFtZSI6IkJsdWV0b290aCBJRCBXaWRnZXQiLCJ0eXBlIjoid2lkZ2V0IiwidmVyc2lvbiI6IjAuMDMiLCJ0YWdzIjoid2lkZ2V0LGFkZHJlc3MsbWFjIiwiZmlsZXMiOiJ3aWRpZC5pbmZvLHdpZGlkLndpZC5qcyJ9//+pAAAAd2VsY29tZS5ib290Lmpz");
  base64DecodeToExistingUint8Array(bufferView, 34900, "KKooKXutcz1yZXF1aXJlKNEHU3RvcmFnZSkucmVhZEpTT04o0Qx3ZWxjb21lLmpzb24sMSmge307oyghcy53ZWxjb21lZCl7c2V0VGltZW91dCgoKaJ7cmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlKNEMd2VsY29tZS5qc29uLHt3ZWxjb21lZDq0fSlsb2FkKNEOd2VsY29tZS5hcHAuanMpfSl9fSkoKf///xkWAAB3ZWxjb21lLmFwcC5qcw==");
  base64DecodeToExistingUint8Array(bufferView, 35104, "CqphbmltYXRlKHNlcSxwZXJpb2Qpe6xjPWcuZ2V0Q29sb3IoKTusaT1zZXRJbnRlcnZhbCiqKCl7oyhzZXEubGVuZ3RoKXusZj1zZXEuc2hpZnQoKTtnLnNldENvbG9yKGMpO6MoZilmKCk7faRjbGVhckludGVydmFsKGkpO30scGVyaW9kKTt9CqpmYWRlKGNvbCxjYWxsYmFjayl7rG49MDuqZigpe9EDcmFtZy5zZXRDb2xvcihjb2wpO6corGk9bjtpPDI0MDtpljEwKWcuZHJhd0xpbmUoaSwwLDAsaSkuZHJhd0xpbmUoaSwyNDAsMjQwLGkpO2cuZmxpcCgpO26YO6MobjwxMClzZXRUaW1lb3V0KGYsMCk7pGNhbGxiYWNrKCk7fWYoKTt9CqxTQ0VORV9DT1VOVD0xMDsKqmdldFNjZW5lKG4pe6MoboowKauqKCl7Zy5yZXNldCgpLnNldEJnQ29sb3IoMCkuY2xlYXJSZWN0KDAsMCwxNzYsMTc2KTtnLnNldEZvbnQo0QQ2eDE1KTusbj0wO6xsPUJhbmdsZS5nZXRMb2dvKCk7rGltPWcuaW1hZ2VNZXRyaWNzKGwpO6xpPXNldEludGVydmFsKKooKXtuljAuMTtnLnNldENvbG9yKG4sbixuKTtnLmRyYXdJbWFnZShsLCgxNzYtaW0ud2lkdGgpLzIsKDE3Ni1pbS5oZWlnaHQpLzIpO6MobpExKXtjbGVhckludGVydmFsKGkpO3NldFRpbWVvdXQoKCmiZy5kcmF3U3RyaW5nKNEET3Blbiw0NCwxMDQpLDUwMCk7c2V0VGltZW91dCgoKaJnLmRyYXdTdHJpbmco0QhIYWNrYWJsZSw0NCwxMTYpLDEwMDApO3NldFRpbWVvdXQoKCmiZy5kcmF3U3RyaW5nKNELU21hcnQgV2F0Y2gsNDQsMTI4KSwxNTAwKTt9fSw1MCk7fTujKG6KMSmrqigpe6xpbWc9cmVxdWlyZSjRCmhlYXRzaHJpbmspLmRlY29tcHJlc3Mo0nUDptR4n/j/4gH+8H5wl+jOukVVoHZ8dt/n//n37OtgH9sHhwHp4H5xmkGiH72MRje/LL/7iIAEE7sPEgoAC+AlagIlIiMQErPxDwUYxAABwIHCj8N7nOl3uEqa6BEggnFjfM5nCkUil3gEq5KDAAQmC6QmBE4JxSEhIABiQmB8QmSXoQlCYRMdEwIlCAAIlNhYlOiO85nNEyMPEoZwIAAcsYIYmPXoYlMiKaFExX/u9VEqLBBOYrCH+czmtVqJyDEpiaCOYsgSYszmc3qtTEqMR7hzG8AlGmd1OQglOOY6aEgYlCmmZoJMCTBrnD6SaIEoU/zOUuolSjbnBJgqaCEoU5zOXX4RyQYBBzCS4X5zNDqqZCJiERJg5zBEoVJEoM1JgYlQjhMHc4JLEmZMEEp6ZIJgPzS4WTmZMVTILmFYAK+BmglCmd1JgUYJiPNEorABEIOZygDBm5MCiJMQlhMH8ByBXwIlBJgUxJiMd5nOTIzlBTAK+BAANVq4jPAAS/HJgJyCTATAEACC/B4S/IJgIlCYAgAPiS/Kn5yEYANTEyPc5niOQxMB/LlCOapyJJgbpBYAZzROQK/Gl0ATIWfEoZzBc6IlB6SYGgBJBJgpzSlhyH8EAh5MBTIjnCuIlOjjlHTAJzC/LmDTSSYIEoTABOYIlETSKYHXwIABOYM0yYmETSCYHEobnDOYqaBExu8TAwlEc4U5EoiaCmK+NTAolFEwX0TQzBMXwXiEpTBCAAomNEoS+EEo4mIYIImKEoS+EEpDoBEyUbEo3gEo4mJdAImIJY4lJEycdEoPOOBYmPuIlE+HcJYhKKTZ1fhYkB2EAhnNcYMuEhomMr8A3YABEoJyB5gjOAAYmHm9VgELEoJMBEoXAEyXzE45YBJgXwEqx1I+ByDOYJyVJw5yCgEB3cQGgJMWJwQnCu6/CgFBigDB13S/glVAAf1qomCglEoADB1QDBADEPEoNVqEAolEgEKolKErJMDYAJMD0lE0AmaEoNaAgJMCFIYAahV/IgIiDOTgABNYJMEOToiCIoJMCOTzfCN4RMBOTxsDJIRyfIwZMBKQZzfJgRyfOYZMBOUBzCJgNKOT5zDJgLoCADxKBOAIABOT6aCAARyfOYRyjOYRyjOYlKEsBzEEsBzEOUJzDOUIABOUiaDOURzCOUZzCEscKCiYKTusaW09Zy5pbWFnZU1ldHJpY3MoaW1nKTtnLnJlc2V0KCk7Zy5zZXRCZ0NvbG9yKNEHI2ZmMDBmZik7rHk9MTc2LHNwZWVkPTU7qmJhbGxvb24oY2FsbGJhY2spe3mXc3BlZWQ7rHg9KDE3Ni1pbS53aWR0aCkvMjtnLmRyYXdJbWFnZShpbWcseCx5KTtnLmNsZWFyUmVjdCh4LHkrODEseCs3Nyx5KzgxK3NwZWVkKTujKHk+MzApc2V0VGltZW91dChiYWxsb29uLDAsY2FsbGJhY2spO6RjYWxsYmFjaygpO31mYWRlKNEHI2ZmMDBmZiyqKCl7YmFsbG9vbiiqKCl7Zy5zZXRDb2xvcigtMSkuc2V0Rm9udCjRBjZ4MTU6Mikuc2V0Rm9udEFsaWduKDAsMCk7Zy5kcmF3U3RyaW5nKNEIV2VsY29tZS4sODgsMTMwKTt9KTt9KTtzZXRUaW1lb3V0KKooKXusbj0wO6xpPXNldEludGVydmFsKKooKXtuljQ7Zy5zY3JvbGwoMCwtNCk7oyhuPjE1MCljbGVhckludGVydmFsKGkpO30sMjApO30sMzUwMCk7fTujKG6KMimrqigpe2cucmVzZXQoKTtnLnNldEJnQ29sb3Io0QcjZmZmZjAwKS5zZXRDb2xvcigwKS5jbGVhcigpO2cuc2V0Rm9udCjRBTEyeDIwKS5zZXRGb250QWxpZ24oMCwwKTuseD03MCx5PTI1LGg9MjU7YW5pbWF0ZShbKCmiZy5kcmF3U3RyaW5nKNEEWW91cix4LHmWaCksKCmiZy5kcmF3U3RyaW5nKNEJQmFuZ2xlLmpzLHgseZZoKSwoKaJnLmRyYXdTdHJpbmco0QdoYXMgb25lLHgseZZoKSwoKaJnLmRyYXdTdHJpbmco0QZidXR0b24seCx5lmgpLCgpontnLnNldEZvbnQo0QcxMngyMDoyKS5zZXRGb250QWxpZ24oMCwwLDEpLmRyYXdTdHJpbmco0QVIRVJFISwxNTAsODgpO31dLDIwMCk7fTujKG6KMymrqigpe2cucmVzZXQoKTtnLnNldEJnQ29sb3Io0QcjMDBmZmZmKS5zZXRDb2xvcigwKS5jbGVhcigpO2cuc2V0Rm9udEFsaWduKDAsMCkuc2V0Rm9udCjRBjZ4MTU6Mik7Zy5kcmF3U3RyaW5nKNEFUHJlc3MsODgsNDApLnNldEZvbnRBbGlnbigwLC0xKTtnLnNldEZvbnQo0QUxMngyMCk7Zy5kcmF3U3RyaW5nKNEjVG8gd2FrZSB0aGUKc2NyZWVuIHVwLCBvciB0bwpzZWxlY3QsODgsNjApO307oyhuijQpq6ooKXtnLnJlc2V0KCk7Zy5zZXRCZ0NvbG9yKNEHIzAwZmZmZikuc2V0Q29sb3IoMCkuY2xlYXIoKTtnLnNldEZvbnRBbGlnbigwLDApLnNldEZvbnQo0QY2eDE1OjIpO2cuZHJhd1N0cmluZyjRCkxvbmcgUHJlc3MsODgsNDApLnNldEZvbnRBbGlnbigwLC0xKTtnLnNldEZvbnQo0QUxMngyMCk7Zy5kcmF3U3RyaW5nKNEXVG8gZ28gYmFjayB0bwp0aGUgY2xvY2ssODgsNjApO307oyhuijUpq6ooKXtnLnJlc2V0KCk7Zy5zZXRCZ0NvbG9yKNEHI2ZmMDAwMCkuc2V0Q29sb3IoMCkuY2xlYXIoKTtnLnNldEZvbnRBbGlnbigwLDApLnNldEZvbnQo0QUxMngyMCk7Zy5kcmF3U3RyaW5nKNFWSWYgQmFuZ2xlLmpzIGV2ZXIKc3RvcHMsIGhvbGQgdGhlCmJ1dHRvbiBmb3IKdGVuIHNlY29uZHMuCgpCYW5nbGUuanMgd2lsbAp0aGVuIHJlYm9vdC4sODgsNzgpO307oyhuijYpq6ooKXtnLnJlc2V0KCk7Zy5zZXRCZ0NvbG9yKNEHIzAwMDBmZikuc2V0Q29sb3IoLTEpLmNsZWFyKCk7Zy5zZXRGb250KNEFMTJ4MjApLnNldEZvbnRBbGlnbigwLDApO6x4PTg4LHk9LTIwLGg9NjA7YW5pbWF0ZShbKCmie2cuZHJhd1N0cmluZyjRIEJhbmdsZS5qcyBoYXMgYQpmdWxsIHRvdWNoc2NyZWVuLHgseZZoKTt9LDAsMCwoKaJ7Zy5kcmF3U3RyaW5nKNEsRHJhZyB1cCBhbmQgZG93bgp0byBzY3JvbGwgYW5kCnRhcCB0byBzZWxlY3QseCx5lmgpO30sXSwzMDApO307oyhuijcpq6ooKXtnLnJlc2V0KCk7Zy5zZXRCZ0NvbG9yKNEHIzAwZmYwMCkuc2V0Q29sb3IoMCkuY2xlYXIoKTtnLnNldEZvbnQo0QUxMngyMCkuc2V0Rm9udEFsaWduKDAsMCk7rHg9ODgseT0tMzUsaD04MDthbmltYXRlKFsoKaJ7Zy5kcmF3U3RyaW5nKNEpQmFuZ2xlLmpzIGNvbWVzCndpdGggYSBmZXcKYXBwcyBpbnN0YWxsZWQseCx5lmgpO30sMCwwLCgpontnLmRyYXdTdHJpbmco0SRUbyBhZGQgbW9yZSwgdmlzaXQKYmFuZ2xlanMuY29tL2FwcHMseCx5lmgpO30sXSw0MDApO307oyhuijgpq6ooKXtnLnJlc2V0KCk7Zy5zZXRCZ0NvbG9yKNEHI2ZmMDAwMCkuc2V0Q29sb3IoMCkuY2xlYXIoKTtnLnNldEZvbnQo0QUxMngyMCkuc2V0Rm9udEFsaWduKDAsMCk7rHg9ODg7Zy5kcmF3U3RyaW5nKNEgWW91IGNhbiBhbHNvIG1ha2UKeW91ciBvd24gYXBwcyEseCwzMCk7Zy5kcmF3U3RyaW5nKNEWQ2hlY2sgb3V0CmJhbmdsZWpzLmNvbSx4LDEzMCk7rHJ4PTAscnk9MDuqZHJhdygpe3J4ljAuMTtyeZYwLjExO6xyY3g9TWF0aC5jb3MocngpLHJzeD1NYXRoLnNpbihyeCkscmN5PU1hdGguY29zKHJ5KSxyc3k9TWF0aC5zaW4ocnkpO6pwKHgseSx6KXusdDt0PXgqcmN5K3oqcnN5O3o9eipyY3kteCpyc3k7eD10O3Q9eSpyY3greipyc3g7ej16KnJjeC15KnJzeDt5PXQ7epY0O6tbODgrNjAqeC96LDc4KzYwKnkvel07faxhO6xzPTMwO2cuY2xlYXJSZWN0KDg4LXMsNzgtcyw4OCtzLDc4K3MpO2E9cCgtMSwtMSwtMSk7Zy5tb3ZlVG8oYVswXSxhWzFdKTthPXAoMSwtMSwtMSk7Zy5saW5lVG8oYVswXSxhWzFdKTthPXAoMSwxLC0xKTtnLmxpbmVUbyhhWzBdLGFbMV0pO2E9cCgtMSwxLC0xKTtnLmxpbmVUbyhhWzBdLGFbMV0pO2E9cCgtMSwtMSwtMSk7Zy5saW5lVG8oYVswXSxhWzFdKTthPXAoLTEsLTEsMSk7Zy5tb3ZlVG8oYVswXSxhWzFdKTthPXAoMSwtMSwxKTtnLmxpbmVUbyhhWzBdLGFbMV0pO2E9cCgxLDEsMSk7Zy5saW5lVG8oYVswXSxhWzFdKTthPXAoLTEsMSwxKTtnLmxpbmVUbyhhWzBdLGFbMV0pO2E9cCgtMSwtMSwxKTtnLmxpbmVUbyhhWzBdLGFbMV0pO2E9cCgtMSwtMSwtMSk7Zy5tb3ZlVG8oYVswXSxhWzFdKTthPXAoLTEsLTEsMSk7Zy5saW5lVG8oYVswXSxhWzFdKTthPXAoMSwtMSwtMSk7Zy5tb3ZlVG8oYVswXSxhWzFdKTthPXAoMSwtMSwxKTtnLmxpbmVUbyhhWzBdLGFbMV0pO2E9cCgxLDEsLTEpO2cubW92ZVRvKGFbMF0sYVsxXSk7YT1wKDEsMSwxKTtnLmxpbmVUbyhhWzBdLGFbMV0pO2E9cCgtMSwxLC0xKTtnLm1vdmVUbyhhWzBdLGFbMV0pO2E9cCgtMSwxLDEpO2cubGluZVRvKGFbMF0sYVsxXSk7fXNldEludGVydmFsKGRyYXcsNTApO307oyhuijkpq6ooKXtnLnJlc2V0KCk7Zy5zZXRCZ0NvbG9yKNEHI2ZmZmZmZik7Zy5jbGVhcigpO2cuc2V0Rm9udEFsaWduKDAsMCk7Zy5zZXRGb250KNEFMTJ4MjApO6x4PTg4LHk9MTAsaD0yMTthbmltYXRlKFsoKaJnLmRyYXdTdHJpbmco0QpUaGF0J3MgaXQhLHgseZZoKSwoKaJ7Zy5kcmF3U3RyaW5nKNEFUHJlc3MseCx5lmgqMik7Zy5kcmF3U3RyaW5nKNEKdGhlIGJ1dHRvbix4LHmWaCk7Zy5kcmF3U3RyaW5nKNEIdG8gc3RhcnQseCx5lmgpO2cuZHJhd1N0cmluZyjRCUJhbmdsZS5qcyx4LHmWaCk7fV0sNDAwKTt9faxzY2VuZU51bWJlcj0wO6ptb3ZlKGRpcil7oyhkaXI+MJ5zY2VuZU51bWJlcisxilNDRU5FX0NPVU5UKas7c2NlbmVOdW1iZXI9KHNjZW5lTnVtYmVyK2RpciklU0NFTkVfQ09VTlQ7oyhzY2VuZU51bWJlcjwwKXNjZW5lTnVtYmVyPTA7Y2xlYXJJbnRlcnZhbCgpO2dldFNjZW5lKHNjZW5lTnVtYmVyKSgpO6Moc2NlbmVOdW1iZXI+MSl7rGw9U0NFTkVfQ09VTlQ7pyisaT0wO2k8bC0yO2mYKXuseD04OCsoaS0obC0yKS8yKSoxMjujKGk8c2NlbmVOdW1iZXItMSl7Zy5zZXRDb2xvcigtMSkuZmlsbENpcmNsZSh4LDE2Niw0KTt9pHtnLnNldENvbG9yKDApLmZpbGxDaXJjbGUoeCwxNjYsNCk7Zy5zZXRDb2xvcigtMSkuZHJhd0NpcmNsZSh4LDE2Niw0KTt9fX2jKHNjZW5lTnVtYmVyPFNDRU5FX0NPVU5ULTEpc2V0VGltZW91dCiqKCl7bW92ZSgxKTt9LDUwMDApO31CYW5nbGUub24o0QVzd2lwZSxkaXKibW92ZShkaXIpKTtzZXRXYXRjaCgoKaJ7oyhzY2VuZU51bWJlcopTQ0VORV9DT1VOVC0xKWxvYWQoKTukbW92ZSgxKTt9LEJUTjEse3JlcGVhdDq0fSk7QmFuZ2xlLnNldExDRFRpbWVvdXQoMCk7QmFuZ2xlLnNldExvY2tlZCgwKTtCYW5nbGUuc2V0TENEUG93ZXIoMSk7bW92ZSgwKTv////UAQAAd2VsY29tZS5zZXR0aW5ncy5qcw==");
  base64DecodeToExistingUint8Array(bufferView, 40796, "KKooYmFjayl7rXNldHRpbmdzPXJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRDHdlbGNvbWUuanNvbiwxKaByZXF1aXJlKNEHU3RvcmFnZSkucmVhZEpTT04o0QxzZXR0aW5nLmpzb24sMSmge31FLnNob3dNZW51KHsnJzp70QV0aXRsZTrRC1dlbGNvbWUgQXBwfSzRDVJ1biBuZXh0IGJvb3Q6e3ZhbHVlOiFzZXR0aW5ncy53ZWxjb21lZCxvbmNoYW5nZTp2onJlcXVpcmUo0QdTdG9yYWdlKS53cml0ZSjRDHdlbGNvbWUuanNvbix7d2VsY29tZWQ6IXZ9KSx9LNEHUnVuIE5vdzooKaJsb2FkKNEOd2VsY29tZS5hcHAuanMpLNETVHVybiBvZmYgJiBydW4gbmV4dDooKaJ7cmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlKNEMd2VsY29tZS5qc29uLHt3ZWxjb21lZDq1fSk7QmFuZ2xlLnNldExvY2tlZCi0KTujKEJhbmdsZS5zb2Z0T2ZmKCkpQmFuZ2xlLnNvZnRPZmYoKTukQmFuZ2xlLm9mZigpO30s0QY8IEJhY2s6YmFjayx9KX0pBAkAAHdlbGNvbWUuaW1n");
  base64DecodeToExistingUint8Array(bufferView, 41296, "MDCI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/szMzMzMzP7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7MzMzMzMzMzMzM/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+zMzMzc7W1tbWzs3MzMaWlrq6uv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7MzMzO1tfWzs3MzMzMzMzAlpa6urq6uv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7MzNXX1s3MzMzMzMzMzMzMupa6urq6urr+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/szMztfWzczMzMzMzMzMzMzMxpaWurq6urq6/v7+/v7+/v7+/v7+/v7+/v7+YVtbf8zN1tbNzMzMzMzMzMzMzMzMzLqWurq6urq6uv7+/v7+/v7+/v7+/v7+/mFhYVtbqczO187MzMzMzMzMzMzMzMzMzMCWurq6urq6uv7+/v7+/v7+/v7+/v7+YWGGq6yHzMzV1szMzMzMzMzMzMzMzMzMzMaWlrq6urq6uv7+/v7+/v7+/v7+/v5hYYfWq1tbzMzWzszMzMzMzMzMzMzMzMzMzMyWlrq6urq6urr+/v7+/v7+/v7+/mFhh9erYVtbzMzWzczMzMzMzMzMzMzMzMzMzMyWlrq6urq6urr+/v7+/v7+/v7+/mGG16xhYVtbzMzVzMzMzMzMzMzMzMzMzMzMzMaWlrq6urq6urr+/v7+/v7+/v7+YWGs14ZhYVtbqMzOzMzMzMzMzMzMzMzMzMzMzMCWurq6urq6urr+/v7+/v7+/v7+YYXWrGFhYVtbf8zMzczMzMzMzMzMzMzMzMzMzMCWurq6urq6urr+/v7+/v7+/v7+YYbXh2FhYVtbW8zMzMzMzMzMzMzMzMzMzMzMzJaWurq6urq6uv7+/v7+/v7+/v7+YYbXhmFhYVtbW6jMzMzMzMzMzMzMzMzMzMzMxpaWurq6urq6uv7+/v7+/v7+/v7+YYbXhmFhYWFbW3/MzMzMzMzMzMzMzMzMzMzMupa6urq6urq6uv7+/v7+/v7+/v7+YWGyhmFhYWFbW1vMzMzMzMzMzMzMzMzMzMzGlpa6urq6urq6/v7+/v7+/v7+/v7+/mGGq2FhYWFhW1t/zMzMzMzMzMzMzMzMzMy6lrq6urq6urr+/v7+/v7+/v7+/v7+/mFhq2FhYWFhW1tbqMzMzMzMzMzMzMzMzMCWlrq6urq6uv7+/v7+/v7+/v7+/v7+/v5hhoZhYWFhYVtbW8zMzMzMzMzMzMzMxpaWurq6urq6/v7+/v7+/v7+/v7+/v7+/v7+YWFhYWFhYWFbW1vMzMzMzMzMzMzGlpa6urq6urr+/v7+/v7+/v7+/v7+/v7+/v7+YWFhYWFhYWFbW1tbqMzMzMzMzMaWlpa6urq6/v7+/v7+/v7+/v7+/v7+/v7+/v7+/mFhYWFhYWFhW1tbW3/MzMzM/v66urq6uv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+YWFhYWFhYVtbW/7GxsbG/paWlv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/lthYWFhYWFb/v7GxsbG/paWlv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+YWFhW1tbW/7+pKT+/p6Xlv7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/ltbW/7+iIj+/oiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/ltbXP7+iIj+/oiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v6BiP7+iIj+iIj+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v6IiP7+iIj+iIj+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+iIj+iIj+iIj+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+iIj+iIiIiP7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/oiIiIiIiP7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/oiIiIiIiP7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/oiIiIiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v6IiIiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v6IiIiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v6IiIiI/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+iIj+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/v7+/uEAAAB3ZWxjb21lLmluZm8=");
  base64DecodeToExistingUint8Array(bufferView, 43636, "eyJpZCI6IndlbGNvbWUiLCJuYW1lIjoiV2VsY29tZSIsInNyYyI6IndlbGNvbWUuYXBwLmpzIiwiaWNvbiI6IndlbGNvbWUuaW1nIiwidmVyc2lvbiI6IjAuMTQiLCJ0YWdzIjoic3RhcnQsd2VsY29tZSIsImZpbGVzIjoid2VsY29tZS5pbmZvLHdlbGNvbWUuYm9vdC5qcyx3ZWxjb21lLmFwcC5qcyx3ZWxjb21lLnNldHRpbmdzLmpzLHdlbGNvbWUuaW1nIiwiZGF0YSI6IndlbGNvbWUuanNvbiJ9////IQkAAG5vdGlmeQ==");
  base64DecodeToExistingUint8Array(bufferView, 43896, "rXBvcz0wLHNpemU9MDsKrWlkPbY7Cq1oaWRlQ2FsbGJhY2s9tzsKrW92ZXJsYXlJbWFnZT23OwqqZml0V29yZHModGV4dCxyb3dzLHdpZHRoKXuud29yZHM9dGV4dC50cmltKCkuc3Vic3RyKDAscm93cyp3aWR0aCkuc3BsaXQoL1xzKy8pO61yb3c9MSxsZW49MCxsaW1pdD13aWR0aDutcmVzdWx0PSIiO6corXdvcmTGd29yZHMpe6MoKGxlbj9sZW4rMTowKSt3b3JkLmxlbmd0aD5saW1pdCl7oyhyb3eRcm93cyl7cmVzdWx0ltEDLi4uO6g7fXJlc3VsdJbRAQo7bGVuPTA7cm93mDujKHJvd4tyb3dzKWxpbWl0lzM7fXJlc3VsdJYobGVuP9EBIDoiIikrd29yZDtsZW6WKGxlbj8xOjApK3dvcmQubGVuZ3RoO32rcmVzdWx0O30KZXhwb3J0cy5zaG93Paoob3B0aW9ucyl7b3B0aW9ucz1vcHRpb25zoHt9O6Mob3B0aW9ucy5vbou3KW9wdGlvbnMub249tDtpZD0o0QJpZLlvcHRpb25zKT9vcHRpb25zLmlkOrY7rXc9Zy5nZXRXaWR0aCgpO610ZXh0PVtdO3NpemU9b3B0aW9ucy5zaXplO6Mob3B0aW9ucy5ib2R5KXuuYmg9KHNpemWgODApLTIwLG1heFJvd3M9TWF0aC5mbG9vcigoYmgtNCkvOCksbWF4Q2hhcnM9TWF0aC5mbG9vcih3LzYpLTI7dGV4dD1maXRXb3JkcyhvcHRpb25zLmJvZHksbWF4Um93cyxtYXhDaGFycyk7oyghc2l6ZSlzaXplPTI4Kyh0ZXh0Lm1hdGNoKC9cbi9nKS5sZW5ndGgrMSkqODt9pHNpemU9MjA7oyhzaXplPjgwKXNpemU9ODA7rWdnPUdyYXBoaWNzLmNyZWF0ZUFycmF5QnVmZmVyKHcsc2l6ZSwxNik7Z2cuc2V0QmdDb2xvcihnLnRoZW1lLmJnKTtvdmVybGF5SW1hZ2U9e3dpZHRoOmdnLmdldFdpZHRoKCksaGVpZ2h0OmdnLmdldEhlaWdodCgpLGJwcDoxNixidWZmZXI6Z2cuYnVmZmVyfTuteD0wLHk9MCxoPXNpemUsYj15K2gtMSxyPXgrdy0xO6Mob3B0aW9ucy5iZ0NvbG9yjbcpZ2cuc2V0QmdDb2xvcihvcHRpb25zLmJnQ29sb3IpO2dnLmNsZWFyUmVjdCh4LHkscixiKTujKG9wdGlvbnMudGl0bGWgb3B0aW9ucy5zcmMpe2dnLnNldENvbG9yKNEMdGl0bGVCZ0NvbG9yuW9wdGlvbnM/b3B0aW9ucy50aXRsZUJnQ29sb3I6Zy50aGVtZS5kYXJrPzB4MToweDM5QzcpLmZpbGxSZWN0KHgseSxyLHkrMjApO650aXRsZT1vcHRpb25zLnRpdGxloG9wdGlvbnMuc3JjO2dnLnNldENvbG9yKGcudGhlbWUuZmcpLnNldEZvbnRBbGlnbigtMSwtMSwwKS5zZXRGb250KNEDNng4LDIpO2dnLmRyYXdTdHJpbmcodGl0bGUudHJpbSgpLnN1YnN0cmluZygwLDEzKSx4KzI1LHkrMyk7oyhvcHRpb25zLnRpdGxlnm9wdGlvbnMuc3JjKXtnZy5zZXRGb250KNEDNng4LDEpLnNldEZvbnRBbGlnbigxLDEsMCk7Z2cuZHJhd1N0cmluZyhvcHRpb25zLnNyYy5zdWJzdHJpbmcoMCwxMCksZ2cuZ2V0V2lkdGgoKS0yMyx5KzE4KTt9fXmWMjA7aJcyMDujKG9wdGlvbnMuaWNvbil7rWk9b3B0aW9ucy5pY29uLGl3O2dnLmRyYXdJbWFnZShpLHgseSs0KTujKNEGc3RyaW5nir9pKWl3PWkuY2hhckNvZGVBdCgwKTukaXc9aVswXTt4lml3O3eXaXc7faMob3B0aW9ucy5ib2R5KXtnZy5zZXRDb2xvcihnLnRoZW1lLmZnKS5zZXRGb250KNEDNng4LDEpLnNldEZvbnRBbGlnbigtMSwtMSwwKS5kcmF3U3RyaW5nKHRleHQseCs2LHkrNCk7faMob3B0aW9ucy5yZW5kZXIpe29wdGlvbnMucmVuZGVyKHt4OngseTp5LHc6dyxoOmh9KTt9oyhvcHRpb25zLm9uniEocmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWRKU09OKNEMc2V0dGluZy5qc29uLDEpoHt9KS5xdWlldCl7QmFuZ2xlLnNldExDRFBvd2VyKDEpO32qYW5pbSgpe3Bvc5cyO6MocG9zPC1zaXplKXtwb3M9LXNpemU7fUJhbmdsZS5zZXRMQ0RPdmVybGF5KG92ZXJsYXlJbWFnZSwwLC0ocG9zK3NpemUpKTujKHBvcz4tc2l6ZSlzZXRUaW1lb3V0KGFuaW0sMTUpO31hbmltKCk7QmFuZ2xlLm9uKNEFdG91Y2gsZXhwb3J0cy5oaWRlKTujKG9wdGlvbnMub25IaWRlKWhpZGVDYWxsYmFjaz1vcHRpb25zLm9uSGlkZTt9OwpleHBvcnRzLmhpZGU9qihvcHRpb25zKXtvcHRpb25zPW9wdGlvbnOge307oyjRAmlkuW9wdGlvbnOeb3B0aW9ucy5pZI1pZCmrO6MoaGlkZUNhbGxiYWNrKWhpZGVDYWxsYmFjayh7aWQ6aWR9KTtoaWRlQ2FsbGJhY2s9tztpZD22O0JhbmdsZS5yZW1vdmVMaXN0ZW5lcijRBXRvdWNoLGV4cG9ydHMuaGlkZSk7RS5zdG9wRXZlbnRQcm9wYWdhdGlvbp5FLnN0b3BFdmVudFByb3BhZ2F0aW9uKCk7qmFuaW0oKXtwb3OWNDujKHBvcz4wKXtwb3M9MDtvdmVybGF5SW1hZ2U9tztCYW5nbGUuc2V0TENET3ZlcmxheSgpO32kQmFuZ2xlLnNldExDRE92ZXJsYXkob3ZlcmxheUltYWdlLDAsLShwb3Mrc2l6ZSkpO6MocG9zPDApc2V0VGltZW91dChhbmltLDEwKTt9YW5pbSgpO307////dAAAAG5vdGlmeS5pbmZv");
  base64DecodeToExistingUint8Array(bufferView, 46268, "eyJpZCI6Im5vdGlmeSIsIm5hbWUiOiJOb3RpZmljYXRpb25zIiwidHlwZSI6Im5vdGlmeSIsInZlcnNpb24iOiIwLjE0IiwidGFncyI6IndpZGdldCIsImZpbGVzIjoibm90aWZ5LmluZm8sbm90aWZ5In3dEQAAaGVhbHRoLmFwcC5qcw==");
  base64DecodeToExistingUint8Array(bufferView, 46416, "rXNldHRpbmdzOwqubXlwcm9maWxlPXJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRDm15cHJvZmlsZS5qc29uLDEpoHt9OwqqbWVudU1haW4oKXtFLnNob3dNZW51KHsiIjp7dGl0bGU60Q9IZWFsdGggVHJhY2tpbmd9LNEGPCBCYWNrOigpomxvYWQoKSzRDVN0ZXAgQ291bnRpbmc6KCmibWVudVN0ZXBDb3VudCgpLNEITW92ZW1lbnQ6KCmibWVudU1vdmVtZW50KCks0QpIZWFydCBSYXRlOigpom1lbnVIUk0oKSzRCFNldHRpbmdzOigpomV2YWwocmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWQo0RJoZWFsdGguc2V0dGluZ3MuanMpKSgoKaJ7bG9hZFNldHRpbmdzKCk7bWVudU1haW4oKTt9KX0pO30Kqm1lbnVTdGVwQ291bnQoKXuubWVudT17IiI6e3RpdGxlOtEFU3RlcHN9LNEGPCBCYWNrOigpom1lbnVNYWluKCks0QhwZXIgaG91cjooKaJzdGVwc1BlckhvdXIobWVudVN0ZXBDb3VudCks0QdwZXIgZGF5OigponN0ZXBzUGVyRGF5KG1lbnVTdGVwQ291bnQpfTujKG15cHJvZmlsZS5zdHJpZGVMZW5ndGgpe21lbnVb0QhkaXN0YW5jZV09KCmibWVudURpc3RhbmNlKCk7fUUuc2hvd01lbnUobWVudSk7fQqqbWVudURpc3RhbmNlKCl7rmRpc3RNdWx0PTEqcmVxdWlyZSjRBmxvY2FsZSkuZGlzdGFuY2UobXlwcm9maWxlLnN0cmlkZUxlbmd0aCwyKTtFLnNob3dNZW51KHsiIjp7dGl0bGU60QhEaXN0YW5jZX0s0QY8IEJhY2s6KCmibWVudVN0ZXBDb3VudCgpLNEIcGVyIGhvdXI6KCmic3RlcHNQZXJIb3VyKG1lbnVEaXN0YW5jZSxkaXN0TXVsdCks0QdwZXIgZGF5OigponN0ZXBzUGVyRGF5KG1lbnVEaXN0YW5jZSxkaXN0TXVsdCl9KTt9CqptZW51TW92ZW1lbnQoKXtFLnNob3dNZW51KHsiIjp7dGl0bGU60QhNb3ZlbWVudH0s0QY8IEJhY2s6KCmibWVudU1haW4oKSzRCHBlciBob3VyOigpom1vdmVtZW50UGVySG91cigpLNEHcGVyIGRheTooKaJtb3ZlbWVudFBlckRheSgpLH0pO30Kqm1lbnVIUk0oKXtFLnNob3dNZW51KHsiIjp7dGl0bGU60QpIZWFydCBSYXRlfSzRBjwgQmFjazooKaJtZW51TWFpbigpLNEIcGVyIGhvdXI6KCmiaHJtUGVySG91cigpLNEHcGVyIGRheTooKaJocm1QZXJEYXkoKSx9KTt9CqpzdGVwc1BlckhvdXIoYmFjayxtdWx0KXtFLnNob3dNZXNzYWdlKNEKTG9hZGluZy4uLik7Y3VycmVudF9zZWxlY3Rpb2490QxzdGVwc1BlckhvdXI7rGRhdGE9uFVpbnQxNkFycmF5KDI0KTtyZXF1aXJlKNEGaGVhbHRoKS5yZWFkRGF5KLhEYXRlKCksaKJkYXRhW2guaHJdlmguc3RlcHMpO6MobXVsdI23KXtkYXRhLmZvckVhY2goKGQsaSmiZGF0YVtpXT1kKm11bHQrMC41KTt9c2V0QnV0dG9uKGJhY2ssbXVsdCk7YmFyQ2hhcnQo0QRIT1VSLGRhdGEsbXVsdCk7fQqqc3RlcHNQZXJEYXkoYmFjayxtdWx0KXtFLnNob3dNZXNzYWdlKNEKTG9hZGluZy4uLik7Y3VycmVudF9zZWxlY3Rpb2490QtzdGVwc1BlckRheTusZGF0YT24VWludDE2QXJyYXkoMzIpO3JlcXVpcmUo0QZoZWFsdGgpLnJlYWREYWlseVN1bW1hcmllcyi4RGF0ZSgpLGiiZGF0YVtoLmRheV2WaC5zdGVwcyk7oyhkYXRhWyi4RGF0ZSgpKS5nZXREYXRlKCldizApe2RhdGFbKLhEYXRlKCkpLmdldERhdGUoKV09QmFuZ2xlLmdldEhlYWx0aFN0YXR1cyjRA2RheSkuc3RlcHM7faMobXVsdI23KXtkYXRhLmZvckVhY2goKGQsaSmiZGF0YVtpXT1kKm11bHQrMC41KTt9c2V0QnV0dG9uKGJhY2ssbXVsdCk7YmFyQ2hhcnQo0QNEQVksZGF0YSxtdWx0KTtkcmF3SG9yaXpvbnRhbExpbmUoc2V0dGluZ3Muc3RlcEdvYWwqKG11bHSgMSkpO30KqmhybVBlckhvdXIoKXtFLnNob3dNZXNzYWdlKNEKTG9hZGluZy4uLik7Y3VycmVudF9zZWxlY3Rpb2490Qpocm1QZXJIb3VyO6xkYXRhPbhVaW50MTZBcnJheSgyNCk7rGNudD24VWludDhBcnJheSgyNCk7cmVxdWlyZSjRBmhlYWx0aCkucmVhZERheSi4RGF0ZSgpLGiie2RhdGFbaC5ocl2WaC5icG07oyhoLmJwbSljbnRbaC5ocl2YO30pO2RhdGEuZm9yRWFjaCgoZCxpKaJkYXRhW2ldPWQvY250W2ldKzAuNSk7c2V0QnV0dG9uKG1lbnVIUk0pO2JhckNoYXJ0KNEESE9VUixkYXRhKTt9Cqpocm1QZXJEYXkoKXtFLnNob3dNZXNzYWdlKNEKTG9hZGluZy4uLik7Y3VycmVudF9zZWxlY3Rpb2490Qlocm1QZXJEYXk7rGRhdGE9uFVpbnQxNkFycmF5KDMyKTusY250PbhVaW50OEFycmF5KDMyKTtyZXF1aXJlKNEGaGVhbHRoKS5yZWFkRGFpbHlTdW1tYXJpZXMouERhdGUoKSxoontkYXRhW2guZGF5XZZoLmJwbTujKGguYnBtKWNudFtoLmRheV2YO30pO2RhdGEuZm9yRWFjaCgoZCxpKaJkYXRhW2ldPWQvY250W2ldKzAuNSk7c2V0QnV0dG9uKG1lbnVIUk0pO2JhckNoYXJ0KNEDREFZLGRhdGEpO30Kqm1vdmVtZW50UGVySG91cigpe0Uuc2hvd01lc3NhZ2Uo0QpMb2FkaW5nLi4uKTtjdXJyZW50X3NlbGVjdGlvbj3RD21vdmVtZW50UGVySG91cjusZGF0YT24VWludDE2QXJyYXkoMjQpO6xjbnQ9uFVpbnQ4QXJyYXkoMjQpO3JlcXVpcmUo0QZoZWFsdGgpLnJlYWREYXkouERhdGUoKSxoontkYXRhW2guaHJdlmgubW92ZW1lbnQ7Y250W2guaHJdmDt9KTtkYXRhLmZvckVhY2goKGQsaSmiZGF0YVtpXT1kL2NudFtpXSswLjUpO3NldEJ1dHRvbihtZW51TW92ZW1lbnQpO2JhckNoYXJ0KNEESE9VUixkYXRhKTt9Cqptb3ZlbWVudFBlckRheSgpe0Uuc2hvd01lc3NhZ2Uo0QpMb2FkaW5nLi4uKTtjdXJyZW50X3NlbGVjdGlvbj3RDm1vdmVtZW50UGVyRGF5O6xkYXRhPbhVaW50MTZBcnJheSgzMik7rGNudD24VWludDhBcnJheSgzMik7cmVxdWlyZSjRBmhlYWx0aCkucmVhZERhaWx5U3VtbWFyaWVzKLhEYXRlKCksaKJ7ZGF0YVtoLmRheV2WaC5tb3ZlbWVudDtjbnRbaC5kYXldmDt9KTtkYXRhLmZvckVhY2goKGQsaSmiZGF0YVtpXT1kL2NudFtpXSswLjUpO3NldEJ1dHRvbihtZW51TW92ZW1lbnQpO2JhckNoYXJ0KNEDREFZLGRhdGEpO30Krnc9Zy5nZXRXaWR0aCgpOwquaD1nLmdldEhlaWdodCgpOwquYmFyX2JvdD0xNDA7CqxkYXRhX2xlbjsKrGNoYXJ0X2luZGV4OwqsY2hhcnRfbWF4X2RhdHVtOwqsY2hhcnRfbGFiZWw7CqxjaGFydF9kYXRhOwqsY3VycmVudF9zZWxlY3Rpb247CqptYXgoYXJyKXusbT0tSW5maW5pdHk7pyisaT0wO2k8YXJyLmxlbmd0aDtpmCmjKGFycltpXT5tKW09YXJyW2ldO6ttO30KqmdldF9kYXRhX2xlbmd0aChhcnIpe6xubGVuPWFyci5sZW5ndGg7pyisaT1hcnIubGVuZ3RoLTE7aT4wnmFycltpXYowO2mZKW5sZW6ZO6tubGVuO30KqmJhckNoYXJ0KGxhYmVsLGR0KXtkYXRhX2xlbj1nZXRfZGF0YV9sZW5ndGgoZHQpO2NoYXJ0X2luZGV4PU1hdGgubWF4KGRhdGFfbGVuLTUsLTUpO2NoYXJ0X21heF9kYXR1bT1tYXgoZHQpO2NoYXJ0X2xhYmVsPWxhYmVsO2NoYXJ0X2RhdGE9ZHQ7ZHJhd0JhckNoYXJ0KCk7fQqqZHJhd0JhckNoYXJ0KCl7rmJhcl93aWR0aD0ody0yKS85O6xiYXJfdG9wO6xiYXI7Zy5yZXNldCgpLmNsZWFyUmVjdCgwLDI0LHcsaCk7pyhiYXI9MTtiYXI8MTA7YmFymCl7oyhiYXKKNSl7Zy5zZXRGb250KNEDNng4LDIpLnNldEZvbnRBbGlnbigwLC0xKS5zZXRDb2xvcihnLnRoZW1lLmZnKTtnLmRyYXdTdHJpbmcoY2hhcnRfbGFiZWwr0QEgKyhjaGFydF9pbmRleCtiYXItMSkr0QMgICArY2hhcnRfZGF0YVtjaGFydF9pbmRleCtiYXItMV0sZy5nZXRXaWR0aCgpLzIsMTUwKTtnLnNldENvbG9yKNEEIzAwZik7faR7Zy5zZXRDb2xvcijRBCMwZmYpO32jKChjaGFydF9pbmRleCtiYXItMSmRMJ4oY2hhcnRfaW5kZXgrYmFyLTEpPGRhdGFfbGVunmNoYXJ0X21heF9kYXR1bT4wKWJhcl90b3A9YmFyX2JvdC0xMDAqKGNoYXJ0X2RhdGFbY2hhcnRfaW5kZXgrYmFyLTFdKS9jaGFydF9tYXhfZGF0dW07pGJhcl90b3A9YmFyX2JvdDtnLmZpbGxSZWN0KDErKGJhci0xKSpiYXJfd2lkdGgsYmFyX2JvdCwxK2JhcipiYXJfd2lkdGgsYmFyX3RvcCk7Zy5zZXRDb2xvcihnLnRoZW1lLmZnKS5kcmF3UmVjdCgxKyhiYXItMSkqYmFyX3dpZHRoLGJhcl9ib3QsMStiYXIqYmFyX3dpZHRoLGJhcl90b3ApO319CqpkcmF3SG9yaXpvbnRhbExpbmUodmFsdWUpe650b3A9YmFyX2JvdC0xMDAqdmFsdWUvY2hhcnRfbWF4X2RhdHVtO2cuc2V0Q29sb3IoZy50aGVtZS5mZykuZHJhd0xpbmUoMCx0b3AsZy5nZXRXaWR0aCgpLHRvcCk7fQqqc2V0QnV0dG9uKGZuLG11bHQpe0JhbmdsZS5zZXRVSSh7bW9kZTrRBmN1c3RvbSxiYWNrOmZuLHN3aXBlOihscix1ZCmie6MobHKKMSl7Y2hhcnRfaW5kZXg9TWF0aC5tYXgoKGNoYXJ0X2xhYmVsitEDREFZKT8tMzotNCxjaGFydF9pbmRleC0xKTt9pKMobHI8MCl7Y2hhcnRfaW5kZXg9TWF0aC5taW4oZGF0YV9sZW4tNSxjaGFydF9pbmRleCsxKTt9pHurZm4oKTt9ZHJhd0JhckNoYXJ0KCk7oyhjdXJyZW50X3NlbGVjdGlvborRC3N0ZXBzUGVyRGF5KXtkcmF3SG9yaXpvbnRhbExpbmUoc2V0dGluZ3Muc3RlcEdvYWwqKG11bHSgMSkpO319fSk7fQqqbG9hZFNldHRpbmdzKCl7c2V0dGluZ3M9cmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWRKU09OKNELaGVhbHRoLmpzb24sMSmge307fQpCYW5nbGUubG9hZFdpZGdldHMoKTsKQmFuZ2xlLmRyYXdXaWRnZXRzKCk7CmxvYWRTZXR0aW5ncygpOwptZW51TWFpbigpO////0wCAABoZWFsdGguaW1n");
  base64DecodeToExistingUint8Array(bufferView, 51024, "MDDCAP//4Pn//zv/");
  base64DecodeToExistingUint8Array(bufferView, 51122, "AVVQAAAFVUAAAAAAFVVVAABVVVQAAAAAVVVVQAFVVVoAAAABVVVVUAVVVWqAAAAFVVVVVBVVVeqgAAAVVVVVVVVVV6q0AAAVVVVVVVVVXqrUAABVVVVVVVVVeqtVAABVVVVVVVVV6q1VAABVVXrVVVVXqrVVAABVVWq1VVVeqtVVAABVVWqtVVV6q1VVAABVVXqrVVXqrVVVAABVVV6q1VeqtVVVAAAVVVeqtV6q1VVUAAAVVVXqrXqrVVVUAAAFVVV6q+qtVVVQAAABVVVeqqq1VVVAAAAAVVVXqqrVVVUAAAAAFVVV6qtVVVQAAAAABVVVeq1VVVAAAAAAAVVVXrVVVUAAAAAAAFVVV9VVVQAAAAAAABVVVVVVVAAAAAAAAAVVVVVVUAAAAAAAAAFVVVVVQAAAAAAAAABVVVVVAAAAAAAAAAAVVVVUAAAAAAAAAAAFVVVQAAAAAAAAAAABVVVA");
  base64DecodeToExistingUint8Array(bufferView, 51485, "VVU=");
  base64DecodeToExistingUint8Array(bufferView, 51497, "FVQ=");
  base64DecodeToExistingUint8Array(bufferView, 51509, "BVA=");
  base64DecodeToExistingUint8Array(bufferView, 51521, "AUA=");
  base64DecodeToExistingUint8Array(bufferView, 51612, "YQgAAGhlYWx0aC5ib290Lmpz");
  base64DecodeToExistingUint8Array(bufferView, 51644, "ZnVuY3Rpb24gbSgpe3ZhciBhPXJlcXVpcmUoIlN0b3JhZ2UiKS5yZWFkSlNPTigiaGVhbHRoLmpzb24iLDEpfHx7fSxkPUJhbmdsZS5nZXRIZWFsdGhTdGF0dXMoImRheSIpLnN0ZXBzO2Euc3RlcEdvYWxOb3RpZmljYXRpb24mJjA8YS5zdGVwR29hbCYmZD49YS5zdGVwR29hbCYmKGQ9KG5ldyBEYXRlKERhdGUubm93KCkpKS50b0lTT1N0cmluZygpLnNwbGl0KCJUIilbMF0sIWEuc3RlcEdvYWxOb3RpZmljYXRpb25EYXRlfHxhLnN0ZXBHb2FsTm90aWZpY2F0aW9uRGF0ZTxkKSYmKEJhbmdsZS5idXp6KDIwMCwuNSkscmVxdWlyZSgibm90aWZ5Iikuc2hvdyh7dGl0bGU6YS5zdGVwR29hbCsiIHN0ZXBzIixib2R5OiJZb3UgcmVhY2hlZCB5b3VyIHN0ZXAgZ29hbCEiLGljb246YXRvYigiREF5QkFCbUQ2QmFCTUFzQThCQ0JDQkNCQ0E4QUFBPT0iKX0pLGEuc3RlcEdvYWxOb3RpZmljYXRpb25EYXRlPWQscmVxdWlyZSgiU3RvcmFnZSIpLndyaXRlSlNPTigiaGVhbHRoLmpzb24iLAphKSl9KGZ1bmN0aW9uKCl7dmFyIGE9MHwocmVxdWlyZSgiU3RvcmFnZSIpLnJlYWRKU09OKCJoZWFsdGguanNvbiIsMSl8fHt9KS5ocm07aWYoMT09YXx8Mj09YSl7ZnVuY3Rpb24gZCgpe0JhbmdsZS5zZXRIUk1Qb3dlcigxLCJoZWFsdGgiKTtzZXRUaW1lb3V0KCgpPT5CYW5nbGUuc2V0SFJNUG93ZXIoMCwiaGVhbHRoIiksNkU0KmEpO2lmKDE9PWEpe2Z1bmN0aW9uIGIoKXtCYW5nbGUuc2V0SFJNUG93ZXIoMSwiaGVhbHRoIik7c2V0VGltZW91dCgoKT0+e0JhbmdsZS5zZXRIUk1Qb3dlcigwLCJoZWFsdGgiKX0sNkU0KX1zZXRUaW1lb3V0KGIsMkU1KTtzZXRUaW1lb3V0KGIsNEU1KX19QmFuZ2xlLm9uKCJoZWFsdGgiLGQpO0JhbmdsZS5vbigiSFJNIixiPT57OTA8Yi5jb25maWRlbmNlJiYxPk1hdGguYWJzKEJhbmdsZS5nZXRIZWFsdGhTdGF0dXMoKS5icG0tYi5icG0pJiZCYW5nbGUuc2V0SFJNUG93ZXIoMCwiaGVhbHRoIil9KTs5MDxCYW5nbGUuZ2V0SGVhbHRoU3RhdHVzKCkuYnBtQ29uZmlkZW5jZXx8CmQoKX1lbHNlIEJhbmdsZS5zZXRIUk1Qb3dlcighIWEsImhlYWx0aCIpfSkoKTtCYW5nbGUub24oImhlYWx0aCIsYT0+e2Z1bmN0aW9uIGQoYyl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYy5zdGVwcz4+OCxjLnN0ZXBzJjI1NSxjLmJwbSxNYXRoLm1pbihjLm1vdmVtZW50LDI1NSkpfXZhciBiPW5ldyBEYXRlKERhdGUubm93KCktNTlFNCk7YSYmMDxhLnN0ZXBzJiZtKCk7dmFyIGY9ZnVuY3Rpb24oYyl7cmV0dXJuIDE0NSooYy5nZXREYXRlKCktMSkrNipjLmdldEhvdXJzKCkrKDB8NipjLmdldE1pbnV0ZXMoKS82MCl9KGIpO2I9ZnVuY3Rpb24oYyl7cmV0dXJuImhlYWx0aC0iK2MuZ2V0RnVsbFllYXIoKSsiLSIrKGMuZ2V0TW9udGgoKSsxKSsiLnJhdyJ9KGIpO3ZhciBnPXJlcXVpcmUoIlN0b3JhZ2UiKS5yZWFkKGIpO2lmKGcpe3ZhciBlPWcuc3Vic3RyKDgrNCpmLDQpO2lmKCJceGZmXHhmZlx4ZmZceGZmIiE9ZSl7cHJpbnQoIkhFQUxUSCBFUlI6IEFscmVhZHkgd3JpdHRlbiEiKTsKcmV0dXJufX1lbHNlIHJlcXVpcmUoIlN0b3JhZ2UiKS53cml0ZShiLCJIRUFMVEgxXHgwMCIsMCwxNzk4OCk7dmFyIGg9OCs0KmY7YT1PYmplY3QuYXNzaWduKHt9LGEpO2EubW92ZW1lbnQvPTg7cmVxdWlyZSgiU3RvcmFnZSIpLndyaXRlKGIsZChhKSxoLDE3OTg4KTtpZigxNDM9PWYlMTQ1KWlmKGY9aCs0LCJceGZmXHhmZlx4ZmZceGZmIiE9Zy5zdWJzdHIoZiw0KSlwcmludCgiSEVBTFRIIEVSUjogRGFpbHkgc3VtbWFyeSBhbHJlYWR5IHdyaXR0ZW4hIik7ZWxzZXthPXtzdGVwczowLGJwbTowLG1vdmVtZW50OjAsbW92Q250OjAsYnBtQ250OjB9O2Zvcih2YXIgaz0wOzE0ND5rO2srKyl7ZT1nLnN1YnN0cihoLDQpO2lmKCJceGZmXHhmZlx4ZmZceGZmIiE9ZSl7YS5zdGVwcys9KGUuY2hhckNvZGVBdCgwKTw8OCkrZS5jaGFyQ29kZUF0KDEpO3ZhciBsPWUuY2hhckNvZGVBdCgyKTthLmJwbSs9bDthLm1vdmVtZW50Kz1lLmNoYXJDb2RlQXQoMyk7YS5tb3ZDbnQrKzsKbCYmYS5icG1DbnQrK31oLT00fWEuYnBtQ250JiYoYS5icG0vPWEuYnBtQ250KTthLm1vdkNudCYmKGEubW92ZW1lbnQvPWEubW92Q250KTtyZXF1aXJlKCJTdG9yYWdlIikud3JpdGUoYixkKGEpLGYsMTc5ODgpfX0p////HAYAAGhlYWx0aA==");
  base64DecodeToExistingUint8Array(bufferView, 53824, "ZnVuY3Rpb24gaChhKXtyZXR1cm4iaGVhbHRoLSIrYS5nZXRGdWxsWWVhcigpKyItIisoYS5nZXRNb250aCgpKzEpKyIucmF3In1mdW5jdGlvbiBrKGEpe3JldHVybiAxNDUqKGEuZ2V0RGF0ZSgpLTEpKzYqYS5nZXRIb3VycygpKygwfDYqYS5nZXRNaW51dGVzKCkvNjApfWV4cG9ydHMucmVhZEFsbFJlY29yZHM9ZnVuY3Rpb24oYSxlKXthPWgoYSk7YT1yZXF1aXJlKCJTdG9yYWdlIikucmVhZChhKTtpZih2b2lkIDAhPT1hKWZvcih2YXIgZD04LGI9MDszMT5iO2IrKyl7Zm9yKHZhciBjPTA7MjQ+YztjKyspZm9yKHZhciBmPTA7Nj5mO2YrKyl7dmFyIGc9YS5zdWJzdHIoZCw0KTsiXHhmZlx4ZmZceGZmXHhmZiIhPWcmJmUoe2RheTpiKzEsaHI6YyxtaW46MTAqZixzdGVwczpnLmNoYXJDb2RlQXQoMCk8PDh8Zy5jaGFyQ29kZUF0KDEpLGJwbTpnLmNoYXJDb2RlQXQoMiksbW92ZW1lbnQ6OCpnLmNoYXJDb2RlQXQoMyl9KTtkKz0KNH1kKz00fX07ZXhwb3J0cy5yZWFkRnVsbERhdGFiYXNlPWZ1bmN0aW9uKGEpe3JlcXVpcmUoIlN0b3JhZ2UiKS5saXN0KC9oZWFsdGgtWzAtOV0rLVswLTldKy5yYXcvKS5mb3JFYWNoKGU9Pntjb25zb2xlLmxvZyhlKTtlPWUuc3BsaXQoIi0iKTt2YXIgZD1wYXJzZUludChlWzFdKSxiPXBhcnNlSW50KGVbMl0ucmVwbGFjZSgiLnJhdyIsIiIpKTtleHBvcnRzLnJlYWRBbGxSZWNvcmRzKG5ldyBEYXRlKGQsYiwxKSxjPT57Yy5kYXRlPW5ldyBEYXRlKGQsYixjLmRheSxjLmhyLGMubWluKTthKGMpfSl9KX07ZXhwb3J0cy5yZWFkQWxsUmVjb3Jkc1NpbmNlPWZ1bmN0aW9uKGEsZSl7Zm9yKHZhciBkPShuZXcgRGF0ZSkuZ2V0VGltZSgpO2EuZ2V0VGltZSgpPD1kOylleHBvcnRzLnJlYWREYXkoYSxiPT57Yi5kYXRlPW5ldyBEYXRlKGEuZ2V0RnVsbFllYXIoKSxhLmdldE1vbnRoKCksYS5nZXREYXRlKCksYi5ocixiLm1pbik7ZShiKX0pLGEuc2V0RGF0ZShhLmdldERhdGUoKSsxKX07CmV4cG9ydHMucmVhZERhaWx5U3VtbWFyaWVzPWZ1bmN0aW9uKGEsZSl7ayhhKTthPWgoYSk7YT1yZXF1aXJlKCJTdG9yYWdlIikucmVhZChhKTtpZih2b2lkIDAhPT1hKWZvcih2YXIgZD01ODQsYj0wOzMxPmI7YisrKXt2YXIgYz1hLnN1YnN0cihkLDQpOyJceGZmXHhmZlx4ZmZceGZmIiE9YyYmZSh7ZGF5OmIrMSxzdGVwczpjLmNoYXJDb2RlQXQoMCk8PDh8Yy5jaGFyQ29kZUF0KDEpLGJwbTpjLmNoYXJDb2RlQXQoMiksbW92ZW1lbnQ6OCpjLmNoYXJDb2RlQXQoMyl9KTtkKz01ODB9fTtleHBvcnRzLnJlYWREYXk9ZnVuY3Rpb24oYSxlKXtrKGEpO3ZhciBkPWgoYSk7ZD1yZXF1aXJlKCJTdG9yYWdlIikucmVhZChkKTtpZih2b2lkIDAhPT1kKXthPTgrNTgwKihhLmdldERhdGUoKS0xKTtmb3IodmFyIGI9MDsyND5iO2IrKylmb3IodmFyIGM9MDs2PmM7YysrKXt2YXIgZj1kLnN1YnN0cihhLDQpOyJceGZmXHhmZlx4ZmZceGZmIiE9ZiYmZSh7aHI6YixtaW46MTAqCmMsc3RlcHM6Zi5jaGFyQ29kZUF0KDApPDw4fGYuY2hhckNvZGVBdCgxKSxicG06Zi5jaGFyQ29kZUF0KDIpLG1vdmVtZW50OjgqZi5jaGFyQ29kZUF0KDMpfSk7YSs9NH19fb8CAABoZWFsdGguc2V0dGluZ3MuanM=");
  base64DecodeToExistingUint8Array(bufferView, 55420, "KKooYmFjayl7rHNldHRpbmdzPU9iamVjdC5hc3NpZ24oe2hybTowLHN0ZXBHb2FsOjEwMDAwLHN0ZXBHb2FsTm90aWZpY2F0aW9uOrV9LHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRC2hlYWx0aC5qc29uLLQpoHt9KTuqc2V0U2V0dGluZ3MoKXtyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGVKU09OKNELaGVhbHRoLmpzb24sc2V0dGluZ3MpO31FLnNob3dNZW51KHsiIjp7dGl0bGU60Q9IZWFsdGggVHJhY2tpbmd9LNEGPCBCYWNrOigpomJhY2soKSzRDEhSTSBJbnRlcnZhbDp7dmFsdWU6c2V0dGluZ3MuaHJtLG1pbjowLG1heDozLGZvcm1hdDp2olvRA09mZizRBTMgbWluLNEGMTAgbWluLNEGQWx3YXlzXVt2XSxvbmNoYW5nZTp2ontzZXR0aW5ncy5ocm09djtzZXRTZXR0aW5ncygpO319LNEPRGFpbHkgU3RlcCBHb2FsOnt2YWx1ZTpzZXR0aW5ncy5zdGVwR29hbCxtaW46MCxtYXg6MjAwMDAsc3RlcDoyNTAsb25jaGFuZ2U6dqJ7c2V0dGluZ3Muc3RlcEdvYWw9djtzZXRTZXR0aW5ncygpO319LNEWU3RlcCBHb2FsIE5vdGlmaWNhdGlvbjp7dmFsdWU60RRzdGVwR29hbE5vdGlmaWNhdGlvbrlzZXR0aW5ncz9zZXR0aW5ncy5zdGVwR29hbE5vdGlmaWNhdGlvbjq1LG9uY2hhbmdlOigpontzZXR0aW5ncy5zdGVwR29hbE5vdGlmaWNhdGlvbj0hc2V0dGluZ3Muc3RlcEdvYWxOb3RpZmljYXRpb247c2V0U2V0dGluZ3MoKTt9fSx9KTt9Kf/jAAAAaGVhbHRoLmluZm8=");
  base64DecodeToExistingUint8Array(bufferView, 56156, "eyJpZCI6ImhlYWx0aCIsIm5hbWUiOiJIZWFsdGgiLCJzcmMiOiJoZWFsdGguYXBwLmpzIiwiaWNvbiI6ImhlYWx0aC5pbWciLCJ2ZXJzaW9uIjoiMC4zMCIsInRhZ3MiOiJ0b29sLHN5c3RlbSxoZWFsdGgiLCJmaWxlcyI6ImhlYWx0aC5pbmZvLGhlYWx0aC5hcHAuanMsaGVhbHRoLmltZyxoZWFsdGguYm9vdC5qcyxoZWFsdGgsaGVhbHRoLnNldHRpbmdzLmpzIiwiZGF0YSI6ImhlYWx0aC5qc29uIn3/iVQAAHNldHRpbmcuYXBwLmpz");
  base64DecodeToExistingUint8Array(bufferView, 56416, "TW9kdWxlcy5hZGRDYWNoZWQo0QpkYXRlX3V0aWxzLKooKXtleHBvcnRzLmRvdz0oaSxhYmJyZXZpYXRlZCmie6xkb3c9cmVxdWlyZSjRBmxvY2FsZSkuZG93KHtnZXREYXk6KCmiKGl8MCklN30sYWJicmV2aWF0ZWQpLnNsaWNlKDAsKGFiYnJldmlhdGVkijIpPzE6MTAwKTurYWJicmV2aWF0ZWSKMj9kb3cudG9VcHBlckNhc2UoKTpkb3c7fWV4cG9ydHMuZG93cz0oZmlyc3REYXlPZldlZWssYWJicmV2aWF0ZWQponusZG93cz1bXTunKKxpPTA7aTw3O2mYKXtkb3dzLnB1c2goZXhwb3J0cy5kb3coaSsoZmlyc3REYXlPZldlZWugMCksYWJicmV2aWF0ZWQpKX2rYWJicmV2aWF0ZWSKMj9kb3dzLm1hcChkb3eiZG93LnRvVXBwZXJDYXNlKCkpOmRvd3M7fTtleHBvcnRzLm1vbnRoPShpLGFiYnJldmlhdGVkKaJ7rG1vbnRoPXJlcXVpcmUo0QZsb2NhbGUpLm1vbnRoKHtnZXRNb250aDooKaIoMTErKGl8MCkpJTEyfSxhYmJyZXZpYXRlZCkuc2xpY2UoMCwoYWJicmV2aWF0ZWSKMik/MToxMDApO6thYmJyZXZpYXRlZIoyP21vbnRoLnRvVXBwZXJDYXNlKCk6bW9udGg7fWV4cG9ydHMubW9udGhzPShhYmJyZXZpYXRlZCmie6xtb250aHM9W107rGxvY2FsZT1yZXF1aXJlKNEGbG9jYWxlKTunKKxpPTA7aTwxMjtpmCltb250aHMucHVzaChsb2NhbGUubW9udGgoe2dldE1vbnRoOigpoml9LGFiYnJldmlhdGVkKS5zbGljZSgwLChhYmJyZXZpYXRlZIoyKT8xOjEwMCkpO6thYmJyZXZpYXRlZIoyP21vbnRocy5tYXAobW9udGiibW9udGgudG9VcHBlckNhc2UoKSk6bW9udGhzO307fSk7Ck1vZHVsZXMuYWRkQ2FjaGVkKNEMd2lkZ2V0X3V0aWxzLKooKXtleHBvcnRzLm9mZnNldD0wO2V4cG9ydHMuaGlkZT2qKCl7ZXhwb3J0cy5jbGVhbnVwKCk7oyghZ2xvYmFsLldJREdFVFMpqztnLnJlc2V0KCk7pyisd8ZnbG9iYWwuV0lER0VUUyl7oyh3Ll9kcmF3Kas7dy5fZHJhdz13LmRyYXc7dy5kcmF3PSgpont9O3cuX2FyZWE9dy5hcmVhO3cuYXJlYT0iIjujKHcueIy3KWcuY2xlYXJSZWN0KHcueCx3Lnksdy54K3cud2lkdGgtMSx3LnkrMjMpO319O2V4cG9ydHMuc2hvdz2qKCl7ZXhwb3J0cy5jbGVhbnVwKCk7oyghZ2xvYmFsLldJREdFVFMpqzunKKx3xmdsb2JhbC5XSURHRVRTKXujKCF3Ll9kcmF3Kas7dy5kcmF3PXcuX2RyYXc7dy5hcmVhPXcuX2FyZWE7vncuX2RyYXc7vncuX2FyZWE7dy5kcmF3KHcpO319O2V4cG9ydHMuY2xlYW51cE92ZXJsYXk9qigpe2V4cG9ydHMub2Zmc2V0PS0yNDtCYW5nbGUuc2V0TENET3ZlcmxheSi3LHtpZDrRDHdpZGdldF91dGlsc30pO75leHBvcnRzLmF1dG9oaWRlO75CYW5nbGUuYXBwUmVjdDujKGV4cG9ydHMuYW5pbUludGVydmFsKXtjbGVhckludGVydmFsKGV4cG9ydHMuYW5pbUludGVydmFsKTu+ZXhwb3J0cy5hbmltSW50ZXJ2YWw7faMoZXhwb3J0cy5oaWRlVGltZW91dCl7Y2xlYXJUaW1lb3V0KGV4cG9ydHMuaGlkZVRpbWVvdXQpO75leHBvcnRzLmhpZGVUaW1lb3V0O319O2V4cG9ydHMuY2xlYW51cD2qKCl7ZXhwb3J0cy5jbGVhbnVwT3ZlcmxheSgpO75leHBvcnRzLm9mZnNldDujKGV4cG9ydHMuc3dpcGVIYW5kbGVyKXtCYW5nbGUucmVtb3ZlTGlzdGVuZXIo0QVzd2lwZSxleHBvcnRzLnN3aXBlSGFuZGxlcik7vmV4cG9ydHMuc3dpcGVIYW5kbGVyO32jKGV4cG9ydHMub3JpZ0RyYXcpe0JhbmdsZS5kcmF3V2lkZ2V0cz1leHBvcnRzLm9yaWdEcmF3O75leHBvcnRzLm9yaWdEcmF3O319O2V4cG9ydHMuc3dpcGVPbj2qKGF1dG9oaWRlKXujKHByb2Nlc3MuZW52LkhXVkVSU0lPTo0yKatleHBvcnRzLmhpZGUoKTtleHBvcnRzLmNsZWFudXAoKTujKCFnbG9iYWwuV0lER0VUUymrO2V4cG9ydHMuYXV0b2hpZGU9YXV0b2hpZGWLtz8yMDAwOmF1dG9oaWRlO0JhbmdsZS5hcHBSZWN0PXt4OjAseTowLHc6Zy5nZXRXaWR0aCgpLGg6Zy5nZXRIZWlnaHQoKSx4MjpnLmdldFdpZHRoKCktMSx5MjpnLmdldEhlaWdodCgpLTF9O61vZz1HcmFwaGljcy5jcmVhdGVBcnJheUJ1ZmZlcihnLmdldFdpZHRoKCksMjYsMTYse21zYjq0fSk7b2cudGhlbWU9Zy50aGVtZTtvZy5fcmVzZXQ9b2cucmVzZXQ7b2cucmVzZXQ9qigpe6uvLl9yZXNldCgpLnNldENvbG9yKGcudGhlbWUuZmcpLnNldEJnQ29sb3IoZy50aGVtZS5iZyk7fTtvZy5yZXNldCgpLmNsZWFyUmVjdCgwLDAsb2cuZ2V0V2lkdGgoKSwyMykuZmlsbFJlY3QoMCwyNCxvZy5nZXRXaWR0aCgpLDI1KTutX2c9ZztleHBvcnRzLm9mZnNldD0tMjQ7qnF1ZXVlRHJhdygpe65vPWV4cG9ydHMub2Zmc2V0O0JhbmdsZS5hcHBSZWN0Lnk9bysyNDtCYW5nbGUuYXBwUmVjdC5oPTErQmFuZ2xlLmFwcFJlY3QueTItQmFuZ2xlLmFwcFJlY3QueTujKG8+LTI0KXtCYW5nbGUuc2V0TENET3ZlcmxheShvZywwLG8se2lkOtEMd2lkZ2V0X3V0aWxzLHJlbW92ZTooKaJ7cmVxdWlyZSjRDHdpZGdldF91dGlscykuY2xlYW51cE92ZXJsYXkoKTt9fSk7faR7QmFuZ2xlLnNldExDRE92ZXJsYXkotyx7aWQ60Qx3aWRnZXRfdXRpbHN9KTt9facorHfGZ2xvYmFsLldJREdFVFMpoyghdy5fZHJhdyl7dy5fZHJhdz13LmRyYXc7dy5kcmF3PaooKXtnPW9nO68uX2RyYXcoryk7Zz1fZzujKGV4cG9ydHMub2Zmc2V0Pi0yNClxdWV1ZURyYXcoKTt9O3cuX2FyZWE9dy5hcmVhO6Mody5hcmVhLnN0YXJ0c1dpdGgo0QFiKSl3LmFyZWE90QF0K3cuYXJlYS5zdWJzdHIoMSk7fWV4cG9ydHMub3JpZ0RyYXc9QmFuZ2xlLmRyYXdXaWRnZXRzO0JhbmdsZS5kcmF3V2lkZ2V0cz0oKaJ7Zz1vZztleHBvcnRzLm9yaWdEcmF3KCk7Zz1fZzt9O6phbmltKGRpcixjYWxsYmFjayl7oyhleHBvcnRzLmFuaW1JbnRlcnZhbCljbGVhckludGVydmFsKGV4cG9ydHMuYW5pbUludGVydmFsKTtleHBvcnRzLmFuaW1JbnRlcnZhbD1zZXRJbnRlcnZhbCiqKCl7ZXhwb3J0cy5vZmZzZXSWZGlyO61zdG9wPbU7oyhkaXI+MJ5leHBvcnRzLm9mZnNldJEwKXtzdG9wPbQ7ZXhwb3J0cy5vZmZzZXQ9MDt9pKMoZGlyPDCeZXhwb3J0cy5vZmZzZXQ8LTIzKXtzdG9wPbQ7ZXhwb3J0cy5vZmZzZXQ9LTI0O32jKHN0b3Ape2NsZWFySW50ZXJ2YWwoZXhwb3J0cy5hbmltSW50ZXJ2YWwpO75leHBvcnRzLmFuaW1JbnRlcnZhbDujKGNhbGxiYWNrKWNhbGxiYWNrKCk7fXF1ZXVlRHJhdygpO30sNTApO31leHBvcnRzLnN3aXBlSGFuZGxlcj2qKGxyLHVkKXujKGV4cG9ydHMuaGlkZVRpbWVvdXQpe2NsZWFyVGltZW91dChleHBvcnRzLmhpZGVUaW1lb3V0KTu+ZXhwb3J0cy5oaWRlVGltZW91dDt9rWNiO6MoZXhwb3J0cy5hdXRvaGlkZT4wKWNiPaooKXtleHBvcnRzLmhpZGVUaW1lb3V0PXNldFRpbWVvdXQoqigpe2FuaW0oLTQpO30sZXhwb3J0cy5hdXRvaGlkZSk7fTujKHVkPjCeZXhwb3J0cy5vZmZzZXQ8MClhbmltKDQsY2IpO6ModWQ8MJ5leHBvcnRzLm9mZnNldD4tMjQpYW5pbSgtNCk7fTtCYW5nbGUub24o0QVzd2lwZSxleHBvcnRzLnN3aXBlSGFuZGxlcik7QmFuZ2xlLmRyYXdXaWRnZXRzKCk7fTt9KTt7QmFuZ2xlLmxvYWRXaWRnZXRzKCk7QmFuZ2xlLmRyYXdXaWRnZXRzKCk7rkJBTkdMRUpTMj1wcm9jZXNzLmVudi5IV1ZFUlNJT06KMjuuc3RvcmFnZT1yZXF1aXJlKNEHU3RvcmFnZSk7rXNldHRpbmdzO65zY3JvbGxzPVtdO61tZW51U2Nyb2xsZXI7qnVwZGF0ZVNldHRpbmdzKCl7c3RvcmFnZS53cml0ZSjRDHNldHRpbmcuanNvbixzZXR0aW5ncyk7fapwdXNoTWVudShtZW51KXujKG1lbnVTY3JvbGxlcilzY3JvbGxzLnB1c2gobWVudVNjcm9sbGVyLnNjcm9sbCk7oyhtZW51KXuubT1FLnNob3dNZW51KG1lbnUpO21lbnVTY3JvbGxlcj1tLnNjcm9sbGVyO6ttO319qnJlc3RvcmVNZW51KG1lbnUpe6MoIW1lbnVbIiJdKW1lbnVbIiJdPXt9O21lbnVbIiJdLnNjcm9sbD1tZW51U2Nyb2xsZXIuc2Nyb2xsO21lbnVTY3JvbGxlcj1FLnNob3dNZW51KG1lbnUpLnNjcm9sbGVyO32qcG9wTWVudShtZW51KXujKCFtZW51WyIiXSltZW51WyIiXT17fTttZW51WyIiXS5zY3JvbGw9c2Nyb2xscy5wb3AoKXwwO65tPUUuc2hvd01lbnUobWVudSk7bWVudVNjcm9sbGVyPW0uc2Nyb2xsZXI7q207fap1cGRhdGVPcHRpb25zKCl7rG89c2V0dGluZ3Mub3B0aW9uczujKEJBTkdMRUpTMil7oyghKG8ud2FrZU9uQlROMaBvLndha2VPbkZhY2VVcKBvLndha2VPblRvdWNooG8ud2FrZU9uRG91YmxlVGFwoG8ud2FrZU9uVHdpc3QpKXtvLndha2VPbkJUTjE9tDt9faR7oyghKG8ud2FrZU9uQlROMaBvLndha2VPbkJUTjKgby53YWtlT25CVE4zoG8ud2FrZU9uRmFjZVVwoG8ud2FrZU9uVG91Y2igby53YWtlT25Ud2lzdCkpby53YWtlT25CVE4yPbQ7fXVwZGF0ZVNldHRpbmdzKCk7QmFuZ2xlLnNldE9wdGlvbnMobyl9qnJlc2V0U2V0dGluZ3MoKXtzZXR0aW5ncz17YmxlOrQsYmxlcmVwbDq0LGxvZzq1LHF1aWV0OjAsdGltZW91dDoxMCx2aWJyYXRlOrQsYmVlcDpCQU5HTEVKUzI/tDrRA3ZpYix0aW1lem9uZTowLEhJRDq1LGNsb2NrOrYs0QYxMmhvdXI6tSxmaXJzdERheU9mV2VlazowLGJyaWdodG5lc3M6MSxvcHRpb25zOnt3YWtlT25CVE4xOrQsd2FrZU9uQlROMjq0LHdha2VPbkJUTjM6tCx3YWtlT25GYWNlVXA6tSx3YWtlT25Ub3VjaDq1LHdha2VPblR3aXN0OrUsdHdpc3RUaHJlc2hvbGQ6ODE5LjIsdHdpc3RNYXhZOi04MDAsdHdpc3RUaW1lb3V0OjEwMDB9LH07dXBkYXRlU2V0dGluZ3MoKTt9c2V0dGluZ3M9c3RvcmFnZS5yZWFkSlNPTijRDHNldHRpbmcuanNvbiwxKTujKCjRBm9iamVjdIy/c2V0dGluZ3MpoCjRBm9iamVjdIy/c2V0dGluZ3Mub3B0aW9ucykpcmVzZXRTZXR0aW5ncygpO6ptYWluTWVudSgpe65tYWlubWVudT17Jyc6e9EFdGl0bGU60QhTZXR0aW5nc30s0QY8IEJhY2s6KCmibG9hZCgpLNEEQXBwczooKaJwdXNoTWVudShhcHBTZXR0aW5nc01lbnUoKSks0QZTeXN0ZW06KCmicHVzaE1lbnUoc3lzdGVtTWVudSgpKSzRCUJsdWV0b290aDooKaJwdXNoTWVudShCTEVNZW51KCkpLNEGQWxlcnRzOigponB1c2hNZW51KGFsZXJ0c01lbnUoKSks0QVVdGlsczooKaJwdXNoTWVudSh1dGlsTWVudSgpKX07q21haW5tZW51O32qc3lzdGVtTWVudSgpe65tYWlubWVudT17Jyc6e9EFdGl0bGU60QZTeXN0ZW19LNEGPCBCYWNrOigponBvcE1lbnUobWFpbk1lbnUoKSks0QVUaGVtZTooKaJzaG93VGhlbWVNZW51KCks0QNMQ0Q6KCmicHVzaE1lbnUoTENETWVudSgpKSzRBkxvY2FsZTooKaJwdXNoTWVudShsb2NhbGVNZW51KCkpLNEFQ2xvY2s6KCmicHVzaE1lbnUoY2xvY2tNZW51KCkpLNEITGF1bmNoZXI6KCmicHVzaE1lbnUobGF1bmNoZXJNZW51KCkpLNELRGF0ZSAmIFRpbWU6KCmicHVzaE1lbnUoc2V0VGltZU1lbnUoKSl9O6ttYWlubWVudTt9qmFsZXJ0c01lbnUoKXusYmVlcE1lbnVJdGVtO6MoQkFOR0xFSlMyKXtiZWVwTWVudUl0ZW09e3ZhbHVlOnNldHRpbmdzLmJlZXCMtSxvbmNoYW5nZTp2ontzZXR0aW5ncy5iZWVwPXY7dXBkYXRlU2V0dGluZ3MoKTujKHNldHRpbmdzLmJlZXApe2FuYWxvZ1dyaXRlKFZJQlJBVEUsMC4xLHtmcmVxOjIwMDB9KTtzZXRUaW1lb3V0KCgpolZJQlJBVEUucmVzZXQoKSwyMDApO319fTt9pHusYmVlcFY9W7UstCzRA3ZpYl07rGJlZXBOPVvRA09mZizRBVBpZXpvLNEHVmlicmF0ZV07YmVlcE1lbnVJdGVtPXt2YWx1ZTpNYXRoLm1heCgwfGJlZXBWLmluZGV4T2Yoc2V0dGluZ3MuYmVlcCksMCksbWluOjAsbWF4OmJlZXBWLmxlbmd0aC0xLGZvcm1hdDp2omJlZXBOW3ZdLG9uY2hhbmdlOnaie3NldHRpbmdzLmJlZXA9YmVlcFZbdl07oyh2ijEpe2FuYWxvZ1dyaXRlKEQxOCwwLjUse2ZyZXE6MjAwMH0pO3NldFRpbWVvdXQoKCmiRDE4LnJlc2V0KCksMjAwKTt9pKModooyKXthbmFsb2dXcml0ZShWSUJSQVRFLDAuMSx7ZnJlcToyMDAwfSk7c2V0VGltZW91dCgoKaJWSUJSQVRFLnJlc2V0KCksMjAwKTt9dXBkYXRlU2V0dGluZ3MoKTt9fTt9rm1haW5tZW51PXsnJzp70QV0aXRsZTrRBkFsZXJ0c30s0QY8IEJhY2s6KCmicG9wTWVudShtYWluTWVudSgpKSzRBEJlZXA6YmVlcE1lbnVJdGVtLNEJVmlicmF0aW9uOnt2YWx1ZTpzZXR0aW5ncy52aWJyYXRlLG9uY2hhbmdlOigpontzZXR0aW5ncy52aWJyYXRlPSFzZXR0aW5ncy52aWJyYXRlO3VwZGF0ZVNldHRpbmdzKCk7oyhzZXR0aW5ncy52aWJyYXRlKXtWSUJSQVRFLndyaXRlKDEpO3NldFRpbWVvdXQoKCmiVklCUkFURS53cml0ZSgwKSwxMCk7fX19LNEKUXVpZXQgTW9kZTp7dmFsdWU6c2V0dGluZ3MucXVpZXR8MCxmb3JtYXQ6dqJb0QNPZmYs0QZBbGFybXMs0QZTaWxlbnRdW3YlM10sb25jaGFuZ2U6dqJ7c2V0dGluZ3MucXVpZXQ9diUzO3VwZGF0ZVNldHRpbmdzKCk7dXBkYXRlT3B0aW9ucygpO6Mo0QdxbXNjaGVkuVdJREdFVFMpV0lER0VUU1vRB3Ftc2NoZWRdLmRyYXcoKTt9LH19O6ttYWlubWVudTt9qkJMRU1lbnUoKXusaGlkVj1btSzRB2tibWVkaWEs0QJrYizRA2NvbSzRA2pveV07rGhpZE49W9EDT2ZmLNEMS2JyZCAmIE1lZGlhLNEES2JyZCzRDEticmQgJiBNb3VzZSzRCEpveXN0aWNrXTuscHJpdmFjeT1b0QNPZmYs0QlTaG93IG5hbWUs0QlIaWRlIG5hbWVdO6t7Jyc6e9EFdGl0bGU60QlCbHVldG9vdGh9LNEGPCBCYWNrOigponBvcE1lbnUobWFpbk1lbnUoKSks0RBNYWtlIENvbm5lY3RhYmxlOigpom1ha2VDb25uZWN0YWJsZSgpLNEDQkxFOnt2YWx1ZTpzZXR0aW5ncy5ibGUsb25jaGFuZ2U6KCmie3NldHRpbmdzLmJsZT0hc2V0dGluZ3MuYmxlO3VwZGF0ZVNldHRpbmdzKCk7fX0s0QxQcm9ncmFtbWFibGU6e3ZhbHVlOnNldHRpbmdzLmJsZXJlcGwsb25jaGFuZ2U6KCmie3NldHRpbmdzLmJsZXJlcGw9IXNldHRpbmdzLmJsZXJlcGw7dXBkYXRlU2V0dGluZ3MoKTt9fSzRB1ByaXZhY3k6e21pbjowLG1heDpwcml2YWN5Lmxlbmd0aC0xLGZvcm1hdDp2onByaXZhY3lbdl0sdmFsdWU6KCgponujKHNldHRpbmdzLmJsZXByaXZhY3mec2V0dGluZ3MuYmxlbmFtZYu1KasyO6Moc2V0dGluZ3MuYmxlcHJpdmFjeSmrMTurMDt9KSgpLG9uY2hhbmdlOnaie3NldHRpbmdzLmJsZXByaXZhY3k9MDu+c2V0dGluZ3MuYmxlbmFtZTu7KHYpe7wwOqg7vDE6c2V0dGluZ3MuYmxlcHJpdmFjeT0xO6g7vDI6c2V0dGluZ3MuYmxlcHJpdmFjeT0xO3NldHRpbmdzLmJsZW5hbWU9tTuoO311cGRhdGVTZXR0aW5ncygpO319LNEDSElEOnt2YWx1ZTpNYXRoLm1heCgwLDB8aGlkVi5pbmRleE9mKHNldHRpbmdzLkhJRCkpLG1pbjowLG1heDpoaWROLmxlbmd0aC0xLGZvcm1hdDp2omhpZE5bdl0sb25jaGFuZ2U6dqJ7c2V0dGluZ3MuSElEPWhpZFZbdl07dXBkYXRlU2V0dGluZ3MoKTt9fSzRB1Bhc3NrZXk6e3ZhbHVlOnNldHRpbmdzLnBhc3NrZXk/c2V0dGluZ3MucGFzc2tleTrRBG5vbmUsb25jaGFuZ2U6KCmic2V0VGltZW91dCgoKaJwdXNoTWVudShwYXNza2V5TWVudSgpKSl9LNEJV2hpdGVsaXN0Ont2YWx1ZTooKHNldHRpbmdzLndoaXRlbGlzdF9kaXNhYmxlZKAhc2V0dGluZ3Mud2hpdGVsaXN0KT/RA29mZjrRAm9uKSsoc2V0dGluZ3Mud2hpdGVsaXN0P9ECICgrc2V0dGluZ3Mud2hpdGVsaXN0Lmxlbmd0aCvRASk6IiIpLG9uY2hhbmdlOigponNldFRpbWVvdXQoKCmicHVzaE1lbnUod2hpdGVsaXN0TWVudSgpKSl9fTt9qnNob3dUaGVtZU1lbnUocG9wKXuqY2woeCl7q2cuc2V0Q29sb3IoeCkuZ2V0Q29sb3IoKTt9qnVwZCh0aCl7Zy50aGVtZT10aDtzZXR0aW5ncy50aGVtZT10aDt1cGRhdGVTZXR0aW5ncygpO75nLnJlc2V0O2cuX3Jlc2V0PWcucmVzZXQ7Zy5yZXNldD2qKG4pe6tnLl9yZXNldCgpLnNldENvbG9yKHRoLmZnKS5zZXRCZ0NvbG9yKHRoLmJnKTt9O2cuY2xlYXI9qihuKXujKG4pZy5yZXNldCgpO6tnLmNsZWFyUmVjdCgwLDAsZy5nZXRXaWR0aCgpLGcuZ2V0SGVpZ2h0KCkpO307Zy5jbGVhcigxKTtCYW5nbGUuZHJhd1dpZGdldHMoKTttLmRyYXcoKTt9rHRoZW1lc01lbnU9eycnOnt0aXRsZTrRBVRoZW1lfSzRBjwgQmFjazooKaJwb3BNZW51KHN5c3RlbU1lbnUoKSks0QdEYXJrIEJXOigpont1cGQoe2ZnOmNsKNEEI2ZmZiksYmc6Y2wo0QQjMDAwKSxmZzI6Y2wo0QQjZmZmKSxiZzI6Y2wo0QQjMDA0KSxmZ0g6Y2wo0QQjZmZmKSxiZ0g6Y2wo0QQjMDBmKSxkYXJrOrR9KTt9LNEITGlnaHQgQlc6KCmie3VwZCh7Zmc6Y2wo0QQjMDAwKSxiZzpjbCjRBCNmZmYpLGZnMjpjbCjRBCMwMDApLGJnMjpjbCjRBCNjZmYpLGZnSDpjbCjRBCMwMDApLGJnSDpjbCjRBCMwZmYpLGRhcms6tX0pO319O3N0b3JhZ2UubGlzdCgvXi4qXC50aGVtZSQvKS5mb3JFYWNoKG6ie61uZXdUaGVtZT1zdG9yYWdlLnJlYWRKU09OKG4pO3RoZW1lc01lbnVbbmV3VGhlbWUubmFtZT9uZXdUaGVtZS5uYW1lOm5dPSgpont1cGQoe2ZnOmNsKG5ld1RoZW1lLmZnKSxiZzpjbChuZXdUaGVtZS5iZyksZmcyOmNsKG5ld1RoZW1lLmZnMiksYmcyOmNsKG5ld1RoZW1lLmJnMiksZmdIOmNsKG5ld1RoZW1lLmZnSCksYmdIOmNsKG5ld1RoZW1lLmJnSCksZGFyazpuZXdUaGVtZS5kYXJrfSk7fTt9KTt0aGVtZXNNZW51W9EJQ3VzdG9taXplXT0oKaJzaG93Q3VzdG9tVGhlbWVNZW51KCk7rG09KHBvcD9wb3BNZW51OnB1c2hNZW51KSh0aGVtZXNNZW51KTuqc2hvd0N1c3RvbVRoZW1lTWVudSgpe6pzZXRUKHQsdil7rXRoPWcudGhlbWU7dGhbdF09djujKHSL0QJiZyl7dGhb0QRkYXJrXT0odotjbCjRBCMwMDApKTt9dXBkKHRoKTt9rXJnYj17fTtyZ2Jb0QVibGFja1090QQjMDAwO3JnYlvRBXdoaXRlXT3RBCNmZmY7cmdiW9EDcmVkXT3RBCNmMDA7cmdiW9EFZ3JlZW5dPdEEIzBmMDtyZ2Jb0QRibHVlXT3RBCMwMGY7cmdiW9EEY3lhbl090QQjMGZmO3JnYlvRB21hZ2VudGFdPdEEI2YwZjtyZ2Jb0QZ5ZWxsb3ddPdEEI2ZmMDujKCFCQU5HTEVKUzIpe3JnYlvRBm9yYW5nZV090QcjZmY3ZjAwO3JnYlvRBnB1cnBsZV090QcjN2YwMGZmO3JnYlvRBGdyZXldPdEHIzdmN2Y3Zjt9rWNvbG9ycz1bXSxuYW1lcz1bXTunKK5juXJnYil7bmFtZXMucHVzaChjKTtjb2xvcnMucHVzaChjbChyZ2JbY10pKTt9rW1lbnU9eycnOnt0aXRsZTrRDEN1c3RvbSBUaGVtZX0s0QY8IEJhY2s6KCmic2hvd1RoZW1lTWVudSgxKX07rmxhYmVscz17Zmc60QpGb3JlZ3JvdW5kLGJnOtEKQmFja2dyb3VuZCxmZzI60QxGb3JlZ3JvdW5kIDIsYmcyOtEMQmFja2dyb3VuZCAyLGZnSDrRDEhpZ2hsaWdodCBGRyxiZ0g60QxIaWdobGlnaHQgQkcsfTtb0QJmZyzRAmJnLNEDZmcyLNEDYmcyLNEDZmdILNEDYmdIXS5mb3JFYWNoKHSie21lbnVbbGFiZWxzW3RdXT17bWluOjAsbWF4OmNvbG9ycy5sZW5ndGgtMSx3cmFwOrQsdmFsdWU6TWF0aC5tYXgoY29sb3JzLmluZGV4T2YoZy50aGVtZVt0XSksMCksZm9ybWF0OnaibmFtZXNbdl0sb25jaGFuZ2U6qih2KXusYz1jb2xvcnNbdl07oyh0i9ECZmeeZy50aGVtZS5iZ4tjKXNldFQo0QJiZyxnLnRoZW1lLmZnKTujKHSL0QJiZ55nLnRoZW1lLmZni2Mpc2V0VCjRAmZnLGcudGhlbWUuYmcpO3NldFQodCxjKTt9LH07fSk7bT1wdXNoTWVudShtZW51KTt9fapwYXNza2V5TWVudSgpe6xtZW51PXvRBjwgQmFjazooKaJwb3BNZW51KEJMRU1lbnUoKSks0QdEaXNhYmxlOigpontzZXR0aW5ncy5wYXNza2V5Pbc7dXBkYXRlU2V0dGluZ3MoKTtwb3BNZW51KEJMRU1lbnUoKSk7fX07oyghc2V0dGluZ3MucGFzc2tleaBzZXR0aW5ncy5wYXNza2V5Lmxlbmd0aIw2KXtzZXR0aW5ncy5wYXNza2V5PdEGMTIzNDU2O3VwZGF0ZVNldHRpbmdzKCk7facorGk9MDtpPDY7aZgpKKooaSl7bWVudVtgRGlnaXQgJHtpKzF9YF09e3ZhbHVlOjB8c2V0dGluZ3MucGFzc2tleVtpXSxtaW46MCxtYXg6OSxvbmNoYW5nZTp2onuscD1zZXR0aW5ncy5wYXNza2V5LnNwbGl0KCIiKTtwW2ldPXY7c2V0dGluZ3MucGFzc2tleT1wLmpvaW4oIiIpO3VwZGF0ZVNldHRpbmdzKCk7fX07fSkoaSk7q21lbnU7fQqqd2hpdGVsaXN0TWVudSgpe6xtZW51PXvRBjwgQmFjazooKaJwb3BNZW51KEJMRU1lbnUoKSksfTujKHNldHRpbmdzLndoaXRlbGlzdF9kaXNhYmxlZCl7bWVudVvRBkVuYWJsZV09KCmie75zZXR0aW5ncy53aGl0ZWxpc3RfZGlzYWJsZWQ7dXBkYXRlU2V0dGluZ3MoKTtwb3BNZW51KEJMRU1lbnUoKSk7fTt9pHttZW51W9EHRGlzYWJsZV09KCmie3NldHRpbmdzLndoaXRlbGlzdF9kaXNhYmxlZD20O3VwZGF0ZVNldHRpbmdzKCk7cG9wTWVudShCTEVNZW51KCkpO307faMoc2V0dGluZ3Mud2hpdGVsaXN0KXNldHRpbmdzLndoaXRlbGlzdC5mb3JFYWNoKKooZCl7bWVudVtkLnN1YnN0cigwLDE3KV09qigpe0Uuc2hvd1Byb21wdCjRB1JlbW92ZQorZCkudGhlbigodimie6Modil7c2V0dGluZ3Mud2hpdGVsaXN0LnNwbGljZShzZXR0aW5ncy53aGl0ZWxpc3QuaW5kZXhPZihkKSwxKTt1cGRhdGVTZXR0aW5ncygpO31zZXRUaW1lb3V0KCgponJlc3RvcmVNZW51KHdoaXRlbGlzdE1lbnUoKSksNTApO30pO319KTttZW51W9EKQWRkIERldmljZV09qigpe0Uuc2hvd0FsZXJ0KNEiQ29ubmVjdCBkZXZpY2UKdG8gYWRkIHRvCndoaXRlbGlzdCzRCVdoaXRlbGlzdCkudGhlbiiqKCl7TlJGLnJlbW92ZUFsbExpc3RlbmVycyjRB2Nvbm5lY3QpO3Jlc3RvcmVNZW51KHdoaXRlbGlzdE1lbnUoKSk7fSk7TlJGLnJlbW92ZUFsbExpc3RlbmVycyjRB2Nvbm5lY3QpO05SRi5vbijRB2Nvbm5lY3QsqihhZGRyKXujKCFzZXR0aW5ncy53aGl0ZWxpc3Qpc2V0dGluZ3Mud2hpdGVsaXN0PVtdO75zZXR0aW5ncy53aGl0ZWxpc3RfZGlzYWJsZWQ7oyhOUkYucmVzb2x2ZUFkZHJlc3ONtyl7rXJlc29sdmVkQWRkcj1OUkYucmVzb2x2ZUFkZHJlc3MoYWRkcik7oyhyZXNvbHZlZEFkZHKNtyl7YWRkcj1yZXNvbHZlZEFkZHIr0QsgKHJlc29sdmVkKTt9fXNldHRpbmdzLndoaXRlbGlzdC5wdXNoKGFkZHIpO3VwZGF0ZVNldHRpbmdzKCk7TlJGLnJlbW92ZUFsbExpc3RlbmVycyjRB2Nvbm5lY3QpO3Jlc3RvcmVNZW51KHdoaXRlbGlzdE1lbnUoKSk7fSk7fTurbWVudTt9CqpMQ0RNZW51KCl7qmdUb0ludGVybmFsKGcpe6tnKjgxOTI7fappbnRlcm5hbFRvRyh1KXurdS84MTkyO32scm90TmFtZXM9W9ECTm8s0QlSb3RhdGUgQ1cs0QtMZWZ0IEhhbmRlZCzRClJvdGF0ZSBDQ1cs0QZNaXJyb3JdO65sY2RNZW51PXsnJzp70QV0aXRsZTrRA0xDRH0s0QY8IEJhY2s6KCmicG9wTWVudShzeXN0ZW1NZW51KCkpLH07oyhCQU5HTEVKUzIpT2JqZWN0LmFzc2lnbihsY2RNZW51LHvRCUNhbGlicmF0ZTooKaJzaG93VG91Y2hzY3JlZW5DYWxpYnJhdGlvbigpfSk7T2JqZWN0LmFzc2lnbihsY2RNZW51LHvRDkxDRCBCcmlnaHRuZXNzOnt2YWx1ZTpzZXR0aW5ncy5icmlnaHRuZXNzLG1pbjowLjEsbWF4OjEsc3RlcDowLjEsb25jaGFuZ2U6dqJ7c2V0dGluZ3MuYnJpZ2h0bmVzcz12oDE7dXBkYXRlU2V0dGluZ3MoKTtCYW5nbGUuc2V0TENEQnJpZ2h0bmVzcyhzZXR0aW5ncy5icmlnaHRuZXNzKTt9fSzRC0xDRCBUaW1lb3V0Ont2YWx1ZTpzZXR0aW5ncy50aW1lb3V0LG1pbjowLG1heDo2MCxzdGVwOjUsb25jaGFuZ2U6dqJ7c2V0dGluZ3MudGltZW91dD0wfHY7dXBkYXRlU2V0dGluZ3MoKTtCYW5nbGUuc2V0TENEVGltZW91dChzZXR0aW5ncy50aW1lb3V0KTt9fSzRBlJvdGF0ZTp7dmFsdWU6MHxzZXR0aW5ncy5yb3RhdGUsbWluOjAsbWF4OnJvdE5hbWVzLmxlbmd0aC0xLGZvcm1hdDp2onJvdE5hbWVzW3ZdLG9uY2hhbmdlOnaie3NldHRpbmdzLnJvdGF0ZT0wfHY7dXBkYXRlU2V0dGluZ3MoKTtnLnNldFJvdGF0aW9uKHNldHRpbmdzLnJvdGF0ZSYzLHNldHRpbmdzLnJvdGF0ZZIyKS5jbGVhcigpO0JhbmdsZS5kcmF3V2lkZ2V0cygpO319fSk7oyhCQU5HTEVKUzIpe09iamVjdC5hc3NpZ24obGNkTWVudSx70Q5XYWtlIG9uIEJ1dHRvbjp7dmFsdWU6ISFzZXR0aW5ncy5vcHRpb25zLndha2VPbkJUTjEsb25jaGFuZ2U6KCmie3NldHRpbmdzLm9wdGlvbnMud2FrZU9uQlROMT0hc2V0dGluZ3Mub3B0aW9ucy53YWtlT25CVE4xO3VwZGF0ZU9wdGlvbnMoKTt9fSzRC1dha2Ugb24gVGFwOnt2YWx1ZTohIXNldHRpbmdzLm9wdGlvbnMud2FrZU9uVG91Y2gsb25jaGFuZ2U6KCmie3NldHRpbmdzLm9wdGlvbnMud2FrZU9uVG91Y2g9IXNldHRpbmdzLm9wdGlvbnMud2FrZU9uVG91Y2g7dXBkYXRlT3B0aW9ucygpO319fSk7oyhwcm9jZXNzLmVudi5WRVJTSU9OLnJlcGxhY2Uo0QF2LDApkTIwMjApT2JqZWN0LmFzc2lnbihsY2RNZW51LHvREldha2Ugb24gRG91YmxlIFRhcDp7dmFsdWU6ISFzZXR0aW5ncy5vcHRpb25zLndha2VPbkRvdWJsZVRhcCxvbmNoYW5nZTooKaJ7c2V0dGluZ3Mub3B0aW9ucy53YWtlT25Eb3VibGVUYXA9IXNldHRpbmdzLm9wdGlvbnMud2FrZU9uRG91YmxlVGFwO3VwZGF0ZU9wdGlvbnMoKTt9fX0pO32kT2JqZWN0LmFzc2lnbihsY2RNZW51LHvRDFdha2Ugb24gQlROMTp7dmFsdWU6ISFzZXR0aW5ncy5vcHRpb25zLndha2VPbkJUTjEsb25jaGFuZ2U6KCmie3NldHRpbmdzLm9wdGlvbnMud2FrZU9uQlROMT0hc2V0dGluZ3Mub3B0aW9ucy53YWtlT25CVE4xO3VwZGF0ZU9wdGlvbnMoKTt9fSzRDFdha2Ugb24gQlROMjp7dmFsdWU6ISFzZXR0aW5ncy5vcHRpb25zLndha2VPbkJUTjIsb25jaGFuZ2U6KCmie3NldHRpbmdzLm9wdGlvbnMud2FrZU9uQlROMj0hc2V0dGluZ3Mub3B0aW9ucy53YWtlT25CVE4yO3VwZGF0ZU9wdGlvbnMoKTt9fSzRDFdha2Ugb24gQlROMzp7dmFsdWU6ISFzZXR0aW5ncy5vcHRpb25zLndha2VPbkJUTjMsb25jaGFuZ2U6KCmie3NldHRpbmdzLm9wdGlvbnMud2FrZU9uQlROMz0hc2V0dGluZ3Mub3B0aW9ucy53YWtlT25CVE4zO3VwZGF0ZU9wdGlvbnMoKTt9fSzRDVdha2Ugb24gVG91Y2g6e3ZhbHVlOiEhc2V0dGluZ3Mub3B0aW9ucy53YWtlT25Ub3VjaCxvbmNoYW5nZTooKaJ7c2V0dGluZ3Mub3B0aW9ucy53YWtlT25Ub3VjaD0hc2V0dGluZ3Mub3B0aW9ucy53YWtlT25Ub3VjaDt1cGRhdGVPcHRpb25zKCk7fX19KTtPYmplY3QuYXNzaWduKGxjZE1lbnUse9EOV2FrZSBvbiBGYWNlVXA6e3ZhbHVlOiEhc2V0dGluZ3Mub3B0aW9ucy53YWtlT25GYWNlVXAsb25jaGFuZ2U6KCmie3NldHRpbmdzLm9wdGlvbnMud2FrZU9uRmFjZVVwPSFzZXR0aW5ncy5vcHRpb25zLndha2VPbkZhY2VVcDt1cGRhdGVPcHRpb25zKCk7fX0s0Q1XYWtlIG9uIFR3aXN0Ont2YWx1ZTohIXNldHRpbmdzLm9wdGlvbnMud2FrZU9uVHdpc3Qsb25jaGFuZ2U6KCmie3NldHRpbmdzLm9wdGlvbnMud2FrZU9uVHdpc3Q9IXNldHRpbmdzLm9wdGlvbnMud2FrZU9uVHdpc3Q7dXBkYXRlT3B0aW9ucygpO319LNEPVHdpc3QgVGhyZXNob2xkOnt2YWx1ZTppbnRlcm5hbFRvRyhzZXR0aW5ncy5vcHRpb25zLnR3aXN0VGhyZXNob2xkKSxtaW46LTAuNSxtYXg6MC41LHN0ZXA6MC4wMSxvbmNoYW5nZTp2ontzZXR0aW5ncy5vcHRpb25zLnR3aXN0VGhyZXNob2xkPWdUb0ludGVybmFsKHagMC4xKTt1cGRhdGVPcHRpb25zKCk7fX0s0QtUd2lzdCBNYXggWTp7dmFsdWU6c2V0dGluZ3Mub3B0aW9ucy50d2lzdE1heFksbWluOi0xNTAwLG1heDoxNTAwLHN0ZXA6MTAwLG9uY2hhbmdlOnaie3NldHRpbmdzLm9wdGlvbnMudHdpc3RNYXhZPXagLTgwMDt1cGRhdGVPcHRpb25zKCk7fX0s0Q1Ud2lzdCBUaW1lb3V0Ont2YWx1ZTpzZXR0aW5ncy5vcHRpb25zLnR3aXN0VGltZW91dCxtaW46MCxtYXg6MjAwMCxzdGVwOjEwMCxvbmNoYW5nZTp2ontzZXR0aW5ncy5vcHRpb25zLnR3aXN0VGltZW91dD12oDEwMDA7dXBkYXRlT3B0aW9ucygpO319fSk7q2xjZE1lbnV9Cqpsb2NhbGVNZW51KCl7rmxvY2FsZW1lbnU9eycnOnvRBXRpdGxlOtEGTG9jYWxlfSzRBjwgQmFjazooKaJwb3BNZW51KHN5c3RlbU1lbnUoKSks0QlUaW1lIFpvbmU6e3ZhbHVlOnNldHRpbmdzLnRpbWV6b25lLGZvcm1hdDp2oih2PjA/0QErOiIiKSt2LG1pbjotMTEsbWF4OjEzLHN0ZXA6MC41LG9uY2hhbmdlOnaie3NldHRpbmdzLnRpbWV6b25lPXagMDt1cGRhdGVTZXR0aW5ncygpO319LNELVGltZSBGb3JtYXQ6e3ZhbHVlOiEhc2V0dGluZ3Nb0QYxMmhvdXJdLGZvcm1hdDp2onY/0QMxMmg60QMyNGgsb25jaGFuZ2U6dqJ7c2V0dGluZ3Nb0QYxMmhvdXJdPXY7dXBkYXRlU2V0dGluZ3MoKTt9fSzRDVN0YXJ0IFdlZWsgT246e3ZhbHVlOnNldHRpbmdzW9EOZmlyc3REYXlPZldlZWtdoDAsbWluOjAsbWF4OjEsZm9ybWF0OnaicmVxdWlyZSjRCmRhdGVfdXRpbHMpLmRvdyh2LDEpLG9uY2hhbmdlOnaie3NldHRpbmdzW9EOZmlyc3REYXlPZldlZWtdPXY7dXBkYXRlU2V0dGluZ3MoKTt9LH19O6tsb2NhbGVtZW51O30KqnV0aWxNZW51KCl7rG1lbnU9eycnOnvRBXRpdGxlOtEJVXRpbGl0aWVzfSzRBjwgQmFjazooKaJwb3BNZW51KG1haW5NZW51KCkpLNEFRGVidWc6e3ZhbHVlOkUuY2xpcCgwfHNldHRpbmdzLmxvZywwLDMpLG1pbjowLG1heDozLGZvcm1hdDp2olvRA09mZizRB0Rpc3BsYXks0QNMb2cs0QRCb3RoXVtFLmNsaXAoMHx2LDAsMyldLG9uY2hhbmdlOnaie3NldHRpbmdzLmxvZz12O3VwZGF0ZVNldHRpbmdzKCk7fX0s0Q9Db21wYWN0IFN0b3JhZ2U6KCmie0Uuc2hvd01lc3NhZ2Uo0SNDb21wYWN0aW5nLi4uClRha2VzIGFwcHJveAoxIG1pbnV0ZSx7dGl0bGU60QdTdG9yYWdlfSk7c3RvcmFnZS5jb21wYWN0KCk7cmVzdG9yZU1lbnUodXRpbE1lbnUoKSk7fSzREFJld3JpdGUgU2V0dGluZ3M6KCmie3N0b3JhZ2Uud3JpdGUo0QYuYm9vdDAs0S9ldmFsKHJlcXVpcmUoJ1N0b3JhZ2UnKS5yZWFkKCdib290dXBkYXRlLmpzJykpOyk7bG9hZCjRDnNldHRpbmcuYXBwLmpzKTt9LNEPRmxhdHRlbiBCYXR0ZXJ5OigpontFLnNob3dNZXNzYWdlKNFGRmxhdHRlbmluZyBiYXR0ZXJ5IC0gdGhpcyBjYW4gdGFrZSBob3Vycy4KTG9uZy1wcmVzcyBidXR0b24gdG8gY2FuY2VsLik7QmFuZ2xlLnNldExDRFRpbWVvdXQoMCk7QmFuZ2xlLnNldExDRFBvd2VyKDEpO0JhbmdsZS5zZXRMQ0RCcmlnaHRuZXNzKDEpO6MoQmFuZ2xlLnNldEdQU1Bvd2VyKUJhbmdsZS5zZXRHUFNQb3dlcigxLNEEZmxhdCk7oyhCYW5nbGUuc2V0SFJNUG93ZXIpQmFuZ2xlLnNldEhSTVBvd2VyKDEs0QRmbGF0KTujKEJhbmdsZS5zZXRDb21wYXNzUG93ZXIpQmFuZ2xlLnNldENvbXBhc3NQb3dlcigxLNEEZmxhdCk7oyhCYW5nbGUuc2V0QmFyb21ldGVyUG93ZXIpQmFuZ2xlLnNldEJhcm9tZXRlclBvd2VyKDEs0QRmbGF0KTtzZXRJbnRlcnZhbCiqKCl7rGk9MTAwMDumKGmZKTt9LDEpO319O65iYWNrPSgpontyZXN0b3JlTWVudSh1dGlsTWVudSgpKTt9O6MoQkFOR0xFSlMyKW1lbnVb0RFDYWxpYnJhdGUgQmF0dGVyeV09KCmie0Uuc2hvd1Byb21wdCjRHUlzIHRoZSBiYXR0ZXJ5IGZ1bGx5IGNoYXJnZWQ/LHt0aXRsZTrRCUNhbGlicmF0ZSxiYWNrfSkudGhlbihva6J7oyhvayl7rHM9c3RvcmFnZS5yZWFkSlNPTijRDHNldHRpbmcuanNvbik7cy5iYXRGdWxsVm9sdGFnZT0oYW5hbG9nUmVhZChEMykrYW5hbG9nUmVhZChEMykrYW5hbG9nUmVhZChEMykrYW5hbG9nUmVhZChEMykpLzQ7c3RvcmFnZS53cml0ZUpTT04o0QxzZXR0aW5nLmpzb24scyk7RS5zaG93QWxlcnQo0QtDYWxpYnJhdGVkISkudGhlbigoKaJsb2FkKNEOc2V0dGluZy5hcHAuanMpKTt9pHtFLnNob3dBbGVydCjRMVBsZWFzZSBjaGFyZ2UgQmFuZ2xlLmpzIGZvciAzIGhvdXJzIGFuZCB0cnkgYWdhaW4pLnRoZW4oYmFjayk7fX0pO307bWVudVvRDlJlc2V0IFNldHRpbmdzXT0oKaJ7RS5zaG93UHJvbXB0KNESUmVzZXQgdG8gRGVmYXVsdHM/LHt0aXRsZTrRCFNldHRpbmdzLGJhY2t9KS50aGVuKCh2KaJ7oyh2KXtFLnNob3dNZXNzYWdlKNEJUmVzZXR0aW5nKTtyZXNldFNldHRpbmdzKCk7c2V0VGltZW91dCgoKaJwb3BNZW51KG1haW5NZW51KCkpLDUwKTt9pHJlc3RvcmVNZW51KHV0aWxNZW51KCkpO30pO307bWVudVvRCFR1cm4gT2ZmXT0oKaJ7RS5zaG93UHJvbXB0KNEqQXJlIHlvdSBzdXJlPyBBbGFybXMgYW5kIHRpbWVycyB3b24ndCBmaXJlLHt0aXRsZTrRCFR1cm4gT2ZmLGJhY2t9KS50aGVuKChjb25maXJtZWQponujKGNvbmZpcm1lZCl7RS5zaG93TWVzc2FnZSjRDlNlZSB5b3UKbGF0ZXIhLNEHR29vZGJ5ZSk7c2V0VGltZW91dCgoKaJ7RS5zaG93TWVzc2FnZSgpO2cuY2xlYXIotCk7QmFuZ2xlLnNvZnRPZmY/QmFuZ2xlLnNvZnRPZmYoKTpCYW5nbGUub2ZmKCk7fSwyNTAwKTt9pHtyZXN0b3JlTWVudSh1dGlsTWVudSgpKTt9fSk7fTujKEJhbmdsZS5mYWN0b3J5UmVzZXQpe21lbnVb0Q1GYWN0b3J5IFJlc2V0XT0oKaJ7RS5zaG93UHJvbXB0KNEcVGhpcyB3aWxsIHJlbW92ZSBldmVyeXRoaW5nISx7dGl0bGU60Q1GYWN0b3J5IFJlc2V0LGJhY2t9KS50aGVuKCh2KaJ7oyh2KXusbj0oKE1hdGgucmFuZG9tKCkqNCkmMykrMTtFLnNob3dQcm9tcHQo0RlUbyBjb25maXJtLCBwbGVhc2UgcHJlc3MgK24se3RpdGxlOtENRmFjdG9yeSBSZXNldCxidXR0b25zOnvRATE6MSzRATI6MizRATM6MyzRATQ6NH0sYmFja30pLnRoZW4oqih2KXujKHaKbil7RS5zaG93TWVzc2FnZSgpO1Rlcm1pbmFsLnNldENvbnNvbGUoKTtCYW5nbGUuZmFjdG9yeVJlc2V0KCk7faR7YmFjaygpO319KTt9pGJhY2soKTt9KTt9fattZW51O30Kqm1ha2VDb25uZWN0YWJsZSgpe7F7TlJGLndha2UoKTt9Y2F0Y2goZSl7fUJsdWV0b290aC5zZXRDb25zb2xlKDEpO05SRi5pZ25vcmVXaGl0ZWxpc3Q9MTusbmFtZT3RCkJhbmdsZS5qcyArTlJGLmdldEFkZHJlc3MoKS5zdWJzdHIoLTUpLnJlcGxhY2Uo0QE6LCIiKTtFLnNob3dQcm9tcHQobmFtZSvREgpTdGF5IENvbm5lY3RhYmxlPyx7dGl0bGU60QtDb25uZWN0YWJsZX0pLnRoZW4ocqJ7oyhzZXR0aW5ncy5ibGWMcil7c2V0dGluZ3MuYmxlPXI7dXBkYXRlU2V0dGluZ3MoKTt9oyghcimxe05SRi5zbGVlcCgpO31jYXRjaChlKXt9vk5SRi5pZ25vcmVXaGl0ZWxpc3Q7cmVzdG9yZU1lbnUoQkxFTWVudSgpKTt9KTt9CqpjbG9ja01lbnUoKXusY2xvY2tBcHBzPXN0b3JhZ2UubGlzdCgvXC5pbmZvJC8pLm1hcChhcHCie6xhPXN0b3JhZ2UucmVhZEpTT04oYXBwLDEpO6soYZ5hLnR5cGWK0QVjbG9jayk/YTq3fSkuZmlsdGVyKGFwcKJhcHApLnNvcnQoKGEsYimiYS5zb3J0b3JkZXItYi5zb3J0b3JkZXIpO65iYWNrPSgponBvcE1lbnUoc3lzdGVtTWVudSgpKTuuY2xvY2tNZW51PXsnJzp70QV0aXRsZTrRDFNlbGVjdCBDbG9jayx9LNEGPCBCYWNrOmJhY2ssfTtjbG9ja0FwcHMuZm9yRWFjaCgoYXBwLGluZGV4KaJ7rGxhYmVsPWFwcC5uYW1lO6MoKCFzZXR0aW5ncy5jbG9ja55pbmRleIswKaAoc2V0dGluZ3MuY2xvY2uLYXBwLnNyYykpe2xhYmVsPdECKiArbGFiZWw7fWNsb2NrTWVudVtsYWJlbF09KCmie3NldHRpbmdzLmNsb2NrPWFwcC5zcmM7c2V0dGluZ3MuY2xvY2tIYXNXaWRnZXRzPXN0b3JhZ2UucmVhZChhcHAuc3JjKS5pbmNsdWRlcyjREkJhbmdsZS5sb2FkV2lkZ2V0cyk7dXBkYXRlU2V0dGluZ3MoKTtiYWNrKCk7fTt9KTujKGNsb2NrQXBwcy5sZW5ndGiLMCl7Y2xvY2tNZW51W9EPTm8gQ2xvY2tzIEZvdW5kXT0oKaJ7fTt9q2Nsb2NrTWVudTt9CqpsYXVuY2hlck1lbnUoKXusbGF1bmNoZXJBcHBzPXN0b3JhZ2UubGlzdCgvXC5pbmZvJC8pLm1hcChhcHCie6xhPXN0b3JhZ2UucmVhZEpTT04oYXBwLDEpO6soYZ5hLnR5cGWK0QZsYXVuY2gpP2E6t30pLmZpbHRlcihhcHCiYXBwKS5zb3J0KChhLGIpomEuc29ydG9yZGVyLWIuc29ydG9yZGVyKTuuYmFjaz0oKaJwb3BNZW51KHN5c3RlbU1lbnUoKSk7rmxhdW5jaGVyTWVudT17Jyc6e9EFdGl0bGU60Q9TZWxlY3QgTGF1bmNoZXIsfSzRBjwgQmFjazpiYWNrLH07bGF1bmNoZXJBcHBzLmZvckVhY2goKGFwcCxpbmRleCmie6xsYWJlbD1hcHAubmFtZTujKCghc2V0dGluZ3MubGF1bmNoZXKeaW5kZXiLMCmgKHNldHRpbmdzLmxhdW5jaGVyi2FwcC5zcmMpKXtsYWJlbD3RAiogK2xhYmVsO31sYXVuY2hlck1lbnVbbGFiZWxdPSgpontzZXR0aW5ncy5sYXVuY2hlcj1hcHAuc3JjO3VwZGF0ZVNldHRpbmdzKCk7YmFjaygpO307fSk7oyhsYXVuY2hlckFwcHMubGVuZ3RoizApe2xhdW5jaGVyTWVudVvREk5vIExhdW5jaGVycyBGb3VuZF09KCmie307fatsYXVuY2hlck1lbnU7fQqqc2V0VGltZU1lbnUoKXutZD24RGF0ZSgpO650aW1lbWVudT17Jyc6e9EFdGl0bGU60QtEYXRlICYgVGltZX0s0QY8IEJhY2s6qigpe3NldFRpbWUoZC5nZXRUaW1lKCkvMTAwMCk7cG9wTWVudShzeXN0ZW1NZW51KCkpO30s0QNEYXk6e3ZhbHVlOmQuZ2V0RGF0ZSgpLG9uY2hhbmdlOqoodil7ry52YWx1ZT0oKHYrMzApJTMxKSsxO2Quc2V0RGF0ZSivLnZhbHVlKTt9fSzRBU1vbnRoOnt2YWx1ZTpkLmdldE1vbnRoKCkrMSxmb3JtYXQ6dqJyZXF1aXJlKNEKZGF0ZV91dGlscykubW9udGgodiksb25jaGFuZ2U6qih2KXuvLnZhbHVlPSgodisxMSklMTIpKzE7ZC5zZXRNb250aCivLnZhbHVlLTEpO319LNEEWWVhcjp7dmFsdWU6ZC5nZXRGdWxsWWVhcigpLG1pbjoyMDE5LG1heDoyMTAwLG9uY2hhbmdlOqoodil7ZC5zZXRGdWxsWWVhcih2KTt9fSzRBEhvdXI6e3ZhbHVlOmQuZ2V0SG91cnMoKSxvbmNoYW5nZTqqKHYpe68udmFsdWU9KHYrMjQpJTI0O2Quc2V0SG91cnMory52YWx1ZSk7fX0s0QZNaW51dGU6e3ZhbHVlOmQuZ2V0TWludXRlcygpLG9uY2hhbmdlOqoodil7ry52YWx1ZT0odis2MCklNjA7ZC5zZXRNaW51dGVzKK8udmFsdWUpO319LNEGU2Vjb25kOnt2YWx1ZTpkLmdldFNlY29uZHMoKSxvbmNoYW5nZTqqKHYpe68udmFsdWU9KHYrNjApJTYwO2Quc2V0U2Vjb25kcyivLnZhbHVlKTt9fX07q3RpbWVtZW51O30KqmFwcFNldHRpbmdzTWVudSgpe61hcHBtZW51PXsnJzp70QV0aXRsZTrRDEFwcCBTZXR0aW5nc30s0QY8IEJhY2s6KCmicG9wTWVudShtYWluTWVudSgpKSx9rmFwcHM9c3RvcmFnZS5saXN0KC9cLnNldHRpbmdzXC5qcyQvKS5tYXAoc6JzLnN1YnN0cigwLHMubGVuZ3RoLTEyKSkubWFwKGlkonuuYT1zdG9yYWdlLnJlYWRKU09OKGlkK9EFLmluZm8sMSmge25hbWU6aWR9O6t7aWQ6aWQsbmFtZTphLm5hbWUsc29ydG9yZGVyOmEuc29ydG9yZGVyfTt9KS5zb3J0KChhLGIponuubj0oMHxhLnNvcnRvcmRlciktKDB8Yi5zb3J0b3JkZXIpO6MobimrbjujKGEubmFtZTxiLm5hbWUpqy0xO6MoYS5uYW1lPmIubmFtZSmrMTurMDt9KaMoYXBwcy5sZW5ndGiLMCl7YXBwbWVudVvRE05vIGFwcCBoYXMgc2V0dGluZ3NdPSgpont9O31hcHBzLmZvckVhY2goqihhcHApe2FwcG1lbnVbYXBwLm5hbWVdPSgpontzaG93QXBwU2V0dGluZ3MoYXBwKX07fSmrYXBwbWVudTt9CqpzaG93QXBwU2V0dGluZ3MoYXBwKXuuYmFjaz0oKaJwb3BNZW51KGFwcFNldHRpbmdzTWVudSgpKTuuc2hvd0Vycm9yPW1zZ6J7RS5zaG93TWVzc2FnZShgJHthcHAubmFtZX06XG4ke21zZ30hXG5cbkJUTjEgdG8gZ28gYmFja2ApOwpzZXRXYXRjaChiYWNrLEJUTjEse3JlcGVhdDq1fSk7Cn2tYXBwU2V0dGluZ3M9c3RvcmFnZS5yZWFkKGFwcC5pZCvRDC5zZXR0aW5ncy5qcyk7sXsKYXBwU2V0dGluZ3M9ZXZhbChhcHBTZXR0aW5ncyk7Cn1jYXRjaChlKXsKY29uc29sZS5sb2coYCR7YXBwLm5hbWV9IHNldHRpbmdzIGVycm9yOmAsZSk7q3Nob3dFcnJvcijREUVycm9yIGluIHNldHRpbmdzKTt9oyi/YXBwU2V0dGluZ3ON0QhmdW5jdGlvbil7q3Nob3dFcnJvcijREEludmFsaWQgc2V0dGluZ3MpO32xe3B1c2hNZW51KCk7YXBwU2V0dGluZ3MoYmFjayk7fWNhdGNoKGUpe2NvbnNvbGUubG9nKGAke2FwcC5uYW1lfSBzZXR0aW5ncyBlcnJvcjpgLGUpO6tzaG93RXJyb3Io0RFFcnJvciBpbiBzZXR0aW5ncyk7fX2qc2hvd1RvdWNoc2NyZWVuQ2FsaWJyYXRpb24oKXtCYW5nbGUuc2V0VUkoKTtyZXF1aXJlKNEMd2lkZ2V0X3V0aWxzKS5oaWRlKCk7QmFuZ2xlLnNldE9wdGlvbnMoe3RvdWNoWDE6MCx0b3VjaFkxOjAsdG91Y2hYMjpnLmdldFdpZHRoKCksdG91Y2hZMjpnLmdldEhlaWdodCgpfSk7rFA9MzI7rGNvcm5lcnM9W1tQLFBdLFtnLmdldFdpZHRoKCktUCxQXSxbZy5nZXRXaWR0aCgpLVAsZy5nZXRIZWlnaHQoKS1QXSxbUCxnLmdldEhlaWdodCgpLVBdLF07rGN1cnJlbnRDb3JuZXI9MDusY3VycmVudFRyeT0wO6xwdD17eDE6MCx5MTowLHgyOjAseTI6MH07qnNob3dUYXBTcG90KCl7rHNwb3Q9Y29ybmVyc1tjdXJyZW50Q29ybmVyXTtnLmNsZWFyKDEpO2cuZHJhd0xpbmUoc3BvdFswXS0zMixzcG90WzFdLHNwb3RbMF0rMzIsc3BvdFsxXSk7Zy5kcmF3TGluZShzcG90WzBdLHNwb3RbMV0tMzIsc3BvdFswXSxzcG90WzFdKzMyKTtnLmRyYXdDaXJjbGUoc3BvdFswXSxzcG90WzFdLDE2KTusdGFwc0xlZnQ9KDItY3VycmVudFRyeSkqNCsoNC1jdXJyZW50Q29ybmVyKTtnLnNldEZvbnQo0QU2eDg6Mikuc2V0Rm9udEFsaWduKDAsMCkuZHJhd1N0cmluZyh0YXBzTGVmdCvRCyB0YXBzCnRvIGdvLGcuZ2V0V2lkdGgoKS8yLGcuZ2V0SGVpZ2h0KCkvMik7fapjYWxjQ2FsaWJyYXRpb24oKXtnLmNsZWFyKDEpO3B0LngxmzY7cHQueTGbNjtwdC54Mps2O3B0LnkymzY7rGNhbGliPXt4MTpNYXRoLnJvdW5kKHB0LngxLShwdC54Mi1wdC54MSkqUC8oZy5nZXRXaWR0aCgpLVAqMikpLHkxOk1hdGgucm91bmQocHQueTEtKHB0LnkyLXB0LnkxKSpQLyhnLmdldEhlaWdodCgpLVAqMikpLHgyOk1hdGgucm91bmQocHQueDIrKHB0LngyLXB0LngxKSpQLyhnLmdldFdpZHRoKCktUCoyKSkseTI6TWF0aC5yb3VuZChwdC55MisocHQueTItcHQueTEpKlAvKGcuZ2V0SGVpZ2h0KCktUCoyKSl9O6xkeD1jYWxpYi54Mi1jYWxpYi54MTusZHk9Y2FsaWIueTItY2FsaWIueTE7oyhkeDwxMDCgZHg+MjgwoGR5PDEwMKBkeT4yODApe2cuc2V0Rm9udCjRBTZ4ODoyKS5zZXRGb250QWxpZ24oMCwwKS5kcmF3U3RyaW5nKNEeT3V0IG9mIFJhbmdlLgpQbGVhc2UKdHJ5IGFnYWluLGcuZ2V0V2lkdGgoKS8yLGcuZ2V0SGVpZ2h0KCkvMik7faR7QmFuZ2xlLnNldE9wdGlvbnMoe3RvdWNoWDE6Y2FsaWIueDEsdG91Y2hZMTpjYWxpYi55MSx0b3VjaFgyOmNhbGliLngyLHRvdWNoWTI6Y2FsaWIueTJ9KTuscz1zdG9yYWdlLnJlYWRKU09OKNEMc2V0dGluZy5qc29uLDEpoHt9O3MudG91Y2g9Y2FsaWI7c3RvcmFnZS53cml0ZUpTT04o0QxzZXR0aW5nLmpzb24scyk7Zy5zZXRGb250KNEFNng4OjIpLnNldEZvbnRBbGlnbigwLDApLmRyYXdTdHJpbmco0QtDYWxpYnJhdGVkISxnLmdldFdpZHRoKCkvMixnLmdldEhlaWdodCgpLzIpO31zZXRUaW1lb3V0KCgponJlc3RvcmVNZW51KExDRE1lbnUoKSksNTAwKTt9qnRvdWNoSGFuZGxlcihfLGUpe0Uuc3RvcEV2ZW50UHJvcGFnYXRpb26eRS5zdG9wRXZlbnRQcm9wYWdhdGlvbigpO6xzcG90PWNvcm5lcnNbY3VycmVudENvcm5lcl07oyhzcG90WzBdKjI8Zy5nZXRXaWR0aCgpKXB0LngxlmUueDukcHQueDKWZS54O6Moc3BvdFsxXSoyPGcuZ2V0SGVpZ2h0KCkpcHQueTGWZS55O6RwdC55MpZlLnk7Y3VycmVudENvcm5lcpg7oyhjdXJyZW50Q29ybmVykWNvcm5lcnMubGVuZ3RoKXtjdXJyZW50Q29ybmVyPTA7Y3VycmVudFRyeZg7oyhjdXJyZW50VHJ5ijMpewpCYW5nbGUucmVtb3ZlTGlzdGVuZXIo0QV0b3VjaCx0b3VjaEhhbmRsZXIpOwqrY2FsY0NhbGlicmF0aW9uKCk7Cn19c2hvd1RhcFNwb3QoKTt9QmFuZ2xlLnByZXBlbmRMaXN0ZW5lcj9CYW5nbGUucHJlcGVuZExpc3RlbmVyKNEFdG91Y2gsdG91Y2hIYW5kbGVyKTpCYW5nbGUub24o0QV0b3VjaCx0b3VjaEhhbmRsZXIpO3Nob3dUYXBTcG90KCk7fXB1c2hNZW51KG1haW5NZW51KCkpO33///9MAgAAc2V0dGluZy5pbWc=");
  base64DecodeToExistingUint8Array(bufferView, 78092, "MDDCAP//8WPMQm9T");
  base64DecodeToExistingUint8Array(bufferView, 78156, "AVVVQAAAAAAAAAAAAVVVQAAAAAAAAAAAAVVVUAAAAAAAAAAAAVVVUAAAAAAAAAAABVVVUAAAAAAAAAAABVVVUAAAAAAAABAABVVVUAAFAAAAAFUAVVVVVQBVAAAAAVVRVVVVVUVVQAAAAVVVVfqvVVVVUAAABVVVXqqqtVVVUAAAFVVV6qqqq1VVVAAAFVVXqqqqqtVVVAAAVVVeqqqqqrVVVQAAVVVaqqqqqqVVVQAAVVV6qqqqqq1VVQAAFVVqqqAKqqlVVAAAAVXqqgAAqqtVQAAAAFXqqgAAqqtVAAAAABWqqAAAKqpVAAAAABWqqAAAKqpVAAAAABWqqAAAKqpVAAAAABWqqAAAKqpVAAAAAFXqqgAAqqtVAAAAAVXqqgAAqqtVQAAAFVVqqqAKqqlVVAAAVVV6qqqqqq1VVQAAVVVaqqqqqqVVVQAAVVVeqqqqqrVVVQAAFVVXqqqqqtVVVAAAFVVV6qqqq1VVVAAABVVVXqqqtVVVUAAABVVVVfqvVVVVQAAAAVVRVVVVVUVVQAAAAFUAVVVVVQBVAAAAAFAABVVVUAAEAAAAAAAABVVVUAAAAAAAAAAABVVVUAAAAAAAAAAABVVVQAAAAAAAAAAABVVVQAAAAAAAAAAAAVVVQAAAAAAAAAAAAVVVQA==");
  base64DecodeToExistingUint8Array(bufferView, 78680, "TwEAAHNldHRpbmcuanNvbg==");
  base64DecodeToExistingUint8Array(bufferView, 78712, "eyJibGUiOnRydWUsImJsZXJlcGwiOnRydWUsImxvZyI6ZmFsc2UsInRpbWVvdXQiOjEwLCJ2aWJyYXRlIjp0cnVlLCJiZWVwIjoidmliIiwidGltZXpvbmUiOjAsIkhJRCI6ZmFsc2UsImNsb2NrIjpudWxsLCIxMmhvdXIiOmZhbHNlLCJicmlnaHRuZXNzIjoxLCJvcHRpb25zIjp7Indha2VPbkJUTjEiOnRydWUsIndha2VPbkJUTjIiOnRydWUsIndha2VPbkJUTjMiOnRydWUsIndha2VPbkZhY2VVcCI6ZmFsc2UsIndha2VPblRvdWNoIjpmYWxzZSwid2FrZU9uVHdpc3QiOmZhbHNlLCJ0d2lzdFRocmVzaG9sZCI6ODE5LjIsInR3aXN0TWF4WSI6LTgwMCwidHdpc3RUaW1lb3V0IjoxMDAwfX3/ywAAAHNldHRpbmcuaW5mbw==");
  base64DecodeToExistingUint8Array(bufferView, 79080, "eyJpZCI6InNldHRpbmciLCJuYW1lIjoiU2V0dGluZ3MiLCJzcmMiOiJzZXR0aW5nLmFwcC5qcyIsImljb24iOiJzZXR0aW5nLmltZyIsInNvcnRvcmRlciI6LTUsInZlcnNpb24iOiIwLjc1IiwidGFncyI6InRvb2wsc3lzdGVtIiwiZmlsZXMiOiJzZXR0aW5nLmluZm8sc2V0dGluZy5hcHAuanMsc2V0dGluZy5pbWciLCJkYXRhIjoic2V0dGluZy5qc29uIn3/gAIAAHNjaGVkLmJvb3QuanM=");
  base64DecodeToExistingUint8Array(bufferView, 79316, "KKooKXujKEJhbmdsZS5TQ0hFRCl7Y2xlYXJUaW1lb3V0KEJhbmdsZS5TQ0hFRCk7vkJhbmdsZS5TQ0hFRDt9rGFsYXJtcz1yZXF1aXJlKNEHU3RvcmFnZSkucmVhZEpTT04o0QpzY2hlZC5qc29uLDEpoFtdO6x0aW1lPbhEYXRlKCk7rGN1cnJlbnRUaW1lPSh0aW1lLmdldEhvdXJzKCkqMzYwMDAwMCkrKHRpbWUuZ2V0TWludXRlcygpKjYwMDAwKSsodGltZS5nZXRTZWNvbmRzKCkqMTAwMCk7rGQ9dGltZS5nZXREYXRlKCk7rGFjdGl2ZT1hbGFybXMuZmlsdGVyKGGiYS5vbp4oYS5sYXN0jGQpnihhLnQrNjAwMDA+Y3VycmVudFRpbWUpnihhLmRvd5J0aW1lLmdldERheSgpJjEpnighYS5kYXRloGEuZGF0ZYp0aW1lLnRvTG9jYWxJU09TdHJpbmcoKS5zdWJzdHIoMCwxMCkpKTujKGFjdGl2ZS5sZW5ndGgpe2FjdGl2ZT1hY3RpdmUuc29ydCgoYSxiKaJhLnQtYi50KTusdD1hY3RpdmVbMF0udC1jdXJyZW50VGltZTujKHQ8MTAwMCl0PTEwMDA7QmFuZ2xlLlNDSEVEPXNldFRpbWVvdXQoYWN0aXZlWzBdLmpzoNEQbG9hZCgic2NoZWQuanMiKSx0KTt9pHtCYW5nbGUuU0NIRUQ9c2V0VGltZW91dCjRLmV2YWwocmVxdWlyZSgiU3RvcmFnZSIpLnJlYWQoInNjaGVkLmJvb3QuanMiKSksODY0MDAwMDAtY3VycmVudFRpbWUpO319KSgpO6ETAABzY2hlZC5qcw==");
  base64DecodeToExistingUint8Array(bufferView, 79988, "TW9kdWxlcy5hZGRDYWNoZWQo0Qp0aW1lX3V0aWxzLKooKXtleHBvcnRzLmVuY29kZVRpbWU9KHRpbWUpont0aW1lPXNhZmVUaW1lKHRpbWUpO6t0aW1lLmQqODY0MDAwMDArdGltZS5oKjM2MDAwMDArdGltZS5tKjYwMDAwK3RpbWUucyoxMDAwO32qc2FmZVRpbWUodGltZSl7q3tkOnRpbWUuZKAwLGg6dGltZS5ooDAsbTp0aW1lLm2gMCxzOnRpbWUuc6AwfTt9ZXhwb3J0cy5kZWNvZGVUaW1lPShtaWxsaXMponujKL9taWxsaXON0QZudW1iZXIpsNEcT25seSBhIG51bWJlciBjYW4gYmUgZGVjb2RlZDusZD1NYXRoLmZsb29yKG1pbGxpcy84NjQwMDAwMCk7bWlsbGlzl2QqODY0MDAwMDA7rGg9TWF0aC5mbG9vcihtaWxsaXMvMzYwMDAwMCk7bWlsbGlzl2gqMzYwMDAwMDusbT1NYXRoLmZsb29yKG1pbGxpcy82MDAwMCk7bWlsbGlzl20qNjAwMDA7rHM9TWF0aC5mbG9vcihtaWxsaXMvMTAwMCk7q3tkOmQsaDpoLG06bSxzOnN9O31leHBvcnRzLmZvcm1hdFRpbWU9KHZhbHVlKaJ7rHRpbWU9c2FmZVRpbWUov3ZhbHVli9EGb2JqZWN0P3ZhbHVlOmV4cG9ydHMuZGVjb2RlVGltZSh2YWx1ZSkpO3RpbWUuaJZ0aW1lLmQqMjQ7q3RpbWUuaCvRATorKNEBMCt0aW1lLm0pLnN1YnN0cigtMik7fWV4cG9ydHMuZm9ybWF0RHVyYXRpb249KHZhbHVlLGNvbXBhY3Qpontjb21wYWN0PWNvbXBhY3SgtTusZHVyYXRpb249IiI7rHRpbWU9c2FmZVRpbWUov3ZhbHVli9EGb2JqZWN0P3ZhbHVlOmV4cG9ydHMuZGVjb2RlVGltZSh2YWx1ZSkpO6ModGltZS5kPjApZHVyYXRpb26WdGltZS5kK9ECZCA7oyh0aW1lLmg+MClkdXJhdGlvbpZ0aW1lLmgr0QJoIDujKHRpbWUubT4wKWR1cmF0aW9ulnRpbWUubSvRAm0gO6ModGltZS5zPjApZHVyYXRpb26WdGltZS5zK9EBc2R1cmF0aW9uPWR1cmF0aW9uLnRyaW0oKatjb21wYWN0P2R1cmF0aW9uLnJlcGxhY2Uo0QEgLCIiKTpkdXJhdGlvbjt9ZXhwb3J0cy5nZXRDdXJyZW50VGltZU1pbGxpcz0oKaJ7rHRpbWU9uERhdGUoKTurKHRpbWUuZ2V0SG91cnMoKSozNjAwK3RpbWUuZ2V0TWludXRlcygpKjYwK3RpbWUuZ2V0U2Vjb25kcygpKSoxMDAwO319KTsKTW9kdWxlcy5hZGRDYWNoZWQo0QRidXp6LKooKXtleHBvcnRzLnBhdHRlcm49cGF0dGVybqK4UHJvbWlzZShyZXNvbHZlonuqZG9CdXp6KCl7oyhwYXR0ZXJuiiIiKatyZXNvbHZlKCk7rGM9cGF0dGVyblswXTtwYXR0ZXJuPXBhdHRlcm4uc3Vic3RyKDEpO65CVVpaX1dFQUs9MC4yNSxCVVpaX1NUUk9ORz0xO65TSE9SVF9NUz0xMDAsTUVESVVNX01TPTIwMCxMT05HX01TPTUwMDujKGOK0QEuKUJhbmdsZS5idXp6KFNIT1JUX01TLEJVWlpfV0VBSykudGhlbigoKaJzZXRUaW1lb3V0KGRvQnV6eiwxMDApKTukoyhjitEBLClCYW5nbGUuYnV6eihNRURJVU1fTVMsQlVaWl9XRUFLKS50aGVuKCgponNldFRpbWVvdXQoZG9CdXp6LDEwMCkpO6SjKGOK0QEtKUJhbmdsZS5idXp6KExPTkdfTVMsQlVaWl9XRUFLKS50aGVuKCgponNldFRpbWVvdXQoZG9CdXp6LDEwMCkpO6SjKGOK0QE6KUJhbmdsZS5idXp6KFNIT1JUX01TLEJVWlpfU1RST05HKS50aGVuKCgponNldFRpbWVvdXQoZG9CdXp6LDEwMCkpO6SjKGOK0QE7KUJhbmdsZS5idXp6KE1FRElVTV9NUyxCVVpaX1NUUk9ORykudGhlbigoKaJzZXRUaW1lb3V0KGRvQnV6eiwxMDApKTukoyhjitEBPSlCYW5nbGUuYnV6eihMT05HX01TLEJVWlpfU1RST05HKS50aGVuKCgponNldFRpbWVvdXQoZG9CdXp6LDEwMCkpO6RzZXRUaW1lb3V0KGRvQnV6eiwxMDApO31kb0J1enooKTt9KTt9KTsKoyhCYW5nbGUuU0NIRUQpe2NsZWFySW50ZXJ2YWwoQmFuZ2xlLlNDSEVEKTu+QmFuZ2xlLlNDSEVEO30KqnNob3dBbGFybShhbGFybSl7rmFsYXJtSW5kZXg9YWxhcm1zLmluZGV4T2YoYWxhcm0pO65zZXR0aW5ncz1yZXF1aXJlKNEFc2NoZWQpLmdldFNldHRpbmdzKCk7rW1lc3NhZ2U9IiI7bWVzc2FnZZZhbGFybS50aW1lcj9yZXF1aXJlKNEKdGltZV91dGlscykuZm9ybWF0RHVyYXRpb24oYWxhcm0udGltZXIpOnJlcXVpcmUo0Qp0aW1lX3V0aWxzKS5mb3JtYXRUaW1lKGFsYXJtLnQpO6MoYWxhcm0ubXNnKXttZXNzYWdlltEBCithbGFybS5tc2c7faR7bWVzc2FnZT0oYWxhcm0udGltZXI/0pkBACQswgD//33vRcGHIQAAABVVVAAAAAAAABVVVAAAAAAAABVVVAAAAAAAABVVVAAAAAAAABVVVAAAAAAAABVVVAAAAAAAAAP/wAAAAAAAAAP/wAAAAAAAAAqqoAPAAAAAAqqqqoP8AAAAKqqqqqv/AAACqqqqqqq/wAAKqqqlWqqvwAAqqqqlVaqrAACqqqqlVVqqAAKqqqqlVVaqgAKqaqqlVVWqgAqpWqqlVVVqoAqlWqqlVVVaoCqlV6qlVVVaqCqVVfqlVVVWqCqVVf6lVVVWqKpVVX/lVVVVqqpVVV/+VVVVqqpVVV//lVVVqqpVVVfr1VVVqqpVVVfr1VVVqqpVVVb/lVVVqqpVVVW+VVVVqqpVVVVVVVVVqiqVVVVVVVVWqCqVVVVVVVVWqCqlVVVVVVVaqAqlVVVVVVVaoAqpVVVVVVVqoAKqVVVVVVWqgAKqlVVVVVaqgACqpVVVVVqqAAAqqlVVVaqoAAAKqqVVWqqgAAACqqqqqqqAAAAAKqqqqqgAAAAAAqqqqoAAAAAAAAqqoAAAADrS/AEALSzCAX3v//9FwSkyVVVVVVV/1VVVVVVVVf/1VV/1VV//VVVX///VV/1Vf//9VVf//9VaqqVX///VV///1qqqqql///1X///aqqqqqqf//9X///qqqqqqqv//9f//6qqgAAqqq///f//qqgAAAAqqv//f/+qoAAAAACqr//f/6qgAAPAAAqq//f/6qAAAPAAAKq//f9qoAAAPAAACqn/X2qgAAAPAAAAqp9XWqAAAAPAAAAKpdVaqAAAAPAAAAKqVVaoAAAAPAAAACqVVaoAAAAPAAAACqVVaoAAAAPAAAACqVVqgAAAAPAAAAAqlVqgAAAAPAAAAAqlVqgAAAAPAAAAAqlVqgAAAA6wAAAAqlVqgAAAA6wAAAAqlVqgAAAAv8AAAAqlVqgAAACA/AAAAqlVqgAAAIAPwAAAqlVaoAAAgAD8AACqVVaoAACAAA/AACqVVaoAAIAAAPAACqVVaqAAgAAAAAAKqVVWqACAAAAAAAKpVVWqgAAAAAAAAqpVVVqoAAAAAAACqlVVVaqAAAAAAAKqVVVVaqgAAAAAAqqVVVVWqoAAAAACqpVVVVVqqgAAAAqqlVVVVV6qqgAAqqq1VVVVX/qqqqqqqv9VVVVf/aqqqqqqf/VVVV/9VqqqqqlX/1VVV/1VVaqqVVV/1VVV/VVVVVVVVVf1VKSvRASArbWVzc2FnZX1CYW5nbGUubG9hZFdpZGdldHMoKTtCYW5nbGUuZHJhd1dpZGdldHMoKTutYnV6ekNvdW50PXNldHRpbmdzLmJ1enpDb3VudDtFLnNob3dQcm9tcHQobWVzc2FnZSx7dGl0bGU6YWxhcm0udGltZXI/0QZUSU1FUiE60QZBTEFSTSEsYnV0dG9uczp70QZTbm9vemU6tCzRBFN0b3A6tX19KS50aGVuKKooc2xlZXApe2J1enpDb3VudD0wO6Moc2xlZXApe6MoYWxhcm0ub3SLtyl7YWxhcm0ub3Q9YWxhcm0udDt9rXRpbWU9uERhdGUoKTutY3VycmVudFRpbWU9KHRpbWUuZ2V0SG91cnMoKSozNjAwMDAwKSsodGltZS5nZXRNaW51dGVzKCkqNjAwMDApKyh0aW1lLmdldFNlY29uZHMoKSoxMDAwKTthbGFybS50PWN1cnJlbnRUaW1lK3NldHRpbmdzLmRlZmF1bHRTbm9vemVNaWxsaXM7YWxhcm0udJw4NjQwMDAwMDtCYW5nbGUuZW1pdCjRC2FsYXJtU25vb3plLGFsYXJtKTt9pHutZGVsPWFsYXJtLmRlbIu3P3NldHRpbmdzLmRlZmF1bHREZWxldGVFeHBpcmVkVGltZXJzOmFsYXJtLmRlbDujKGRlbCl7YWxhcm1zLnNwbGljZShhbGFybUluZGV4LDEpO32ke6MoYWxhcm0uZGF0ZZ5hbGFybS5ycCl7c2V0TmV4dFJlcGVhdERhdGUoYWxhcm0pO32koyghYWxhcm0udGltZXIpe2FsYXJtLmxhc3Q9uERhdGUoKS5nZXREYXRlKCk7faMoYWxhcm0ub3SNtyl7YWxhcm0udD1hbGFybS5vdDu+YWxhcm0ub3Q7faMoIWFsYXJtLnJwKXthbGFybS5vbj21O319QmFuZ2xlLmVtaXQo0QxhbGFybURpc21pc3MsYWxhcm0pO31yZXF1aXJlKNEFc2NoZWQpLnNldEFsYXJtcyhhbGFybXMpO2xvYWQoKTt9KTuqYnV6eigpe6Moc2V0dGluZ3MudW5sb2NrQXRCdXp6KXtCYW5nbGUuc2V0TG9ja2VkKLUpO32ucGF0dGVybj1hbGFybS52aWJyYXRloChhbGFybS50aW1lcj9zZXR0aW5ncy5kZWZhdWx0VGltZXJQYXR0ZXJuOnNldHRpbmdzLmRlZmF1bHRBbGFybVBhdHRlcm4pO3JlcXVpcmUo0QRidXp6KS5wYXR0ZXJuKHBhdHRlcm4pLnRoZW4oKCmie6MoYnV6ekNvdW50iragYnV6ekNvdW50mSl7c2V0VGltZW91dChidXp6LHNldHRpbmdzLmJ1enpJbnRlcnZhbE1pbGxpcyk7faSjKGFsYXJtLmFzKXtidXp6Q291bnQ9c2V0dGluZ3MuYnV6ekNvdW50O3NldFRpbWVvdXQoYnV6eixzZXR0aW5ncy5kZWZhdWx0U25vb3plTWlsbGlzKTt9fSk7fapzZXROZXh0UmVwZWF0RGF0ZShhbGFybSl7rWRhdGU9uERhdGUoYWxhcm0uZGF0ZSk7rXJwPWFsYXJtLnJwO6MocnCLtCl7ZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpKzEpO32kuyhycC5pbnRlcnZhbCl7vNEDZGF5OmRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKStycC5udW0pO6g7vNEEd2VlazpkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkrKHJwLm51bSo3KSk7qDu80QVtb250aDqjKCFhbGFybS5vZClhbGFybS5vZD1kYXRlLmdldERhdGUoKTtkYXRlPbhEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSxkYXRlLmdldE1vbnRoKCkrcnAubnVtLGFsYXJtLm9kKTujKGRhdGUuZ2V0RGF0ZSgpjGFsYXJtLm9kKWRhdGUuc2V0RGF0ZSgwKTuoO7zRBHllYXI6oyghYWxhcm0ub2QpYWxhcm0ub2Q9ZGF0ZS5nZXREYXRlKCk7ZGF0ZT24RGF0ZShkYXRlLmdldEZ1bGxZZWFyKCkrcnAubnVtLGRhdGUuZ2V0TW9udGgoKSxhbGFybS5vZCk7oyhkYXRlLmdldERhdGUoKYxhbGFybS5vZClkYXRlLnNldERhdGUoMCk7qDu9OmNvbnNvbGUubG9nKGBzY2hlZDogdW5rbm93biByZXBlYXQgJyR7SlNPTi5zdHJpbmdpZnkocnApfSdgKTuoO31hbGFybS5kYXRlPWRhdGUudG9Mb2NhbElTT1N0cmluZygpLnNsaWNlKDAsMTApO32jKChyZXF1aXJlKNEHU3RvcmFnZSkucmVhZEpTT04o0QxzZXR0aW5nLmpzb24sMSmge30pLnF1aWV0PjEpqztidXp6KCk7fa1hbGFybXM9cmVxdWlyZSjRBXNjaGVkKS5nZXRBbGFybXMoKTutYWN0aXZlPXJlcXVpcmUo0QVzY2hlZCkuZ2V0QWN0aXZlQWxhcm1zKGFsYXJtcyk7oyhhY3RpdmUubGVuZ3RoKXtzaG93QWxhcm0oYWN0aXZlWzBdKTt9pHtzZXRUaW1lb3V0KGxvYWQsMTAwKTt9////hAQAAHNjaGVkLmltZw==");
  base64DecodeToExistingUint8Array(bufferView, 85048, "MDCEBmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmERFmZmZmZmZmZmZmZmZmZmYRERFmZmZmERFmZmZmERERZmZmZmZmZhERERERZmZmERFmZmYREREREWZmZmZmYREREREWZmbMzMzMZmZhERERERZmZmZmERERERFmzMzMzMzMzMxmERERERFmZmZhERERERbMzMzMzMzMzMzMYREREREWZmZhERERERzMzMzMzMzMzMzMwREREREWZmYRERERFMzMzEQz//8zRMzMzEERERERZmYRERERTMzMQ////////zTMzMQRERERZmYREREUzMzD//////////88zMxBERERZmYRERFMzMQ/////8A/////zTMzEERERZmYRERHMzE//////8A//////9MzMERERZmYREWzMxP//////8A///////0zMxhERZmZhFszMw///////8A///////zzMzGEWZmZhZszMP///////8A////////PMzGYWZmZmbMzE////////8A////////9MzMZmZmZmbMzD////////8A////////88zMZmZmZmbMxP////////8A/////////0zMZmZmZmbMxP////////8A/////////0zMZmZmZmzMw/////////8A/////////zzMxmZmZmzMw/////////8A/////////zzMxmZmZmzMz/////////MAP/////////zMxmZmZmzMz/////////BVD/////////zMxmZmZmzMz/////////BVA/////////zMxmZmZmzMz////////zQAAD////////zMxmZmZmzMw///////80PzAAP//////zzMxmZmZmzMw///////ND//MAA//////zzMxmZmZmbMxP/////zQ///8wAD/////0zMZmZmZmbMxP////80P////zAAP////0zMZmZmZmbMzD////ND//////MC////88zMZmZmZmbMzE///zQ///////8/////9MzMZmZmZmZszMP/80P/////////////PMzGZmZmZmZszMw//z/////////////zzMzGZmZmZmZmzMxP///////////////0zMxmZmZmZmZmbMzE//////////////9MzMZmZmZmZmZmbMzMQ////////////zTMzMZmZmZmZmZmZszMzD//////////88zMzGZmZmZmZmZmZmzMzMQ////////zTMzMxmZmZmZmZmZmZmFMzMzEQz//8zRMzMzEFmZmZmZmZmZmZhERzMzMzMzMzMzMzMwREWZmZmZmZmZmYRERbMzMzMzMzMzMzMYRERZmZmZmZmZmEREWZmzMzMzMzMzMxmZhERFmZmZmZmZmERFmZmZmbMzMzMZmZmZmERFmZmZmZmZmERZmZmZmZmZmZmZmZmZmYRFmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZuoIAABzY2hlZA==");
  base64DecodeToExistingUint8Array(bufferView, 86236, "CmV4cG9ydHMuZ2V0QWxhcm1zPaooKXurcmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWRKU09OKNEKc2NoZWQuanNvbiwxKaBbXTt9OwpleHBvcnRzLnNldEFsYXJtcz2qKGFsYXJtcyl7YWxhcm1zLmZvckVhY2goZaJlLnScODY0MDAwMDApO6tyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGVKU09OKNEKc2NoZWQuanNvbixhbGFybXMpO307CmV4cG9ydHMuZ2V0QWxhcm09qihpZCl7q2V4cG9ydHMuZ2V0QWxhcm1zKCkuZmluZChhomEuaWSKaWQpO307CmV4cG9ydHMuZ2V0QWN0aXZlQWxhcm1zPaooYWxhcm1zLHRpbWUpe6MoIXRpbWUpdGltZT24RGF0ZSgpO6xjdXJyZW50VGltZT0odGltZS5nZXRIb3VycygpKjM2MDAwMDApKyh0aW1lLmdldE1pbnV0ZXMoKSo2MDAwMCkrKHRpbWUuZ2V0U2Vjb25kcygpKjEwMDApKzEwMDAwO6thbGFybXMuZmlsdGVyKGGiYS5vbp4oYS5sYXN0jHRpbWUuZ2V0RGF0ZSgpKZ4oYS50PGN1cnJlbnRUaW1lKZ4oYS5kb3eSdGltZS5nZXREYXkoKSYxKZ4oIWEuZGF0ZaBhLmRhdGWKdGltZS50b0xvY2FsSVNPU3RyaW5nKCkuc3Vic3RyKDAsMTApKSkuc29ydCgoYSxiKaJhLnQtYi50KTt9CmV4cG9ydHMuc2V0QWxhcm09qihpZCxhbGFybSl7rGFsYXJtcz1leHBvcnRzLmdldEFsYXJtcygpLmZpbHRlcihhomEuaWSMaWQpO6MoYWxhcm2Ntyl7YWxhcm0uaWQ9aWQ7oyhhbGFybS5kb3eLtylhbGFybS5kb3c9MGIxMTExMTExO6MoYWxhcm0ub26NtSlhbGFybS5vbj20O6MoYWxhcm0udGltZXIpe2V4cG9ydHMucmVzZXRUaW1lcihhbGFybSk7fWFsYXJtcy5wdXNoKGFsYXJtKTt9ZXhwb3J0cy5zZXRBbGFybXMoYWxhcm1zKTt9OwpleHBvcnRzLnJlc2V0VGltZXI9qihhbGFybSx0aW1lKXt0aW1lPXRpbWWguERhdGUoKTusY3VycmVudFRpbWU9KHRpbWUuZ2V0SG91cnMoKSozNjAwMDAwKSsodGltZS5nZXRNaW51dGVzKCkqNjAwMDApKyh0aW1lLmdldFNlY29uZHMoKSoxMDAwKTthbGFybS50PShjdXJyZW50VGltZSthbGFybS50aW1lciklODY0MDAwMDA7fTsKZXhwb3J0cy5nZXRUaW1lVG9BbGFybT2qKGFsYXJtLHRpbWUpe6MoIWFsYXJtKau3O6MoIXRpbWUpdGltZT24RGF0ZSgpO6xjdXJyZW50VGltZT0odGltZS5nZXRIb3VycygpKjM2MDAwMDApKyh0aW1lLmdldE1pbnV0ZXMoKSo2MDAwMCkrKHRpbWUuZ2V0U2Vjb25kcygpKjEwMDApO6xhY3RpdmU9YWxhcm0ub26eKGFsYXJtLmRvd5IoKHRpbWUuZ2V0RGF5KCkrKGFsYXJtLnQ8Y3VycmVudFRpbWUpKSU3KSkmMZ4oIWFsYXJtLmRhdGWgYWxhcm0uZGF0ZYp0aW1lLnRvTG9jYWxJU09TdHJpbmcoKS5zdWJzdHIoMCwxMCkpO6MoIWFjdGl2ZSmrtzusdD1hbGFybS50LWN1cnJlbnRUaW1lO6MoYWxhcm0ubGFzdIp0aW1lLmdldERhdGUoKaB0PC02MDAwMCl0ljg2NDAwMDAwO6t0O307CmV4cG9ydHMucmVsb2FkPaooKXtldmFsKHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkKNENc2NoZWQuYm9vdC5qcykpO0JhbmdsZS5lbWl0KNELYWxhcm1SZWxvYWQpO307CmV4cG9ydHMubmV3RGVmYXVsdEFsYXJtPaooKXuuc2V0dGluZ3M9ZXhwb3J0cy5nZXRTZXR0aW5ncygpO6xhbGFybT17dDoxMiozNjAwMDAwLGRlbDq1LG9uOrQscnA6tSxhczpzZXR0aW5ncy5kZWZhdWx0QXV0b1Nub296ZSxkb3c6MGIxMTExMTExLGxhc3Q6MCx2aWJyYXRlOnNldHRpbmdzLmRlZmF1bHRBbGFybVBhdHRlcm4sfTu+c2V0dGluZ3M7q2FsYXJtO30KZXhwb3J0cy5uZXdEZWZhdWx0VGltZXI9qigpe65zZXR0aW5ncz1leHBvcnRzLmdldFNldHRpbmdzKCk7rHRpbWVyPXt0aW1lcjo1KjYwKjEwMDAsZGVsOnNldHRpbmdzLmRlZmF1bHREZWxldGVFeHBpcmVkVGltZXJzLG9uOrQscnA6tSxhczq1LGRvdzowYjExMTExMTEsbGFzdDowLHZpYnJhdGU6c2V0dGluZ3MuZGVmYXVsdFRpbWVyUGF0dGVybn2+c2V0dGluZ3M7q3RpbWVyO307CmV4cG9ydHMuZ2V0U2V0dGluZ3M9qigpe6tPYmplY3QuYXNzaWduKHt1bmxvY2tBdEJ1eno6tSxkZWZhdWx0U25vb3plTWlsbGlzOjYwMDAwMCxkZWZhdWx0QXV0b1Nub296ZTq1LGRlZmF1bHREZWxldGVFeHBpcmVkVGltZXJzOrQsYnV6ekNvdW50OjEwLGJ1enpJbnRlcnZhbE1pbGxpczozMDAwLGRlZmF1bHRBbGFybVBhdHRlcm460QI6OixkZWZhdWx0VGltZXJQYXR0ZXJuOtECOjp9LHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRE3NjaGVkLnNldHRpbmdzLmpzb24stCmge30pO30KZXhwb3J0cy5zZXRTZXR0aW5ncz2qKHNldHRpbmdzKXtyZXF1aXJlKNEHU3RvcmFnZSkud3JpdGVKU09OKNETc2NoZWQuc2V0dGluZ3MuanNvbixzZXR0aW5ncyk7fTv//4sJAABzY2hlZC5zZXR0aW5ncy5qcw==");
  base64DecodeToExistingUint8Array(bufferView, 88552, "TW9kdWxlcy5hZGRDYWNoZWQo0QRidXp6LKooKXtleHBvcnRzLnBhdHRlcm49cGF0dGVybqK4UHJvbWlzZShyZXNvbHZlonuqZG9CdXp6KCl7oyhwYXR0ZXJuiiIiKatyZXNvbHZlKCk7rGM9cGF0dGVyblswXTtwYXR0ZXJuPXBhdHRlcm4uc3Vic3RyKDEpO65CVVpaX1dFQUs9MC4yNSxCVVpaX1NUUk9ORz0xO65TSE9SVF9NUz0xMDAsTUVESVVNX01TPTIwMCxMT05HX01TPTUwMDujKGOK0QEuKUJhbmdsZS5idXp6KFNIT1JUX01TLEJVWlpfV0VBSykudGhlbigoKaJzZXRUaW1lb3V0KGRvQnV6eiwxMDApKTukoyhjitEBLClCYW5nbGUuYnV6eihNRURJVU1fTVMsQlVaWl9XRUFLKS50aGVuKCgponNldFRpbWVvdXQoZG9CdXp6LDEwMCkpO6SjKGOK0QEtKUJhbmdsZS5idXp6KExPTkdfTVMsQlVaWl9XRUFLKS50aGVuKCgponNldFRpbWVvdXQoZG9CdXp6LDEwMCkpO6SjKGOK0QE6KUJhbmdsZS5idXp6KFNIT1JUX01TLEJVWlpfU1RST05HKS50aGVuKCgponNldFRpbWVvdXQoZG9CdXp6LDEwMCkpO6SjKGOK0QE7KUJhbmdsZS5idXp6KE1FRElVTV9NUyxCVVpaX1NUUk9ORykudGhlbigoKaJzZXRUaW1lb3V0KGRvQnV6eiwxMDApKTukoyhjitEBPSlCYW5nbGUuYnV6eihMT05HX01TLEJVWlpfU1RST05HKS50aGVuKCgponNldFRpbWVvdXQoZG9CdXp6LDEwMCkpO6RzZXRUaW1lb3V0KGRvQnV6eiwxMDApO31kb0J1enooKTt9KTt9KTsKTW9kdWxlcy5hZGRDYWNoZWQo0QlidXp6X21lbnUsqigpe2V4cG9ydHMucGF0dGVybj2qKHZhbHVlLGNhbGxiYWNrKXuscGF0dGVybnM9WyIiLNEBLizRATos0QIuLizRAjo6LNEBLCzRATss0QIsLCzRAjs7LNEBLSzRAT0s0QItLSzRAj09LNEDLi4uLNEDOjo6LNEDLS0tLNEDOzs7LNEDPT09XTure3ZhbHVlOk1hdGgubWF4KDAscGF0dGVybnMuaW5kZXhPZih2YWx1ZSkpLG1pbjowLG1heDpwYXR0ZXJucy5sZW5ndGgtMSxmb3JtYXQ6dqJwYXR0ZXJuc1t2XaDRA09mZixvbmNoYW5nZTp2ontyZXF1aXJlKNEEYnV6eikucGF0dGVybihwYXR0ZXJuc1t2XSk7Y2FsbGJhY2socGF0dGVybnNbdl0pO319O319KTsoqihiYWNrKXutc2V0dGluZ3M9cmVxdWlyZSjRBXNjaGVkKS5nZXRTZXR0aW5ncygpO0Uuc2hvd01lbnUoeyIiOnvRBXRpdGxlOtEJU2NoZWR1bGVyfSzRBjwgQmFjazooKaJiYWNrKCks0Q5VbmxvY2sgYXQgQnV6ejp7dmFsdWU6c2V0dGluZ3MudW5sb2NrQXRCdXp6LG9uY2hhbmdlOnaie3NldHRpbmdzLnVubG9ja0F0QnV6ej12O3JlcXVpcmUo0QVzY2hlZCkuc2V0U2V0dGluZ3Moc2V0dGluZ3MpO319LNEVRGVsZXRlIEV4cGlyZWQgVGltZXJzOnt2YWx1ZTpzZXR0aW5ncy5kZWZhdWx0RGVsZXRlRXhwaXJlZFRpbWVycyxvbmNoYW5nZTp2ontzZXR0aW5ncy5kZWZhdWx0RGVsZXRlRXhwaXJlZFRpbWVycz12O3JlcXVpcmUo0QVzY2hlZCkuc2V0U2V0dGluZ3Moc2V0dGluZ3MpO319LNETRGVmYXVsdCBBdXRvIFNub296ZTp7dmFsdWU6c2V0dGluZ3MuZGVmYXVsdEF1dG9Tbm9vemUsb25jaGFuZ2U6dqJ7c2V0dGluZ3MuZGVmYXVsdEF1dG9Tbm9vemU9djtyZXF1aXJlKNEFc2NoZWQpLnNldFNldHRpbmdzKHNldHRpbmdzKTt9fSzRDkRlZmF1bHQgU25vb3plOnt2YWx1ZTpzZXR0aW5ncy5kZWZhdWx0U25vb3plTWlsbGlzLzYwMDAwLG1pbjo1LG1heDozMCxzdGVwOjUsZm9ybWF0OnaidivRAW0sb25jaGFuZ2U6dqJ7c2V0dGluZ3MuZGVmYXVsdFNub296ZU1pbGxpcz12KjYwMDAwO3JlcXVpcmUo0QVzY2hlZCkuc2V0U2V0dGluZ3Moc2V0dGluZ3MpO319LNEKQnV6eiBDb3VudDp7dmFsdWU6c2V0dGluZ3MuYnV6ekNvdW50irY/NDpzZXR0aW5ncy5idXp6Q291bnQsbWluOjQsbWF4OjE1LHN0ZXA6MSxmb3JtYXQ6dqJ2izQ/0QdGb3JldmVyOnYsb25jaGFuZ2U6dqJ7c2V0dGluZ3MuYnV6ekNvdW50PXaLND+2OnY7cmVxdWlyZSjRBXNjaGVkKS5zZXRTZXR0aW5ncyhzZXR0aW5ncyk7fX0s0Q1CdXp6IEludGVydmFsOnt2YWx1ZTpzZXR0aW5ncy5idXp6SW50ZXJ2YWxNaWxsaXMvMTAwMCxtaW46MSxtYXg6NSxzdGVwOjEsZm9ybWF0OnaidivRAXMsb25jaGFuZ2U6dqJ7c2V0dGluZ3MuYnV6ekludGVydmFsTWlsbGlzPXYqMTAwMDtyZXF1aXJlKNEFc2NoZWQpLnNldFNldHRpbmdzKHNldHRpbmdzKTt9fSzRFURlZmF1bHQgQWxhcm0gUGF0dGVybjpyZXF1aXJlKNEJYnV6el9tZW51KS5wYXR0ZXJuKHNldHRpbmdzLmRlZmF1bHRBbGFybVBhdHRlcm4sdqJ7c2V0dGluZ3MuZGVmYXVsdEFsYXJtUGF0dGVybj12O3JlcXVpcmUo0QVzY2hlZCkuc2V0U2V0dGluZ3Moc2V0dGluZ3MpO30pLNEVRGVmYXVsdCBUaW1lciBQYXR0ZXJuOnJlcXVpcmUo0QlidXp6X21lbnUpLnBhdHRlcm4oc2V0dGluZ3MuZGVmYXVsdFRpbWVyUGF0dGVybix2ontzZXR0aW5ncy5kZWZhdWx0VGltZXJQYXR0ZXJuPXY7cmVxdWlyZSjRBXNjaGVkKS5zZXRTZXR0aW5ncyhzZXR0aW5ncyk7fSl9KTt9Kf98DgAAc2NoZWQuY2xraW5mby5qcw==");
  base64DecodeToExistingUint8Array(bufferView, 91028, "TW9kdWxlcy5hZGRDYWNoZWQo0Qp0aW1lX3V0aWxzLKooKXtleHBvcnRzLmVuY29kZVRpbWU9KHRpbWUpont0aW1lPXNhZmVUaW1lKHRpbWUpO6t0aW1lLmQqODY0MDAwMDArdGltZS5oKjM2MDAwMDArdGltZS5tKjYwMDAwK3RpbWUucyoxMDAwO32qc2FmZVRpbWUodGltZSl7q3tkOnRpbWUuZKAwLGg6dGltZS5ooDAsbTp0aW1lLm2gMCxzOnRpbWUuc6AwfTt9ZXhwb3J0cy5kZWNvZGVUaW1lPShtaWxsaXMponujKL9taWxsaXON0QZudW1iZXIpsNEcT25seSBhIG51bWJlciBjYW4gYmUgZGVjb2RlZDusZD1NYXRoLmZsb29yKG1pbGxpcy84NjQwMDAwMCk7bWlsbGlzl2QqODY0MDAwMDA7rGg9TWF0aC5mbG9vcihtaWxsaXMvMzYwMDAwMCk7bWlsbGlzl2gqMzYwMDAwMDusbT1NYXRoLmZsb29yKG1pbGxpcy82MDAwMCk7bWlsbGlzl20qNjAwMDA7rHM9TWF0aC5mbG9vcihtaWxsaXMvMTAwMCk7q3tkOmQsaDpoLG06bSxzOnN9O31leHBvcnRzLmZvcm1hdFRpbWU9KHZhbHVlKaJ7rHRpbWU9c2FmZVRpbWUov3ZhbHVli9EGb2JqZWN0P3ZhbHVlOmV4cG9ydHMuZGVjb2RlVGltZSh2YWx1ZSkpO3RpbWUuaJZ0aW1lLmQqMjQ7q3RpbWUuaCvRATorKNEBMCt0aW1lLm0pLnN1YnN0cigtMik7fWV4cG9ydHMuZm9ybWF0RHVyYXRpb249KHZhbHVlLGNvbXBhY3Qpontjb21wYWN0PWNvbXBhY3SgtTusZHVyYXRpb249IiI7rHRpbWU9c2FmZVRpbWUov3ZhbHVli9EGb2JqZWN0P3ZhbHVlOmV4cG9ydHMuZGVjb2RlVGltZSh2YWx1ZSkpO6ModGltZS5kPjApZHVyYXRpb26WdGltZS5kK9ECZCA7oyh0aW1lLmg+MClkdXJhdGlvbpZ0aW1lLmgr0QJoIDujKHRpbWUubT4wKWR1cmF0aW9ulnRpbWUubSvRAm0gO6ModGltZS5zPjApZHVyYXRpb26WdGltZS5zK9EBc2R1cmF0aW9uPWR1cmF0aW9uLnRyaW0oKatjb21wYWN0P2R1cmF0aW9uLnJlcGxhY2Uo0QEgLCIiKTpkdXJhdGlvbjt9ZXhwb3J0cy5nZXRDdXJyZW50VGltZU1pbGxpcz0oKaJ7rHRpbWU9uERhdGUoKTurKHRpbWUuZ2V0SG91cnMoKSozNjAwK3RpbWUuZ2V0TWludXRlcygpKjYwK3RpbWUuZ2V0U2Vjb25kcygpKSoxMDAwO319KTsoqigpe6pnZXRBbGFybVZhbHVlKGEpe61taW49TWF0aC5yb3VuZChyZXF1aXJlKNEFc2NoZWQpLmdldFRpbWVUb0FsYXJtKGEpLyg2MCoxMDAwKSk7oyghbWluKaswO6tnZXRBbGFybU1heChhKS1taW47fapnZXRBbGFybU1heChhKXujKGEudGltZXIpq01hdGgucm91bmQoYS50aW1lci8oNjAqMTAwMCkpO6sxNDQwO32qZ2V0QWxhcm1JY29uKGEpe6MoYS5vbil7oyhhLnRpbWVyKavRTBgYgQ==");
  base64DecodeToExistingUint8Array(bufferView, 92323, "B//gB//gAYGAAYGAAYGAAP8AAP8AAH4AADwAADwAAH4AAOcAAMMAAYGAAYGAAYGAB//gB//g");
  base64DecodeToExistingUint8Array(bufferView, 92386, "O6MoYS5kYXRlKavRTBgYgQ==");
  base64DecodeToExistingUint8Array(bufferView, 92412, "D//wH//4GAAYGAAYGAAYH//4H//4H//4H/74H/z4H/n4HzP4H4f4H8/4H//4H//4H//4D//w");
  base64DecodeToExistingUint8Array(bufferView, 92475, "O6vRTBgYgQAAAAAAAAAGAGAOAHAcfjg5/5wD/8AH/+AP5/AP5/Af5/gf5/gf5/gf5/gf4fgf+PgP/vAP//AH/+AD/8AB/4AAfgAAAAAAAAA7faR7oyhhLnRpbWVyKavRTBgYgQ==");
  base64DecodeToExistingUint8Array(bufferView, 92585, "B//gB//gAYGAAYGAAYGAAP8AAP8AAH4AADwAADwAAH4AAOR4AMH+AYG2AYMDAYOHB/OHB/MDAAG2AAH+AAB4O6MoYS5kYXRlKavRSxgYAQ==");
  base64DecodeToExistingUint8Array(bufferView, 92673, "D//wH//4GAAYGAAYGAAYH//4H//4H//4H/74H/wAH/gAHzB4H4H+H8m2H/MDH/OHH/OHD/MDAAG2AAH+AAB4O6vRTBgYgQAAAAAAAAAGAGAOAHAcfjg5/5wD/8AH/+AP5/AP5/Af5/gf5/gf5wAf5gAf4Hgf+f4P+bYP8wMH84cD84cB8wMAebYAAf4AAHg7fX2qZ2V0QWxhcm1UZXh0KGEpe6MoYS50aW1lcil7oyghYS5vbimr0QNvZmY7rXRpbWU9TWF0aC5yb3VuZChyZXF1aXJlKNEFc2NoZWQpLmdldFRpbWVUb0FsYXJtKGEpLyg2MCoxMDAwKSk7oyh0aW1lPjYwKXRpbWU9TWF0aC5yb3VuZCh0aW1lLzYwKSvRAWg7pHRpbWWW0QFtO6t0aW1lO32jKGEuZGF0ZSl7rmQ9uERhdGUoYS5kYXRlKTurYCR7ZC5nZXREYXRlKCl9ICR7cmVxdWlyZSjRBmxvY2FsZSkubW9udGgoZCwxKX1gO32rcmVxdWlyZSjRCnRpbWVfdXRpbHMpLmZvcm1hdFRpbWUoYS50KTt9qmdldEFsYXJtT3JkZXIoYSl7rXZhbD1yZXF1aXJlKNEFc2NoZWQpLmdldFRpbWVUb0FsYXJtKGEpO6Mov3ZhbIrRCXVuZGVmaW5lZCmrODY0MDAqMTAwMDurdmFsO32qZ2V0UmVmcmVzaEludGVydmFscyhhKXuubWludXRlPTYwKjEwMDA7rmhhbGZob3VyPTMwKm1pbnV0ZTuuaG91cj0yKmhhbGZob3VyO61tc2Vjcz1yZXF1aXJlKNEFc2NoZWQpLmdldFRpbWVUb0FsYXJtKGEpO6Mov21zZWNzitEJdW5kZWZpbmVkoG1zZWNzijApq1tdO6MobXNlY3M+aG91cil7rXJlbWFpbj0obXNlY3MrbWludXRlKSVoYWxmaG91cjujKHJlbWFpbjwyNyptaW51dGWecmVtYWlujDApq1toYWxmaG91cixyZW1haW5dO6tbaGFsZmhvdXIsbXNlY3MtaG91cl07faR7oyghYS50aW1lcimrW107q1ttaW51dGUsbXNlY3NdO319ql9kb0ludGVydmFsKGludGVydmFsKXurc2V0VGltZW91dCgoKaJ7ry5lbWl0KNEGcmVkcmF3KTuvLmludGVydmFsPXNldEludGVydmFsKCgponuvLmVtaXQo0QZyZWRyYXcpO30saW50ZXJ2YWwpO30saW50ZXJ2YWwpO32qX2RvU3dpdGNoVGltZW91dChhLHN3aXRjaFRpbWVvdXQpe6tzZXRUaW1lb3V0KCgponuvLmVtaXQo0QZyZWRyYXcpO2NsZWFySW50ZXJ2YWwory5pbnRlcnZhbCk7ry5pbnRlcnZhbD23O6x0bXA9Z2V0UmVmcmVzaEludGVydmFscyhhKTusaW50ZXJ2YWw9dG1wWzBdO6xzd2l0Y2hUaW1lb3V0PXRtcFsxXTujKCFpbnRlcnZhbCmrO68uaW50ZXJ2YWw9X2RvSW50ZXJ2YWwuY2FsbCivLGludGVydmFsKTuvLnN3aXRjaFRpbWVvdXQ9X2RvU3dpdGNoVGltZW91dC5jYWxsKK8sYSxzd2l0Y2hUaW1lb3V0KTt9LHN3aXRjaFRpbWVvdXQpO32sYWxsPXJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRCnNjaGVkLmpzb24sMSmgW107rGFsYXJtSXRlbXM9e25hbWU60QZBbGFybXMsaW1nOmdldEFsYXJtSWNvbih7b246MX0pLGR5bmFtaWM6tCxpdGVtczphbGwuZmlsdGVyKGGiIWEuYXBwaWQpLnNvcnQoKGEsYimiZ2V0QWxhcm1PcmRlcihhKS1nZXRBbGFybU9yZGVyKGIpKS5tYXAoYaIoe25hbWU6tixoYXNSYW5nZTq0LGdldDooKaIoe3RleHQ6Z2V0QWxhcm1UZXh0KGEpLGltZzpnZXRBbGFybUljb24oYSksdjpnZXRBbGFybVZhbHVlKGEpLG1pbjowLG1heDpnZXRBbGFybU1heChhKX0pLHNob3c6qigpe6x0bXA9Z2V0UmVmcmVzaEludGVydmFscyhhKTusaW50ZXJ2YWw9dG1wWzBdO6xzd2l0Y2hUaW1lb3V0PXRtcFsxXTujKCFpbnRlcnZhbCmrO68uaW50ZXJ2YWw9X2RvSW50ZXJ2YWwuY2FsbCivLGludGVydmFsKTuvLnN3aXRjaFRpbWVvdXQ9X2RvU3dpdGNoVGltZW91dC5jYWxsKK8sYSxzd2l0Y2hUaW1lb3V0KTt9LGhpZGU6qigpe6Mory5pbnRlcnZhbCljbGVhckludGVydmFsKK8uaW50ZXJ2YWwpO6Mory5zd2l0Y2hUaW1lb3V0KWNsZWFyVGltZW91dCivLnN3aXRjaFRpbWVvdXQpO68uaW50ZXJ2YWw9tzuvLnN3aXRjaFRpbWVvdXQ9tzt9LHJ1bjqqKCl7oyhhLmRhdGUpqzthLm9uPSFhLm9uO2EubGFzdD0wO6MoYS5vbp5hLnRpbWVyKXJlcXVpcmUo0QVzY2hlZCkucmVzZXRUaW1lcihhKTuvLmVtaXQo0QZyZWRyYXcpO3JlcXVpcmUo0QVzY2hlZCkuc2V0QWxhcm1zKGFsbCk7cmVxdWlyZSjRBXNjaGVkKS5yZWxvYWQoKTt9fSkpLH07q2FsYXJtSXRlbXM7fSkCAQAAc2NoZWQuaW5mbw==");
  base64DecodeToExistingUint8Array(bufferView, 94768, "eyJpZCI6InNjaGVkIiwibmFtZSI6IlNjaGVkdWxlciIsInR5cGUiOiJzY2hlZHVsZXIiLCJpY29uIjoic2NoZWQuaW1nIiwidmVyc2lvbiI6IjAuMzAiLCJ0YWdzIjoidG9vbCxzeXN0ZW0sYWxhcm0sY2xraW5mbyIsImZpbGVzIjoic2NoZWQuaW5mbyxzY2hlZC5ib290LmpzLHNjaGVkLmpzLHNjaGVkLmltZyxzY2hlZCxzY2hlZC5zZXR0aW5ncy5qcyxzY2hlZC5jbGtpbmZvLmpzIiwiZGF0YSI6InNjaGVkLmpzb24sc2NoZWQuc2V0dGluZ3MuanNvbiJ9//+iAQAAd2lkYWxhcm0ud2lkLmpz");
  base64DecodeToExistingUint8Array(bufferView, 95060, "V0lER0VUU1vRBWFsYXJtXT17YXJlYTrRAnRsLHdpZHRoOjAsZHJhdzqqKCl7oyivLndpZHRoKWcucmVzZXQoKS5kcmF3SW1hZ2Uo0UsYGAEAAAAAAAAAGAAOGHAMPDAY/xgZ/5gx/4wz/8wz/8wD/8AD/8AD/8AD/8AD/8AD/8AH/+AP//AP//AAAAAAPAAAGAAAAAAAAAAsry54LK8ueSk7fSxyZWxvYWQ6qigpe1dJREdFVFNb0QVhbGFybV0ud2lkdGg9KHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRCnNjaGVkLmpzb24sMSmgW10pLnNvbWUoYWxhcm2iYWxhcm0ub26eKGFsYXJtLmhpZGRlbo20KSk/MjQ6MDt9fTtXSURHRVRTW9EFYWxhcm1dLnJlbG9hZCgpO0JhbmdsZS5vbijRC2FsYXJtUmVsb2FkLCgponujKFdJREdFVFNb0QVhbGFybV0pe1dJREdFVFNb0QVhbGFybV0ucmVsb2FkKCk7QmFuZ2xlLmRyYXdXaWRnZXRzKCk7fX0pO///jAAAAHdpZGFsYXJtLmluZm8=");
  base64DecodeToExistingUint8Array(bufferView, 95512, "eyJpZCI6IndpZGFsYXJtIiwibmFtZSI6IkFsYXJtcyBXaWRnZXQiLCJ0eXBlIjoid2lkZ2V0IiwidmVyc2lvbiI6IjAuMDIiLCJ0YWdzIjoidG9vbCxhbGFybSx3aWRnZXQiLCJmaWxlcyI6IndpZGFsYXJtLmluZm8sd2lkYWxhcm0ud2lkLmpzIn0cPAAAYWxhcm0uYXBwLmpz");
  base64DecodeToExistingUint8Array(bufferView, 95684, "TW9kdWxlcy5hZGRDYWNoZWQo0Qp0aW1lX3V0aWxzLKooKXtleHBvcnRzLmVuY29kZVRpbWU9KHRpbWUpont0aW1lPXNhZmVUaW1lKHRpbWUpO6t0aW1lLmQqODY0MDAwMDArdGltZS5oKjM2MDAwMDArdGltZS5tKjYwMDAwK3RpbWUucyoxMDAwO32qc2FmZVRpbWUodGltZSl7q3tkOnRpbWUuZKAwLGg6dGltZS5ooDAsbTp0aW1lLm2gMCxzOnRpbWUuc6AwfTt9ZXhwb3J0cy5kZWNvZGVUaW1lPShtaWxsaXMponujKL9taWxsaXON0QZudW1iZXIpsNEcT25seSBhIG51bWJlciBjYW4gYmUgZGVjb2RlZDusZD1NYXRoLmZsb29yKG1pbGxpcy84NjQwMDAwMCk7bWlsbGlzl2QqODY0MDAwMDA7rGg9TWF0aC5mbG9vcihtaWxsaXMvMzYwMDAwMCk7bWlsbGlzl2gqMzYwMDAwMDusbT1NYXRoLmZsb29yKG1pbGxpcy82MDAwMCk7bWlsbGlzl20qNjAwMDA7rHM9TWF0aC5mbG9vcihtaWxsaXMvMTAwMCk7q3tkOmQsaDpoLG06bSxzOnN9O31leHBvcnRzLmZvcm1hdFRpbWU9KHZhbHVlKaJ7rHRpbWU9c2FmZVRpbWUov3ZhbHVli9EGb2JqZWN0P3ZhbHVlOmV4cG9ydHMuZGVjb2RlVGltZSh2YWx1ZSkpO3RpbWUuaJZ0aW1lLmQqMjQ7q3RpbWUuaCvRATorKNEBMCt0aW1lLm0pLnN1YnN0cigtMik7fWV4cG9ydHMuZm9ybWF0RHVyYXRpb249KHZhbHVlLGNvbXBhY3Qpontjb21wYWN0PWNvbXBhY3SgtTusZHVyYXRpb249IiI7rHRpbWU9c2FmZVRpbWUov3ZhbHVli9EGb2JqZWN0P3ZhbHVlOmV4cG9ydHMuZGVjb2RlVGltZSh2YWx1ZSkpO6ModGltZS5kPjApZHVyYXRpb26WdGltZS5kK9ECZCA7oyh0aW1lLmg+MClkdXJhdGlvbpZ0aW1lLmgr0QJoIDujKHRpbWUubT4wKWR1cmF0aW9ulnRpbWUubSvRAm0gO6ModGltZS5zPjApZHVyYXRpb26WdGltZS5zK9EBc2R1cmF0aW9uPWR1cmF0aW9uLnRyaW0oKatjb21wYWN0P2R1cmF0aW9uLnJlcGxhY2Uo0QEgLCIiKTpkdXJhdGlvbjt9ZXhwb3J0cy5nZXRDdXJyZW50VGltZU1pbGxpcz0oKaJ7rHRpbWU9uERhdGUoKTurKHRpbWUuZ2V0SG91cnMoKSozNjAwK3RpbWUuZ2V0TWludXRlcygpKjYwK3RpbWUuZ2V0U2Vjb25kcygpKSoxMDAwO319KTsKTW9kdWxlcy5hZGRDYWNoZWQo0QpkYXRlX3V0aWxzLKooKXtleHBvcnRzLmRvdz0oaSxhYmJyZXZpYXRlZCmie6xkb3c9cmVxdWlyZSjRBmxvY2FsZSkuZG93KHtnZXREYXk6KCmiKGl8MCklN30sYWJicmV2aWF0ZWQpLnNsaWNlKDAsKGFiYnJldmlhdGVkijIpPzE6MTAwKTurYWJicmV2aWF0ZWSKMj9kb3cudG9VcHBlckNhc2UoKTpkb3c7fWV4cG9ydHMuZG93cz0oZmlyc3REYXlPZldlZWssYWJicmV2aWF0ZWQponusZG93cz1bXTunKKxpPTA7aTw3O2mYKXtkb3dzLnB1c2goZXhwb3J0cy5kb3coaSsoZmlyc3REYXlPZldlZWugMCksYWJicmV2aWF0ZWQpKX2rYWJicmV2aWF0ZWSKMj9kb3dzLm1hcChkb3eiZG93LnRvVXBwZXJDYXNlKCkpOmRvd3M7fTtleHBvcnRzLm1vbnRoPShpLGFiYnJldmlhdGVkKaJ7rG1vbnRoPXJlcXVpcmUo0QZsb2NhbGUpLm1vbnRoKHtnZXRNb250aDooKaIoMTErKGl8MCkpJTEyfSxhYmJyZXZpYXRlZCkuc2xpY2UoMCwoYWJicmV2aWF0ZWSKMik/MToxMDApO6thYmJyZXZpYXRlZIoyP21vbnRoLnRvVXBwZXJDYXNlKCk6bW9udGg7fWV4cG9ydHMubW9udGhzPShhYmJyZXZpYXRlZCmie6xtb250aHM9W107rGxvY2FsZT1yZXF1aXJlKNEGbG9jYWxlKTunKKxpPTA7aTwxMjtpmCltb250aHMucHVzaChsb2NhbGUubW9udGgoe2dldE1vbnRoOigpoml9LGFiYnJldmlhdGVkKS5zbGljZSgwLChhYmJyZXZpYXRlZIoyKT8xOjEwMCkpO6thYmJyZXZpYXRlZIoyP21vbnRocy5tYXAobW9udGiibW9udGgudG9VcHBlckNhc2UoKSk6bW9udGhzO307fSk7Ck1vZHVsZXMuYWRkQ2FjaGVkKNEEYnV6eiyqKCl7ZXhwb3J0cy5wYXR0ZXJuPXBhdHRlcm6iuFByb21pc2UocmVzb2x2ZaJ7qmRvQnV6eigpe6MocGF0dGVybooiIimrcmVzb2x2ZSgpO6xjPXBhdHRlcm5bMF07cGF0dGVybj1wYXR0ZXJuLnN1YnN0cigxKTuuQlVaWl9XRUFLPTAuMjUsQlVaWl9TVFJPTkc9MTuuU0hPUlRfTVM9MTAwLE1FRElVTV9NUz0yMDAsTE9OR19NUz01MDA7oyhjitEBLilCYW5nbGUuYnV6eihTSE9SVF9NUyxCVVpaX1dFQUspLnRoZW4oKCmic2V0VGltZW91dChkb0J1enosMTAwKSk7pKMoY4rRASwpQmFuZ2xlLmJ1enooTUVESVVNX01TLEJVWlpfV0VBSykudGhlbigoKaJzZXRUaW1lb3V0KGRvQnV6eiwxMDApKTukoyhjitEBLSlCYW5nbGUuYnV6eihMT05HX01TLEJVWlpfV0VBSykudGhlbigoKaJzZXRUaW1lb3V0KGRvQnV6eiwxMDApKTukoyhjitEBOilCYW5nbGUuYnV6eihTSE9SVF9NUyxCVVpaX1NUUk9ORykudGhlbigoKaJzZXRUaW1lb3V0KGRvQnV6eiwxMDApKTukoyhjitEBOylCYW5nbGUuYnV6eihNRURJVU1fTVMsQlVaWl9TVFJPTkcpLnRoZW4oKCmic2V0VGltZW91dChkb0J1enosMTAwKSk7pKMoY4rRAT0pQmFuZ2xlLmJ1enooTE9OR19NUyxCVVpaX1NUUk9ORykudGhlbigoKaJzZXRUaW1lb3V0KGRvQnV6eiwxMDApKTukc2V0VGltZW91dChkb0J1enosMTAwKTt9ZG9CdXp6KCk7fSk7fSk7Ck1vZHVsZXMuYWRkQ2FjaGVkKNEJYnV6el9tZW51LKooKXtleHBvcnRzLnBhdHRlcm49qih2YWx1ZSxjYWxsYmFjayl7rHBhdHRlcm5zPVsiIizRAS4s0QE6LNECLi4s0QI6OizRASws0QE7LNECLCws0QI7OyzRAS0s0QE9LNECLS0s0QI9PSzRAy4uLizRAzo6OizRAy0tLSzRAzs7OyzRAz09PV07q3t2YWx1ZTpNYXRoLm1heCgwLHBhdHRlcm5zLmluZGV4T2YodmFsdWUpKSxtaW46MCxtYXg6cGF0dGVybnMubGVuZ3RoLTEsZm9ybWF0OnaicGF0dGVybnNbdl2g0QNPZmYsb25jaGFuZ2U6dqJ7cmVxdWlyZSjRBGJ1enopLnBhdHRlcm4ocGF0dGVybnNbdl0pO2NhbGxiYWNrKHBhdHRlcm5zW3ZdKTt9fTt9fSk7CkJhbmdsZS5sb2FkV2lkZ2V0cygpOwpCYW5nbGUuZHJhd1dpZGdldHMoKTsKrnNldHRpbmdzPU9iamVjdC5hc3NpZ24oe3Nob3dDb25maXJtOrQsc2hvd0F1dG9Tbm9vemU6tCxzaG93SGlkZGVuOrR9LHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRCmFsYXJtLmpzb24sMSmge30pOwquZmlyc3REYXlPZldlZWs9KHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRDHNldHRpbmcuanNvbiy0KaB7fSkuZmlyc3REYXlPZldlZWugMDsKrldPUktEQVlTPTYyOwquV0VFS0VORD1maXJzdERheU9mV2Vlaz8xOTI6NjU7Cq5FVkVSWV9EQVk9Zmlyc3REYXlPZldlZWs/MjU0OjEyNzsKrklOVEVSVkFMUz1b0QNkYXks0QR3ZWVrLNEFbW9udGgs0QR5ZWFyXTsKrklOVEVSVkFMX0xBQkVMUz1b0QNEYXks0QRXZWVrLNEFTW9udGgs0QRZZWFyXTsKrmljb25BbGFybU9uPdEBACvRTBgYgQAAAAAAAAAGAGAOAHAcfjg5/5wD/8AH/+AP5/AP5/Af5/gf5/gf5/gf5/gf4fgf+PgP/vAP//AH/+AD/8AB/4AAfgAAAAAAAAA7rmljb25BbGFybU9mZj3RAQArKGcudGhlbWUuZGFyaz/RUBgYwQD/////AAAAAAAABgBgDgBwHH44Of+cA//AB//gD+fwD+fwH+f4H+f4H+cAH+YAH+B4H/n+D/m2D/MDB/OHA/OHAfMDAHm2AAH+AAB4OtFQGBjBAP//AAAAAAAAAAAGAGAOAHAcfjg5/5wD/8AH/+AP5/AP5/Af5/gf5/gf5wAf5gAf4Hgf+f4P+bYP8wMH84cD84cB8wMAebYAAf4AAHgpO65pY29uVGltZXJPbj3RAQArKGcudGhlbWUuZGFyaz/RUBgYwQD/////");
  base64DecodeToExistingUint8Array(bufferView, 99338, "B//gB//gAYGAAYGAAYGAAP8AAP8AAH4AADwAADwAAH4AAOcAAMMAAYGAAYGAAYGAB//gB//g");
  base64DecodeToExistingUint8Array(bufferView, 99401, "OtFQGBjBAP//");
  base64DecodeToExistingUint8Array(bufferView, 99421, "B//gB//gAYGAAYGAAYGAAP8AAP8AAH4AADwAADwAAH4AAOcAAMMAAYGAAYGAAYGAB//gB//g");
  base64DecodeToExistingUint8Array(bufferView, 99484, "KTuuaWNvblRpbWVyT2ZmPdEBACsoZy50aGVtZS5kYXJrP9FQGBjBAP////8=");
  base64DecodeToExistingUint8Array(bufferView, 99537, "B//gB//gAYGAAYGAAYGAAP8AAP8AAH4AADwAADwAAH4AAOR4AMH+AYG2AYMDAYOHB/OHB/MDAAG2AAH+AAB4OtFQGBjBAP//");
  base64DecodeToExistingUint8Array(bufferView, 99620, "B//gB//gAYGAAYGAAYGAAP8AAP8AAH4AADwAADwAAH4AAOR4AMH+AYG2AYMDAYOHB/OHB/MDAAG2AAH+AAB4KTusYWxhcm1zPXJlcXVpcmUo0QVzY2hlZCkuZ2V0QWxhcm1zKCk7YWxhcm1zLmZvckVhY2goZaJlLnScODY0MDAwMDApO6poYW5kbGVGaXJzdERheU9mV2Vlayhkb3cpe6MoZmlyc3REYXlPZldlZWuKMSl7oygoZG93JjEpijEpe2Rvd5YxMjc7faSjKChkb3cmMTI4KYoxMjgpe2Rvd5cxMjc7fX2rZG93O31hbGFybXMuZmlsdGVyKGWiZS50aW1lcou3KS5mb3JFYWNoKGGiYS5kb3c9aGFuZGxlRmlyc3REYXlPZldlZWsoYS5kb3cpKTuqZ2V0TGFiZWwoZSl7rmRhdGVTdHI9Z2V0RGF0ZVRleHQoZS5kYXRlKTurKGUudGltZXI/cmVxdWlyZSjRCnRpbWVfdXRpbHMpLmZvcm1hdER1cmF0aW9uKGUudGltZXIpOihkYXRlU3RyP2Ake2RhdGVTdHJ9JHtlLnJwP9EBKjoiIn0gJHtyZXF1aXJlKNEKdGltZV91dGlscykuZm9ybWF0VGltZShlLnQpfWA6cmVxdWlyZSjRCnRpbWVfdXRpbHMpLmZvcm1hdFRpbWUoZS50KSsoZS5ycD9gICR7ZGVjb2RlUmVwZWF0KGUpfWA6IiIpKSkrKGUubXNnP2AgJHtlLm1zZ31gOiIiKTt9qmdldERhdGVUZXh0KGQpe6tknihzZXR0aW5ncy5tZW51RGF0ZUZvcm1hdIvRBG1tZGQ/ZC5zdWJzdHJpbmcoZC5zdGFydHNXaXRoKLhEYXRlKCkuZ2V0RnVsbFllYXIoKSk/NTowKTpyZXF1aXJlKNEGbG9jYWxlKS5kYXRlKLhEYXRlKGQpLDEpKTt9qnRyaW1MYWJlbChsYWJlbCxtYXhMZW5ndGgpe6Moc2V0dGluZ3Muc2hvd092ZXJmbG93KatsYWJlbDurKGxhYmVsLmxlbmd0aD5tYXhMZW5ndGg/bGFiZWwuc3Vic3RyaW5nKDAsbWF4TGVuZ3RoLTMpK9EDLi4uOmxhYmVsLnN1YnN0cmluZygwLG1heExlbmd0aCkpO32qZm9ybWF0QWxhcm1Qcm9wZXJ0eShtc2cpe6Moc2V0dGluZ3Muc2hvd092ZXJmbG93Kattc2c7oyhtc2eKtil7q21zZzt9pKMobXNnLmxlbmd0aD43KXurbXNnLnN1YnN0cmluZygwLDYpK9EDLi4uO32ke6ttc2cuc3Vic3RyaW5nKDAsNyk7fX2qc2hvd01haW5NZW51KHNjcm9sbCxncm91cCxzY3JvbGxiYWNrKXuubWVudT17IiI6e9EFdGl0bGU6Z3JvdXCg0Q9BbGFybXMgJiBUaW1lcnMsc2Nyb2xsOnNjcm9sbH0s0QY8IEJhY2s6KCmiZ3JvdXA/c2hvd01haW5NZW51KHNjcm9sbGJhY2spOmxvYWQoKSzRBk5ldy4uLjooKaJzaG93TmV3TWVudShncm91cCl9O65nZXRHcm91cHM9c2V0dGluZ3Muc2hvd0dyb3VwniFncm91cDuuZ3JvdXBzPWdldEdyb3Vwcz97fTq3O6xzaG93QWxhcm07rmdldEljb249KGUponurZS5vbj8oZS50aW1lcj9pY29uVGltZXJPbjppY29uQWxhcm1Pbik6KGUudGltZXI/aWNvblRpbWVyT2ZmOmljb25BbGFybU9mZik7fTthbGFybXMuZm9yRWFjaCgoZSxpbmRleCmie3Nob3dBbGFybT0hc2V0dGluZ3Muc2hvd0dyb3VwoChncm91cD9lLmdyb3Vwi2dyb3VwOiFlLmdyb3VwKTujKHNob3dBbGFybSl7rmxhYmVsPXRyaW1MYWJlbChnZXRMYWJlbChlKSw0MCk7bWVudVtsYWJlbF09e3ZhbHVlOmUub24sb25jaGFuZ2U6KHYsdG91Y2gponujKHRvdWNonigyinRvdWNoLnR5cGWgMTQ1PHRvdWNoLngpKXtlLm9uPXY7c2F2ZUFuZFJlbG9hZCgpO32ke3NldFRpbWVvdXQoZS50aW1lcj9zaG93RWRpdFRpbWVyTWVudTpzaG93RWRpdEFsYXJtTWVudSwxMCxlLGluZGV4LLcsc2Nyb2xsZXI/c2Nyb2xsZXIuc2Nyb2xsOrcsZ3JvdXApO319LGZvcm1hdDp2omdldEljb24oZSl9O32koyhnZXRHcm91cHMpe2dyb3Vwc1tlLmdyb3VwXT23O319KTujKCFncm91cCl7T2JqZWN0LmtleXMoZ3JvdXBzKS5zb3J0KCkuZm9yRWFjaChnom1lbnVbZ109KCmic2hvd01haW5NZW51KLYsZyxzY3JvbGxlcj9zY3JvbGxlci5zY3JvbGw6tykpO21lbnVb0QhBZHZhbmNlZF09KCmic2hvd0FkdmFuY2VkTWVudSgpO32sc2Nyb2xsZXI9RS5zaG93TWVudShtZW51KS5zY3JvbGxlcjt9qnNob3dOZXdNZW51KGdyb3VwKXuubmV3TWVudT17IiI6e9EFdGl0bGU60QZOZXcuLi59LNEGPCBCYWNrOigponNob3dNYWluTWVudShncm91cCks0QVBbGFybTooKaJzaG93RWRpdEFsYXJtTWVudSi3LLcstSy2LGdyb3VwKSzRBVRpbWVyOigponNob3dFZGl0VGltZXJNZW51KLcstyks0QVFdmVudDooKaJzaG93RWRpdEFsYXJtTWVudSi3LLcstCy2LGdyb3VwKX07oyhncm91cCm+bmV3TWVudVvRBVRpbWVyXTtFLnNob3dNZW51KG5ld01lbnUpO32qc2hvd0VkaXRBbGFybU1lbnUoc2VsZWN0ZWRBbGFybSxhbGFybUluZGV4LHdpdGhEYXRlLHNjcm9sbCxncm91cCl7rGlzTmV3PWFsYXJtSW5kZXiLtzusYWxhcm09cmVxdWlyZSjRBXNjaGVkKS5uZXdEZWZhdWx0QWxhcm0oKTujKGlzTmV3nmdyb3VwKWFsYXJtLmdyb3VwPWdyb3VwO6Mod2l0aERhdGWgKHNlbGVjdGVkQWxhcm2ec2VsZWN0ZWRBbGFybS5kYXRlKSl7YWxhcm0uZGVsPXJlcXVpcmUo0QVzY2hlZCkuZ2V0U2V0dGluZ3MoKS5kZWZhdWx0RGVsZXRlRXhwaXJlZFRpbWVyczt9YWxhcm0uZG93PWhhbmRsZUZpcnN0RGF5T2ZXZWVrKGFsYXJtLmRvdyk7oyhzZWxlY3RlZEFsYXJtKXtPYmplY3QuYXNzaWduKGFsYXJtLHNlbGVjdGVkQWxhcm0pO32sdGltZT1yZXF1aXJlKNEKdGltZV91dGlscykuZGVjb2RlVGltZShhbGFybS50KTujKHdpdGhEYXRlniFhbGFybS5kYXRlKWFsYXJtLmRhdGU9uERhdGUoKS50b0xvY2FsSVNPU3RyaW5nKCkuc2xpY2UoMCwxMCk7rGRhdGU9YWxhcm0uZGF0ZT+4RGF0ZShhbGFybS5kYXRlKTq3O6x0aXRsZT1kYXRlPyhpc05ldz/RCU5ldyBFdmVudDrRCkVkaXQgRXZlbnQpOihpc05ldz/RCU5ldyBBbGFybTrRCkVkaXQgQWxhcm0pO6xrZXlib2FyZD3RCXRleHRpbnB1dDuxe2tleWJvYXJkPXJlcXVpcmUoa2V5Ym9hcmQpO31jYXRjaChlKXtrZXlib2FyZD22O32sZGF0ZXRpbWVpbnB1dDuxe2RhdGV0aW1laW5wdXQ9cmVxdWlyZSjRDWRhdGV0aW1laW5wdXQpO31jYXRjaChlKXtkYXRldGltZWlucHV0PbY7fa5tZW51PXsiIjp70QV0aXRsZTp0aXRsZX0s0QY8IEJhY2s6KCmie3ByZXBhcmVBbGFybUZvclNhdmUoYWxhcm0sYWxhcm1JbmRleCx0aW1lLGRhdGUpO3NhdmVBbmRSZWxvYWQoKTtzaG93TWFpbk1lbnUoc2Nyb2xsLGdyb3VwKTt9fTujKGFsYXJtLmRhdGWeZGF0ZXRpbWVpbnB1dCl7bWVudVtgJHtnZXREYXRlVGV4dChkYXRlLnRvTG9jYWxJU09TdHJpbmcoKS5zbGljZSgwLDEwKSl9ICR7cmVxdWlyZSjRCnRpbWVfdXRpbHMpLmZvcm1hdFRpbWUodGltZSl9YF09e3ZhbHVlOmRhdGUsZm9ybWF0OnaiIiIsb25jaGFuZ2U6dqJ7c2V0VGltZW91dCgoKaJ7rGRhdGV0aW1lPbhEYXRlKHYuZ2V0VGltZSgpKTtkYXRldGltZS5zZXRIb3Vycyh0aW1lLmgsdGltZS5tKTtkYXRldGltZWlucHV0LmlucHV0KHtkYXRldGltZX0pLnRoZW4ocmVzdWx0ont0aW1lLmg9cmVzdWx0LmdldEhvdXJzKCk7dGltZS5tPXJlc3VsdC5nZXRNaW51dGVzKCk7cHJlcGFyZUFsYXJtRm9yU2F2ZShhbGFybSxhbGFybUluZGV4LHRpbWUscmVzdWx0LLQpO3NldFRpbWVvdXQoc2hvd0VkaXRBbGFybU1lbnUsMTAsYWxhcm0sYWxhcm1JbmRleCx3aXRoRGF0ZSxzY3JvbGwsZ3JvdXApO30pO30sMTAwKTt9fTt9pHtPYmplY3QuYXNzaWduKG1lbnUse9EESG91cjp7dmFsdWU6dGltZS5oLGZvcm1hdDp2oijRATArdikuc3Vic3RyKC0yKSxtaW46MCxtYXg6MjMsd3JhcDq0LG9uY2hhbmdlOnaidGltZS5oPXZ9LNEGTWludXRlOnt2YWx1ZTp0aW1lLm0sZm9ybWF0OnaiKNEBMCt2KS5zdWJzdHIoLTIpLG1pbjowLG1heDo1OSx3cmFwOrQsb25jaGFuZ2U6dqJ0aW1lLm09dn0s0QNEYXk6e3ZhbHVlOmRhdGU/ZGF0ZS5nZXREYXRlKCk6tixtaW46MSxtYXg6MzEsd3JhcDq0LG9uY2hhbmdlOnaiZGF0ZS5zZXREYXRlKHYpfSzRBU1vbnRoOnt2YWx1ZTpkYXRlP2RhdGUuZ2V0TW9udGgoKSsxOrYsZm9ybWF0OnaicmVxdWlyZSjRCmRhdGVfdXRpbHMpLm1vbnRoKHYpLG9uY2hhbmdlOnaiZGF0ZS5zZXRNb250aCgodisxMSklMTIpfSzRBFllYXI6e3ZhbHVlOmRhdGU/ZGF0ZS5nZXRGdWxsWWVhcigpOrYsbWluOrhEYXRlKCkuZ2V0RnVsbFllYXIoKSxtYXg6MjEwMCxvbmNoYW5nZTp2omRhdGUuc2V0RnVsbFllYXIodil9fSk7fU9iamVjdC5hc3NpZ24obWVudSx70QdNZXNzYWdlOnt2YWx1ZTphbGFybS5tc2csZm9ybWF0OmZvcm1hdEFsYXJtUHJvcGVydHksb25jaGFuZ2U6KCmie3NldFRpbWVvdXQoKCmie2tleWJvYXJkLmlucHV0KHt0ZXh0OmFsYXJtLm1zZ30pLnRoZW4ocmVzdWx0onthbGFybS5tc2c9cmVzdWx0O3ByZXBhcmVBbGFybUZvclNhdmUoYWxhcm0sYWxhcm1JbmRleCx0aW1lLGRhdGUstCk7c2V0VGltZW91dChzaG93RWRpdEFsYXJtTWVudSwxMCxhbGFybSxhbGFybUluZGV4LHdpdGhEYXRlLHNjcm9sbCxncm91cCk7fSk7fSwxMDApO319LNEFR3JvdXA6e3ZhbHVlOmFsYXJtLmdyb3VwLGZvcm1hdDpmb3JtYXRBbGFybVByb3BlcnR5LG9uY2hhbmdlOigpontzZXRUaW1lb3V0KCgpontrZXlib2FyZC5pbnB1dCh7dGV4dDphbGFybS5ncm91cH0pLnRoZW4ocmVzdWx0onthbGFybS5ncm91cD1yZXN1bHQ7cHJlcGFyZUFsYXJtRm9yU2F2ZShhbGFybSxhbGFybUluZGV4LHRpbWUsZGF0ZSy0KTtzZXRUaW1lb3V0KHNob3dFZGl0QWxhcm1NZW51LDEwLGFsYXJtLGFsYXJtSW5kZXgsd2l0aERhdGUsc2Nyb2xsLGdyb3VwKTt9KTt9LDEwMCk7fX0s0QdFbmFibGVkOnt2YWx1ZTphbGFybS5vbixvbmNoYW5nZTp2omFsYXJtLm9uPXZ9LNEGUmVwZWF0Ont2YWx1ZTpkZWNvZGVSZXBlYXQoYWxhcm0pLG9uY2hhbmdlOigponNldFRpbWVvdXQoc2hvd0VkaXRSZXBlYXRNZW51LDEwMCxhbGFybS5ycCxkYXRloGFsYXJtLmRvdywocmVwZWF0LGRvdymie6MocmVwZWF0KXthbGFybS5kZWw9tTt9YWxhcm0ucnA9cmVwZWF0O2FsYXJtLmRvdz1kb3c7cHJlcGFyZUFsYXJtRm9yU2F2ZShhbGFybSxhbGFybUluZGV4LHRpbWUsZGF0ZSy0KTtzZXRUaW1lb3V0KHNob3dFZGl0QWxhcm1NZW51LDEwLGFsYXJtLGFsYXJtSW5kZXgsd2l0aERhdGUsc2Nyb2xsLGdyb3VwKTt9KX0s0QdWaWJyYXRlOnJlcXVpcmUo0QlidXp6X21lbnUpLnBhdHRlcm4oYWxhcm0udmlicmF0ZSx2omFsYXJtLnZpYnJhdGU9diks0QtBdXRvIFNub296ZTp7dmFsdWU6YWxhcm0uYXMsb25jaGFuZ2U6dqJhbGFybS5hcz12fSzRF0RlbGV0ZSBBZnRlciBFeHBpcmF0aW9uOnt2YWx1ZTphbGFybS5kZWwsb25jaGFuZ2U6dqJhbGFybS5kZWw9dn0s0QZIaWRkZW46e3ZhbHVlOmFsYXJtLmhpZGRlbqC1LG9uY2hhbmdlOnaiYWxhcm0uaGlkZGVuPXZ9LNEGQ2FuY2VsOigponNob3dNYWluTWVudShzY3JvbGwsZ3JvdXApLNEHQ29uZmlybTooKaJ7cHJlcGFyZUFsYXJtRm9yU2F2ZShhbGFybSxhbGFybUluZGV4LHRpbWUsZGF0ZSk7c2F2ZUFuZFJlbG9hZCgpO3Nob3dNYWluTWVudShzY3JvbGwsZ3JvdXApO319KTujKCFrZXlib2FyZCm+bWVudVvRB01lc3NhZ2VdO6MoIWtleWJvYXJkoCFzZXR0aW5ncy5zaG93R3JvdXApvm1lbnVb0QVHcm91cF07oyghc2V0dGluZ3Muc2hvd0NvbmZpcm0pvm1lbnVb0QdDb25maXJtXTujKCFzZXR0aW5ncy5zaG93QXV0b1Nub296ZSm+bWVudVvRC0F1dG8gU25vb3plXTujKCFzZXR0aW5ncy5zaG93SGlkZGVuKb5tZW51W9EGSGlkZGVuXTujKCFhbGFybS5kYXRlKXu+bWVudVvRA0RheV07vm1lbnVb0QVNb250aF07vm1lbnVb0QRZZWFyXTu+bWVudVvRF0RlbGV0ZSBBZnRlciBFeHBpcmF0aW9uXTt9oyghaXNOZXcpe21lbnVb0QZEZWxldGVdPSgpontFLnNob3dQcm9tcHQoZ2V0TGFiZWwoYWxhcm0pK9EBCivRDUFyZSB5b3Ugc3VyZT8se3RpdGxlOtEMRGVsZXRlIEFsYXJtfSkudGhlbigoY29uZmlybSmie6MoY29uZmlybSl7YWxhcm1zLnNwbGljZShhbGFybUluZGV4LDEpO3NhdmVBbmRSZWxvYWQoKTtzaG93TWFpbk1lbnUoc2Nyb2xsLGdyb3VwKTt9pHthbGFybS50PXJlcXVpcmUo0Qp0aW1lX3V0aWxzKS5lbmNvZGVUaW1lKHRpbWUpO3NldFRpbWVvdXQoc2hvd0VkaXRBbGFybU1lbnUsMTAsYWxhcm0sYWxhcm1JbmRleCx3aXRoRGF0ZSxzY3JvbGwsZ3JvdXApO319KTt9O31FLnNob3dNZW51KG1lbnUpO30KqnByZXBhcmVBbGFybUZvclNhdmUoYWxhcm0sYWxhcm1JbmRleCx0aW1lLGRhdGUsdGVtcCl7YWxhcm0udD1yZXF1aXJlKNEKdGltZV91dGlscykuZW5jb2RlVGltZSh0aW1lKTthbGFybS5sYXN0PWFsYXJtLnQ8cmVxdWlyZSjRCnRpbWVfdXRpbHMpLmdldEN1cnJlbnRUaW1lTWlsbGlzKCk/uERhdGUoKS5nZXREYXRlKCk6MDujKGRhdGUpYWxhcm0uZGF0ZT1kYXRlLnRvTG9jYWxJU09TdHJpbmcoKS5zbGljZSgwLDEwKTujKCF0ZW1wKXujKGFsYXJtSW5kZXiLtyl7YWxhcm1zLnB1c2goYWxhcm0pO32ke2FsYXJtc1thbGFybUluZGV4XT1hbGFybTt9fX0KqnNhdmVBbmRSZWxvYWQoKXthbGFybXMuZmlsdGVyKGWiZS50aW1lcou3KS5mb3JFYWNoKGGiYS5kb3c9aGFuZGxlRmlyc3REYXlPZldlZWsoYS5kb3cpKTtyZXF1aXJlKNEFc2NoZWQpLnNldEFsYXJtcyhhbGFybXMpO3JlcXVpcmUo0QVzY2hlZCkucmVsb2FkKCk7YWxhcm1zLmZpbHRlcihlomUudGltZXKLtykuZm9yRWFjaChhomEuZG93PWhhbmRsZUZpcnN0RGF5T2ZXZWVrKGEuZG93KSk7fQqqZGVjb2RlUmVwZWF0KGFsYXJtKXurYWxhcm0ucnA/KGFsYXJtLmRhdGU/YCR7YWxhcm0ucnAubnVtfSoke0lOVEVSVkFMX0xBQkVMU1tJTlRFUlZBTFMuaW5kZXhPZihhbGFybS5ycC5pbnRlcnZhbCldfWAKOnJlcXVpcmUo0QpkYXRlX3V0aWxzKQouZG93cyhmaXJzdERheU9mV2VlaywyKQoubWFwKChkYXksaW5kZXgpomFsYXJtLmRvdyYoMY8oaW5kZXgrZmlyc3REYXlPZldlZWspKT9kYXk60QFfKQouam9pbigiIikKLnRvTG93ZXJDYXNlKCkpOtEET25jZTt9qnNob3dFZGl0UmVwZWF0TWVudShyZXBlYXQsZGF5LGRvd0NoYW5nZUNhbGxiYWNrKXusZG93O65tZW51PXsKIiI6e9EFdGl0bGU60QxSZXBlYXQgQWxhcm19LArRBjwgQmFjazooKaJkb3dDaGFuZ2VDYWxsYmFjayhyZXBlYXQsZG93KSwK0QlPbmx5IE9uY2U6KCmiZG93Q2hhbmdlQ2FsbGJhY2sotSxFVkVSWV9EQVkpCn07rXJlc3RPZk1lbnU7oyi/ZGF5i9EGbnVtYmVyKXsKZG93PWRheTsKrG9yaWdpbmFsRG93PWRvdzsKrGlzQ3VzdG9tPXJlcGVhdJ5kb3eMV09SS0RBWVOeZG93jFdFRUtFTkSeZG93jEVWRVJZX0RBWTsKcmVzdE9mTWVudT170QhXb3JrZGF5czp7dmFsdWU6cmVwZWF0nmRvd4pXT1JLREFZUyxvbmNoYW5nZTooKaJkb3dDaGFuZ2VDYWxsYmFjayi0LFdPUktEQVlTKX0s0QhXZWVrZW5kczp7dmFsdWU6cmVwZWF0nmRvd4pXRUVLRU5ELG9uY2hhbmdlOigpomRvd0NoYW5nZUNhbGxiYWNrKLQsV0VFS0VORCl9LNEJRXZlcnkgRGF5Ont2YWx1ZTpyZXBlYXSeZG93ikVWRVJZX0RBWSxvbmNoYW5nZTooKaJkb3dDaGFuZ2VDYWxsYmFjayi0LEVWRVJZX0RBWSl9LNEGQ3VzdG9tOnt2YWx1ZTppc0N1c3RvbT9kZWNvZGVSZXBlYXQoe3JwOrQsZG93OmRvd30pOrUsb25jaGFuZ2U6KCmic2V0VGltZW91dChzaG93Q3VzdG9tRGF5c01lbnUsMTAsZG93LGRvd0NoYW5nZUNhbGxiYWNrLHJlcGVhdCxvcmlnaW5hbERvdyl9fTsKfaR7CmRvdz1FVkVSWV9EQVk7Cq5yZXBlYXRPYmo9cmVwZWF0oHtpbnRlcnZhbDrRBW1vbnRoLG51bToxfTsKcmVzdE9mTWVudT170QVFdmVyeTp7dmFsdWU6cmVwZWF0T2JqLm51bSxtaW46MSxvbmNoYW5nZTp2ontyZXBlYXQ9cmVwZWF0T2JqO3JlcGVhdC5udW09djt9fSzRCEludGVydmFsOnt2YWx1ZTpJTlRFUlZBTFMuaW5kZXhPZihyZXBlYXRPYmouaW50ZXJ2YWwpLGZvcm1hdDp2oklOVEVSVkFMX0xBQkVMU1t2XSxtaW46MCxtYXg6SU5URVJWQUxTLmxlbmd0aC0xLG9uY2hhbmdlOnaie3JlcGVhdD1yZXBlYXRPYmo7cmVwZWF0LmludGVydmFsPUlOVEVSVkFMU1t2XTt9fX07Cn1PYmplY3QuYXNzaWduKG1lbnUscmVzdE9mTWVudSk7RS5zaG93TWVudShtZW51KTt9qnNob3dDdXN0b21EYXlzTWVudShkb3csZG93Q2hhbmdlQ2FsbGJhY2ssb3JpZ2luYWxSZXBlYXQsb3JpZ2luYWxEb3cpe65tZW51PXsKIiI6e9EFdGl0bGU60QtDdXN0b20gRGF5c30sCtEGPCBCYWNrOigponuscmVwZWF0PWRvdz4wO2Rvd0NoYW5nZUNhbGxiYWNrKHJlcGVhdCxyZXBlYXQ/ZG93OkVWRVJZX0RBWSk7fQp9O3JlcXVpcmUo0QpkYXRlX3V0aWxzKS5kb3dzKGZpcnN0RGF5T2ZXZWVrKS5mb3JFYWNoKChkYXksaSmie21lbnVbZGF5XT17dmFsdWU6ISEoZG93JigxjyhpK2ZpcnN0RGF5T2ZXZWVrKSkpLG9uY2hhbmdlOnaidj8oZG93nzGPKGkrZmlyc3REYXlPZldlZWspKTooZG93nX4oMY8oaStmaXJzdERheU9mV2VlaykpKX07fSk7bWVudVvRBkNhbmNlbF09KCmic2V0VGltZW91dChzaG93RWRpdFJlcGVhdE1lbnUsMTAsb3JpZ2luYWxSZXBlYXQsb3JpZ2luYWxEb3csZG93Q2hhbmdlQ2FsbGJhY2spO0Uuc2hvd01lbnUobWVudSk7fapzaG93RWRpdFRpbWVyTWVudShzZWxlY3RlZFRpbWVyLHRpbWVySW5kZXgpe6xpc05ldz10aW1lckluZGV4i7c7rHRpbWVyPXJlcXVpcmUo0QVzY2hlZCkubmV3RGVmYXVsdFRpbWVyKCk7oyhzZWxlY3RlZFRpbWVyKXsKT2JqZWN0LmFzc2lnbih0aW1lcixzZWxlY3RlZFRpbWVyKTsKfax0aW1lPXJlcXVpcmUo0Qp0aW1lX3V0aWxzKS5kZWNvZGVUaW1lKHRpbWVyLnRpbWVyKTusa2V5Ym9hcmQ90Ql0ZXh0aW5wdXQ7sXtrZXlib2FyZD1yZXF1aXJlKGtleWJvYXJkKTt9Y2F0Y2goZSl7a2V5Ym9hcmQ9tjt9rm1lbnU9ewoiIjp70QV0aXRsZTppc05ldz/RCU5ldyBUaW1lcjrRCkVkaXQgVGltZXJ9LArRBjwgQmFjazooKaJ7cHJlcGFyZVRpbWVyRm9yU2F2ZSh0aW1lcix0aW1lckluZGV4LHRpbWUpO3NhdmVBbmRSZWxvYWQoKTtzaG93TWFpbk1lbnUoKTt9LArRBUhvdXJzOnt2YWx1ZTp0aW1lLmgsbWluOjAsbWF4OjIzLHdyYXA6tCxvbmNoYW5nZTp2onRpbWUuaD12fSwK0QdNaW51dGVzOnt2YWx1ZTp0aW1lLm0sbWluOjAsbWF4OjU5LHdyYXA6tCxvbmNoYW5nZTp2onRpbWUubT12fSwK0QdTZWNvbmRzOnt2YWx1ZTp0aW1lLnMsbWluOjAsbWF4OjU5LHN0ZXA6MSx3cmFwOrQsb25jaGFuZ2U6dqJ0aW1lLnM9dn0sCtEHTWVzc2FnZTp7dmFsdWU6dGltZXIubXNnLGZvcm1hdDpmb3JtYXRBbGFybVByb3BlcnR5LG9uY2hhbmdlOigpontzZXRUaW1lb3V0KCgpontrZXlib2FyZC5pbnB1dCh7dGV4dDp0aW1lci5tc2d9KS50aGVuKHJlc3VsdKJ7dGltZXIubXNnPXJlc3VsdDtwcmVwYXJlVGltZXJGb3JTYXZlKHRpbWVyLHRpbWVySW5kZXgsdGltZSy0KTtzZXRUaW1lb3V0KHNob3dFZGl0VGltZXJNZW51LDEwLHRpbWVyLHRpbWVySW5kZXgpO30pO30sMTAwKTt9fSwK0QdFbmFibGVkOnt2YWx1ZTp0aW1lci5vbixvbmNoYW5nZTp2onRpbWVyLm9uPXZ9LArRF0RlbGV0ZSBBZnRlciBFeHBpcmF0aW9uOnt2YWx1ZTp0aW1lci5kZWwsb25jaGFuZ2U6dqJ0aW1lci5kZWw9dn0sCtEGSGlkZGVuOnt2YWx1ZTp0aW1lci5oaWRkZW6gtSxvbmNoYW5nZTp2onRpbWVyLmhpZGRlbj12fSwK0QdWaWJyYXRlOnJlcXVpcmUo0QlidXp6X21lbnUpLnBhdHRlcm4odGltZXIudmlicmF0ZSx2onRpbWVyLnZpYnJhdGU9diksCtEGQ2FuY2VsOigponNob3dNYWluTWVudSgpLArRB0NvbmZpcm06KCmie3ByZXBhcmVUaW1lckZvclNhdmUodGltZXIsdGltZXJJbmRleCx0aW1lKTtzYXZlQW5kUmVsb2FkKCk7c2hvd01haW5NZW51KCk7fQp9O6MoIWtleWJvYXJkKb5tZW51W9EHTWVzc2FnZV07oyghc2V0dGluZ3Muc2hvd0NvbmZpcm0pvm1lbnVb0QdDb25maXJtXTujKCFzZXR0aW5ncy5zaG93SGlkZGVuKb5tZW51W9EGSGlkZGVuXTujKCFpc05ldyl7Cm1lbnVb0QZEZWxldGVdPSgpontFLnNob3dQcm9tcHQoZ2V0TGFiZWwodGltZXIpK9EBCivRDUFyZSB5b3Ugc3VyZT8se3RpdGxlOtEMRGVsZXRlIFRpbWVyfSkudGhlbigoY29uZmlybSmie6MoY29uZmlybSl7YWxhcm1zLnNwbGljZSh0aW1lckluZGV4LDEpO3NhdmVBbmRSZWxvYWQoKTtzaG93TWFpbk1lbnUoKTt9pHt0aW1lci50aW1lcj1yZXF1aXJlKNEKdGltZV91dGlscykuZW5jb2RlVGltZSh0aW1lKTtzZXRUaW1lb3V0KHNob3dFZGl0VGltZXJNZW51LDEwLHRpbWVyLHRpbWVySW5kZXgpO319KTt9Owp9RS5zaG93TWVudShtZW51KTt9qnByZXBhcmVUaW1lckZvclNhdmUodGltZXIsdGltZXJJbmRleCx0aW1lLHRlbXApe3RpbWVyLnRpbWVyPXJlcXVpcmUo0Qp0aW1lX3V0aWxzKS5lbmNvZGVUaW1lKHRpbWUpO3RpbWVyLnQ9KHJlcXVpcmUo0Qp0aW1lX3V0aWxzKS5nZXRDdXJyZW50VGltZU1pbGxpcygpK3RpbWVyLnRpbWVyKSU4NjQwMDAwMDt0aW1lci5sYXN0PTA7oyghdGVtcCl7CqModGltZXJJbmRleIu3KXthbGFybXMucHVzaCh0aW1lcik7faR7YWxhcm1zW3RpbWVySW5kZXhdPXRpbWVyO30KfX2qc2hvd0FkdmFuY2VkTWVudSgpe0Uuc2hvd01lbnUoeyIiOnvRBXRpdGxlOtEIQWR2YW5jZWR9LNEGPCBCYWNrOigponNob3dNYWluTWVudSgpLNESU2NoZWR1bGVyIFNldHRpbmdzOigpomV2YWwocmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWQo0RFzY2hlZC5zZXR0aW5ncy5qcykpKCgponNob3dBZHZhbmNlZE1lbnUoKSks0QpFbmFibGUgQWxsOigpomVuYWJsZUFsbCi0KSzRC0Rpc2FibGUgQWxsOigpomVuYWJsZUFsbCi1KSzRCkRlbGV0ZSBBbGw6KCmiZGVsZXRlQWxsKCl9KTt9qmVuYWJsZUFsbChvbil7oyhhbGFybXMuZmlsdGVyKGWiZS5vboohb24pLmxlbmd0aIowKXsKRS5zaG93QWxlcnQob24/0RFOb3RoaW5nIHRvIEVuYWJsZTrREk5vdGhpbmcgdG8gRGlzYWJsZSxvbj/RCkVuYWJsZSBBbGw60QtEaXNhYmxlIEFsbCkudGhlbigoKaJzaG93QWR2YW5jZWRNZW51KCkpOwp9pHsKRS5zaG93UHJvbXB0KNENQXJlIHlvdSBzdXJlPyx7dGl0bGU6b24/0QpFbmFibGUgQWxsOtELRGlzYWJsZSBBbGx9KS50aGVuKChjb25maXJtKaJ7oyhjb25maXJtKXthbGFybXMuZm9yRWFjaCgoYWxhcm0saSmie2FsYXJtLm9uPW9uO6Mob24pe6MoYWxhcm0udGltZXIpe3ByZXBhcmVUaW1lckZvclNhdmUoYWxhcm0saSxyZXF1aXJlKNEKdGltZV91dGlscykuZGVjb2RlVGltZShhbGFybS50aW1lcikpO32ke3ByZXBhcmVBbGFybUZvclNhdmUoYWxhcm0saSxyZXF1aXJlKNEKdGltZV91dGlscykuZGVjb2RlVGltZShhbGFybS50KSk7fX19KTtzYXZlQW5kUmVsb2FkKCk7c2hvd01haW5NZW51KCk7faR7c2hvd0FkdmFuY2VkTWVudSgpO319KTsKfX2qZGVsZXRlQWxsKCl7oyhhbGFybXMubGVuZ3RoijApewpFLnNob3dBbGVydCjREU5vdGhpbmcgdG8gZGVsZXRlLNEKRGVsZXRlIEFsbCkudGhlbigoKaJzaG93QWR2YW5jZWRNZW51KCkpOwp9pHsKRS5zaG93UHJvbXB0KNENQXJlIHlvdSBzdXJlPyx7dGl0bGU60QpEZWxldGUgQWxsfSkudGhlbigoY29uZmlybSmie6MoY29uZmlybSl7YWxhcm1zPVtdO3NhdmVBbmRSZWxvYWQoKTtzaG93TWFpbk1lbnUoKTt9pHtzaG93QWR2YW5jZWRNZW51KCk7fX0pOwp9fXNob3dNYWluTWVudSgpO4QEAABhbGFybS5pbWc=");
  base64DecodeToExistingUint8Array(bufferView, 111104, "MDCEBmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmERFmZmZmZmZmZmZmZmZmZmYRERFmZmZmERFmZmZmERERZmZmZmZmZhERERERZmZmERFmZmYREREREWZmZmZmYREREREWZmbMzMzMZmZhERERERZmZmZmERERERFmzMzMzMzMzMxmERERERFmZmZhERERERbMzMzMzMzMzMzMYREREREWZmZhERERERzMzMzMzMzMzMzMwREREREWZmYRERERFMzMzEQz//8zRMzMzEERERERZmYRERERTMzMQ////////zTMzMQRERERZmYREREUzMzD//////////88zMxBERERZmYRERFMzMQ/////8A/////zTMzEERERZmYRERHMzE//////8A//////9MzMERERZmYREWzMxP//////8A///////0zMxhERZmZhFszMw///////8A///////zzMzGEWZmZhZszMP///////8A////////PMzGYWZmZmbMzE////////8A////////9MzMZmZmZmbMzD////////8A////////88zMZmZmZmbMxP////////8A/////////0zMZmZmZmbMxP////////8A/////////0zMZmZmZmzMw/////////8A/////////zzMxmZmZmzMw/////////8A/////////zzMxmZmZmzMz/////////MAP/////////zMxmZmZmzMz/////////BVD/////////zMxmZmZmzMz/////////BVA/////////zMxmZmZmzMz////////zQAAD////////zMxmZmZmzMw///////80PzAAP//////zzMxmZmZmzMw///////ND//MAA//////zzMxmZmZmbMxP/////zQ///8wAD/////0zMZmZmZmbMxP////80P////zAAP////0zMZmZmZmbMzD////ND//////MC////88zMZmZmZmbMzE///zQ///////8/////9MzMZmZmZmZszMP/80P/////////////PMzGZmZmZmZszMw//z/////////////zzMzGZmZmZmZmzMxP///////////////0zMxmZmZmZmZmbMzE//////////////9MzMZmZmZmZmZmbMzMQ////////////zTMzMZmZmZmZmZmZszMzD//////////88zMzGZmZmZmZmZmZmzMzMQ////////zTMzMxmZmZmZmZmZmZmFMzMzEQz//8zRMzMzEFmZmZmZmZmZmZhERzMzMzMzMzMzMzMwREWZmZmZmZmZmYRERbMzMzMzMzMzMzMYRERZmZmZmZmZmEREWZmzMzMzMzMzMxmZhERFmZmZmZmZmERFmZmZmbMzMzMZmZmZmERFmZmZmZmZmERZmZmZmZmZmZmZmZmZmYRFmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZhcEAABhbGFybS5zZXR0aW5ncy5qcw==");
  base64DecodeToExistingUint8Array(bufferView, 112292, "KKooYmFjayl7rXNldHRpbmdzPU9iamVjdC5hc3NpZ24oe3Nob3dDb25maXJtOrQsc2hvd0F1dG9Tbm9vemU6tCxzaG93SGlkZGVuOrR9LHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRCmFsYXJtLmpzb24sMSmge30pO65zYXZlPSgponJlcXVpcmUo0QdTdG9yYWdlKS53cml0ZSjRCmFsYXJtLmpzb24sc2V0dGluZ3MpO65EQVRFX0ZPUk1BVFM9W9EHZGVmYXVsdCzRBG1tZGRdO65EQVRFX0ZPUk1BVFNfTEFCRUxTPVvRB0RlZmF1bHQs0QRNTUREXTuuYXBwTWVudT17Jyc6e3RpdGxlOtEFYWxhcm19LNEGPCBCYWNrOmJhY2ss0RBNZW51IERhdGUgRm9ybWF0Ont2YWx1ZTpEQVRFX0ZPUk1BVFMuaW5kZXhPZihzZXR0aW5ncy5tZW51RGF0ZUZvcm1hdKDRB2RlZmF1bHQpLGZvcm1hdDp2okRBVEVfRk9STUFUU19MQUJFTFNbdl0sbWluOjAsbWF4OkRBVEVfRk9STUFUUy5sZW5ndGgtMSxvbmNoYW5nZTp2onujKHY+MCl7c2V0dGluZ3MubWVudURhdGVGb3JtYXQ9REFURV9GT1JNQVRTW3ZdO32ke75zZXR0aW5ncy5tZW51RGF0ZUZvcm1hdDt9c2F2ZSgpO319LNEVU2hvdyBNZW51IEF1dG8gU25vb3plOnt2YWx1ZTohIXNldHRpbmdzLnNob3dBdXRvU25vb3plLG9uY2hhbmdlOnaie3NldHRpbmdzLnNob3dBdXRvU25vb3plPXY7c2F2ZSgpO319LNERU2hvdyBNZW51IENvbmZpcm06e3ZhbHVlOiEhc2V0dGluZ3Muc2hvd0NvbmZpcm0sb25jaGFuZ2U6dqJ7c2V0dGluZ3Muc2hvd0NvbmZpcm09djtzYXZlKCk7fX0s0RBTaG93IE1lbnUgSGlkZGVuOnt2YWx1ZTohIXNldHRpbmdzLnNob3dIaWRkZW4sb25jaGFuZ2U6dqJ7c2V0dGluZ3Muc2hvd0hpZGRlbj12O3NhdmUoKTt9fSzRD1Nob3cgTWVudSBHcm91cDp7dmFsdWU6ISFzZXR0aW5ncy5zaG93R3JvdXAsb25jaGFuZ2U6dqJ7c2V0dGluZ3Muc2hvd0dyb3VwPXY7c2F2ZSgpO319LNESU2hvdyBUZXh0IE92ZXJmbG93Ont2YWx1ZTohIXNldHRpbmdzLnNob3dPdmVyZmxvdyxvbmNoYW5nZTp2ontzZXR0aW5ncy5zaG93T3ZlcmZsb3c9djtzYXZlKCk7fX0sfTtFLnNob3dNZW51KGFwcE1lbnUpO30p/8YAAABhbGFybS5pbmZv");
  base64DecodeToExistingUint8Array(bufferView, 113372, "eyJpZCI6ImFsYXJtIiwibmFtZSI6IkFsYXJtcyIsInNyYyI6ImFsYXJtLmFwcC5qcyIsImljb24iOiJhbGFybS5pbWciLCJ2ZXJzaW9uIjoiMC41MCIsInRhZ3MiOiJ0b29sLGFsYXJtIiwiZmlsZXMiOiJhbGFybS5pbmZvLGFsYXJtLmFwcC5qcyxhbGFybS5pbWcsYWxhcm0uc2V0dGluZ3MuanMiLCJkYXRhIjoiYWxhcm0uc2V0dGluZ3MuanNvbiJ9//8=");
  base64DecodeToExistingUint8Array(bufferView, 113593, "AQEBAQE=");
  base64DecodeToExistingUint8Array(bufferView, 113616, "AQYEAAILCQQAAAwHAAgDAQMDAwMDAwMDAwMAAA8QEQUAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAANAgQCAgICAgICAgICAgICAgICAgICAgICAgICAgAKDv8AdmFyIHA9MDtyZXR1cm57cmVhZDpmdW5jdGlvbihsKXtyZXR1cm4gcy5zdWJzdHJpbmcocCxwKz1sKXx8dW5kZWZpbmVkO319AKt7X3Y6ITEscmVhZDqqKCl7q68uX3Z9LHNldDqqKCl7ry53cml0ZSgxKX0scmVzZXQ6qigpe68ud3JpdGUoMCl9LHdyaXRlOqooYSl7Zy5zZXRDb2xvcigory5fdj0hIWEpP9EEI2YwMDpnLnRoZW1lLmJnKS5maWxsQ2lyY2xlKChnLmdldFdpZHRoKCktMjApLzIsNSw1KTtCYW5nbGUuc2V0TENEUG93ZXIoMSl9LHRvZ2dsZTqqKCl7ry53cml0ZSghry5fdil9fQCre192OiExLHJlYWQ6qigpe6uvLl92fSxzZXQ6qigpe68ud3JpdGUoMSl9LHJlc2V0OqooKXuvLndyaXRlKDApfSx3cml0ZTqqKGEpe2cuc2V0Q29sb3IoKK8uX3Y9ISFhKT/RBCMwZjA6Zy50aGVtZS5iZykuZmlsbENpcmNsZSgoZy5nZXRXaWR0aCgpKzIwKS8yLDUsNSk7QmFuZ2xlLnNldExDRFBvd2VyKDEpfSx0b2dnbGU6qigpe68ud3JpdGUoIa8uX3YpfX0AoyhnbG9iYWwuV0lER0VUUyl7rGQ9Zy5nZXRXaWR0aCgpLGU9Zy5nZXRIZWlnaHQoKSxjPXt0bDp7eDowLHk6MCxyOjAsYzowfSx0cjp7eDpkLTEseTowLHI6MSxjOjB9LGJsOnt4OjAseTplLTI0LHI6MCxjOjB9LGJyOnt4OmQtMSx5OmUtMjQscjoxLGM6MH19LGIsYTunKGHGV0lER0VUUykoYj1jW2EuYXJlYV0pnjCMYS53aWR0aJ4oYS54PWIueC1iLnIqYS53aWR0aCxhLnk9Yi55LGIueJZhLndpZHRoKigxLTIqYi5yKSxiLmOYKTtnLnJlc2V0KCk7KGMudGwuY6BjLnRyLmMpnmcuY2xlYXJSZWN0KDAsMCxkLTEsMjMpOyhjLmJsLmOgYy5ici5jKZ5nLmNsZWFyUmVjdCgwLGUtMjQsZC0xLGUtMSk7sXunKGHGV0lER0VUUylhLmRyYXcoYSl9Y2F0Y2goZil7cHJpbnQoZil9fQB7fQB7JXN9AKplKGEsYil7wDCLYp4oYj0xKTurYS50b0ZpeGVkKE1hdGgubWluKGIsYi1NYXRoLmZsb29yKE1hdGgubG9nKGEpL01hdGgubG9nKDEwKSkpKX2qZigpe8Awi2eeKGc9KHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkSlNPTijRDHNldHRpbmcuanNvbiwxKaB7fSlb0QYxMmhvdXJdKTurZ32sZztleHBvcnRzPXtuYW1lOtEGc3lzdGVtLGN1cnJlbmN5U3ltOtEBoyx0cmFuc2xhdGU6YaJhLGRhdGU6KGEsYimiYj8o0QEwK2EuZ2V0RGF0ZSgpKS5zdWJzdHIoLTIpK9EBLyso0QEwKyhhLmdldE1vbnRoKCkrMSkpLnN1YnN0cigtMikr0QEvK2EuZ2V0RnVsbFllYXIoKTphLnRvU3RyaW5nKCkuc3Vic3RyKDQsMTEpLnRyaW0oKSx0aW1lOihhLGIponusYz1hLmdldEhvdXJzKCksZD1hLmdldE1pbnV0ZXMoKTtmKCmeKGM9MIpjJTEyPzEyOmMlMTIpO6so0QEgK2MpLnN1YnN0cigtMikr0QE6KyjRATArZCkuc3Vic3RyKC0yKSsoYj8iIjrRAS4rKNEBMCthLmdldFNlY29uZHMoKSkuc3Vic3RyKC0yKSl9LGRvdzooYSxiKaLROFN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5LnNwbGl0KNEBIClbYS5nZXREYXkoKV0uc3Vic3RyKDAsYj8zOjEwKSxtb250aDooYSxiKaLRVUphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXIuc3BsaXQo0QEgKVthLmdldE1vbnRoKCldLnN1YnN0cigwLGI/MzoxMCksbnVtYmVyOihhLGIponu2imKeKGI9Mik7rGM9YS50b0ZpeGVkKGIpLGQ9Y3wwO2E9MD5hPzE6MDtiPSgiIitNYXRoLmFicyhjLWQpLnRvRml4ZWQoYikpLnN1YnN0cigyLGIpO2Q9IiIrZDtjPWQubGVuZ3RoO6corGg9IiI7KGOXMyk+YTspaD3RASwrZC5zdWJzdHIoYywzKStoO6tkLnN1YnN0cigwLGMrMykraCsoYj/RAS4rYjoiIil9LGN1cnJlbmN5OmGie2NvbnNvbGUubG9nKNErV2FybmluZzogQ3VycmVuY3kgaW5mb3JtYXRpb24gaXMgZGVwcmVjYXRlZCk7q9EBoythLnRvRml4ZWQoMil9LGRpc3RhbmNlOihhLGIpojFFMz5hP2UoYSxiKSvRAW06ZShhLzFFMyxiKSvRAmttLHNwZWVkOihhLGIpomUoYS8xLjYwOTM0LGIpK9EDbXBoLHRlbXA6KGEsYimiZShhLGIpK9ECJ0MsbWVyaWRpYW46KGEsYimiYqBmKCk/MTKRYS5nZXRIb3VycygpP9ECYW060QJwbToiIixpczEySG91cnM6Zn0AoyghZ2xvYmFsLldJREdFVFMpe2dsb2JhbC5XSURHRVRTPXt9O3JlcXVpcmUo0QdTdG9yYWdlKS5saXN0KC8ud2lkLmpzJC8pLmZvckVhY2goYaJ7sXtldmFsKHJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkKGEpKX1jYXRjaChjKXtwcmludChhLGMpfX0pO6xiPVdJREdFVFM7V0lER0VUUz17fTtPYmplY3Qua2V5cyhiKS5zb3J0KChhLGMpoigwfGJbY10uc29ydG9yZGVyKS0oMHxiW2FdLnNvcnRvcmRlcikpLmZvckVhY2goYaJXSURHRVRTW2FdPWJbYV0pfQB7IFtuYXRpdmUgY29kZV0gfQAKfQAvLVx8AHsAdHoARnJlcXVlbmN5IG11c3QgYmUgYWJvdmUgMC4wMDFIegAjb25wYXJpdHkALUluZmluaXR5AGhpc3RvcnkATm90IGVub3VnaCBtZW1vcnkATWF4aW11bSBudW1iZXIgb2YgcG9pbnRzICglZCkgZXhjZWVkZWQgZm9yIGZpbGxQb2x5AEFTQ0lJIG9ubHkAaW5hbGx5AGR5AFRoaXJkIGFyZ3VtZW50IHNob3VsZCBiZSBhIGZ1bmN0aW9uIG9yIGFycmF5AFVpbnQ4Q2xhbXBlZEFycmF5AFVpbnQ4QXJyYXkASW50OEFycmF5AFVpbnQxNkFycmF5AEludDE2QXJyYXkARmxvYXQ2NEFycmF5AFVpbnQyNEFycmF5AFVpbnQzMkFycmF5AEludDMyQXJyYXkARmxvYXQzMkFycmF5AGRheQB0eAByeABsb3dSZXNpc3RhbmNlRml4AP9nZngAaW50ZXJsZWF2ZXgAaW5kZXgAbGFzdEluZGV4AGFjY0hpc3RvcnlJZHgAVW5maW5pc2hlZCBjaGFyYWN0ZXIgc2V0IGluIFJlZ0V4AFVua25vd24gZXJyb3I6IC0weCV4AGhyb3cAdGVuc29yZmxvdwBUb28gbXVjaCByZWN1cnNpb24gLSB0aGUgc3RhY2sgaXMgYWJvdXQgdG8gb3ZlcmZsb3cAVW5hYmxlIHRvIGFsbG9jYXRlIGVub3VnaCBSQU0gZm9yIFRlbnNvckZsb3cAc3RlcENvdW50ZXJUaHJlc2hvbGRMb3cAQXJyYXlCdWZmZXJWaWV3LnN1YmFycmF5IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhbiBBcnJheUJ1ZmZlclZpZXcAQ2FuIG9ubHkgYmUgY2FsbGVkIG9uIGFuIEFycmF5QnVmZmVyVmlldwBEYXRhVmlldwAjb25IUk0tZW52AFx2AHNldEZvbnQldgAjb24ldgAldi4ldgBkYXRhOmltYWdlL2JtcDtiYXNlNjQsJXYAZnVuY3Rpb24gJXYAVW5rbm93biBXYXRjaCAldgAldjogJXYAVW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uOiAldgBGYWlsZWQgdG8gYWxsb2NhdGUgdGVtcCBtZW1vcnkuIFJlcXVlc3RlZDogJXUsIGF2YWlsYWJsZSAldSwgbWlzc2luZzogJXUARmFpbGVkIHRvIGFsbG9jYXRlIHRhaWwgbWVtb3J5LiBSZXF1ZXN0ZWQ6ICV1LCBhdmFpbGFibGUgJXUsIG1pc3Npbmc6ICV1AEZhaWxlZCB0byBhZGp1c3QgaGVhZCBzaXplLiBSZXF1ZXN0ZWQ6ICV1LCBhdmFpbGFibGUgJXUsIG1pc3Npbmc6ICV1AG5leHQAYWZfb3V0cHV0AGlucHV0AFVuZXhwZWN0ZWQgZW5kIG9mIElucHV0AEZsYXNoLFN0b3JhZ2UsaGVhdHNocmluayxjcnlwdG8sdGVuc29yZmxvdyxsb2NhbGUsTGF5b3V0AHRpbWVvdXQAdHdpc3RUaW1lb3V0AGJhY2tsaWdodFRpbWVvdXQAbGNkUG93ZXJUaW1lb3V0AGxvY2tUaW1lb3V0AGJ0bkxvYWRUaW1lb3V0AC5ib290cnN0AG9uc3QAI29udHdpc3QAd2FrZU9uVHdpc3QAZHN0AGxhc3QAcG9ydABleGNlcHQAY291bnQAdHJhc2hDb3VudABnZXN0dXJlSW5hY3RpdmVDb3VudABhY2NHZXN0dXJlQ291bnQAZmlsZUNvdW50AGFjY0lkbGVDb3VudABpbWFnZUNvdW50AGZyb250AHNldEZvbnQAYWZmaW5lX3F1YW50aXphdGlvbi0+emVyb19wb2ludABvdXRwdXQtPnBhcmFtcy56ZXJvX3BvaW50AHRyYW5zcGFyZW50AEV4cGVjdGVkIGVpdGhlciBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgd2l0aCA2IGVudHJpZXMgZm9yIHNlY29uZCBhcmd1bWVudABtb3ZlbWVudABBc3NpZ25tZW50IHRvIGEgY29uc3RhbnQATm90IGVub3VnaCBtZW1vcnkgZm9yIHJlc3VsdABlZmF1bHQAI29uaW5pdABvbkluaXQAZHJhaW5XYWl0AHJpZ2h0ACNvbm1pZG5pZ2h0ACNvbmJhY2tsaWdodABMQ0RfYmFja2xpZ2h0AGhlaWdodABtYXhJbWFnZUhlaWdodABzb2Z0AGZvcmNlU29mdABsZWZ0AHByb3BlcnRpZXNPYmplY3QgaXMgbm90IHN1cHBvcnRlZCB5ZXQAU29mdHdhcmUgU2VyaWFsIENLIG5vdCBpbXBsZW1lbnRlZCB5ZXQAb2Zmc2V0AGJ5dGVPZmZzZXQAI29ucGFja2V0AGdldABvYmplY3QAT2JqZWN0AGZpbGxSZWN0AGlGaWxsUmVjdABmbG9hdABGbGF0AHJlcGVhdAD/Y2F0AFx0AEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgQXJyYXksIG5vdCAldABFeHBlY3Rpbmcgb3B0aW9ucyB0byBiZSB1bmRlZmluZWQgb3IgYW4gT2JqZWN0LCBub3QgJXQARk9SIGxvb3AgY2FuIG9ubHkgaXRlcmF0ZSBvdmVyIEFycmF5cywgU3RyaW5ncyBvciBPYmplY3RzLCBub3QgJXQAZm9yKGEgJXMgYikgLSAnYScgbXVzdCBiZSBhIHZhcmlhYmxlIG5hbWUsIG5vdCAldABGaXJzdCBhcmd1bWVudCBtdXN0IGl0ZXJhYmxlLCBub3QgJXQARXhwZWN0aW5nIENhbGxiYWNrIEZ1bmN0aW9uIG9yIGFuIE9iamVjdCBidXQgZ290ICV0AEV4cGVjdGluZyBOdW1iZXIgb3IgQXJyYXksIGdvdCAldABGaXJzdCBhcmd1bWVudCBtdXN0IGJlIE9iamVjdCwgRnVuY3Rpb24gb3IgQXJyYXksIGdvdCAldABFeHBlY3RpbmcgU3RyaW5nIG9yIEFycmF5LCBnb3QgJXQARXhwZWN0aW5nIFN0cmluZyBhcyBmaXJzdCBhcmd1bWVudCwgZ290ICV0AFByb3RvdHlwZSBzaG91bGQgYmUgYW4gb2JqZWN0LCBnb3QgJXQARXhwZWN0aW5nIE9iamVjdCwgZ290ICV0AEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgT2JqZWN0LCBnb3QgJXQAU2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgT2JqZWN0LCBnb3QgJXQAUHJvcGVydHkgZGVzY3JpcHRpb24gbXVzdCBiZSBPYmplY3QsIGdvdCAldABBZGRyZXNzIHNob3VsZCBiZSBhbiBpbnRlZ2VyLCBnb3QgJXQARXhwZWN0aW5nIEFycmF5QnVmZmVyLCBnb3QgJXQAJ2J1ZmZlcicgc2hvdWxkIGJlIEFycmF5QnVmZmVyLCBnb3QgJXQARnVuY3Rpb24uYmluZCBleHBlY3RzIHRvIGJlIGNhbGxlZCBvbiBmdW5jdGlvbiwgZ290ICV0AEV4cGVjdGluZyBmdW5jdGlvbiwgZ290ICV0AEV4cGVjdGluZyBjb21wYXJlIGZ1bmN0aW9uLCBnb3QgJXQAJ2V4dGVuZHMnIGFyZ3VtZW50ICVxIHNob3VsZCBiZSBhIGZ1bmN0aW9uLCBnb3QgJXQARXhwZWN0aW5nIG1vZHVsZSBuYW1lIGFzIGEgc3RyaW5nLCBnb3QgJXQARXhwZWN0aW5nIFN0cmluZywgZ290ICV0AEV4cGVjdGluZyBOdW1iZXIgb3IgaXRlcmFibGUsIGdvdCAldABFeHBlY3Rpbmcgc29tZXRoaW5nIGl0ZXJhYmxlLCBnb3QgJXQAU2Vjb25kIGFyZ3VtZW50IHRvIEZ1bmN0aW9uLmFwcGx5IG11c3QgYmUgaXRlcmFibGUsIGdvdCAldABFeHBlY3RpbmcgT2JqZWN0IG9yIHVuZGVmaW5lZCwgZ290ICV0AEV4cGVjdGluZyBmdW5jdGlvbiBvbiBSSFMsIGdvdCAldABDb25zdHJ1Y3RvciBzaG91bGQgYmUgYSBmdW5jdGlvbiwgYnV0IGlzICV0AEZpZWxkIG9yIG1ldGhvZCAlcSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LCBhbmQgY2FuJ3QgY3JlYXRlIGl0IG9uICV0AFVuc3VwcG9ydGVkIGZpcnN0IGFyZ3VtZW50IG9mIHR5cGUgJXQAVW5hYmxlIHRvIGFzc2lnbiB2YWx1ZSB0byBub24tcmVmZXJlbmNlICV0AENhbid0IGV4dGVuZCAldABFeHBlY3RpbmcgZmlyc3QgMiBhcmd1bWVudHMgdG8gYmUgaXRlcmFibGUsIG5vdCAldCBhbmQgJXQARXhwZWN0aW5nIGZpcnN0IDIgYXJndW1lbnRzIHRvIGJlIGl0ZXJhYmxlIG9yIHVuZGVmaW5lZCwgbm90ICV0IGFuZCAldABDYW4ndCB1c2UgJ2luJyBvcGVyYXRvciB0byBzZWFyY2ggYSAldABPYmplY3QgcHJvdG90eXBlIG1heSBvbmx5IGJlIGFuIE9iamVjdCBvciBudWxsOiAldABleHBvcnRzAEUuc3RvcEV2ZW50UHJvcGFnYXRpb24oKSBjYWxsZWQgd2hlbiBub3QgaGFuZGxpbmcgZXZlbnRzAEluc3VmZmljaWVudCBzdGFjayBmb3IgdGhpcyBtYW55IGFyZ3VtZW50cwBVbmV4cGVjdGVkIGFyZ3VtZW50cwBudW1fb3V0cHV0X2VsZW1lbnRzAG51bV9pbnB1dF9lbGVtZW50cwBQYWxldHRlIHNwZWNpZmllZCwgYnV0IG11c3QgYmUgYSBmbGF0IFVpbnQxNkFycmF5IG9mIDIsNCw4LDE2LDI1NiBlbGVtZW50cwBzdG9wYml0cwBJbnZhbGlkIG51bWJlciBvZiBiaXRzAGN0cwBhZGRyZXNzAHByb2Nlc3MAY29tcGFzcwBDYWxsaW5nICdzdXBlcicgb3V0c2lkZSBvZiBjbGFzcwBlcnJvcnMAY29sb3Jfb3JkZXIgbXVzdCBiZSAzIGNoYXJhY3RlcnMAdGltZXJzAEZpcnN0IDIgYXJndW1lbnRzIHNob3VsZCBiZSBhcnJheSBidWZmZXJzAHZlcnRpY2FsX2J5dGUgb25seSB3b3JrcyBmb3IgMWJwcCBBcnJheUJ1ZmZlcnMAdW5yZW5kZXJhYmxlQ2hhcnMAc3RlcHMAX29wdGlvbnMASW52YWxpZCBvcHRpb25zAGZ1bmN0aW9ucwBDb3B5cmlnaHQgMjAyMSBHLldpbGxpYW1zAG51bV9jaGFubmVscwBqcwB0aGlzAP90aHMAYXJncwBmbGFncwBvZmZzAHRvdGFsQnl0ZXMAdHJhc2hCeXRlcwBmaWxlQnl0ZXMAZnJlZUJ5dGVzAP9yZXMAcGlwZXMAZnJhbWVzAG1vZHVsZXMARXhwZWN0aW5nIEFycmF5IGZvciBmaXJzdCBhcmd1bWVudCB3aXRoIDwlZCBlbnRyaWVzAHdhdGNoZXMAQ2FuJ3QgaGF2ZSBwYWxldHRlIG9uID44IGJpdCBpbWFnZXMAc2V0Q29uc29sZSBjYW4ndCBiZSB1c2VkIG9uICdzb2Z0JyBvciBub24tU2VyaWFsIGRldmljZXMAc2V0Q29uc29sZSBjYW4ndCBiZSB1c2VkIG9uICdzb2Z0JyBkZXZpY2VzAG5vYm91bmRzAERhdGUgb3V0IG9mIGJvdW5kcwB4dGVuZHMAR3JhcGhpY3MAQURDcwAldiVzACVxJXMAJVElcwBJRDolcwBFeHBlY3RpbmcgdmFsaWQgdmFsdWUsIGdvdCAlcwBEaWQgbm90IGZpbmQgYSBwYXJzZXIgZm9yICVzAEJvb2wgJXMAQ2FuJ3QgcmVhZCBwcm9wZXJ0eSAnJXMnIG9mICVzAEZhaWxlZCB0byByZWdpc3RlciBzY3JhdGNoIGJ1ZmZlciBoYW5kbGUgZm9yIG5vZGUgJXMAR290ICVzIGV4cGVjdGVkICVzAEkyQyBFcnJvcjogJXMAcmVjdXIAcGFyYW1zICE9IG51bGxwdHIAcGxhbm5lcl9hcmVuYSAhPSBudWxscHRyAGludHIAbGNkQnVmZmVyUHRyAHhvcgBWYXJpYWJsZXMgb2YgdHlwZSAldCBhcmUgbm90IHN1cHBvcnRlZCBpbiBkYXRlIGNvbnN0cnVjdG9yAEZ1bmN0aW9uIHJlcXVpcmVkIGluIHByb21pc2UgY29uc3RydWN0b3IAVmVjdG9yAC5vZmYgbm90IGltcGxlbWVudGVkIG9uIGVtdWxhdG9yAFVuYWJsZSB0byBnZXQgdGVuc29yAFN5bnRheEVycm9yAEludGVybmFsRXJyb3IAVHlwZUVycm9yAFJlZmVyZW5jZUVycm9yAGRpcgBiZ3IAI29ubGNkUG93ZXIAY2VudGVyAGZpbHRlcgBURk1pY3JvSW50ZXJwcmV0ZXIAdXBlcgBVbmFibGUgdG8gc2NoZWR1bGUgYSB0aW1lcgBUaW1lb3V0IG9uIFV0aWxpdHkgVGltZXIASW50ZXJydXB0ZWQgaW4gVXRpbGl0eSBUaW1lcgBlYnVnZ2VyAEZvbnQgd2lkdGggbXVzdCBiZSBhIFN0cmluZyBvciBhbiBpbnRlZ2VyAEludGVnZXIAI29uYnVmZmVyAC5idWZmZXIATW9kZWwgaXMgbm90IGEgRmxhdCBTdHJpbmcvQXJyYXlCdWZmZXIASW52YWxpZCBsZW5ndGggZm9yIEFycmF5QnVmZmVyACdzYW1wbGVzJyBzaG91bGQgYmUgYSBpbnRlZ2VyIG9yIEFycmF5QnVmZmVyAHVua25vd24gQXJyYXlCdWZmZXIAY3VycmVudEJ1ZmZlcgBkb3VibGVCdWZmZXIAY29sb3Jfb3JkZXIAU3RyaW5nIHRvbyBiaWcgdG8gY29udmVydCB0byBudW1iZXIAUHVsc2UgVGltZSBpcyBsZXNzIHRoYW4gMCBvciBub3QgYSBudW1iZXIATnVtYmVyAGFkZHIAZ2JyAEpzVmFyAFxyAGlycQBmcmVxACVxJXMlcQBJbnZhbGlkIE9uZVdpcmUgZGV2aWNlIGFkZHJlc3MgJXEAVW5rbm93biBvcHRpb24gJXEAVW5rbm93biBvcCB0eXBlICVxAFVua25vd24gZGV2aWNlIHR5cGUgJXEAVW5rbm93biByYW5nZSBuYW1lICVxAFVuYWJsZSB0byBsb2FkIG1vZHVsZSAlcQAlc1N0cmluZyBbJWQgYmxvY2tzXSAlcQBJbnZhbGlkIGZsb3cgY29udHJvbDogJXEAUmVnRXhwAGlucHV0X3B1bGx1cABvcGVuZHJhaW5fcHVsbHVwAGJwcABzdG9wAENPTlRJTlVFIHN0YXRlbWVudCBvdXRzaWRlIG9mIEZPUiBvciBXSElMRSBsb29wAEJSRUFLIHN0YXRlbWVudCBvdXRzaWRlIG9mIFNXSVRDSCwgRk9SIG9yIFdISUxFIGxvb3AAZmxpcAAjb25zdGVwAGJlZXAAI29udGFwAHNldEZvbnRCaXRtYXAAd2FrZU9uRG91YmxlVGFwACNvbmZhY2VVcAB3YWtlT25GYWNlVXAAqnAoZCxoKXuqYihlKXvRA3JhbTtlLmlknihhW2UuaWRdPWUpO2UudHlwZaAoZS50eXBlPSIiKTtlLmOeZS5jLmZvckVhY2goYil9ry5fbD2vLmw9ZDuvLm9wdGlvbnM9aKB7fTuvLmxhenk9ry5vcHRpb25zLmxhenmgITE7ry5waHlzQnRucz0xO61mO6MoMoxwcm9jZXNzLmVudi5IV1ZFUlNJT04pe68ucGh5c0J0bnM9MztmPVtdO6plKGwpe9EDcmFtO9EDYnRuimwudHlwZZ5mLnB1c2gobCk7bC5jnmwuYy5mb3JFYWNoKGUpfWUoZCk7Zi5sZW5ndGieKK8ucGh5c0J0bnM9MCyvLmJ1dHRvbnM9ZiyvLnNlbGVjdGVkQnV0dG9uPS0xKX2jKK8ub3B0aW9ucy5idG5zKaMoZD2vLm9wdGlvbnMuYnRucyyvLnBoeXNCdG5zkWQubGVuZ3RoKXuvLmI9ZDutZT1NYXRoLmZsb29yKEJhbmdsZS5hcHBSZWN0Lmgvry5waHlzQnRucyk7pygyPK8ucGh5c0J0bnOeMYpkLmxlbmd0aJ5kLnVuc2hpZnQoe2xhYmVsOiIifSk7ry5waHlzQnRucz5kLmxlbmd0aDspZC5wdXNoKHtsYWJlbDoiIn0pO68uX2wud2lkdGg9Zy5nZXRXaWR0aCgpLTg7ry5fbD17dHlwZTrRAWgsZmlsbHk6MSxjOluvLl9sLHt0eXBlOtEBdixwYWQ6MSxmaWxseToxLGM6ZC5tYXAobKIobC50eXBlPdEDdHh0LGwuZm9udD3RAzZ4OCxsLmhlaWdodD1lLGwucj0xLGwpKX1dfX2kry5fbC53aWR0aD1nLmdldFdpZHRoKCktMzIsry5fbD17dHlwZTrRAWgsYzpbry5fbCx7dHlwZTrRAXYsYzpkLm1hcChloihlLnR5cGU90QNidG4sZS5maWxseT0xLGUud2lkdGg9MzIsZS5yPTEsZSkpfV19LGaeZi5wdXNoLmFwcGx5KGYsry5fbC5jWzFdLmMpO68uc2V0VUkoKTusYT2vO2Iory5fbCk7ry51cGRhdGVOZWVkZWQ9ITB9qnQoZCxoLGIsZixhKXusZT22imQuYmdDb2w/YTpnLnRvQ29sb3IoZC5iZ0NvbCk7oyhljGGg0QN0eHSKZC50eXBloNEDYnRuimQudHlwZaDRA2ltZ4pkLnR5cGWg0QZjdXN0b22KZC50eXBlKXusbD1kLmM7vmQuYzusaz3RAUgrRS5DUkMzMihFLnRvSlMoZCkpO2yeKGQuYz1sKTu+aFtrXaAoKGZba109W2QueCxkLnksZC54K2Qudy0xLGQueStkLmgtMV0pLmJnPbaKYT9nLnRoZW1lLmJnOmEsYp4oYi5wdXNoKGQpLGI9tikpfaMoZC5jKacorGPGZC5jKXQoYyxoLGIsZixlKX1wLnByb3RvdHlwZS5zZXRVST2qKCl7QmFuZ2xlLnNldFVJKCk7rWQ7ry5idXR0b25znihCYW5nbGUuc2V0VUkoe21vZGU60QZ1cGRvd24sYmFjazqvLm9wdGlvbnMuYmFjayxyZW1vdmU6ry5vcHRpb25zLnJlbW92ZX0saKJ7rGI9ry5zZWxlY3RlZEJ1dHRvbixmPa8uYnV0dG9ucy5sZW5ndGg7oyjAMItonq8uYnV0dG9uc1tiXSmrry5idXR0b25zW2JdLmNiKCk7ry5idXR0b25zW2Jdnii+ry5idXR0b25zW2JdLnNlbGVjdGVkLK8ucmVuZGVyKK8uYnV0dG9uc1tiXSkpO2I9KGIrZitoKSVmO68uYnV0dG9uc1tiXZ4ory5idXR0b25zW2JdLnNlbGVjdGVkPTEsry5yZW5kZXIory5idXR0b25zW2JdKSk7ry5zZWxlY3RlZEJ1dHRvbj1ifSksZD0hMCk7Ia8ub3B0aW9ucy5iYWNrniGvLm9wdGlvbnMucmVtb3ZloGSgQmFuZ2xlLnNldFVJKHttb2RlOtEGY3VzdG9tLGJhY2s6ry5vcHRpb25zLmJhY2sscmVtb3ZlOq8ub3B0aW9ucy5yZW1vdmV9KTujKK8uYil7qmgoYixmKXsuNzU8Zi50aW1lLWYubGFzdFRpbWWery5iW2JdLmNibD+vLmJbYl0uY2JsKGYpOq8uYltiXS5jYp6vLmJbYl0uY2IoZil9QmFuZ2xlLmJ0bldhdGNoZXOeQmFuZ2xlLmJ0bldhdGNoZXMuZm9yRWFjaChjbGVhcldhdGNoKTtCYW5nbGUuYnRuV2F0Y2hlcz1bXTuvLmJbMF2eQmFuZ2xlLmJ0bldhdGNoZXMucHVzaChzZXRXYXRjaChoLmJpbmQorywwKSxCVE4xLHtyZXBlYXQ6ITAsZWRnZTotMX0pKTuvLmJbMV2eQmFuZ2xlLmJ0bldhdGNoZXMucHVzaChzZXRXYXRjaChoLmJpbmQorywxKSxCVE4yLHtyZXBlYXQ6ITAsZWRnZTotMX0pKTuvLmJbMl2eQmFuZ2xlLmJ0bldhdGNoZXMucHVzaChzZXRXYXRjaChoLmJpbmQorywyKSxCVE4zLHtyZXBlYXQ6ITAsZWRnZTotMX0pKX2jKDKKcHJvY2Vzcy5lbnYuSFdWRVJTSU9OKXuqaChiLGYpe2IuY2KeZi54kWIueJ5mLnmRYi55nmYueI5iLngrYi53nmYueY5iLnkrYi5onigyimYudHlwZZ5iLmNibD9iLmNibChmKTpiLmNinmIuY2IoZikpO2IuY55iLmMuZm9yRWFjaChhomgoYSxmKSl9QmFuZ2xlLnRvdWNoSGFuZGxlcj0oYixmKaJoKK8uX2wsZik7QmFuZ2xlLm9uKNEFdG91Y2gsQmFuZ2xlLnRvdWNoSGFuZGxlcil9fTtwLnByb3RvdHlwZS5yZW5kZXI9qihkKXuqaChjKXvRA3JhbTtiLnJlc2V0KCk7wDCNYy5jb2yeYi5zZXRDb2xvcihjLmNvbCk7wDCNYy5iZ0NvbJ5iLnNldEJnQ29sb3IoYy5iZ0NvbCkuY2xlYXJSZWN0KGMueCxjLnksYy54K2Mudy0xLGMueStjLmgtMSk7ZltjLnR5cGVdKGMpfWSgKGQ9ry5fbCk7ry51cGRhdGVOZWVkZWSery51cGRhdGUoKTusYj1nLGY9eyIiOqooKXt9LHR4dDqqKGMpe9EDcmFtO6MoYy53cmFwKXusbT1iLnNldEZvbnQoYy5mb250KS5zZXRGb250QWxpZ24oMCwtMSkud3JhcFN0cmluZyhjLmxhYmVsLGMudyksbj1jLnkrKGMuaC1iLmdldEZvbnRIZWlnaHQoKSptLmxlbmd0aJIxKTtiLmRyYXdTdHJpbmcobS5qb2luKNEBCiksYy54KyhjLneSMSksbil9pGIuc2V0Rm9udChjLmZvbnQpLnNldEZvbnRBbGlnbigwLDAsYy5yKS5kcmF3U3RyaW5nKGMubGFiZWwsYy54KyhjLneSMSksYy55KyhjLmiSMSkpfSxidG46qihjKXvRA3JhbTusbT1jLngrKDB8Yy5wYWQpLG49Yy55KygwfGMucGFkKSxxPWMudy0oYy5wYWSPMSkscj1jLmgtKGMucGFkjzEpO209W20sbis0LG0rNCxuLG0rcS01LG4sbStxLTEsbis0LG0rcS0xLG4rci01LG0rcS01LG4rci0xLG0rNCxuK3ItMSxtLG4rci01LG0sbis0XTtuPcAwjWMuYnRuQm9yZGVyQ29sP2MuYnRuQm9yZGVyQ29sOmIudGhlbWUuZmcyO3E9wDCNYy5idG5GYWNlQ29sP2MuYnRuRmFjZUNvbDpiLnRoZW1lLmJnMjtjLnNlbGVjdGVknihxPWIudGhlbWUuYmdILG49Yi50aGVtZS5mZ0gpO2Iuc2V0Q29sb3IocSkuZmlsbFBvbHkobSkuc2V0Q29sb3IobikuZHJhd1BvbHkobSk7wDCNYy5jb2yeYi5zZXRDb2xvcihjLmNvbCk7Yy5zcmM/Yi5zZXRCZ0NvbG9yKHEpLmRyYXdJbWFnZSjRCGZ1bmN0aW9uir9jLnNyYz9jLnNyYygpOmMuc3JjLGMueCtjLncvMixjLnkrYy5oLzIse3NjYWxlOmMuc2NhbGWgwDAscm90YXRlOi41Kk1hdGguUEkqKGMucqAwKX0pOmIuc2V0Rm9udChjLmZvbnSg0QU2eDg6Mikuc2V0Rm9udEFsaWduKDAsMCxjLnIpLmRyYXdTdHJpbmcoYy5sYWJlbCxjLngrYy53LzIsYy55K2MuaC8yKX0saW1nOqooYyl70QNyYW07Yi5kcmF3SW1hZ2Uo0QhmdW5jdGlvboq/Yy5zcmM/Yy5zcmMoKTpjLnNyYyxjLngrYy53LzIsYy55K2MuaC8yLHtzY2FsZTpjLnNjYWxloMAwLHJvdGF0ZTouNSpNYXRoLlBJKihjLnKgMCl9KX0sY3VzdG9tOqooYyl70QNyYW07Yy5yZW5kZXIoYyl9LGg6qihjKXvRA3JhbTtjLmMuZm9yRWFjaChoKX0sdjqqKGMpe9EDcmFtO2MuYy5mb3JFYWNoKGgpfX07oyivLmxhenkpe68ucmVjdHOgKK8ucmVjdHM9e30pO6xhPa8ucmVjdHMuY2xvbmUoKSxlPVtdO3QoZCxhLGUsry5yZWN0cyy2KTunKKxsuWEpvq8ucmVjdHNbbF07ZD1PYmplY3Qua2V5cyhhKS5tYXAoY6JhW2NdKS5yZXZlcnNlKCk7pyisa8ZkKWIuc2V0QmdDb2xvcihrLmJnKS5jbGVhclJlY3QuYXBwbHkoZyxrKTtlLmZvckVhY2goaCl9pGgoZCl9O3AucHJvdG90eXBlLmZvcmdldExhenlTdGF0ZT2qKCl7ry5yZWN0cz17fX07cC5wcm90b3R5cGUubGF5b3V0PaooZCl7rGg9e2g6qihiKXvRA3JhbTusZj1iLngrKDB8Yi5wYWQpLGE9MCxlPWIuY55iLmMucmVkdWNlKChrLGMpomsrKDB8Yy5maWxseCksMCk7ZaAoZpZiLnctYi5fd5IxLGU9MSk7rGw9ZjtiLmMuZm9yRWFjaChrontrLng9MHxsO2aWay5fdzthljB8ay5maWxseDtsPWYrTWF0aC5mbG9vcihhKihiLnctYi5fdykvZSk7ay53PTB8bC1rLng7ay5oPTB8KGsuZmlsbHk/Yi5oLShiLnBhZI8xKTprLl9oKTtrLnk9MHxiLnkrKDB8Yi5wYWQpKygoMSsoMHxrLnZhbGlnbikpKihiLmgtKGIucGFkjzEpLWsuaCmSMSk7oyhrLmMpaFtrLnR5cGVdKGspfSl9LHY6qihiKXvRA3JhbTusZj1iLnkrKDB8Yi5wYWQpLGE9MCxlPWIuY55iLmMucmVkdWNlKChrLGMpomsrKDB8Yy5maWxseSksMCk7ZaAoZpZiLmgtYi5faJIxLGU9MSk7rGw9ZjtiLmMuZm9yRWFjaChrontrLnk9MHxsO2aWay5faDthljB8ay5maWxseTtsPWYrTWF0aC5mbG9vcihhKihiLmgtYi5faCkvZSk7ay5oPTB8bC1rLnk7ay53PTB8KGsuZmlsbHg/Yi53LShiLnBhZI8xKTprLl93KTtrLng9MHxiLngrKDB8Yi5wYWQpKygoMSsoMHxrLmhhbGlnbikpKihiLnctKGIucGFkjzEpLWsudymSMSk7oyhrLmMpaFtrLnR5cGVdKGspfSl9fTujKGhbZC50eXBlXSloW2QudHlwZV0oZCl9O3AucHJvdG90eXBlLmRlYnVnPQqqKGQsaCl7ZKAoZD2vLl9sKTtoPWigMTtnLnNldENvbG9yKGgmMSxoJjIsaCY0KS5kcmF3UmVjdChkLngraC0xLGQueStoLTEsZC54K2Qudy1oLGQueStkLmgtaCk7ZC5wYWSeZy5kcmF3UmVjdChkLngrZC5wYWQtMSxkLnkrZC5wYWQtMSxkLngrZC53LWQucGFkLGQueStkLmgtZC5wYWQpO2iYO2QuY55kLmMuZm9yRWFjaChioq8uZGVidWcoYixoKSl9O3AucHJvdG90eXBlLnVwZGF0ZT2qKCl7qmQoYSl70QNyYW07YlthLnR5cGVdKGEpO6MoYS5yJjEpe6xlPWEuX3c7YS5fdz1hLl9oO2EuX2g9ZX1hLl93PU1hdGgubWF4KGEuX3crKGEucGFkjzEpLDB8YS53aWR0aCk7YS5faD1NYXRoLm1heChhLl9oKyhhLnBhZI8xKSwwfGEuaGVpZ2h0KX2+ry51cGRhdGVOZWVkZWQ7rGg9ZyxiPXt0eHQ6qihhKXvRA3JhbTthLmZvbnQuZW5kc1dpdGgo0QElKZ4oYS5mb250PdEGVmVjdG9yK01hdGgucm91bmQoaC5nZXRIZWlnaHQoKSphLmZvbnQuc2xpY2UoMCwtMSkvMTAwKSk7oyhhLndyYXApYS5faD1hLl93PTA7pHusZT1nLnNldEZvbnQoYS5mb250KS5zdHJpbmdNZXRyaWNzKGEubGFiZWwpO2EuX3c9ZS53aWR0aDthLl9oPWUuaGVpZ2h0fX0sYnRuOqooYSl70QNyYW07YS5mb250nmEuZm9udC5lbmRzV2l0aCjRASUpnihhLmZvbnQ90QZWZWN0b3IrTWF0aC5yb3VuZChoLmdldEhlaWdodCgpKmEuZm9udC5zbGljZSgwLC0xKS8xMDApKTusZT1hLnNyYz9oLmltYWdlTWV0cmljcyjRCGZ1bmN0aW9uir9hLnNyYz9hLnNyYygpOmEuc3JjKTpoLnNldEZvbnQoYS5mb250oNEFNng4OjIpLnN0cmluZ01ldHJpY3MoYS5sYWJlbCk7YS5faD0xNitlLmhlaWdodDthLl93PTIwK2Uud2lkdGh9LGltZzqqKGEpe9EDcmFtO6xlPWguaW1hZ2VNZXRyaWNzKNEIZnVuY3Rpb26Kv2Euc3JjP2Euc3JjKCk6YS5zcmMpLGw9YS5zY2FsZaAxO2EuX3c9ZS53aWR0aCpsO2EuX2g9ZS5oZWlnaHQqbH0sIiI6qihhKXvRA3JhbTthLl93PTA7YS5faD0wfSxjdXN0b206qihhKXvRA3JhbTthLl93PTA7YS5faD0wfSxoOqooYSl70QNyYW07YS5jLmZvckVhY2goZCk7YS5faD1hLmMucmVkdWNlKChlLGwpok1hdGgubWF4KGUsbC5faCksMCk7YS5fdz1hLmMucmVkdWNlKChlLGwpomUrbC5fdywwKTu2imEuZmlsbHieYS5jLnNvbWUoZaJlLmZpbGx4KZ4oYS5maWxseD0xKTu2imEuZmlsbHmeYS5jLnNvbWUoZaJlLmZpbGx5KZ4oYS5maWxseT0xKX0sdjqqKGEpe9EDcmFtO2EuYy5mb3JFYWNoKGQpO2EuX2g9YS5jLnJlZHVjZSgoZSxsKaJlK2wuX2gsMCk7YS5fdz1hLmMucmVkdWNlKChlLGwpok1hdGgubWF4KGUsbC5fdyksMCk7tophLmZpbGx4nmEuYy5zb21lKGWiZS5maWxseCmeKGEuZmlsbHg9MSk7tophLmZpbGx5nmEuYy5zb21lKGWiZS5maWxseSmeKGEuZmlsbHk9MSl9fSxmPa8uX2w7ZChmKTu+YjtmLmZpbGx4oGYuZmlsbHk/KGYudz1CYW5nbGUuYXBwUmVjdC53LGYuaD1CYW5nbGUuYXBwUmVjdC5oLGYueD1CYW5nbGUuYXBwUmVjdC54LGYueT1CYW5nbGUuYXBwUmVjdC55KTooZi53PWYuX3csZi5oPWYuX2gsZi54PUJhbmdsZS5hcHBSZWN0LnctZi53kjEsZi55PUJhbmdsZS5hcHBSZWN0LnkrKEJhbmdsZS5hcHBSZWN0LmgtZi5okjEpKTuvLmxheW91dChmKX07cC5wcm90b3R5cGUuY2xlYXI9qihkKXtkoChkPa8uX2wpO2cucmVzZXQoKTvAMI1kLmJnQ29snmcuc2V0QmdDb2xvcihkLmJnQ29sKTtnLmNsZWFyUmVjdChkLngsZC55LGQueCtkLnctMSxkLnkrZC5oLTEpfTtleHBvcnRzPXAAYXV0bwBjcnlwdG8AbWlzbwBiYXJvAP9zY28ATGltYm8A/24AaW5wdXRfcHVsbGRvd24A/3J0bgBldHVybgB4b24AYnV0dG9uAHNldHRpbmcuanNvbgBsb24AI29udW5jYXVnaHRFeGNlcHRpb24AaXJxPXRydWUgc2V0LCBidXQgZnVuY3Rpb24gaXMgbm90IGEgbmF0aXZlIGZ1bmN0aW9uAEVkaXQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24AQ2FuIG9ubHkgdXNlICdhcmd1bWVudHMnIHZhcmlhYmxlIGluc2lkZSBhIGZ1bmN0aW9uAEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbgBBcmd1bWVudCBzaG91bGQgYmUgYSBmdW5jdGlvbgBGdW5jdGlvbgBhZmZpbmVfcXVhbnRpemF0aW9uAGtUZkxpdGVBZmZpbmVRdWFudGl6YXRpb24AVmFyaWFibGUgdHlwZSAldCBub3Qgc3VpdGVkIHRvIHRyYW5zbWl0IG9wZXJhdGlvbgBkZXN0aW5hdGlvbgAjb24AbnBpbgBJbnZhbGlkIHBpbgAxMG1pbgBhZl9vcGVuZHJhaW4AUGluAP90aG4Ac2V0Rm9udEFsaWduAGZuAGV2ZW4AdGhlbgBib29sZWFuAFxuAC5ib290UG93ZXJPbgBudW0AVG9vIG1hbnkgcGlucyEgJWQgTWF4aW11bQBXYXZlZm9ybQBGdW5jdGlvbiBtYXJrZWQgd2l0aCAiY29tcGlsZWQiIHVwbG9hZGVkIGluIHNvdXJjZSBmb3JtAGJvdHRvbQBzZXRGb250Q3VzdG9tAHByb20Ac3RyZXRjaF9kaW0AcmFtAP9uYW0AcmVzbABib29sAGNsa1BvbABudWxsACNvbmtpbGwAc2V0UGl4ZWwAQ2FuJ3QgdXNlIGZsb29kRmlsbCBvbiBHcmFwaGljcyB3aXRoIG5vIGdldFBpeGVsAGlTZXRQaXhlbABjaGFubmVsAC50Zm1vZGVsAE1pY3JvQWxsb2NhdG9yOiBNb2RlbCBhbGxvY2F0aW9uIGZpbmlzaGVkIGJlZm9yZSBzdGFydGluZyBhbGxvY2F0aW5nIG1vZGVsAE1pY3JvQWxsb2NhdG9yOiBNb2RlbCBhbGxvY2F0aW9uIHN0YXJ0ZWQgYmVmb3JlIGZpbmlzaGluZyBwcmV2aW91c2x5IGFsbG9jYXRlZCBtb2RlbAAjb25hY2NlbABzY2wA/3ZhbABJbnZhbGlkIGludGVydmFsAHBvbGxJbnRlcnZhbABVbmtub3duIEludGVydmFsAHRvdGFsAFRlcm1pbmFsAHN3c2VyaWFsAFNlcmlhbABkYXJrAGNodW5rAGhlYXRzaHJpbmsAY2xrAHNjawAjb25sb2NrAHN0YWNrAGNhbGxiYWNrAHJlYWsAa1RmTGl0ZU9rAGJhc2UsagBJZiBzcGVjaWZ5aW5nIGFuIG9iamVjdCwgaXQgbXVzdCBiZSBvZiB0aGUgZm9ybSB7ZGF0YSA6IC4uLiwgY291bnQgOiBOfSBvciB7Y2FsbGJhY2sgOiBmbn0gLSBnb3QgJWoAVW5rbm93biBmb250ICVqAFVua25vd24gaW1hZ2UgdHlwZSAlagBJbnZhbGlkIG1vZGUgJWoAZXh0aQBtb3NpAG1pAGJvdGgAI29uaGVhbHRoAGVuZHNXaXRoAEludmFsaWQgYXJyYXkgbGVuZ3RoAGdlc3R1cmVNaW5MZW5ndGgAYnl0ZUxlbmd0aAB3aWR0aAAjb25maW5pc2gAZ2VzdHVyZVN0YXJ0VGhyZXNoAGdlc3R1cmVFbmRUaHJlc2gAbGNkRG91YmxlUmVmcmVzaAAuc3BsYXNoAEZsYXNoAHN0ZXBDb3VudGVyVGhyZXNob2xkSGlnaAAjb250b3VjaABMQ0RfdG91Y2gAd2FrZU9uVG91Y2gAd2l0Y2gAVW5hYmxlIHRvIHNldCB3YXRjaC4gWW91IG1heSBhbHJlYWR5IGhhdmUgYSB3YXRjaCBvbiBhIHBpbiB3aXRoIHRoZSBzYW1lIG51bWJlciAoZWcuIEEwIGFuZCBCMCksCm9yIHRoaXMgcGluIGNhbm5vdCBiZSB1c2VkIHdpdGggd2F0Y2gAYnJnAGFuYWxvZwBtYW51YWxXYXRjaGRvZwBBcnJheUJ1ZmZlciB0b28gbG9uZwByaXNpbmcAVmFyaWFibGUgdHlwZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIHN0cmluZwB0b1N0cmluZwBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIE9iamVjdCBvciBTdHJpbmcARXhwZWN0aW5nIFN0cmluZwBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIFN0cmluZwBTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGEgU3RyaW5nAEZvbnQgYml0bWFwIG11c3QgYmUgYSBTdHJpbmcAV2F2ZWZvcm0gaXMgYWxyZWFkeSBydW5uaW5nAFdhdmVmb3JtIGlzIG5vdCBydW5uaW5nACNvbmZyYW1pbmcAZmFsbGluZwAjb25jaGFyZ2luZwAubG9hZGluZwBmZwByYmcAemlnemFnAHRhZwAjb25kcmFnACNvbm1hZwAjb25lcnJvckZsYWcA/2J1ZgBzZgB5cGVvZgBuc3RhbmNlb2YASWxsZWdhbCByZXNvbHZpbmcgdG8gc2VsZgBvZmYAZGlmZgBhZgBcZgBJbnZhbGlkIHR5cGUgJXQgZm9yIHZhbHVlT2YAMWRjY2FiODlmAERvdWJsZSAlZgAsIGRlYm91bmNlIDogJWYAqmsoYSl7q2EqZC5oK2IueS1mfapsKGEpe6tNYXRoLmZsb29yKChhK2YtYi55KS9kLmgpfaMoIWQpq0JhbmdsZS5zZXRVSSgpO6xuPSgpontnLnJlc2V0KCkuY2xlYXJSZWN0KGIpLnNldENsaXBSZWN0KGIueCxiLnksYi54MixiLnkyKTunKKxhPWwoYi55KSxjPU1hdGgubWluKGwoYi55MiksZC5jLTEpO2GOYzthmClkLmRyYXcoYSx7eDpiLngseTprKGEpLHc6Yi53LGg6ZC5ofSk7Zy5zZXRDbGlwUmVjdCgwLDAsZy5nZXRXaWR0aCgpLTEsZy5nZXRIZWlnaHQoKS0xKX07QmFuZ2xlLnNldFVJKHttb2RlOtEGY3VzdG9tLGJhY2s6ZC5iYWNrLHJlbW92ZTpkLnJlbW92ZSxyZWRyYXc6bixkcmFnOmGie6xjPWEuZHk7ZS5zY3JvbGwtYz5tnihjPWUuc2Nyb2xsLW0pO2Uuc2Nyb2xsLWM8aJ4oYz1lLnNjcm9sbC1oKTtlLnNjcm9sbJdjO2M9ZjtmPWUuc2Nyb2xsJi0yO6MoY5dmKXtnLnJlc2V0KCkuc2V0Q2xpcFJlY3QoYi54LGIueSxiLngyLGIueTIpLnNjcm9sbCgwLGMpO2E9YS5keTujKDA+YSmnKGE9TWF0aC5tYXgoYi55Mi0oMS1hKSxiLnkpLGcuc2V0Q2xpcFJlY3QoYi54LGEsYi54MixiLnkyKSxjPWwoYSksYT1rKGMpO2E8Yi55MjspZC5kcmF3KGMse3g6Yi54LHk6YSx3OmIudyxoOmQuaH0pLGOYLGGWZC5oO6SnKGE9TWF0aC5taW4oYi55K2EsYi55MiksZy5zZXRDbGlwUmVjdChiLngsYi55LGIueDIsYSksYz1sKGEpLGE9ayhjKTthPmIueS1kLmg7KWQuZHJhdyhjLHt4OmIueCx5OmEsdzpiLncsaDpkLmh9KSxhl2QuaCxjmTtnLnNldENsaXBSZWN0KDAsMCxnLmdldFdpZHRoKCktMSxnLmdldEhlaWdodCgpLTEpfX0sdG91Y2g6KGEsYymie6MoIShjLnk8Yi55LTQpKXthPWwoYy55KTuscD1jLnkrZi1iLnktYSpkLmg7MTYzPGMueZ4xNjM8ayhhKZ4oYZkscD1kLmgtMSk7KDA+aKAwjmEpnmE8ZC5jnmQuc2VsZWN0KGEse3g6Yy54LHk6cCx0eXBlOmMudHlwZX0pfX19KTusYj1CYW5nbGUuYXBwUmVjdCxoPTB8ZC5zY3JvbGxNaW4sbT1kLmgqZC5jLWIuaDttPGieKG09aCk7rGU9e3Njcm9sbDpFLmNsaXAoMHxkLnNjcm9sbCxoLG0pLGRyYXc6bixkcmF3SXRlbTphonusYz1rKGEpO2cucmVzZXQoKS5zZXRDbGlwUmVjdChiLngsTWF0aC5tYXgoYyxiLnkpLGIueDIsTWF0aC5taW4oYytkLmgsYi55MikpO2QuZHJhdyhhLHt4OmIueCx5OmMsdzpiLncsaDpkLmh9KTtnLnNldENsaXBSZWN0KDAsMCxnLmdldFdpZHRoKCktMSxnLmdldEhlaWdodCgpLTEpfSxpc0FjdGl2ZTooKaJCYW5nbGUudWlSZWRyYXeKbn0sZj1lLnNjcm9sbCYtMjtlLmRyYXcoKTtnLmZsaXAoKTurZQBSZXF1YW50aXplAGJsb2Nrc2l6ZQBieXRlc2l6ZQBhZmZpbmVfcXVhbnRpemF0aW9uLT56ZXJvX3BvaW50LT5zaXplAG5vZGUtPm91dHB1dHMtPnNpemUAYWZmaW5lX3F1YW50aXphdGlvbi0+c2NhbGUtPnNpemUAVG9vIG11Y2ggZGF0YSBmb3IgZmlsZSBzaXplAGNodW5rU2l6ZQBJbnZhbGlkIFNpemUASW52YWxpZCBBcmVuYSBTaXplAHJlbW92ZQBOYXRpdmUAd2F2ZQBwb3dlclNhdmUAQ2FuJ3QgaGF2ZSBhIGRhdGEgcGluIGFuZCBpcnE6dHJ1ZQAsIHRydWUAb250aW51ZQBJbnZhbGlkIGNvdW50IHZhbHVlAFVzZWQgb24gZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlAFVua25vd24gdHlwZSBvZiBjYWxsYmFjayBpbiBFdmVudCBRdWV1ZQBoZWlnaHQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDggd2hlbiB1c2luZyB2ZXJ0aWNhbF9ieXRlAHBhbGV0dGUAQ2FuJ3QgZ2V0IHBvaW50ZXIgdG8gZGF0YSB0byB3cml0ZQAjb25jb21wbGV0ZQBlbGV0ZQBzdGF0ZQByb3RhdGUASW52YWxpZCBJMkMgYml0cmF0ZQBfYmF1ZHJhdGUAdmlicmF0ZQBJbnZhbGlkIFNQSSBiYXVkIHJhdGUARGF0ZQBjb21wb3NlAGNsb3NlAGZhbHNlAFByb21pc2UAYXNlACNvbmdlc3R1cmUAI29uYWlHZXN0dXJlAEludmFsaWQgU2lnbmF0dXJlAG1vcmUAT25lV2lyZQAucHJvdG90eXBlAE9wZXJhdGlvbiAlcyBub3Qgc3VwcG9ydGVkIG9uIHRoZSAlcyBkYXRhdHlwZQBvdXRwdXQtPnR5cGUAaW5wdXQtPnR5cGUAZmlsdGVyLT50eXBlAG91dHB1dC0+cXVhbnRpemF0aW9uLnR5cGUAaW5wdXQtPnF1YW50aXphdGlvbi50eXBlAGZpbHRlci0+cXVhbnRpemF0aW9uLnR5cGUAVW5rbm93biB0eXBlACNvbnN3aXBlAFBpcGUAcmVzaGFwZQBub25lAGdjdGltZQBsYXN0VGltZQB0aGVtZQBmcmFtZQBuYW1lAG1vZHVsZQBoaWxlAENhbid0IGNyZWF0ZSB6ZXJvIGxlbmd0aCBmaWxlAFVuYWJsZSB0byBmaW5kIG9yIGNyZWF0ZSBmaWxlAFN0b3JhZ2VGaWxlAEJhbmdsZQBkb3VibGUARG91YmxlAHdyaXRhYmxlAGNvbmZpZ3VyYWJsZQBNdXN0IGJlIGNhbGxlZCBvbiBzb21ldGhpbmcgaXRlcmFibGUAZW51bWVyYWJsZQBGZWF0dXJlIHVuYXZhaWxhYmxlAGFmZmluZV9xdWFudGl6YXRpb24tPnNjYWxlAGxvY2FsZQBGaXJzdCBjaGFyYWN0ZXIgb3V0IG9mIHJhbmdlAGVkZ2UAdXNhZ2UAbWVzc2FnZQBTdG9yYWdlAGltYWdlAEV4cGVjdGluZyB2YWxpZCBJbWFnZQBmcmVlAENhbid0IHdyaXRlIGluIHRoaXMgbW9kZQBDYW4ndCByZWFkIGluIHRoaXMgbW9kZQBVbmtub3duIHBpbiBtb2RlAC5ib290Y2RlAHNvdXJjZQBmb3JjZQBkZWJvdW5jZQBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZQBzZXRMQ0RNb2RlIGlzIHVuc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlAHNUcmFjZQBkLGUAcHdkAGJhdWQAcGFzc3dvcmQARGVzdGluYXRpb24gU3RyZWFtIGRvZXMgbm90IGltcGxlbWVudCB0aGUgcmVxdWlyZWQgd3JpdGUoYnVmZmVyKSBtZXRob2QAU291cmNlIFN0cmVhbSBkb2VzIG5vdCBpbXBsZW1lbnQgdGhlIHJlcXVpcmVkIHJlYWQobGVuZ3RoKSBtZXRob2QARGVzdGluYXRpb24gb2JqZWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgcmVxdWlyZWQgd3JpdGUoYnVmZmVyLCBsZW5ndGgpIG1ldGhvZABTb3VyY2Ugb2JqZWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgcmVxdWlyZWQgcmVhZChidWZmZXIsIGxlbmd0aCkgbWV0aG9kAP9jb2QATW9kdWxlICVxIG5vdCBmb3VuZABlbmQAdHdpc3RUaHJlc2hvbGQAVW5pY29kZSBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnVpbGQAUEJGIEZvbnRzIG5vdCBlbmFibGVkIG9uIHRoaXMgYnVpbGQAb2lkAE5lc3RpbmcgJ25ldycgb3BlcmF0b3JzIGlzIHVuc3VwcG9ydGVkAENBU0UgYWZ0ZXIgREVGQVVMVCB1bnN1cHBvcnRlZABJbnB1dCB0eXBlICVzIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkAFRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFscyBub3Qgc3VwcG9ydGVkAEJhY2tyZWZlcmVuY2VzIG5vdCBzdXBwb3J0ZWQAVGFnZ2VkIFRlbXBsYXRlcyBhcmUgbm90IHN1cHBvcnRlZABJbnZhbGlkIEJQUCAtIDEsMiw0IHN1cHBvcnRlZABzdGFydGVkAFRGTWljcm9JbnRlcnByZXRlciBzdHJ1Y3R1cmUgY29ycnVwdGVkAEVtdWxhdGVkAGlycT10cnVlIHNldCwgYnV0IHdhdGNoIGlzIGFscmVhZHkgdXNlZABGYWlsZWQgdG8gYWxsb2NhdGUgbWVtb3J5IGZvciBjb250ZXh0LT5ldmFsX3RlbnNvcnMsICVkIGJ5dGVzIHJlcXVpcmVkAEZhaWxlZCB0byBhbGxvY2F0ZSBtZW1vcnkgZm9yIGFsbG9jYXRpb25faW5mbywgJWQgYnl0ZXMgcmVxdWlyZWQAV2F2ZWZvcm0gY291bGRuJ3QgYmUgc3RvcHBlZABTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBPYmplY3Qgb3IgdW5kZWZpbmVkAEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgU3RyaW5nIG9yIHVuZGVmaW5lZAAnb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QsIG9yIHVuZGVmaW5lZAAlcSBpcyBub3QgZGVmaW5lZABEYXRhIGlzIG5vdCBkZWZpbmVkAGNvbXBpbGVkAEF1dGhlbnRpY2F0ZWQgZGVjcnlwdGlvbiBmYWlsZWQATWljcm9JbnRlcnByZXRlciBjcmVhdGlvbiBmYWlsZWQAVEZNaWNyb0ludGVycHJldGVyIGludm9rZSBmYWlsZWQASW52b2tlIGZhaWxlZABzZXRNb2RpZmllZABoaXNwZWVkAG9kZABhZGQAbGNkACdFLmFzbScgY2FsbHMgc2hvdWxkIGhhdmUgYmVlbiByZXBsYWNlZCBieSB0aGUgRXNwcnVpbm8gdG9vbHMgYmVmb3JlIHVwbG9hZAAnRS5jb21waWxlZEMnIGNhbGxzIHNob3VsZCBoYXZlIGJlZW4gcmVwbGFjZWQgYnkgdGhlIEVzcHJ1aW5vIHRvb2xzIGJlZm9yZSB1cGxvYWQAY2xlYXIlcyh1bmRlZmluZWQpIG5vdCBhbGxvd2VkLiBVc2UgY2xlYXIlcygpIGluc3RlYWQAY2xlYXJXYXRjaCh1bmRlZmluZWQpIG5vdCBhbGxvd2VkLiBVc2UgY2xlYXJXYXRjaCgpIGluc3RlYWQAcmVhZABsY2RPdnJJZAAlZC0lMDJkLSUwMmRUJTAyZDolMDJkOiUwMmQuJTAzZCVjJTA0ZAAlcyAlcyAlZCAlZCAlMDJkOiUwMmQ6JTAyZCBHTVQlYyUwNGQAeCxkACVzOiVkeCVkACVzOiVkAFVuc3VwcG9ydGVkIFRlbnNvciBmb3JtYXQgVGZMaXRlVHlwZTolZAAlcy5zZXR1cCglZABJbnZhbGlkIHBhcml0eSAlZABBcnJheSBwYXNzZWQgdG8gRnVuY3Rpb24uYXBwbHkgaXMgdG9vIGJpZyEgTWF4aW11bSAyNTYgYXJndW1lbnRzLCBnb3QgJWQATm9kZSAlcyAobnVtYmVyICVkZikgZmFpbGVkIHRvIHByZXBhcmUgd2l0aCBzdGF0dXMgJWQATm9kZSAlcyAobnVtYmVyICVkKSBmYWlsZWQgdG8gaW52b2tlIHdpdGggc3RhdHVzICVkAEZhaWxlZCB0byBpbml0aWFsaXplIHRlbnNvciAlZABJbnRlZ2VyICVkAEVycm9yIFBhcnNpbmcgc2lnbmF0dXJlIGF0IGFyZ3VtZW50IG51bWJlciAlZABidWZmZXIgaW5kZXggJWQgaXMgb3V0c2lkZSByYW5nZSAwIHRvICVkAFVua25vd24gJWQAUGluICVkAEZhaWxlZCB0byBhbGxvY2F0ZSB2YXJpYWJsZSB0ZW5zb3Igb2Ygc2l6ZSAlZABJbnZhbGlkIGJhdWQgcmF0ZSAlZABVbmtub3duIGFyZ3NwZWMgJWQATG9naWMgZXJyb3IgaW4gbWVtb3J5IHBsYW5uZXIsIHRlbnNvciAlZCBoYXMgYW4gaW52YWxpZCBsaWZldGltZTogZmlyc3RfY3JlYXRlZDogJWQsIGxhc3RfdXNlZDogJWQArWI9cmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWRKU09OKNEMc2V0dGluZy5qc29uLDEpoHt9LGM9cmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWQoYi5sYXVuY2hlcik7oyghYyl7Yz3AMDutZD1yZXF1aXJlKNEHU3RvcmFnZSkubGlzdCgvLmluZm8kLykubWFwKGGie6MoKGE9cmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWRKU09OKGEsMSkpntEGbGF1bmNoimEudHlwZSmrYX0pLmZpbHRlcihhomEpLnNvcnQoKGEsZSmiYS5zb3J0b3JkZXItZS5zb3J0b3JkZXIpWzBdO2SeKGIubGF1bmNoZXI9ZC5zcmMscmVxdWlyZSjRB1N0b3JhZ2UpLndyaXRlSlNPTijRDHNldHRpbmcuanNvbixiKSxjPXJlcXVpcmUo0QdTdG9yYWdlKS5yZWFkKGQuc3JjKSl9Yz9CYW5nbGUubG9hZChiLmxhdW5jaGVyKTpldmFsKNFsRS5zaG93TWVzc2FnZSgiTm8gTGF1bmNoZXIgRm91bmQiKTtzZXRXYXRjaCgoKT0+e2xvYWQoKTt9LCBnbG9iYWwuQlROMnx8QlROLCB7cmVwZWF0OmZhbHNlLGVkZ2U6ImZhbGxpbmcifSk7KTu+Yju+YwBQYXJlbnQgbXVzdCBiZSBhbiBvYmplY3QgLSBub3QgYSBTdHJpbmcsIEludGVnZXIsIGV0YwBmdW5jAHRhdGljAGdjAAglYwBtc2IAbHNiAGdyYgBhdG9iAHJnYgBjYgAxMjozNDo1Njo3ODo5MDphYgBcYgBsY2RPdnJDYgAjb25kYXRhAEJhZCBpbnB1dCBkYXRhAEZpbGUgYWxyZWFkeSB3cml0dGVuIHdpdGggZGlmZmVyZW50IGRhdGEATm90IGVub3VnaCBzdGFjayBtZW1vcnkgZm9yIGRhdGEAaXJxRGF0YQBhcmVhAHNkYQBlLGEAYixhAF9fcHJvdG9fXwBfX0ZJTEVfXwBbb2JqZWN0IE9iamVjdF0AJXZbJXFdAGZpbHRlci0+ZGltcy0+ZGF0YVthZmZpbmVfcXVhbnRpemF0aW9uLT5xdWFudGl6ZWRfZGltZW5zaW9uXQBhZmZpbmVfcXVhbnRpemF0aW9uLT5zY2FsZS0+c2l6ZSA9PSAxIHx8IGFmZmluZV9xdWFudGl6YXRpb24tPnNjYWxlLT5zaXplID09IGZpbHRlci0+ZGltcy0+ZGF0YVtrQ29udlF1YW50aXplZERpbWVuc2lvbl0AYWZmaW5lX3F1YW50aXphdGlvbi0+c2NhbGUtPnNpemUgPT0gMSB8fCBhZmZpbmVfcXVhbnRpemF0aW9uLT5zY2FsZS0+c2l6ZSA9PSBmaWx0ZXItPmRpbXMtPmRhdGFba0RlcHRod2lzZUNvbnZRdWFudGl6ZWREaW1lbnNpb25dAD9bJWRdAFtGSUxFTkFNRV9UQUJMRV0AW0VSQVNFRF0AIF0AXFwALlwAbmV3ICVzKFsAJWQtJTAyZC0lMDJkVCUwMmQ6JTAyZDolMDJkLiUwM2RaAHR3aXN0TWF4WQBNRU1PUllfQlVTWQBMT1dfTUVNT1JZAFJFRFVDRV9BTlkAREVOU0lGWQAuYm9vdFgAVFgAVW5hYmxlIHRvIGFsbG9jYXRlIGRhdGEgZm9yIFNlcmlhbCBSWABVbmFibGUgdG8gd2F0Y2ggcGluICVwLCBubyBTb2Z0d2FyZSBTZXJpYWwgUlgAVU5GSU5JU0hFRCBSRUdFWABBUkdfTUFYAFJFRFVDRV9NQVgATE9HX1NPRlRNQVgA/2ZuVwBQT1cAVUFSVF9PVkVSRkxPVwBTUExJVF9WAFRSQU5TUE9TRV9DT05WAEZMT09SX0RJVgBMRUFLWV9SRUxVAFBSRUxVAFBLX1RJTUVPVVQAUEtfRlRJTUVPVVQAQ0FTVABSU1FSVABVU0FSVABST09UAExPR0lDQUxfTk9UAE9ORV9IT1QASU5UAFVORklOSVNIRUQgQ09NTUVOVABGQUtFX1FVQU5UACVzLCAlZCAlcyAlZCAlMDJkOiUwMmQ6JTAyZCBHTVQAR0lUX0NPTU1JVABTUExJVABJbnN1ZmZpY2llbnQgc3RhY2sgZm9yIGNvbXB1dGluZyBGRlQAU0VMRUNUAEZMT0FUAFdJREdFVFMATEVTUwBHUFMAQ09TAEVYUEFORF9ESU1TAENPTkNBVF9FTUJFRERJTkdTAE1PRFVMRVMAQUJTAEVYUFRSAExPR0lDQUxfT1IARkxPT1IAUkVTSVpFX05FQVJFU1RfTkVJR0hCT1IAR1JFQVRFUgBHQVRIRVIAUkVTSVpFX0JJTElORUFSACVRAEVYUABFTUJFRERJTkdfTE9PS1VQAEhBU0hUQUJMRV9MT09LVVAASW52YWxpZCBCUFAATUlTTwBOYU4AQUREX04AdG9KU09OAExTSF9QUk9KRUNUSU9OAExPQ0FMX1JFU1BPTlNFX05PUk1BTElaQVRJT04ATDJfTk9STUFMSVpBVElPTgBDT05DQVRFTkFUSU9OAEhXVkVSU0lPTgBVTklESVJFQ1RJT05BTF9TRVFVRU5DRV9STk4AQklESVJFQ1RJT05BTF9TRVFVRU5DRV9STk4AU0lOAEFSR19NSU4AUkVEVUNFX01JTgBNRUFOAFNFR01FTlRfU1VNAE1BWElNVU0ATUlOSU1VTQBVTklESVJFQ1RJT05BTF9TRVFVRU5DRV9MU1RNAEJJRElSRUNUSU9OQUxfU0VRVUVOQ0VfTFNUTQBIUk0AQ1VTVE9NAFRJTQBBRVMtMTI4LUNDTQBBRVMtMjU2LUNDTQBBRVMtMTkyLUNDTQBTS0lQX0dSQU0AQkFUQ0hfTUFUTVVMAEJPT0wAQlVGRkVSX0ZVTEwARklGT19GVUxMAEZJTEwAQ0FMTABQS19JTABDRUlMAFNDTABOT1RfRVFVQUwATEVTU19FUVVBTABHUkVBVEVSX0VRVUFMAFVORklOSVNIRUQgVEVNUExBVEUgTElURVJBTABTRVJJQUwAUkFOSwBTQ0sAVU5QQUNLAENBTExCQUNLABtbSgBNT1NJAEludmFsaWQgVVJJAFNQSS5zZW5kOGJpdCBvbmx5IHdvcmtzIG9uIGhhcmR3YXJlIFNQSQBTUEkuc2VuZDRiaXQgb25seSB3b3JrcyBvbiBoYXJkd2FyZSBTUEkA/2ZuSABmZ0gAYmdIAFNQQUNFX1RPX0RFUFRIAEhBUkRfU1dJU0gAU1BJRkxBU0gAVEFOSABMT0cAVU5GSU5JU0hFRCBTVFJJTkcATkVHAE1BVFJJWF9ESUFHAE1BVFJJWF9TRVRfRElBRwBFT0YASUYAU1ZERgBzZXRGb250UEJGAERFUVVBTlRJWkUAU1FVRUVaRQBVTklRVUUAREVMRUdBVEUARU1CRURESU5HX0xPT0tVUF9TUEFSU0UAVFJBTlNQT1NFAFNQQVJTRV9UT19ERU5TRQBXSEVSRQBTUVVBUkUATk9UWVBFAFJFU0hBUEUAQ09OU09MRQBUSUxFAFdISUxFAFBLX0ZJTEUAWkVST1NfTElLRQBSQU5HRQBTVE9SQUdFAFJFVkVSU0VfU0VRVUVOQ0UAU1FVQVJFRF9ESUZGRVJFTkNFAFNUUklERURfU0xJQ0UAREVQVEhfVE9fU1BBQ0UAG1tEAEJPQVJEAFJFRFVDRV9QUk9EAEZMT09SX01PRABTQ0FUVEVSX05EAEdBVEhFUl9ORABTUEFDRV9UT19CQVRDSF9ORABCQVRDSF9UT19TUEFDRV9ORABST1VORABMT0dJQ0FMX0FORABJRABGVUxMWV9DT05ORUNURUQAQUREAE1JUlJPUl9QQUQAREVQVEhXSVNFX0NPTlZfMkQATUFYX1BPT0xfMkQAQVZFUkFHRV9QT09MXzJEAEwyX1BPT0xfMkQAG1tDAExPR0lTVElDAERBQwBJMkMA/2ZuQgBMb29wYmFja0IAG1tCAFNVQgBVU0IAQUVTLTEyOC1FQ0IAQUVTLTI1Ni1FQ0IAQUVTLTE5Mi1FQ0IATG9vcGJhY2tBABtbQQBTREEAT3AgYnVpbHRpbl9jb2RlIG91dCBvZiByYW5nZTogJWQuIEFyZSB5b3UgdXNpbmcgb2xkIFRGTGl0ZSBiaW5hcnkgd2l0aCBuZXdlciBtb2RlbD8AVW5hYmxlIHRvIGdldCBwb2ludGVyIHRvIHBhbGV0dGUuIEltYWdlIGluIGZsYXNoPwAKICBJbnZhbGlkIHBhc3N3b3JkCnBhc3N3b3JkPgA9AHZhciBvPXt9LGFkZHI7Zm9yICh2YXIgcmVnIGluIGopIHthZGRyPWJhc2UraltyZWddO09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLHJlZyx7Z2V0OnBlZWszMi5iaW5kKHVuZGVmaW5lZCxhZGRyKSxzZXQ6cG9rZTMyLmJpbmQodW5kZWZpbmVkLGFkZHIpfSk7fXJldHVybiBvOwB2YXIgbT0wLGc7Zm9yICh2YXIgaSBpbiBhKSBpZiAoYVtpXT5tKSB7IG09YVtpXTtnPWk7IH1pZiAoZyE9PXVuZGVmaW5lZCkge3ZhciBuPXJlcXVpcmUoJ1N0b3JhZ2UnKS5yZWFkKCcudGZuYW1lcycpO2lmIChuKSBnPW4uc3BsaXQoJywnKVtnXTt9cmV0dXJuIGc7AGVjaG8oMCk7AEJhbmdsZS5zZXRMQ0RPdmVybGF5KEdyYXBoaWNzLmNyZWF0ZUFycmF5QnVmZmVyKDE2MCw0NCwxLHttc2I6dHJ1ZX0pLmRyYXdSZWN0KDAsMCwxNTksNDMpLmRyYXdSZWN0KDEsMSwxNTgsNDIpLnNldEZvbnQoJzEyeDIwJykuc2V0Rm9udEFsaWduKDAsMCkuZHJhd1N0cmluZygnUGxlYXNlIFdhaXQnLDgwLDE0KS5zZXRDb2xvcignIzg4OCcpLnNldEZvbnQoJzZ4OCcpLmRyYXdTdHJpbmcoJ1NUT1JBR0UgQ09NUEFDVElPTlxuSU4gUFJPR1JFU1MuLi4nLDgwLDMyKSw4LDY2KTtnLmZsaXAoKTsAQmFuZ2xlLnNldExDRE92ZXJsYXkoKTtnLmZsaXAoKTsATmV3Q2hpbGQgUEFSRU5UOgAKOgA2eDgAaW5wdXQtPnR5cGUgPT0ga1RmTGl0ZUZsb2F0MzIgfHwgaW5wdXQtPnR5cGUgPT0ga1RmTGl0ZUludDE2IHx8IGlucHV0LT50eXBlID09IGtUZkxpdGVJbnQ4AGtUZkxpdGVVSW50OABVSU5UOAAtMzI3NjgAQ09NUExFWDEyOAAtMTI4ADR4NgBSRUxVNgBvdXRwdXQtPnBhcmFtcy5zY2FsZSA9PSAxLmYgLyAyNTYAb3V0cHV0LT50eXBlID09IGtUZkxpdGVVSW50OCB8fCBvdXRwdXQtPnR5cGUgPT0ga1RmTGl0ZUludDggfHwgb3V0cHV0LT50eXBlID09IGtUZkxpdGVJbnQxNgBpbnB1dC0+dHlwZSA9PSBrVGZMaXRlVUludDggfHwgaW5wdXQtPnR5cGUgPT0ga1RmTGl0ZUludDggfHwgaW5wdXQtPnR5cGUgPT0ga1RmTGl0ZUludDE2AElOVDE2AEZMT0FUMTYATk9OX01BWF9TVVBQUkVTU0lPTl9WNQAydjI1AE5PTl9NQVhfU1VQUFJFU1NJT05fVjQAQ09NUExFWDY0AElOVDY0AEZMT0FUNjQASFNCdG9SR0IncyBmb3JtYXQgYXJnIGV4cGVjdHMgdW5kZWZpbmVkLzEvMTYvMjQAd2FrZU9uQlROMwB5MgB4MgBidWZmZXIyAGZnMgBiZzIAdG91Y2hZMgB0b3VjaFgyAFNFTEVDVF9WMgBUT1BLX1YyAFJFVkVSU0VfVjIAUEFEVjIAd2FrZU9uQlROMgBFTVNDUklQVEVOMgBDSDIAb3V0cHV0LT50eXBlID09IGtUZkxpdGVGbG9hdDMyIHx8IG91dHB1dC0+dHlwZSA9PSBrVGZMaXRlSW50MzIAa1RmTGl0ZUZsb2F0MzIASU5UMzIARkxPQVQzMgBzY2FsZV9kaWZmIC8gb3V0cHV0X3NjYWxlIDw9IDAuMDIAaGFzX2JpYXMgfHwgbm9kZS0+aW5wdXRzLT5zaXplID09IDIATnVtSW5wdXRzKG5vZGUpID09IDEgfHwgTnVtSW5wdXRzKG5vZGUpID09IDIAeTEAeDEA/2ZuMQBTZXJpYWwxAFJFTFVfTjFfVE9fMQB0b3VjaFkxAHRvdWNoWDEAd2FrZU9uQlROMQBTUEkxAENIMQBMRUQxAEkyQzEALTEATnVtRGltZW5zaW9ucyhpbnB1dCkgPj0gMQBhZmZpbmVfcXVhbnRpemF0aW9uLT5zY2FsZS0+c2l6ZSA9PSAxAFNhbXBsZXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMABjaHVua1NpemUgbXVzdCBiZSBhbiBpbnRlZ2VyID4gMABpbnB1dF9wcm9kdWN0X3NjYWxlID49IDAARXJyb3IgcHJvY2Vzc2luZyBTZXJpYWwgZGF0YSBoYW5kbGVyIC0gcmVtb3ZpbmcgaXQuAEN0cmwtQyB3aGlsZSBwcm9jZXNzaW5nIGludGVydmFsIC0gcmVtb3ZpbmcgaXQuAEN0cmwtQyB3aGlsZSBwcm9jZXNzaW5nIHdhdGNoIC0gcmVtb3ZpbmcgaXQuAFVuaGFuZGxlZCBmdWxseS1jb25uZWN0ZWQgd2VpZ2h0cyBmb3JtYXQuAEZhaWxlZCB0byBhbGxvY2F0ZSBtZW1vcnkgZm9yIG5vZGVfYW5kX3JlZ2lzdHJhdGlvbnMuAEludGVybmFsIGVycm9yOiBBbGxvY2F0ZUZyb21UYWlsIGNhbiBub3QgYmUgY2FsbGVkIGJldHdlZW4gdHdvIFJlcXVlc3RTY3JhdGNoQnVmZmVySW5BcmVuYSBjYWxscy4ASHlicmlkIG1vZGVscyBhcmUgbm90IHN1cHBvcnRlZCBvbiBURkxpdGUgTWljcm8uAEludmFsaWQgcGFyYW1ldGVyIEJ1aWx0aW5PcGVyYXRvcl9DVVNUT00gdG8gdGhlIEFkZEJ1aWx0aW4gZnVuY3Rpb24uAFJFVFVSTiBzdGF0ZW1lbnQsIGJ1dCBub3QgaW4gYSBmdW5jdGlvbi4AJXMgd2FzIG5vdCB0cnVlLgBCdWZmZXIgJWQgbm90IGZvdW5kLiAlZCBidWZmZXJzIGF2YWlsYWJsZS4AQXJlbmEgc2l6ZSBpcyB0b28gc21hbGwgZm9yIGFjdGl2YXRpb24gYnVmZmVycy4gTmVlZGVkICVkIGJ1dCBvbmx5ICVkIHdhcyBhdmFpbGFibGUuAEVyYXNpbmcgc2F2ZWQgY29kZS4AVHlwZSAlcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZC4ASW5wdXQgJXMsIG91dHB1dCAlcyBub3Qgc3VwcG9ydGVkLgBUeXBlICVzICglZCkgbm90IHN1cHBvcnRlZC4AJWQgYnl0ZXMgbG9zdCBkdWUgdG8gYWxpZ25tZW50LiBUbyBhdm9pZCB0aGlzIGxvc3MsIHBsZWFzZSBtYWtlIHN1cmUgdGhlIHRlbnNvcl9hcmVuYSBpcyAxNiBieXRlcyBhbGlnbmVkLgBNb2RlbCBwcm92aWRlZCBpcyBzY2hlbWEgdmVyc2lvbiAlZCBub3QgZXF1YWwgdG8gc3VwcG9ydGVkIHZlcnNpb24gJWQuAExvYWRpbmcuLi4AQ291bGRuJ3QgcmVnaXN0ZXIgYnVpbHRpbiBvcCAjJWQsIHJlc29sdmVyIHNpemUgaXMgdG9vIHNtYWxsICglZCkuAENhbGxpbmcgQWRkQnVpbHRpbiB3aXRoIHRoZSBzYW1lIG9wIG1vcmUgdGhhbiBvbmNlIGlzIG5vdCBzdXBwb3J0ZWQgKE9wOiAjJWQpLgBJbnRlcm5hbCBlcnJvcjogRW5zdXJlSGVhZFNpemUoKSBuZWVkcyB0byBiZSBjYWxsZWQgYWZ0ZXJSZXNldFRlbXBBbGxvY2F0aW9ucygpLgAtAEFycmF5LABPYmplY3QsACVxLABOdW1iZXIgJWosAFN0cmluZyAlaiwAJXA9JWQsACVkLCVkLCVkLABkYXRhOmltYWdlL2JtcDtiYXNlNjQsAKpyKG4pe2cucmVzZXQoKS5zZXRGb250KNEFNng4OjIpLnNldEZvbnRBbGlnbigwLC0xKTusaD1CYW5nbGUuYXBwUmVjdC55LGM9Zy5nZXRXaWR0aCgpLGY9Zy5nZXRIZWlnaHQoKS1oLGs9Zy5nZXRGb250SGVpZ2h0KCkscD1nLndyYXBTdHJpbmcoZC50aXRsZSxjLTIpLHQ9Zy53cmFwU3RyaW5nKHigIiIsYy0yKSxhPWgrKGYrKHAubGVuZ3RoLXQubGVuZ3RoKSprKS8yLTI0O2QuaW1nnihmPWcuaW1hZ2VNZXRyaWNzKGQuaW1nKSxnLmRyYXdJbWFnZShkLmltZywoYy1mLndpZHRoKS8yLGEtZi5oZWlnaHQvMiksYZY0K2YuaGVpZ2h0LzIpO3CeZy5zZXRDb2xvcihnLnRoZW1lLmZnSCkuc2V0QmdDb2xvcihnLnRoZW1lLmJnSCkuY2xlYXJSZWN0KDAsaCxjLTEsaCs0K3AubGVuZ3RoKmspLmRyYXdTdHJpbmcocC5qb2luKNEBCiksYy8yLGgrMik7Zy5zZXRDb2xvcihnLnRoZW1lLmZnKS5zZXRCZ0NvbG9yKGcudGhlbWUuYmcpLmRyYXdTdHJpbmcodC5qb2luKNEBCiksYy8yLGEpO2GWdC5sZW5ndGgqayszMjusbT0wO2cuc2V0Rm9udEFsaWduKDAsMCk7cS5mb3JFYWNoKGyibZYyNCtnLnN0cmluZ1dpZHRoKGwpKTttPmOeKGcuc2V0Rm9udCjRAzZ4OCksbT0wLHEuZm9yRWFjaChsom2WMjQrZy5zdHJpbmdXaWR0aChsKSkpO6xiPShjLW0pLzI7dT1bXTtxLmZvckVhY2goKGwseSmie6x2PWcuc3RyaW5nV2lkdGgobCk7YpYoMjQrdikvMjusZT02K3YvMix3PVtiLWUsYS0xNixiK2UsYS0xNixiK2UrNCxhLTEyLGIrZSs0LGErMTIsYitlLGErMTYsYi1lLGErMTYsYi1lLTQsYSsxMixiLWUtNCxhLTEyLGItZSxhLTE2XTt1LnB1c2goe3gxOmItZS0xMix4MjpiK2UrMTIseTE6YS0zMCx5MjphKzMwLHBvbHk6d30pO2cuc2V0Q29sb3IoeYtuP2cudGhlbWUuYmdIOmcudGhlbWUuYmcyKS5maWxsUG9seSh3KS5zZXRDb2xvcih5i24/Zy50aGVtZS5mZ0g6Zy50aGVtZS5mZzIpLmRyYXdQb2x5KHcpLmRyYXdTdHJpbmcobCxiLGErMSk7YpYoMjQrdikvMn0pO0JhbmdsZS5zZXRMQ0RQb3dlcigxKX1koChkPXt9KTtkLmJ1dHRvbnOgKGQuYnV0dG9ucz17WWVzOiEwLE5vOiExfSk7rHE9T2JqZWN0LmtleXMoZC5idXR0b25zKSx1O2cucmVzZXQoKS5jbGVhclJlY3QoQmFuZ2xlLmFwcFJlY3QpO6MoIXgpq0JhbmdsZS5zZXRVSSgpLFByb21pc2UucmVzb2x2ZSgpO3IoKTuruFByb21pc2UobqJ7QmFuZ2xlLnNldFVJKHttb2RlOtEGY3VzdG9tLHJlbW92ZTpkLnJlbW92ZSxyZWRyYXc6cixiYWNrOmQuYmFjayx0b3VjaDooaCxjKaJ7dS5mb3JFYWNoKChmLGspontjLng+Zi54MZ5jLng8Zi54Mp5jLnk+Zi55MZ5jLnk8Zi55Mp4ocihrKSxnLmZsaXAoKSxFLnNob3dQcm9tcHQoKSxuKGQuYnV0dG9uc1txW2tdXSkpfSl9fSl9KQBUaW1lb3V0IChzdGFydCkAQXJiaXRyYXRpb24gKHN0YXJ0KQAldi5hcHBseSh0aGlzLGFyZ3VtZW50cykAU2VhcmNoIHN0cmluZyBpcyB0b28gbG9uZyAoPj0lZCBjaGFycykATW9kdWxlIG5hbWUgdG9vIGxvbmcgKG1heCAxMjggY2hhcnMpAEludGVydmFsIGlzIHRvbyBsb25nICg+MTAwIHllYXJzKQAlcyAhPSAlcyAoJXMgIT0gJXMpAFRpbWVvdXQgKHdyKQBUaW1lb3V0IChzdG9wKQBBcmJpdHJhdGlvbiAoc3RvcCkAYXJncyBtdXN0IGJlIGFkZENhY2hlZChzdHJpbmcsIHN0cmluZ3xmdW5jdGlvbikAYnl0ZU9mZnNldCB0b28gbGFyZ2UgKG9yIG5lZ2F0aXZlKQBOdW1PdXRwdXRzKG5vZGUpAE51bUlucHV0cyhub2RlKQBSZXNoYXBlT3V0cHV0KGNvbnRleHQsIG5vZGUpAEJhbmdsZS5sb2FkKNEILmJvb3RjZGUpAFRpbWVvdXQgKHJkKQBUb28gbWFueSBhcmd1bWVudHMgKD4lZCkAbmV3ICVzKCVkKQBUb28gbWFueSBidWZmZXJzIChtYXggaXMgJWQpAE91dHB1dCBpbmRleCAlZCBvdXQgb2YgcmFuZ2UgKGxlbmd0aCBpcyAlZCkASW5wdXQgaW5kZXggJWQgb3V0IG9mIHJhbmdlIChsZW5ndGggaXMgJWQpACVzIChvZmZzICVkLCBsZW4gJWQpACVzICE9ICVzICglZCAhPSAlZCkAQmFuZ2xlLnNldFVJKCk7Y2xlYXJUaW1lb3V0KCk7Y2xlYXJJbnRlcnZhbCgpO2NsZWFyV2F0Y2goKTtCYW5nbGUucmVtb3ZlQWxsTGlzdGVuZXJzKCk7RS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtOUkYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7QmFuZ2xlLnNldExDREJyaWdodG5lc3MoMSk7rWE9eyIiOnt0aXRsZTrRCFJlY292ZXJ5fSzRCkNsZWFuIEJvb3Q6KCmie3Jlc2V0KCl9LFJlYm9vdDooKaJ7RS5yZWJvb3QoKX0s0QhUdXJuIE9mZjooKaJ7QmFuZ2xlLm9mZigpfX070QlCQU5HTEVKUzKKcHJvY2Vzcy5lbnYuQk9BUkSeT2JqZWN0LmFzc2lnbihhLHtUZXN0OkJhbmdsZS5zaG93VGVzdFNjcmVlbn0pO09iamVjdC5hc3NpZ24oYSx70Q1GYWN0b3J5IFJlc2V0OigpontFLnNob3dQcm9tcHQo0ShBcmUgeW91IHN1cmU/ClRoaXMgd2lsbCByZW1vdmUgYWxsIGRhdGEuLHt0aXRsZTrRDUZhY3RvcnkgUmVzZXR9KS50aGVuKGKie6MoIWIpq0JhbmdsZS5zaG93UmVjb3ZlcnlNZW51KCk7RS5zaG93TWVzc2FnZSjRCVJlc2V0dGluZyk7QmFuZ2xlLnNldExDRFRpbWVvdXQoMCk7TlJGLmdldFNlY3VyaXR5U3RhdHVzKCkuY29ubmVjdGVkoFRlcm1pbmFsLnNldENvbnNvbGUoKTtCYW5nbGUuZmFjdG9yeVJlc2V0KCl9KX0sRXhpdDooKaJ7MDxyZXF1aXJlKNEHU3RvcmFnZSkubGlzdCgpLmxlbmd0aD8oRS5zaG93TWVzc2FnZSjRCkxvYWRpbmcuLi4pLE5SRi5nZXRTZWN1cml0eVN0YXR1cygpLmNvbm5lY3RlZKBUZXJtaW5hbC5zZXRDb25zb2xlKCksbG9hZCgpKTpFLnJlYm9vdCgpfSzRD0F0dGVtcHQgQ29tcGFjdDooKaJ7RS5zaG93TWVzc2FnZSjRHUNvbXBhY3RpbmcuLi4KTWF5IHRha2UKNSBtaW4uKTtOUkYuZ2V0U2VjdXJpdHlTdGF0dXMoKS5jb25uZWN0ZWSgVGVybWluYWwuc2V0Q29uc29sZSgpO3JlcXVpcmUo0QdTdG9yYWdlKS5jb21wYWN0KCk7RS5yZWJvb3QoKX0s0RJSZXdyaXRlIEJvb3Rsb2FkZXI6KCmie3NldFRpbWVvdXQobG9hZCwxRTMpO2V2YWwocmVxdWlyZSjRB1N0b3JhZ2UpLnJlYWQo0Q1ib290dXBkYXRlLmpzKSl9fSk7RS5zaG93TWVudShhKQBdKQDRBnN0cmluZ4q/YZ4oYT17dGl0bGU6YX0pO2E9YaB7fTtnLnJlc2V0KCkuY2xlYXJSZWN0KEJhbmdsZS5hcHBSZWN0KTtnLnNldEZvbnQo0QM2eDgsMTI4PGcuZ2V0V2lkdGgoKT8yOjEpLnNldEZvbnRBbGlnbigwLC0xKTusYz1CYW5nbGUuYXBwUmVjdC55LGI9Zy5nZXRXaWR0aCgpLGQ9Zy5nZXRIZWlnaHQoKS1jLGs9Zy5nZXRGb250SGVpZ2h0KCksZj1nLndyYXBTdHJpbmcoYS50aXRsZSxiLTIpO2U9Zy53cmFwU3RyaW5nKGWgIiIsYi0yKTtkPWMrKGQrKGYubGVuZ3RoLWUubGVuZ3RoKSprKS8yO6MoYS5pbWcpe6xoPWcuaW1hZ2VNZXRyaWNzKGEuaW1nKTtnLmRyYXdJbWFnZShhLmltZywoYi1oLndpZHRoKS8yLGQtaC5oZWlnaHQvMik7ZJY0K2guaGVpZ2h0LzJ9Zy5kcmF3U3RyaW5nKGUuam9pbijRAQopLGIvMixkKTthLnRpdGxlnmcuc2V0Q29sb3IoZy50aGVtZS5mZ0gpLnNldEJnQ29sb3IoZy50aGVtZS5iZ0gpLmNsZWFyUmVjdCgwLGMsYi0xLGMrNCtmLmxlbmd0aCprKS5kcmF3U3RyaW5nKGYuam9pbijRAQopLGIvMixjKzIpO2cuZmxpcCgpO0JhbmdsZS5zZXRMQ0RQb3dlcigxKQBCYW5nbGUudWlSZW1vdmU/KEJhbmdsZS5zZXRVSSgpLChfX0ZJTEVfXz1hKaAoYT3RCC5ib290Y2RlKSxzZXRUaW1lb3V0KGV2YWwsMCxyZXF1aXJlKNEHU3RvcmFnZSkucmVhZChhKSkpOmxvYWQo0QguYm9vdGNkZYxhP2E6wDApAHNldFRpbWVvdXQoQmFuZ2xlLnNob3dSZWNvdmVyeU1lbnUsMTAwKQBFZGl0IHNob3VsZCBiZSBjYWxsZWQgd2l0aCBlZGl0KGZ1bmNOYW1lKSBvciBlZGl0KCdmdW5jTmFtZScpAHNldFRpbWVvdXQoACVzLnNldHVwKABzZXRJbnRlcnZhbCgALnJlcGxhY2VXaXRoKABzZXRXYXRjaCgARnVuY3Rpb24gY29kZSBtdXN0IGJlIGEgU3RyaW5nLCBnb3QgJyV0JwBTdHJpbmc6JyVzJwAsICVqLCB7IHJlcGVhdDolcywgZWRnZTonJXMnACdlZGdlJyBpbiBzZXRXYXRjaCBzaG91bGQgYmUgMSwgLTEsIDAsICdyaXNpbmcnLCAnZmFsbGluZycgb3IgJ2JvdGgnAFNQSSBvcmRlciBzaG91bGQgYmUgJ21zYicgb3IgJ2xzYicASWYgQ29sb3IgaXMgYSBTdHJpbmcsIGl0IG11c3QgYmUgb2YgdGhlIGZvcm0gJyNycmdnYmInIG9yICcjcmdiJwAuW10oKXxeKiskACMAXCIAT3V0cHV0IHRlbnNvcnMgbm90IGF0IGluZGV4IDAgYXJlIGFsbG9jYXRlZCBmcm9tIHRoZSBwZXJzaXN0ZW50IG1lbW9yeSBhcmVuYS4gUmVwZWF0IGNhbGxzIHdpbGwgY2F1c2UgZXhjZXNzIGFsbG9jYXRpb24hAElucHV0IHRlbnNvcnMgbm90IGF0IGluZGV4IDAgYXJlIGFsbG9jYXRlZCBmcm9tIHRoZSBwZXJzaXN0ZW50IG1lbW9yeSBhcmVuYS4gUmVwZWF0IGNhbGxzIHdpbGwgY2F1c2UgZXhjZXNzIGFsbG9jYXRpb24hAEZpbGUgdG9vIGJpZyEARnVuY3Rpb24gJXEgbm90IGZvdW5kIQBGdW5jdGlvbiBub3QgZm91bmQhAFB1cmUgdmlydHVhbCBmdW5jdGlvbiBjYWxsZWQhAEZ1bmN0aW9uIG9yIFN0cmluZyBub3Qgc3VwcGxpZWQhAEZhaWxlZCB0byBwb3B1bGF0ZSBhIHBlcnNpc3RlbnQgVGZMaXRlVGVuc29yIHN0cnVjdCBmcm9tIGZsYXRidWZmZXIgZGF0YSEARmFpbGVkIHRvIHBvcHVsYXRlIGEgdGVtcCBUZkxpdGVUZW5zb3Igc3RydWN0IGZyb20gZmxhdGJ1ZmZlciBkYXRhIQBPYmplY3QgeyAAR2V0dGVyL1NldHRlciB7IABGdW5jdGlvbiB7IABOYXRpdmVGdW5jdGlvbiAweCV4ICglZCkgeyAAIGF0IABQYXJhbSAlcSAAcmV0dXJuIABmdW5jdGlvbiAAaW4gZnVuY3Rpb24gJXEgY2FsbGVkIGZyb20gAGluIGZ1bmN0aW9uIGNhbGxlZCBmcm9tIABOYW1lIAAjJWRbciVkLGwlZF0gAEFycmF5QnVmZmVyTmFtZVslZF0gAEFycmF5KCVkKSBbIAAgQ09OU1QgAFNFVCAAJXYuJXYgPSAAdmFyICV2ID0gACV2OiAARVJST1I6IABXQVJOSU5HOiAAQ0hJTEQ6IAAlMDhkIHVzLCByZXBlYXQgJTA4ZCB1cyA6IABXcml0aW5nIGluaXRpYWwgc3RvcmFnZSBjb250ZW50cy4uLiAAQ29tcGFjdGluZy4uLiAAIC4uLiAAJXYub24oJXEsIAApIAAgICAgAHsKICAARmFpbGVkIHRvIGdldCByZWdpc3RyYXRpb24gZnJvbSBvcCBjb2RlICVzCiAACCAAZmxvb2RGaWxsIG92ZXJmbG93CgBVbmNhdWdodCAldgoAbGluZSAlZCBjb2wgJWQgaW4gJXYKAE5ldyBpbnRlcnByZXRlciBlcnJvcjogJXYKACwgJWYpOyAvLyAldgoATGVzcyB0aGFuIDEwIHBlcmNlbnQgYmF0dGVyeSByZW1haW5pbmcgLSBjYW5ub3QgY29tcGFjdAoARXNwcnVpbm8gJXMgJXMKAFV0aWwgVGltZXIgJXMKACA9IGJvb2wgJXMKAC0+ICVzCgA8LSAlcwoAVW5zdXBwb3J0ZWQgZGF0YSB0eXBlICVkIGluIHRlbnNvcgoAc3lzdGVtCgBURiBlcnJvciAtIG5vIG1vZGVsCgAbWz83bAogX19fXyAgICAgICAgICAgICAgICAgXyAKfCAgX198X19fIF9fXyBfX18gXyBffF98X19fIF9fXyAKfCAgX198XyAtfCAuIHwgIF98IHwgfCB8ICAgfCAuIHwKfF9fX198X19ffCAgX3xffCB8X19ffF98X3xffF9fX3wKICAgICAgICAgfF98IGVzcHJ1aW5vLmNvbQogMnYyNSAoYykgMjAyNCBHLldpbGxpYW1zCgpFc3BydWlubyBpcyBPcGVuIFNvdXJjZS4gT3VyIHdvcmsgaXMgc3VwcG9ydGVkCm9ubHkgYnkgc2FsZXMgb2Ygb2ZmaWNpYWwgYm9hcmRzIGFuZCBkb25hdGlvbnM6Cmh0dHA6Ly9lc3BydWluby5jb20vRG9uYXRlCgAvLyBDb2RlIHNhdmVkIHdpdGggRS5zZXRCb290Q29kZQoATm90IGltcGxlbWVudGVkIGluIHRoaXMgYnVpbGQKAEV4ZWN1dGlvbiBJbnRlcnJ1cHRlZAoASW52b2tlKCkgY2FsbGVkIGFmdGVyIGluaXRpYWxpemF0aW9uIGZhaWxlZAoAU2tpcHBpbmcgb3AgZm9yIG9wY29kZV9pbmRleCAlZAoATWlzc2luZyByZWdpc3RyYXRpb24gZm9yIG9wY29kZV9pbmRleCAlZAoAID0gaW50ICVkCgBDb3VsZG4ndCBjb252ZXJ0IHBpbiBmdW5jdGlvbiAlZAoAbGluZSAlZCBjb2wgJWQKAF4KAD9bJWRdCgBXS1VQCgAgfSk7CgBPYmplY3QuY3JlYXRlKCV2KTsKAHBpbk1vZGUoJXAsICVxJXMpOwoAc2V0QnVzeUluZGljYXRvciglcCk7CgBzZXRTbGVlcEluZGljYXRvciglcCk7CgBFLnNldEZsYWdzKCVqKTsKAGRpZ2l0YWxXcml0ZSglcCwgJWQpOwoAV1I4CgBSRDgKAFdSMTYKAFJEMTYKAFVuYWJsZSB0byBhbGxvY2F0ZSBxdWFudGl6YXRpb24tPnplcm9fcG9pbnQuCgBVbnN1cHBvcnRlZCBiZWhhdmlvcjogZm91bmQgYnVpbHRpbiBvcGVyYXRvciAlcyB3aXRoIGN1c3RvbSBvcHRpb25zLgoAVW5hYmxlIHRvIGFsbG9jYXRlIFRmTGl0ZUFmZmluZVF1YW50aXphdGlvbi4KAEZhaWxlZCBzdGFydGluZyBtb2RlbCBhbGxvY2F0aW9uLgoACiAgTG9nZ2VkIGluLgoARXhlY3V0aW9uIEludGVycnVwdGVkIGR1cmluZyBldmVudCBwcm9jZXNzaW5nLgoACldyaXRlIGNvbXBsZXRlLgoARXJhc2UgY29tcGxldGUuCgBPcGVyYXRvciB3aXRoIENVU1RPTSBidWlsdGluX2NvZGUgaGFzIG5vIGN1c3RvbV9jb2RlLgoATm8gVGltZXJzIGZvdW5kLgoAT25seSAxIHN1YmdyYXBoIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuCgByZWYsc2l6ZSxmbGFncyxuYW1lLGxpbmtzLi4uCgBFcmFzaW5nIFN0b3JhZ2UgQXJlYS4uLgoAUnVubmluZyBvbkluaXQoKS4uLgoASW5wdXQgYXJyYXkgbm90IHByb3ZpZGVkIGZvciBvcGVyYXRpb24gJyVzJy4KAEZvdW5kIHRvbyBtYW55IGRpbWVuc2lvbnMgaW4gdGhlIGlucHV0IGFycmF5IG9mIG9wZXJhdGlvbiAnJXMnLgoARVhFQyAleCgleCkKAE5iciBvZiBvZmZsaW5lIGJ1ZmZlciBvZmZzZXRzICglZCkgaW4gbWV0YWRhdGEgbm90IGVxdWFsIG5iciB0ZW5zb3JzICglZCkKAERpZG4ndCBmaW5kIG9wIGZvciBidWlsdGluIG9wY29kZSAnJXMnIHZlcnNpb24gJyVkJwoASW5pdGlhbCBzdG9yYWdlIGlzIHRvbyBsYXJnZSB0byBmaXQgaW4gaW50ZXJuYWwgU1BJIGZsYXNoIQoACkRvbmUhCgAKCgAAAAAAPT0APT09ACE9ACE9PQA8PQA8PAA8PD0APj0APj4APj4+AD4+PQA+Pj49ACs9AC09ACsrAC0tACo9AC89ACU9ACY9ACYmAHw9AHx8AF49AD0+AGlmAGVsc2UAZG8Ad2hpbGUAZm9yAGJyZWFrAGNvbnRpbnVlAGZ1bmN0aW9uAHJldHVybgB2YXIAbGV0AGNvbnN0AHRoaXMAdGhyb3cAdHJ5AGNhdGNoAGZpbmFsbHkAdHJ1ZQBmYWxzZQBudWxsAHVuZGVmaW5lZABuZXcAaW4AaW5zdGFuY2VvZgBzd2l0Y2gAY2FzZQBkZWZhdWx0AGRlbGV0ZQB0eXBlb2YAdm9pZABkZWJ1Z2dlcgBjbGFzcwBleHRlbmRzAHN1cGVyAHN0YXRpYwBvZg==");
  base64DecodeToExistingUint8Array(bufferView, 148580, "Pz8AADAAAAAAZGVlcFNsZWVwAHVuc2FmZUZsYXNoAHVuc3luY0ZpbGVzAHByZXRva2VuaXNlAGppdERlYnVn");
  base64DecodeToExistingUint8Array(bufferView, 148658, "B4AzAAAABwABgDQAAAAPAAGANQAAABcACIA2AAAAHABYgDcAAAAiAHiAOAAAACYAA4A5AAAAKwAAgDoAAAAxAACAOwAAADUAA4A8AAAAPAAYgD0AAABCANiBPgAAAGFuYWxvZwBnZXRJbmZvAGdldE1vZGUAbW9kZQBwdWxzZQBwd20AcmVhZAByZXNldABzZXQAdG9nZ2xlAHdyaXRlAHdyaXRlQXRUaW1lAAAAAAABAC4AAAAEABEAIAAAAAoAIQAwAAAAFgABADEAAAAmAAVwPwAAACoABXBAAAAALwABABwAAAA2AAEAHwAAAEAACwBBAAAASAAJCQsAAABRABEADAAAAFYAAQAdAAAAWAAJAA0AAABeAAkJQgAAAGsACQlDAAAAeAARADIAAACBAAEACgAAAIoABHBEAAAAjwABABgAAACTAAFwRQAAAJgAB3BGAAAAoQAJCUcAAACsAAkJSAAAALcACQlJAAAAwQAJABAAAADPAAEAIgAAANQAAXBKAAAA2AABcEoAAADdAAFwSwAAAOIABHBMAAAA5gABcE0AAADwAAFwTgAAAPoAAQAnAAAA/wABACYAAAAHAQEAHgAAAAsBB3BPAAAADwERACMAAAAWAQkAJAAAAB0BKQATAAAAJQEJABsAAAApAQkAFAAAADEBCQARAAAAQAFJABIAAABHAQEAFwAAAEsBAXBQAAAAUAEBABUAAABXAQFwUQAAAF8BAQAWAAAAawERACUAAAByAQkADgAAAH4BAQAaAAAAkQEBcFIAAACaAQkADwAAAKQBAXBTAAAAqAEJCVQAAAC0AQkJVQAAAMABCQlWAAAAzAEJCVcAAADXAQkJWAAAAOkBBXBZAAAA8QFJABkAAAD6AS8AWgAAAAUC6ANbAAAAEQIBcFwAAAAbAgkAXQAAACACCQBeAAAAJQLIAV8AAAA0AhAAYAAAAEICEABhAAAATwIQAGIAAABaAgEAIQAAAGICCQBjAAAAdQLoAmQAAACCAgwAZQAAAI4CSABmAAAAmwIAAGcAAACgAhgAaAAAAKUCCABpAAAAqgIJAGoAAAC9AgkACQAAAMICAQApAAAAxQIpAGsAAADQAgEAbAAAANoCBwBtAAAA4gIBcG4AAADpAgFwbgAAAPQCCwBvAAAA/QILAHAAAAADAwgAcQAAAAgDDwByAAAAEwNJAHMAAAAcAyEBdAAAACMDIQF1AAAAKgMhAXYAAAAwA2gGdwAAADgDYAB4AAAAPwNgAHkAAABGA2AAegAAAEwDEAB7AAAAUgMBACoAAABaAwkAfAAAAGIDGAB9AAAAaAMIAH4AAAB5A8kFfwAAAIUDCACAAAAAlwM4AIEAAACfA8kFggAAAKoDSQODAAAAswNIAoQAAAC8AwgAhQAAAEFFUwBBcnJheQBBcnJheUJ1ZmZlcgBBcnJheUJ1ZmZlclZpZXcAQlROAEJUTjEAQmFuZ2xlAEJsdWV0b290aABCb29sZWFuAERhdGFWaWV3AERhdGUARQBFcnJvcgBGbG9hdDMyQXJyYXkARmxvYXQ2NEFycmF5AEZ1bmN0aW9uAEdyYXBoaWNzAEhJR0gASTJDAEkyQzEASW5maW5pdHkASW50MTZBcnJheQBJbnQzMkFycmF5AEludDhBcnJheQBJbnRlcm5hbEVycm9yAEpTT04ATEVEAExFRDEATEVEMgBMT1cATG9vcGJhY2tBAExvb3BiYWNrQgBNYXRoAE1vZHVsZXMATlJGAE5hTgBOdW1iZXIAT2JqZWN0AE9uZVdpcmUAUGluAFByb21pc2UAUmVmZXJlbmNlRXJyb3IAUmVnRXhwAFNQSQBTUEkxAFNlcmlhbABTZXJpYWwxAFN0b3JhZ2VGaWxlAFN0cmluZwBTeW50YXhFcnJvcgBURk1pY3JvSW50ZXJwcmV0ZXIAVGVybWluYWwAVHlwZUVycm9yAFVTQgBVaW50MTZBcnJheQBVaW50MjRBcnJheQBVaW50MzJBcnJheQBVaW50OEFycmF5AFVpbnQ4Q2xhbXBlZEFycmF5AFZJQlJBVEUAV2F2ZWZvcm0AYW5hbG9nUmVhZABhbmFsb2dXcml0ZQBhcmd1bWVudHMAYXRvYgBidG9hAGNoYW5nZUludGVydmFsAGNsZWFySW50ZXJ2YWwAY2xlYXJUaW1lb3V0AGNsZWFyV2F0Y2gAY29uc29sZQBkZWNvZGVVUklDb21wb25lbnQAZGlnaXRhbFB1bHNlAGRpZ2l0YWxSZWFkAGRpZ2l0YWxXcml0ZQBkdW1wAGVjaG8AZWRpdABlbmNvZGVVUklDb21wb25lbnQAZXZhbABmcwBnZXRQaW5Nb2RlAGdldFNlcmlhbABnZXRUaW1lAGdsb2JhbABnbG9iYWxUaGlzAGlzRmluaXRlAGlzTmFOAGxvYWQAcGFyc2VGbG9hdABwYXJzZUludABwZWVrMTYAcGVlazMyAHBlZWs4AHBpbk1vZGUAcG9rZTE2AHBva2UzMgBwb2tlOABwcmludABwcm9jZXNzAHJlcXVpcmUAcmVzZXQAc2V0QnVzeUluZGljYXRvcgBzZXRJbnRlcnZhbABzZXRTbGVlcEluZGljYXRvcgBzZXRUaW1lAHNldFRpbWVvdXQAc2V0V2F0Y2gAc2hpZnRPdXQAdHJhY2U=");
  base64DecodeToExistingUint8Array(bufferView, 150690, "IQGGAAAACAABcIcAAAAQACEBiAAAABwAIAGJAAAAKAAhAYoAAAAtAOEBiwAAADIAIQGMAAAAPAAgAY0AAABGAAEAjgAAAEoAAACPAAAAVgAYAJAAAABjAAEAkQAAAGwAAQCSAAAAdwABAJMAAACBAAkAlAAAAJEAAQCVAAAAnAABAJYAAACkAAEAlwAAAK8AAQCYAAAAuwAEAJkAAADIACEBmgAAAM4AIAGbAAAA1AADAJwAAADiAAMAnQAAAPAAAwCeAAAA+wADAJ8AAAAHAQMAoAAAAA8BAwChAAAAFwEDAKIAAAAfAQMAowAAACgBYACkAAAALgEIAKUAAAAzAQAApgAAAD8BAACnAAAAQwEJAKgAAABLAQAAqQAAAFgBGACqAAAAZQFbAKsAAAB3AVsArAAAAIcBWwCtAAAAkwFbAK4AAACfATgArwAAALABCACwAAAAuwEgALEAAADIAUgYsgAAANYBGACzAAAA4gE4ALQAAADwARgAtQAAAPoBCAC2AAAABQI4ALcAAAAVAiAAuAAAACICSAC5AAAAKAIAALoAAAAyAgAAuwAAAD8CAAC8AAAAUAIAAL0AAABYAiABvg==");
  base64DecodeToExistingUint8Array(bufferView, 151152, "YWNjZWxSZABhcHBSZWN0AGJhcm9tZXRlclJkAGJhcm9tZXRlcldyAGJlZXAAYnV6egBjb21wYXNzUmQAY29tcGFzc1dyAGRiZwBkcmF3V2lkZ2V0cwBmYWN0b3J5UmVzZXQAZ2V0QWNjZWwAZ2V0Q29tcGFzcwBnZXRHUFNGaXgAZ2V0SGVhbHRoU3RhdHVzAGdldExDRE1vZGUAZ2V0TG9nbwBnZXRPcHRpb25zAGdldFByZXNzdXJlAGdldFN0ZXBDb3VudABocm1SZABocm1XcgBpc0JhY2tsaWdodE9uAGlzQmFyb21ldGVyT24AaXNDaGFyZ2luZwBpc0NvbXBhc3NPbgBpc0dQU09uAGlzSFJNT24AaXNMQ0RPbgBpc0xvY2tlZABsY2RXcgBsb2FkAGxvYWRXaWRnZXRzAG9mZgBwcm9qZWN0AHJlc2V0Q29tcGFzcwBzZXRCYWNrbGlnaHQAc2V0QmFyb21ldGVyUG93ZXIAc2V0Q29tcGFzc1Bvd2VyAHNldEdQU1Bvd2VyAHNldEhSTVBvd2VyAHNldExDREJyaWdodG5lc3MAc2V0TENETW9kZQBzZXRMQ0RPZmZzZXQAc2V0TENET3ZlcmxheQBzZXRMQ0RQb3dlcgBzZXRMQ0RUaW1lb3V0AHNldExvY2tlZABzZXRPcHRpb25zAHNldFBvbGxJbnRlcnZhbABzZXRTdGVwQ291bnQAc2V0VUkAc2hvd0Nsb2NrAHNob3dMYXVuY2hlcgBzaG93UmVjb3ZlcnlNZW51AHNvZnRPZmYAdG91Y2hXcg==");
  base64DecodeToExistingUint8Array(bufferView, 151778, "CQC/AAAABgBIBsAAAAAKAPlPwQAAABMACQDCAAAAGgCIAMMAAAAeAP8PxAAAACMACADFAAAALQBPCMYAAAA2AEkCxwAAAEEAAADIAAAASAAAAMkAAABaAAEAygAAAGIAAADLAAAAbQAAAMwAAAB7AHgAzQAAAIoACQDOAAAAkwDMAM8AAACgAAcA0AAAAK4ABADRAAAAuQABANIAAADCAAEA0wAAAM0AAQDUAAAA2wABANUAAADkAAEA1gAAAPIACQHXAAAA/AAHANgAAAALAQQA2QAAABIBCwDaAAAAGQEAANsAAAAmAQAA3AAAADIBSQbdAAAAPwFIQt4AAABKASEB3wAAAFUBSQDgAAAAXwFhAuEAAABqAUgC4gAAAG8BAADjAAAAdgEkAOQAAACCAcgA5QAAAI4BDADmAAAAlwFIAOcAAACiARAA6AAAAKkBCADpAAAAsgEIAOoAAAC+ATgA6wAAAMoBSQDsAAAA1AEJAO0AAADdAUgA7gAAAOkBSQDvAAAA9AEJAPAAAAABAiAA8QAAAAcCAADyAAAAHAIPAPMAAAAgAgkA9AAAAC4CEQD1AAAAOwIJAPYAAABAAhEA9wAAAEkCEQD4AAAAVgLPAfk=");
  base64DecodeToExistingUint8Array(bufferView, 152256, "Q1JDMzIARkZUAEhTQnRvUkdCAGFzVVRGOABhc20AY2xpcABjb21waWxlZEMAY29udm9sdmUAZGVjb2RlVVRGOABkZWZyYWcAZHVtcEZyYWdtZW50YXRpb24AZHVtcFN0cgBkdW1wVGltZXJzAGR1bXBWYXJpYWJsZXMAZW5hYmxlV2F0Y2hkb2cAZnJvbVVURjgAZ2V0QWRkcmVzc09mAGdldEFuYWxvZ1ZSZWYAZ2V0QmF0dGVyeQBnZXRDbG9jawBnZXRDb25zb2xlAGdldEVycm9yRmxhZ3MAZ2V0RmxhZ3MAZ2V0UG93ZXJVc2FnZQBnZXRTaXplT2YAZ2V0VGVtcGVyYXR1cmUAaHdSYW5kAGlzVVRGOABraWNrV2F0Y2hkb2cAbG9ja0NvbnNvbGUAbG9va3VwTm9DYXNlAG1hcEluUGxhY2UAbWVtb3J5QXJlYQBtZW1vcnlNYXAAbmF0aXZlQ2FsbABwaXBlAHJlYm9vdAByZXZlcnNlQnl0ZQBzZXRCb290Q29kZQBzZXRDbG9jawBzZXRDb25zb2xlAHNldERTVABzZXRGbGFncwBzZXRQYXNzd29yZABzZXRUaW1lWm9uZQBzaG93QWxlcnQAc2hvd01lbnUAc2hvd01lc3NhZ2UAc2hvd1Byb21wdABzaG93U2Nyb2xsZXIAc3JhbmQAc3RvcEV2ZW50UHJvcGFnYXRpb24Ac3VtAHRvQXJyYXlCdWZmZXIAdG9GbGF0U3RyaW5nAHRvSlMAdG9TdHJpbmcAdG9VaW50OEFycmF5AHZhcmlhbmNlAAAAAAGA+gAAAAYACYD7AAAADgABgPwAAAAUAEyC/QAAAB8ACYD+AAAAJAAZgP8AAAAqAAnJAAEAADQAIYkBAQAAPwAhiQIBAABMACHJAwEAAFgACZkEAQAAYgBJgAUBAABtACHJBgEAAHYA+f8HAQAAgQDJgAgBAACKAMmACQEAAJUACckKAQAAngAJuQsBAACpAACADAEAAK4AIYkNAQAAuQAhyQ4BAADFAAmADwEAAM4ACYAQAQAA2QAJyREBAADiACGDEgEAAOwABIATAQAA8wAEgBQBAAD+AASAFQEAAAcBAYAWAQAADwEEgBcBAAAdAQGAGAEAACYBBIAZAQAAMAEZgBoBAAA8ASSBGwEAAEUBSYAcAQAAWAEEgB0BAABhAQmAHgEAAG4BIYEfAQAAdQEhgSABAAB8AUmAIQEAAIwBAYAiAQAAkgEhgSMBAACZAUmCJAEAAKQBIcklAQAAsAFJgiYBAAC5AQmBJwEAAMEBIYAoAQAAzgEhgCkBAADaASGJKgEAAOcBAYArAQAA9QEJwywBAAADAgmBLQEAAA4CIYAuAQAAHAIhgy8BAAAlAuGAMAEAADECCYAxAQAAOgIJgDIBAABIAgyAMwEAAFQCAfA0AQAAWgJMgjUBAABiAkmANgEAAHQCCYE3AQAAYXNCTVAAYXNJbWFnZQBhc1VSTABibGVuZENvbG9yAGJsaXQAY2xlYXIAY2xlYXJSZWN0AGRyYXdDaXJjbGUAZHJhd0NpcmNsZUFBAGRyYXdFbGxpcHNlAGRyYXdJbWFnZQBkcmF3SW1hZ2VzAGRyYXdMaW5lAGRyYXdMaW5lQUEAZHJhd1BvbHkAZHJhd1BvbHlBQQBkcmF3UmVjdABkcmF3U3RyaW5nAGR1bXAAZmlsbENpcmNsZQBmaWxsRWxsaXBzZQBmaWxsUG9seQBmaWxsUG9seUFBAGZpbGxSZWN0AGZsb29kRmlsbABnZXRCUFAAZ2V0QmdDb2xvcgBnZXRDb2xvcgBnZXRGb250AGdldEZvbnRIZWlnaHQAZ2V0Rm9udHMAZ2V0SGVpZ2h0AGdldE1vZGlmaWVkAGdldFBpeGVsAGdldFZlY3RvckZvbnRQb2x5cwBnZXRXaWR0aABpbWFnZU1ldHJpY3MAbGluZVRvAG1vdmVUbwBxdWFkcmF0aWNCZXppZXIAcmVzZXQAc2Nyb2xsAHNldEJnQ29sb3IAc2V0Q2xpcFJlY3QAc2V0Q29sb3IAc2V0Rm9udABzZXRGb250MTJ4MjAAc2V0Rm9udDZ4MTUAc2V0Rm9udEFsaWduAHNldEZvbnRCaXRtYXAAc2V0Rm9udEN1c3RvbQBzZXRGb250UEJGAHNldEZvbnRWZWN0b3IAc2V0UGl4ZWwAc2V0Um90YXRpb24Ac2V0VGhlbWUAc3RyaW5nTWV0cmljcwBzdHJpbmdXaWR0aAB0aGVtZQB0b0NvbG9yAHRyYW5zZm9ybVZlcnRpY2VzAHdyYXBTdHJpbmcAAAAAAQA4AQAACwABADkBAAAdAEgAOgEAACwASAA7AQAAZ2V0QWRkcmVzcwBnZXRTZWN1cml0eVN0YXR1cwBzZXRBZHZlcnRpc2luZwBzZXRTZXJ2aWNlcw==");
  base64DecodeToExistingUint8Array(bufferView, 154096, "PAEAAHNldENvbnNvbGUAAAAAEYA9AQAABwBJgD4BAAANAAmDPwEAABIASYBAAQAAGQAJgEEBAAAeAAmAQgEAACgASIBDAQAAMAALgUQBAAA5AAmBRQEAAEEACYBGAQAARgAB8EcBAABNAEmASAEAAFEAAYBJAQAAVQAUgEoBAABaAEmASwEAAGEAAYBMAQAAaQABgE0BAABvAGGATgEAAHUASYBPAQAAegAJgFABAAB/AGGEUQEAAIYACYABAAAAjwAUgFIB");
  base64DecodeToExistingUint8Array(bufferView, 154304, "Y29uY2F0AGV2ZXJ5AGZpbGwAZmlsdGVyAGZpbmQAZmluZEluZGV4AGZvckVhY2gAaW5jbHVkZXMAaW5kZXhPZgBqb2luAGxlbmd0aABtYXAAcG9wAHB1c2gAcmVkdWNlAHJldmVyc2UAc2hpZnQAc2xpY2UAc29tZQBzb3J0AHNwbGljZQB0b1N0cmluZwB1bnNoaWZ0AAAAAAsAUwEAAGlzQXJyYXkAAAAAAAAABPBUAQAAYnl0ZUxlbmd0aAAAAAAB8FUBAAAHAATwVgEAABIABPBXAQAAHQAJgz8BAAAiAEmAQAEAACkACYBBAQAALgAJgEIBAAA4AEiAQwEAAEAAC4FEAQAASQAJgUUBAABRAAmARgEAAFYASYBYAQAAWgBJgEsBAABhAAGATAEAAGkACIFZAQAAbQBhgE4BAABzAAmAWgEAAHgAYYBbAQAAYnVmZmVyAGJ5dGVMZW5ndGgAYnl0ZU9mZnNldABmaWxsAGZpbHRlcgBmaW5kAGZpbmRJbmRleABmb3JFYWNoAGluY2x1ZGVzAGluZGV4T2YAam9pbgBtYXAAcmVkdWNlAHJldmVyc2UAc2V0AHNsaWNlAHNvcnQAc3ViYXJyYXk=");
  base64DecodeToExistingUint8Array(bufferView, 154786, "4YBcAQAACwDhgF0BAAAWAOGAXgEAAB8A4YBfAQAAKADhgGABAAAwAOGAYQEAADoA4YBiAQAARADhgGMBAABNAGCGZAEAAFgAYIZlAQAAYwBghmYBAABsAGCGZwEAAHUAYIZoAQAAfQBghmkBAACHAGCGagEAAJEAYIZrAQAAZ2V0RmxvYXQzMgBnZXRGbG9hdDY0AGdldEludDE2AGdldEludDMyAGdldEludDgAZ2V0VWludDE2AGdldFVpbnQzMgBnZXRVaW50OABzZXRGbG9hdDMyAHNldEZsb2F0NjQAc2V0SW50MTYAc2V0SW50MzIAc2V0SW50OABzZXRVaW50MTYAc2V0VWludDMyAHNldFVpbnQ4");
  base64DecodeToExistingUint8Array(bufferView, 155074, "BwBsAQAABAAPAG0BAABub3cAcGFyc2U=");
  base64DecodeToExistingUint8Array(bufferView, 155106, "BIBuAQAACAAEgG8BAAAPAASAcAEAABsABIBxAQAAJAAEgHIBAAAtAASAcwEAAD0ABIB0AQAASAAEgHUBAABRAASAdgEAAFwAB4B3AQAAZAAEgHgBAAB2ACeAeQEAAH4AZ4J6AQAAigBnknsBAACTACeAfAEAAKMAZ4J9AQAArgBngH4BAAC3AGeAfwEAAMIAP4CAAQAAygABgIEBAADWAAGAgQEAAN0AAYCCAQAA7gABgIMBAAD3AAGAhAEAAAMBB4B3AQ==");
  base64DecodeToExistingUint8Array(bufferView, 155312, "Z2V0RGF0ZQBnZXREYXkAZ2V0RnVsbFllYXIAZ2V0SG91cnMAZ2V0SXNEU1QAZ2V0TWlsbGlzZWNvbmRzAGdldE1pbnV0ZXMAZ2V0TW9udGgAZ2V0U2Vjb25kcwBnZXRUaW1lAGdldFRpbWV6b25lT2Zmc2V0AHNldERhdGUAc2V0RnVsbFllYXIAc2V0SG91cnMAc2V0TWlsbGlzZWNvbmRzAHNldE1pbnV0ZXMAc2V0TW9udGgAc2V0U2Vjb25kcwBzZXRUaW1lAHRvSVNPU3RyaW5nAHRvSlNPTgB0b0xvY2FsSVNPU3RyaW5nAHRvU3RyaW5nAHRvVVRDU3RyaW5nAHZhbHVlT2YAAAAAAYCFAQAAdG9TdHJpbmcAAAAAAAABgIUBAAB0b1N0cmluZwAAAAAAAAGAhQEAAHRvU3RyaW5nAAAAAAAAAYCFAQAAdG9TdHJpbmcAAAAAAAABgIUBAAB0b1N0cmluZwAAAAAAABAAewAAAAYAEAB7AAAADAAQAHsAAAARABAAewAAABUAEAB7");
  base64DecodeToExistingUint8Array(bufferView, 155728, "ZGVidWcAZXJyb3IAaW5mbwBsb2cAd2Fybg==");
  base64DecodeToExistingUint8Array(bufferView, 155762, "CQCGAQAABgBJAocBAABwYXJzZQBzdHJpbmdpZnk=");
  base64DecodeToExistingUint8Array(bufferView, 155810, "B3CIAQAACgAHcIkBAAAUAAdwigEAACYAB3CLAQAAKgAHcIwB");
  base64DecodeToExistingUint8Array(bufferView, 155856, "TUFYX1ZBTFVFAE1JTl9WQUxVRQBORUdBVElWRV9JTkZJTklUWQBOYU4AUE9TSVRJVkVfSU5GSU5JVFkAAAAAAAAAIYCNAQAAdG9GaXhlZA==");
  base64DecodeToExistingUint8Array(bufferView, 155954, "SICOAQAADAABgI8BAAASAIiAkAEAABcAC4CRAQAAJgAB8EcBAAAtAEiAjgEAADAASICSAQAAQAAIgJMBAABTAEiAlAEAAGIACYABAAAAawABgJUB");
  base64DecodeToExistingUint8Array(bufferView, 156048, "YWRkTGlzdGVuZXIAY2xvbmUAZW1pdABoYXNPd25Qcm9wZXJ0eQBsZW5ndGgAb24AcHJlcGVuZExpc3RlbmVyAHJlbW92ZUFsbExpc3RlbmVycwByZW1vdmVMaXN0ZW5lcgB0b1N0cmluZwB2YWx1ZU9m");
  base64DecodeToExistingUint8Array(bufferView, 156178, "EQCWAQAABwBJAJcBAAAOAEkAmAEAAB8ASQKZAQAALgAJAJoBAAA2AAkAmwEAAEIASQCcAQAAWwAJAJ0BAAB1AAkAngEAAIkACQCfAQAAmAAJAKABAACdAEkAoQEAAKwACQCiAQ==");
  base64DecodeToExistingUint8Array(bufferView, 156288, "YXNzaWduAGNyZWF0ZQBkZWZpbmVQcm9wZXJ0aWVzAGRlZmluZVByb3BlcnR5AGVudHJpZXMAZnJvbUVudHJpZXMAZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yAGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMAZ2V0T3duUHJvcGVydHlOYW1lcwBnZXRQcm90b3R5cGVPZgBrZXlzAHNldFByb3RvdHlwZU9mAHZhbHVlcw==");
  base64DecodeToExistingUint8Array(bufferView, 156482, "SYCjAQAABgCJgKQBAAALAImAowEAABAACIClAQAAYXBwbHkAYmluZABjYWxsAHJlcGxhY2VXaXRoAAAAAAAAAAmApgEAAAUAC4CnAQAAZXhlYwB0ZXN0");
  base64DecodeToExistingUint8Array(bufferView, 156578, "IYCoAQAABwAhgKkBAAASABGAqgEAABkAS4CrAQAAIgBLgKwBAAArAEyArQEAADMATICuAQAAPwAB8EcBAABGAAmArwEAAEwAYYCwAQAAUwBhgLEBAABcAAGAsgEAAGoAIYCzAQAAcQBJgLQBAAB5AEmAtQEAAIQAYYC2AQAAigAJgLcBAACQAAuBuAEAAJsAYYC5AQAAogBhgLoBAACsAAGAuwEAALgAAYC8AQAAxAABgL0B");
  base64DecodeToExistingUint8Array(bufferView, 156768, "Y2hhckF0AGNoYXJDb2RlQXQAY29uY2F0AGVuZHNXaXRoAGluY2x1ZGVzAGluZGV4T2YAbGFzdEluZGV4T2YAbGVuZ3RoAG1hdGNoAHBhZEVuZABwYWRTdGFydAByZW1vdmVBY2NlbnRzAHJlcGVhdAByZXBsYWNlAHJlcGxhY2VBbGwAc2xpY2UAc3BsaXQAc3RhcnRzV2l0aABzdWJzdHIAc3Vic3RyaW5nAHRvTG93ZXJDYXNlAHRvVXBwZXJDYXNlAHRyaW0AAAAAAAARAL4BAABmcm9tQ2hhckNvZGU=");
  base64DecodeToExistingUint8Array(bufferView, 157010, "SAC/AQAACgABAMABAAAUAAAAwQEAACQACADCAQAAYWRkQ2FjaGVkAGdldENhY2hlZAByZW1vdmVBbGxDYWNoZWQAcmVtb3ZlQ2FjaGVk");
  base64DecodeToExistingUint8Array(bufferView, 157106, "B3DDAQAAAgAHcMQBAAAHAAdwxQEAAAsAB3DGAQAAEgAHcMcBAAAYAAdwyAEAABsAB3DJAQAAIwAHcMoBAAApAD8AywEAAC0APwDMAQAAMgA/AM0BAAA3AD8AzgEAADwA/wHPAQAAQgA/ANABAABHAP8P0QEAAEwAPwDSAQAAUAA/ANMBAABUAD8A1AEAAFoAPwDVAQAAXgAXANYBAABiABcA1wEAAGYA/wHYAQAAagAkANkBAAByAAcA2gEAAHkAOQDbAQAAfwA8ANwBAACEAD8A3QEAAIgAPwDeAQAAjQA/AN8BAACRAP8B4AEAAEUATE4xMABMTjIATE9HMTBFAExPRzJFAFBJAFNRUlQxXzIAU1FSVDIAYWJzAGFjb3MAYXNpbgBhdGFuAGF0YW4yAGNlaWwAY2xpcABjb3MAZXhwAGZsb29yAGxvZwBtYXgAbWluAHBvdwByYW5kSW50AHJhbmRvbQByb3VuZABzaWduAHNpbgBzcXJ0AHRhbgB3cmFw");
  base64DecodeToExistingUint8Array(bufferView, 157506, "CADhAQAACgABAOIBAAASACEA4wEAABoAIQHkAQAAHwAIAeUB");
  base64DecodeToExistingUint8Array(bufferView, 157552, "ZXJhc2VQYWdlAGdldEZyZWUAZ2V0UGFnZQByZWFkAHdyaXRlAAAAAAAASALiAAAAcGlwZQ==");
  base64DecodeToExistingUint8Array(bufferView, 157618, "AXDmAQAABAAJAOcBAAALAAFw6AE=");
  base64DecodeToExistingUint8Array(bufferView, 157648, "ZW52AG1lbW9yeQB2ZXJzaW9u");
  base64DecodeToExistingUint8Array(bufferView, 157682, "CYDpAQAABQADgOoBAAALACGA6wEAABIACIDsAQAAGQAAgO0BAAAeAMiA7gEAAHJlYWQAcmVzZXQAc2VhcmNoAHNlbGVjdABza2lwAHdyaXRl");
  base64DecodeToExistingUint8Array(bufferView, 157778, "CQDvAQAABAAJAPABAAALAAkA8QE=");
  base64DecodeToExistingUint8Array(bufferView, 157808, "YWxsAHJlamVjdAByZXNvbHZl");
  base64DecodeToExistingUint8Array(bufferView, 157842, "CYDyAQAABgBJgPMBAABjYXRjaAB0aGVuAAAAACkA9AEAAGZpbmQ=");
  base64DecodeToExistingUint8Array(bufferView, 157890, "BID1AQAACgAAgPYBAAAQABCA9wEAABcAA4D4AQAAIwBIgOIAAAAoAAiA+QEAAC4ACID6AQAANgAhgPsBAAA7ABiA/AEAAEYASID9AQAATAAAgP4BAABUABCA/wEAAGF2YWlsYWJsZQBmbHVzaABpbmplY3QAaXNDb25uZWN0ZWQAcGlwZQBwcmludABwcmludGxuAHJlYWQAc2V0Q29uc29sZQBzZXR1cAB1bnNldHVwAHdyaXRl");
  base64DecodeToExistingUint8Array(bufferView, 158082, "GAAAAgAACAAIAAECAAAOAAAAAgIAABcAHAADAgAAHwAZAAQCAAAoAAwABQIAAC0ASQAGAgAAMgBJAAcCAAA3AAAACAIAAEAACQkJAgAARQAJAAoCAABVAMkACwIAAF4AS0gMAgAAZABLAA0CAABjb21wYWN0AGVyYXNlAGVyYXNlQWxsAGdldEZyZWUAZ2V0U3RhdHMAaGFzaABsaXN0AG9wZW4Ab3B0aW1pc2UAcmVhZAByZWFkQXJyYXlCdWZmZXIAcmVhZEpTT04Ad3JpdGUAd3JpdGVKU09OAAAAAAAAgA4CAAAGAASADwIAABAASIDiAAAAFQAhgBACAAAaAAGAEQIAACMACIASAgAAZXJhc2UAZ2V0TGVuZ3RoAHBpcGUAcmVhZAByZWFkTGluZQB3cml0ZQAAAAAAACkAEwIAAGZpbmQ=");
  base64DecodeToExistingUint8Array(bufferView, 158418, "SYEUAgAABQAI2RUCAAAOAAjZFgIAABcACIAXAgAAHQAQgBgC");
  base64DecodeToExistingUint8Array(bufferView, 158464, "c2VuZABzZW5kNGJpdABzZW5kOGJpdABzZXR1cAB3cml0ZQAAAAApABkCAABmaW5k");
  base64DecodeToExistingUint8Array(bufferView, 158530, "CYEaAgAACQAhiRsCAAARAAiAHAIAABcAiIAdAgAAcmVhZEZyb20AcmVhZFJlZwBzZXR1cAB3cml0ZVRv");
  base64DecodeToExistingUint8Array(bufferView, 158610, "6IMeAgAACwDogx8CAAAXAACAIAI=");
  base64DecodeToExistingUint8Array(bufferView, 158640, "c3RhcnRJbnB1dABzdGFydE91dHB1dABzdG9wAAAAAAAAAAkAIQIAAAkACQAiAgAAY29tcHJlc3MAZGVjb21wcmVzcw==");
  base64DecodeToExistingUint8Array(bufferView, 158722, "IRkjAgAAEgAhGSQCAAAhAAkAJQIAAC0AAQAmAgAAY3JlYXRlQXJyYXlCdWZmZXIAY3JlYXRlQ2FsbGJhY2sAY3JlYXRlSW1hZ2UAZ2V0SW5zdGFuY2U=");
  base64DecodeToExistingUint8Array(bufferView, 158818, "CQAnAgAABQAJACgCAAAMAAkAKQIAABMACQAqAgAAGgAJACsC");
  base64DecodeToExistingUint8Array(bufferView, 158864, "U0hBMQBTSEEyMjQAU0hBMjU2AFNIQTM4NABTSEE1MTI=");
  base64DecodeToExistingUint8Array(bufferView, 158914, "SRIsAgAACwBJEi0CAABjY21EZWNyeXB0AGNjbUVuY3J5cHQAAAAAAGEALgIAAGNyZWF0ZQ==");
  base64DecodeToExistingUint8Array(bufferView, 158978, "AYAvAgAACQABgDACAAATAACAMQI=");
  base64DecodeToExistingUint8Array(bufferView, 159008, "Z2V0SW5wdXQAZ2V0T3V0cHV0AGludm9rZQAAAAAAAACoRAIAqEQCAACwRAIAEEUCAAxgRQIA0EgCAG6gTAIAcE4CADngUAIAwFICADsgVQIAEFcCAD6QWQIAsFkCAATsWQIA9FkCAAEAWgIAwFoCABdYWwIAYFsCAAFsWwIAdFsCAAGAWwIAEFwCABKgXAIAIF0CABDAXQIA0F0CAALgXQIAsF4CABm8XwIAxF8CAAHQXwIA2F8CAAHkXwIA7F8CAAH4XwIAAGACAAEMYAIAFGACAAEgYAIAUGACAAVwYAIAgGACAAKgYAIA0GACAAUQYQIAGGECAAEwYQIAkGECAAsQYgIAgGICAA1AYwIAYGMCAASAYwIAkGMCAAKgYwIAYGQCABcsZQIANGUCAAFQZQIAcGUCAASwZQIAoGYCAB5AZwIAcGcCAAWYZwIAoGcCAAGwZwIA0GcCAAPwZwIAIGgCAAZQaAIAcGgCAAOQaAIAoGgCAAKsaAIAtGgCAAHAaAIAIGkCAAyAaQIA8GkCAA5gagIAkGoCAAa8agIAxGoCAAHQagIAAGsCAAUkawIALGsCAAFAawIAYGsCAASAawIAgGsCAACQawIAsGsCAAPQawIA4GsCAAIAbAIAIGwCAARgbAIAkGwCAAXAbAIA0GwCAALobAIA8GwCAAEAbQIAIG0CAANQaW4AQmFuZ2xlAEUAR3JhcGhpY3MATlJGAEJsdWV0b290aABBcnJheQBBcnJheUJ1ZmZlcgBBcnJheUJ1ZmZlclZpZXcAVWludDhBcnJheQBVaW50OENsYW1wZWRBcnJheQBJbnQ4QXJyYXkAVWludDE2QXJyYXkASW50MTZBcnJheQBVaW50MjRBcnJheQBVaW50MzJBcnJheQBJbnQzMkFycmF5AEZsb2F0MzJBcnJheQBGbG9hdDY0QXJyYXkARGF0YVZpZXcARGF0ZQBFcnJvcgBTeW50YXhFcnJvcgBUeXBlRXJyb3IASW50ZXJuYWxFcnJvcgBSZWZlcmVuY2VFcnJvcgBGdW5jdGlvbgBjb25zb2xlAEpTT04ATnVtYmVyAE9iamVjdABCb29sZWFuAFJlZ0V4cABTdHJpbmcATW9kdWxlcwBNYXRoAGZzAHByb2Nlc3MAT25lV2lyZQBQcm9taXNlAFNlcmlhbABTdG9yYWdlRmlsZQBTUEkASTJDAFdhdmVmb3JtAEFFUwBURk1pY3JvSW50ZXJwcmV0ZXIAAKprKCl7sXtCYW5nbGUuYnV6eigzMCl9Y2F0Y2goYil7fX2sYT17fTujKNEGb2JqZWN0ir9knihhPWQsZD1hLm1vZGUsIWQpKbBFcnJvcijRHE1pc3NpbmcgbW9kZSBpbiBzZXRVSSh7Li4ufSkpO6xtPSEwO2dsb2JhbC5XSURHRVRTnldJREdFVFMuYmFja54obT0hMSxXSURHRVRTLmJhY2sucmVtb3ZlKGSeYS5iYWNrKSk7QmFuZ2xlLmJ0bldhdGNoZXOeKEJhbmdsZS5idG5XYXRjaGVzLmZvckVhY2goY2xlYXJXYXRjaCksvkJhbmdsZS5idG5XYXRjaGVzKTtCYW5nbGUuc3dpcGVIYW5kbGVynihCYW5nbGUucmVtb3ZlTGlzdGVuZXIo0QVzd2lwZSxCYW5nbGUuc3dpcGVIYW5kbGVyKSy+QmFuZ2xlLnN3aXBlSGFuZGxlcik7QmFuZ2xlLmRyYWdIYW5kbGVynihCYW5nbGUucmVtb3ZlTGlzdGVuZXIo0QRkcmFnLEJhbmdsZS5kcmFnSGFuZGxlciksvkJhbmdsZS5kcmFnSGFuZGxlcik7QmFuZ2xlLnRvdWNoSGFuZGxlcp4oQmFuZ2xlLnJlbW92ZUxpc3RlbmVyKNEFdG91Y2gsQmFuZ2xlLnRvdWNoSGFuZGxlciksvkJhbmdsZS50b3VjaEhhbmRsZXIpO75CYW5nbGUudWlSZWRyYXc7vkJhbmdsZS5DTE9DSzujKEJhbmdsZS51aVJlbW92ZSl7rWI9QmFuZ2xlLnVpUmVtb3ZlO75CYW5nbGUudWlSZW1vdmU7YigpfWcucmVzZXQoKTujKGQpe6Mo0QZ1cGRvd26KZCl7oyhhLmRyYWcpsEVycm9yKNExQ3VzdG9tIGRyYWcgaGFuZGxlciBub3Qgc3VwcG9ydGVkIGluIG1vZGUgdXBkb3duISk7rGY9MDtCYW5nbGUuZHJhZ0hhbmRsZXI9YqJ7ZpZiLmR5O6coYi5ioChmPTApOzMyPE1hdGguYWJzKGYpOykwPGY/KGaXMzIsZSgxKSk6KGaWMzIsZSgtMSkpLEJhbmdsZS5idXp6KDIwKX07QmFuZ2xlLm9uKNEEZHJhZyxCYW5nbGUuZHJhZ0hhbmRsZXIpO0JhbmdsZS50b3VjaEhhbmRsZXI9YqJ7aygpO2UoKX07QmFuZ2xlLmJ0bldhdGNoZXM9W3NldFdhdGNoKKooKXtrKCk7ZSgpfSxCVE4xLHtyZXBlYXQ6MSxlZGdlOtEGcmlzaW5nfSldfaSjKNEJbGVmdHJpZ2h0imQpe6MoYS5kcmFnKbBFcnJvcijRNEN1c3RvbSBkcmFnIGhhbmRsZXIgbm90IHN1cHBvcnRlZCBpbiBtb2RlIGxlZnRyaWdodCEpO6xoPTA7QmFuZ2xlLmRyYWdIYW5kbGVyPWKie2iWYi5keDunKGIuYqAoaD0wKTszMjxNYXRoLmFicyhoKTspMDxoPyholzMyLGUoMSkpOiholjMyLGUoLTEpKSxCYW5nbGUuYnV6eigyMCl9O0JhbmdsZS5vbijRBGRyYWcsQmFuZ2xlLmRyYWdIYW5kbGVyKTtCYW5nbGUudG91Y2hIYW5kbGVyPWKie2soKTtlKCl9O0JhbmdsZS5idG5XYXRjaGVzPVtzZXRXYXRjaCiqKCl7aygpO2UoKX0sQlROMSx7cmVwZWF0OjEsZWRnZTrRBnJpc2luZ30pXX2koyjRBWNsb2NrimQpQmFuZ2xlLkNMT0NLPTEsQmFuZ2xlLmJ0bldhdGNoZXM9W3NldFdhdGNoKEJhbmdsZS5zaG93TGF1bmNoZXIsQlROMSx7cmVwZWF0OjEsZWRnZTrRBnJpc2luZ30pXTukoyjRC2Nsb2NrdXBkb3duimQpQmFuZ2xlLkNMT0NLPTEsQmFuZ2xlLnRvdWNoSGFuZGxlcj0oYixjKaJ7MTIwPmMueKAoaygpLGUoODg8Yy55PzE6LTEpKX0sQmFuZ2xlLmJ0bldhdGNoZXM9W3NldFdhdGNoKEJhbmdsZS5zaG93TGF1bmNoZXIsQlROMSx7cmVwZWF0OjEsZWRnZTrRBnJpc2luZ30pXTukoyjRBmN1c3RvbYpkKWEuY2xvY2ueKEJhbmdsZS5idG5XYXRjaGVzPVtzZXRXYXRjaChCYW5nbGUuc2hvd0xhdW5jaGVyLEJUTjEse3JlcGVhdDoxLGVkZ2U60QZyaXNpbmd9KV0pO6SwRXJyb3Io0RBVbmtub3duIFVJIG1vZGUgK0UudG9KUyhkKSk7YS5jbG9ja54oQmFuZ2xlLkNMT0NLPTEpO2EudG91Y2ieKEJhbmdsZS50b3VjaEhhbmRsZXI9YS50b3VjaCk7YS5kcmFnnihCYW5nbGUuZHJhZ0hhbmRsZXI9YS5kcmFnLEJhbmdsZS5vbijRBGRyYWcsQmFuZ2xlLmRyYWdIYW5kbGVyKSk7YS5zd2lwZZ4oQmFuZ2xlLnN3aXBlSGFuZGxlcj1hLnN3aXBlLEJhbmdsZS5vbijRBXN3aXBlLEJhbmdsZS5zd2lwZUhhbmRsZXIpKTshYS5idG6eIWEuYnRuUmVsZWFzZaBCYW5nbGUuYnRuV2F0Y2hlc6AoQmFuZ2xlLmJ0bldhdGNoZXM9W10pO2EuYnRunkJhbmdsZS5idG5XYXRjaGVzLnB1c2goc2V0V2F0Y2goYS5idG4uYmluZChhKSxCVE4xLHtyZXBlYXQ6MSxlZGdlOtEGcmlzaW5nfSkpO2EuYnRuUmVsZWFzZZ5CYW5nbGUuYnRuV2F0Y2hlcy5wdXNoKHNldFdhdGNoKGEuYnRuUmVsZWFzZS5iaW5kKGEpLEJUTjEse3JlcGVhdDoxLGVkZ2U60QdmYWxsaW5nfSkpO2EucmVtb3ZlnihCYW5nbGUudWlSZW1vdmU9YS5yZW1vdmUpO2EucmVkcmF3nihCYW5nbGUudWlSZWRyYXc9YS5yZWRyYXcpO6MoYS5iYWNrKXusbj0oYixjKaJ7MzY+Yy55njQ4PmMueJ4oYy5oYW5kbGVkPSEwLEUuc3RvcEV2ZW50UHJvcGFnYXRpb24oKSxhLmJhY2soKSl9O0JhbmdsZS5vbijRBXRvdWNoLG4pO6MoQmFuZ2xlLnRvdWNoSGFuZGxlcil7rHA9QmFuZ2xlLnRvdWNoSGFuZGxlcjtCYW5nbGUudG91Y2hIYW5kbGVyPShiLGMpontjLmhhbmRsZWSgcChiLGMpfTtCYW5nbGUub24o0QV0b3VjaCxCYW5nbGUudG91Y2hIYW5kbGVyKX2sbDvAMItCYW5nbGUuYnRuV2F0Y2hlc54obD1zZXRXYXRjaCiqKCl7bD3AMDthLmJhY2soKX0sQlROMSx7ZWRnZTrRBnJpc2luZ30pKTtXSURHRVRTPU9iamVjdC5hc3NpZ24oe2JhY2s6e2FyZWE60QJ0bCx3aWR0aDoyNCxkcmF3OmKiZy5yZXNldCgpLnNldENvbG9yKNEEI2YwMCkuZHJhd0ltYWdlKNFMGBiBAAAYAAH/gAf/4A//8B//+D///D///H/P/n+H/n8P/n4f/vwAP/wAP34f/n8P/n+H/n/P/j///D///B//+A//8Af/4AH/gAAYACxiLngsYi55KSxyZW1vdmU6YqJ7rGM9V0lER0VUUy5iYWNrO9ECdGyMYy5hcmVhnihiPSEwKTtsnmNsZWFyV2F0Y2gobCk7QmFuZ2xlLnJlbW92ZUxpc3RlbmVyKNEFdG91Y2gsbik7YqBnLnJlc2V0KCkuY2xlYXJSZWN0KHt4OmMueCx5OmMueSx3OjI0LGg6MjR9KTu+V0lER0VUUy5iYWNrO2KgQmFuZ2xlLmRyYXdXaWRnZXRzKCl9fX0sZ2xvYmFsLldJREdFVFMpO22eQmFuZ2xlLmRyYXdXaWRnZXRzKCl9pKMoQmFuZ2xlLnRvdWNoSGFuZGxlcilCYW5nbGUub24o0QV0b3VjaCxCYW5nbGUudG91Y2hIYW5kbGVyKX0A0QZzdHJpbmeKv2GeKGE9e3RpdGxlOmF9KTthPWGge307YS5idXR0b25zPXtPazoxfTthLmltZz1yZXF1aXJlKNEKaGVhdHNocmluaykuZGVjb21wcmVzcyjRgJRKOFAaL/v//wSDIIBVQAEBwQKGCBAUNUASHBQSHQASHAQQFVB2LFQ4MHhA4IHhC0OCShgHD/gMgxgHDtgMgwSSOgwSJAQS6SgwSIABATigRAAUshjGMCUxiJAVmm0SXenVSMNAQSCMgxgGCQRkGMBA8MHAg8MHAgAEORQUMBQwKTurRS5zaG93UHJvbXB0KGIsYSkAqnkoYSxiKXusYz1hLnN0ZXCgMTujKCFhLm5vTGlzdJ7AMI1hLm1pbp7AMI1hLm1heJ4yMD4oYS5tYXgtYS5taW4pL2MpRS5zaG93U2Nyb2xsZXIoe2g6NDAsYzooYS5tYXgrYy1hLm1pbikvYyxiYWNrOnQscmVtb3ZlOm4ucmVtb3ZlLHNjcm9sbE1pbjotMjQsc2Nyb2xsOi0yNCxkcmF3OihrLGUponujKDA+aymrZy5zZXRGb250KNEFMTJ4MjApLnNldEZvbnRBbGlnbigtMSwwKS5kcmF3U3RyaW5nKNEYAAwMgQD///8AAAAAD///8AAAAAD///8gK2IsZS54KzEyLGUueSs0MC0xMik7Zy5zZXRDb2xvcihnLnRoZW1lLmJnMikuZmlsbFJlY3Qoe3g6ZS54KzQseTplLnkrMix3OmUudy04LGg6ZS5oLTQscjo1fSk7az1rKmMrYS5taW47Zy5zZXRDb2xvcihnLnRoZW1lLmZnMikuc2V0Rm9udCjRBTEyeDIwKS5zZXRGb250QWxpZ24oLTEsMCkuZHJhd1N0cmluZyhhLmZvcm1hdD9hLmZvcm1hdChrLDEpOmssZS54KzEyLGUueSsyMCk7Zy5kcmF3SW1hZ2UoYXRvYihrimEudmFsdWU/0UhGQlNCQUFINEFIL2dIZ2VEZ0J3dzhNWS94bWYrYkgvanovODgvL1BQL3p6Lzg4ZitObi9tWS94akR3dzRBY0hnZUFmK0FCK0E60UhGQlNCQUFINEFIL2dIZ2VEZ0J3d0FNWUFCbUFBYkFBRHdBQThBQVBBQUR3QUE4QUFOZ0FHWUFCakFBdzRBY0hnZUFmK0FCK0EpLGUueCtlLnctMzIsZS55KzIwLTEwKX0sc2VsZWN0Oqooayl7oyghKDA+aykpe0JhbmdsZS5idXp6KDIwKTthLnZhbHVlPWEubWluK2sqYzujKGEub25jaGFuZ2UpYS5vbmNoYW5nZShhLnZhbHVlKTt1LnNjcm9sbD1xLnNjcm9sbGVyLnNjcm9sbDt0KCl9fX0pO6R7rGQ9QmFuZ2xlLmFwcFJlY3QsZj1hLnZhbHVlO2cucmVzZXQoKS5jbGVhclJlY3QoZCk7Zy5zZXRGb250KNEFMTJ4MjApLnNldEZvbnRBbGlnbigwLDApLmRyYXdTdHJpbmco0RgADAyBAP///wAAAAAP///wAAAAAP///yArYixkLngrZC53LzIsZC55KzEyKTuqaygpe6xoPWQueCtkLncvMixtPTEyK2QueStkLmgvMix3PWEuZm9ybWF0P2EuZm9ybWF0KGYsMik6ZjtnLnJlc2V0KCkuc2V0Q29sb3IoZy50aGVtZS5iZzIpLmZpbGxSZWN0KHt4OmQueCsyNCx5OmQueSszNix3OmQudy00OCxoOmQuaC00OCxyOjV9KTtnLnNldENvbG9yKGcudGhlbWUuZmcyKS5zZXRGb250VmVjdG9yKE1hdGgubWluKDMwLDEwMCooZC53LTUyKS9nLnNldEZvbnRWZWN0b3IoMTAwKS5zdHJpbmdXaWR0aCh3KSkpLnNldEZvbnRBbGlnbigwLDApLmRyYXdTdHJpbmcodyxoLG0pO2cuZmlsbFBvbHkoW2gsbS00NSxoKzE1LG0tMzAsaC0xNSxtLTMwXSkuZmlsbFBvbHkoW2gsbSs0NSxoKzE1LG0rMzAsaC0xNSxtKzMwXSl9qmUoaCl7oyhoKWaXKGigMSkqKGEuc3RlcKAxKSzAMI1hLm1pbp5mPGEubWlunihmPWEud3JhcD9hLm1heDphLm1pbikswDCNYS5tYXieZj5hLm1heJ4oZj1hLndyYXA/YS5taW46YS5tYXgpLGsoKTuke2EudmFsdWU9ZjujKGEub25jaGFuZ2UpYS5vbmNoYW5nZShhLnZhbHVlKTt1LnNjcm9sbD1xLnNjcm9sbGVyLnNjcm9sbDt0KCl9fWsoKTusbD0wO0JhbmdsZS5zZXRVSSh7bW9kZTrRBmN1c3RvbSxiYWNrOnQscmVtb3ZlOm4ucmVtb3ZlLHJlZHJhdzprLGRyYWc6aKJ7bJZoLmR5O6coaC5ioChsPTApOzMyPE1hdGguYWJzKGwpOykwPGw/KGyXMzIsZSgxKSk6KGyWMzIsZSgtMSkpLEJhbmdsZS5idXp6KDIwKX0sdG91Y2g6KGgsbSmie0JhbmdsZS5idXp6KDIwKTs4Mj5tLnk/ZSgtMSk6MTQyPG0ueT9lKDEpOmUoKX19KX19qnQoKXtxLnNjcm9sbGVyPUUuc2hvd1Njcm9sbGVyKHUpfaMowDCLcCmrZy5jbGVhclJlY3QoQmFuZ2xlLmFwcFJlY3QpLEJhbmdsZS5zZXRVSSgpO6xuPXBbIiJdoHt9O24udGl0bGWgKG4udGl0bGU90QRNZW51KTusdj1uLmJhY2ugcFvRBjwgQmFja10scj1PYmplY3Qua2V5cyhwKS5maWx0ZXIoYaIiIo1hntEGPCBCYWNrjGEpO3IuZm9yRWFjaChhonthPXBbYV070QZvYmplY3SMv2Gg0Qdib29sZWFujL9hLnZhbHVloGEuZm9ybWF0oChhLmZvcm1hdD1iotEBACthdG9iKGI/0TxFaEtCQUgvL3YvLy8vLy8vLy8vLy8vNS8veC8vai8vSCtlUCtNZi9BLy9oLy96Ly8vLy8vLy8vLzMvL2c60TxFaEtCQUgvL3YvLzhBQThBQThBQThBQThBQThBQThBQThBQThBQThBQThBQThBQThBQThBQS8vLzMvL2cpKX0pO6xxPXtkcmF3OigponEuc2Nyb2xsZXIuZHJhdygpLHNjcm9sbGVyOsAwfTuteDusdT17aDo0MCxjOnIubGVuZ3RoLHNjcm9sbE1pbjotMjQsc2Nyb2xsOraMKHg9bi5zY3JvbGwpP3g6LTI0LGJhY2s6dixyZW1vdmU6bi5yZW1vdmUsZHJhdzooYSxiKaJ7oygwPmEpq2cuc2V0Q29sb3IoZy50aGVtZS5mZykuc2V0Rm9udCjRBTEyeDIwKS5zZXRGb250QWxpZ24oLTEsMCkuZHJhd1N0cmluZyjRGAAMDIEA////AAAAAA////AAAAAA////ICtuLnRpdGxlLGIueCsxMixiLnkrNDAtMTIpO2cuc2V0Q29sb3IoZy50aGVtZS5iZzIpLmZpbGxSZWN0KHt4OmIueCs0LHk6Yi55KzIsdzpiLnctOCxoOmIuaC00LHI6NX0pO2cuc2V0Q29sb3IoZy50aGVtZS5mZzIpLnNldEZvbnQo0QUxMngyMCk7rGM9MjQsZD1wW3JbYV1dO6Mo0QZvYmplY3SKv2Qpe6xmPWQudmFsdWU7ZC5mb3JtYXSeKGY9ZC5mb3JtYXQoZikpO2cuc3RyaW5nTWV0cmljcyhmKS53aWR0aD5iLncvMp4oZj1nLndyYXBTdHJpbmcoZixiLncvMikuam9pbijRAQopKTtnLnNldEZvbnRBbGlnbigxLDApLmRyYXdTdHJpbmcoZixiLngrYi53LTgsYi55KzIwKTtjlmcuc3RyaW5nV2lkdGgoZil9pNEIZnVuY3Rpb26Kv2SeKGcuZHJhd0ltYWdlKNEZCRKBAGA4Hg8DwPB4HgcDg8PB4eHg8HAwACxiLngrYi53LTIxLGIueSsyMC05KSxjljE2KTusbDthPbaMKGw9ZJ5kLnRpdGxlKT9sOnJbYV07bD1nLndyYXBTdHJpbmcoYSxiLnctYyk7MTxsLmxlbmd0aJ4obD1nLnNldEZvbnQo0QQ2eDE1KS53cmFwU3RyaW5nKGEsYi53LWMpKTtnLnNldEZvbnRBbGlnbigtMSwwKS5kcmF3U3RyaW5nKGwuam9pbijRAQopLGIueCsxMixiLnkrMjApfSxzZWxlY3Q6qihhLGIpe6MoMD5hKat2nnYoKTusYz1wW3JbYV1dO0JhbmdsZS5idXp6KDIwKTujKNEIZnVuY3Rpb26Kv2MpYyhiKTukoyjRBm9iamVjdIq/YymjKNEGbnVtYmVyir9jLnZhbHVlKXkoYyxyW2FdKTuke9EHYm9vbGVhboq/Yy52YWx1ZZ4oYy52YWx1ZT0hYy52YWx1ZSk7oyhjLm9uY2hhbmdlKWMub25jaGFuZ2UoYy52YWx1ZSxiKTtxLnNjcm9sbGVyLmlzQWN0aXZlKCmecS5zY3JvbGxlci5kcmF3SXRlbShhKX19fTt0KCk7q3EAZw==");
  base64DecodeToExistingUint8Array(bufferView, 166448, "alXqH0ItwEdCXwAEliQWcwNTBgOHBAAAABAAEAIgx0ESRCAAkj11UpVUFXP6HQAA3yVkWnY0qRqWJAAAAAAAAJIuABGSLiAAlixpW3pN4FtaLQAA/lclWbV7JVs+VwAAT1mKeYp5anlXfwAAlWVvW29br28VVwAAe1tUW1J7UX/WVQAA7U9tSLooFRnVHwAAFwgpZAEQAXDHcQAARBDeJGV/ZSneJgAAoEQzUK1tq1TpVQYIBgCyZXpbelt/ZQBAAATrXrVVZVSjMwEAAABte70qf0d6cwAMk3eSfNZwknCTcQBwAwAEAAYABgAEAAMAQAGSCUQppxVEfSoIBChHGgSogiQA/LokBCg3GwAAAgBEIAAAhBAAAAQJRQAACUIAAIn/AQAJQgiAEEUIQCAAEAAEAAAACEccAIjJIgCQSgMfkEocgKBMIIAg9z8AQAAAAAAAAE588x3RQBQiRnkvHEGGSCLxx4giTjiHHAAAAAAAAAAADgABIJEQAhCREPQJDwAIBIEQ9AmOEAIQACABIMABAAAuEu84cZIYJaIqDyOkuggjYMYYJQRG7zjgAQAAAAAAAP+76A4QwkgCnMNPAhDeSCIQxkgiH7roHAAAAAAAAAAAEcboPBLuHCMU1hojHMYZPRLGGCHxx+ggAAAAAAAAAADOux8jMUISI9E7EiMxBhIVMkYSFS064ggBAAAAAADgIDHGjxBRRYEQlSiCCFURhAguEogEKpKPBAAA4AKOAAQgggACIEIB4DxCARAiIgLwIgIAECMCAPA8DnwAACCAAyAgAAQg7jn/PDBGFCMwfhQjMEL0Iu89FCIAAOAAREAGAABAAgDMRaI9REhSI0RwUiNESFIjTkRTI4ADAAAAAAAQAAAAEM4/6zwxxgwRMUboENE/GBAOBugPAAY=");
  base64DecodeToExistingUint8Array(bufferView, 167144, "McYYPzFGFQVRVRIJUVX1EI+oGD4AAOAAg2AADIQQABKEEAA4mIwEEJiMCjiEEAkShBAADINgAAAADAAAABAACAAQAAgAOAA+ABAACICRDQiAkFQJAGEJCARkAgCEaAceXxEoKAQgRywEwIAoH+xIKARsJx4EAAAAgABAGOADgAhPAMAQlAAAABYBAAAUAgAA7wMAAAAAAABpAwAAMgEAGlsSACwAOAAAAHz3AQA4AAAAEAAAAAAAAIAAAAgfAAAAy0EFPguiCgTAEQsIICAKEMDDBT4AAAAAAAACABEAYgAREIciCgDKHQQQihQEkIccBBByIwAQAgCROOUYkUAQBYowUB0fSJAlBCSQHZ8YUAGEBBABgHjgAAAA9xkAgAgkBYAOJAqADRjUgw4ASoANAEWACAAAAAcAgDEBAEQIkh6EEJA6HwmQGsQx0AoEAKAKHwCACgAAAAsAEAYkADAJJAAQSSkMEKkIDDhWEgABoBaAAEAvAAMAIhICZhxSAQAAVBJCCIQBpRSLEuccKaEYI3LFGCMzOgAAVhEAGISA4z6EEBYhSikLOc45DiExRhohMcbrPgAAQABGAWYc/3/nHBBCQgicc0IIEEJCCBBCQgj/f+ccAAAAAApYZhSOReccROUYI6TXGCMkzRgjRMUYI45F5xwAAAAAVoHADM4BFyMxghkjMaoaIzGSGiMxqhwjzgHnHAAACABKEQAYMUbIADFGLx0xqkgDMZI4HzESHyPOEWgfAAAAAMRZpQAAAEAAzjnnPCGEEArvvfc+McYYKe+99xYAAAAAgBmlGAAAAADOOecYMMYYCdB77wkQQggJ7733HAQAAABGKWUZAAAGAIwx4R2EEBcjhJAYI4SQGCPOORcdAAAAAEZZBQAAAAACzjlHHDHGCCYxxvgrMcYIMs45RxwAAAAgzChFIAAAACAxxhgtMcYYMzHGGDMxxvgs770XIAAA4CAKAAAAAAAAABEAAAARAAAAEQAAAA8AAAABAAAADgAAAAQEBAQEBAQEBB4EFRUeDAwEBAQEBAYEBAoKBAQLDg0KBgwHGBAEBAYEBAYLBCsMGxgUDAoGDAwQDAYOCh8QBAQOCAQHEAQECQoIBAgGBAQEFgQUBBUJBAwLBAQJBAwLBAQJHAkQBw8EBAkEChsEGxIWBAQEBBQEEQQeBAQEBAQeFAYGBhIOEAQEBAQEBAQLBgYECwsMEhMEBAQHCAQEFRQLBAQHBAQEBAwHBAQUBAQEBAQSGwQEBwgEBBUmCwQEBAQHCAQEBAQEBAAAAAAAAACpq8XDJymRjycpXVsqLGBeKy3HxS8xy8mCjaecT1p0aR0e1NMqKzpVU0VEUF1rbHuWo7zHxrecnqytoZSGhXZbTjUuMMXDKCo4Ul5dQVBFXUQpRTZBKUJdXE40lZelv8vKrr2yyrGWsqOulq/KybuhLDdQa8vNbVJGVGB2j5y3xsi9sX99lq6snpGFb1Y7HR9Eap7G7+3EnGhCGhxFbaHH7OrFn2tDKiyUkjVOiXA7VoNoaHCKgkRGrqyqrMbf3cRobYeCISPS0CosO1ZURkRQTjWcnqyuoqS9yMa3TlCenFRWpKIqLK6xy8OprERbQVRWY3yfuKuxy8OpkG1hVFZjfJekopWHhWttYSwuyshThIqknIInL0lDaoJeYG+KpKKIeniEgmknL0nHxUdBTlBda21hVFZjiG6XpKKVh4WRnpyPaoRbTlBqeHpuVFakooiJlJKDaFtdd3VcXnh2SWN5l7F1TlZwaIKKpJxBW3mPqX1UVmN8h5SSeGxtYayuyMZFSVhmgajAv6KWiJSisbytknlufZimpZmMcWJga4SeucjN2uXh0sSpdVxQKy3Ny1OknoWJU8XDJyw7VmN8bn2Ypb7Jxauvo5aIhGptYVRGQ8XDKy49S1ZHRlFqhJ+ur6Szv8rHuKqPW0I2Jyw7SWSYsb3IxautoolvVEVDxcMnL0lDam6IhKuxy8MnL0lDam6IhMXDe3+zsZeVJylqby4wzMqJhMXDJytFRKytx8OpqkJBLjClvsnGt5yRrJ6trqOvlicpdy4weczKhZHFwycpq7HLwycplZQwMs7MZK+uXcXDJymWLjDMyl3FwysuPUtmmrO/ysiur6SLcVZHRlFqhJ+uyMe4qo9bQjYnLDtWcImUkXd6blRGQ8XDsbzm24aIzMpOUF1rbXyXpKKVh4V2WycxS0fJx0VBJymenCcpoS8xyccnKcjGLC7MyjEzzMosLsjGJynNyy8xxcMnKW0vMYjJx4YnL0mrscvDqUdBGh85NtLV7+oaHNnXGh/v6tDTNzQrdXdSe33Q2PLqJylSUGBiysheX26Jo7zHraGHeXiEnqytx8a3nIJpJynFw15fbomHeXiEnqytoaO8x8a3nIJpLC7KyF5fbomjnoSHeXiEnqyuvMfGt5yCaSssRkVRxsRPNltgenVgYsrj7u3e0MTT1MheX26JysiHeXiEaVtdxcMnKUNBXV/H4Ovq0NHFKStFQycpkWBik8rIn6vFw2Nkc47PzYx+fYluW13s6mBi8e9eX258h3l4hGleX258iHl4hHeFhpWjvMfGt6mdrK2hrqCfkIJpKCqfra7Ix7idW12erK2hYGLKyLu8x8a3nFtdoGFjyMZbXcjGYGLMymVnzMqVyMZbXcvJYWPFw2JkyOHs69HSxltdrsdbYnyssMrDqXl1HyA6OUVfeISSrcfV1vDv4MWrkJ6PdWp2XUMqGhzs6hobKkVfemx7laCUrcfg6+rQ0cWrkoZ4XUM1NFFcdYKEd2t5lKOYf3JwfYl7YCwvPldIR1JrhaCvsKXAy8i5q5BcQzdocH11goqXj0FDXVt1d9/dUVJhfHpsa3eRn6CUlq+6uaqPdVxERcfGKyw7SVRGRVGSq7HLw6mQTzZoboiCQk5cdZCcqp6tlJKEal5gboiUraKwpJZ9YlZIVEVQdn6Lg5CYpZ2PkezqGhx3dSstR0UrLz5MZ5u0wMu+s5pmSzw4Q1yQq7q+y8e4qo9bQjZGSFdycGJgbIaUloqMpbCun4RqUV5shKCsgmFvh6OvhWhwsa+IgisvPDhDXJCrur7Lx7iqj1tCNi88S2aas77LwLSbZ0w+REhkfoqysIiWlHp8YmCurCcvSUE3OaGfqbHLw1tjfXUpK1BOnLjs6oKEnpzExdPg7Ord3tLf0V9rh5+tiVxohJyqhi8xxsQpKl5fbGlcXTZCNYqLzMuKi7CzwLyviYuZpr7Azcq9pZiWKCo4RVFEUl9raVxeUVBDRDc1eHqUoJ+ruMbIvL7X4uDRtqmQhURGYF4DBSAfBQcfHgQGIiASHhwEDxwRIBUIEwIEHhwGCCIgBAYULjo5HSwhOSAFIRIdBR45OCoQLDNNSXBzjYqxtc/Jop+GiEcuxcPIydfk8O7h4tbj1QIEHx4EBh4dAwUhHxEdGwEDHRsFByEfAAIdHAIEHBsoLEZFra7IxKqrQ0ICBCAeEBwaAAIcGgQGIB4oLTxKZZmyvsnGrK6jinBVRkTGxAQGISBCTrCkSFaqnDAyxcMnKZGcJylDRlVwiqOuq5GUiG5gXcXDKis6VWJue5exvcjGrK6ilXlsYFNFRFDFw041KStGRSosREMqLEhGOERCKjVCN0Y7LjkoKkRCLC5IRh0fLUdTUjZFOlI5HjorNh43UlFDKV5fbmNkc46oo4mMfn2Jo7GzwczLvMfFqZyEh6Gfq56sraGHeXdpxsfV4u7s3+DU4dNcXsbEJylEQygqQkFdX8fFKStHRTdDQSk1RF+JfFQ4LDpdT5KUrqxgYsXDKy1FRCcp7OotL0lHAAAAAAABAgMEBQYHCAkKCwwNAg4PEBESExQVFgAXGBkaGxwdGB4YGR8gGSEhGRgaIiMYGSQZGCUAFSYnKCkqKywYLS4vMDEyMzQwNTY3ODk6Ozw9Pjw/PUAYGUFCN0NERUZHSElKS0xNTk9QUFFSUFNUVVZXUFhRWVpbXF1RWFleWFlQUF9QYGFZYmNWZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7R3x9Wn5/gIGCg4SFhocLiImKi4xkjY6PkJGSk5GUkpGTlZaXmC6ZLpoumy6cnS6eLp8woDKhMqIyozKkpTamNqeoqaiqq6wWO5utPJk8mjybPJydPK6vsDyYsTeisTeasTecnbE3R5mys7RPULVPULZPULdPULi5T1BPULq7UrxUtFS1VLZUuLm9vlm/wMHAWn5QwsO3WFlQtFC1ULZQt1C4uROXxFDFZLRktWS2ZLi5aWrGx1BpalzIAAAAAAACAgQCAwEBAQEDAgEBAQEEAQIDAQMEAQMDAgIBAgEDAQEBAQEBAQIBAQEBAQEBAQECAgMBAgEBAgEBAQEBAQEBAgIBAgECAgICAgEBAwIBAgICAQIBAQECAgEBAQEBAAM=");
  base64DecodeToExistingUint8Array(bufferView, 170496, "AgICAQMCAAICAAIBAAMBAQMAAAECAAEBAAACAwMDAgICAgIDAgECAgICAwICAgMCAgICAgIDAgIDAwMEAgEBAwMDAwQDAQICAgIDAgICAwMDAgICAgMDAgICAgMDAgQABCEUpRznDGMAAAAAAAAAAJgvikKRRDdxz/vAtaXbtelbwlY58RHxWaSCP5LVXhyrmKoH2AFbgxK+hTEkw30MVXRdvnL+sd6Apwbcm3Txm8HBaZvkhke+78adwQ/MoQwkbyzpLaqEdErcqbBc2oj5dlJRPphtxjGoyCcDsMd/Wb/zC+DGR5Gn1VFjygZnKSkUhQq3JzghGy78bSxNEw04U1RzCmW7Cmp2LsnCgYUscpKh6L+iS2YaqHCLS8KjUWzHGeiS0SQGmdaFNQ70cKBqEBbBpBkIbDceTHdIJ7W8sDSzDBw5SqrYTk/KnFvzby5o7oKPdG9jpXgUeMiECALHjPr/vpDrbFCk96P5vvJ4ccaA");
  base64DecodeToExistingUint8Array(bufferView, 170928, "Iq4o15gvikLNZe8jkUQ3cS87TezP+8C1vNuJgaXbtek4tUjzW8JWORnQBbbxEfFZm08Zr6SCP5IYgW3a1V4cq0ICA6OYqgfYvm9wRQFbgxKMsuROvoUxJOK0/9XDfQxVb4l78nRdvnKxlhY7/rHegDUSxyWnBtyblCZpz3Txm8HSSvGewWmb5OMlTziGR77vtdWMi8adwQ9lnKx3zKEMJHUCK1lvLOktg+SmbqqEdErU+0G93KmwXLVTEYPaiPl2q99m7lJRPpgQMrQtbcYxqD8h+5jIJwOw5A7vvsd/Wb/Cj6g98wvgxiWnCpNHkafVb4ID4FFjygZwbg4KZykpFPwv0kaFCrcnJskmXDghGy7tKsRa/G0sTd+zlZ0TDThT3mOvi1RzCmWosnc8uwpqduau7UcuycKBOzWCFIUscpJkA/FMoei/ogEwQrxLZhqokZf40HCLS8IwvlQGo1FsxxhS79YZ6JLREKllVSQGmdYqIHFXhTUO9LjRuzJwoGoQyNDSuBbBpBlTq0FRCGw3Hpnrjt9Md0gnqEib4bW8sDRjWsnFswwcOcuKQeNKqthOc+Njd0/KnFujuLLW828uaPyy713ugo90YC8XQ29jpXhyq/ChFHjIhOw5ZBoIAseMKB5jI/r/vpDpvYLe62xQpBV5xrL3o/m+K1Ny4/J4ccacYSbqzj4nygfCwCHHuIbRHuvgzdZ92up40W7uf0999bpvF3KqZ/AGppjIosV9YwquDfm+BJg/ERtHHBM1C3EbhH0EI/V32yiTJMdAe6vKMry+yRUKvp48TA0QnMRnHUO2Qj7LvtTFTCp+ZfycKX9Z7PrWOqtvy18XWEdKjBlEbIA=");
  base64DecodeToExistingUint8Array(bufferView, 171696, "AQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAbAAAANg==");
  base64DecodeToExistingUint8Array(bufferView, 171744, "Y3x3e/Jrb8UwAWcr/terdsqCyX36WUfwrdSir5ykcsC3/ZMmNj/3zDSl5fFx2DEVBMcjwxiWBZoHEoDi6yeydQmDLBobblqgUjvWsynjL4RT0QDtIPyxW2rLvjlKTFjP0O+q+0NNM4VF+QJ/UDyfqFGjQI+SnTj1vLbaIRD/89LNDBPsX5dEF8Snfj1kXRlzYIFP3CIqkIhG7rgU3l4L2+AyOgpJBiRcwtOsYpGV5HnnyDdtjdVOqWxW9Opleq4IunglLhymtMbo3XQfS72LinA+tWZIA/YOYTVXuYbBHZ7h+JgRadmOlJseh+nOVSjfjKGJDb/mQmhBmS0PsFS7FlH0p1B+QWVTGhekwzonXpY7q2vLH51F8az6WKtL4wOTIDD6Va12bfaIzHaR9QJMJU/l1/zFKsvXJjVEgLVio4/esVpJJbobZ0XqDphd/sDhwy91AoFM8BKNRpeja9P5xgOPX+cVkpyVv21665VSWdrUvoMtWHQh00ngaSmOychEdcKJavSOeXiZWD5rJ7lx3b7hT7bwiK0XySCsZn3OOrRj30oY5RoxgpdRM2BiU39FsWR34LtrroT+gaAc+QgrlHBIaFiPRf0ZlN5sh1J7+Lerc9MjcksC4uMfj1dmVasqsusoBy+1wgOGxXua0zcIpTAoh/Ijv6WyAgNquu0WglyKzxwrp3m0kvMH8vBOaeKhZdr0zQYFvtXRNGIfxKb+ijQuU52i81WgBYrhMqT263ULg+w5QGDvql5xnwa9bhBRPiGK+ZbdBj3dPgWuTea9RpFUjbVxxF0FBAbUb2BQFf8ZmPsk1r3pl4lAQ8xn2Z53sOhCvQeJi4jnGVs4ecju26F8Ckd8Qg/p+IQeyQAAAAAJgIaDMivtSB4RcKxsWnJO/Q7/+w+FOFY9rtUeNi05JwoP2WRoXKYhm1tU0SQ2LjoMCmexk1fnD7TultIbm5GegMDFT2HcIKJad0tpHBIaFuKTugrAoCrlPCLgQxIbFx0OCQ0L8ovHrS22qLkUHqnIV/EZha91B0zumd27o39g/fcBJp9ccvW8RGY7xVv7fjSLQyl2yyPG3Lbt/Gi45PFj1zHcykJjhRATlyJAhMYRIIVKJH3Suz34rvkyEccpoW0dni9L3LIw8w2GUux3wePQK7MWbKlwuZkRlEj6R+lkIqj8jMSg8D8aVn0s2CIzkO+HSU7H2TjRwYzKov6Y1As2pvWBz6V63ijat44mP62/pCw6neRQeJINal/Mm1R+RmL2jRPCkNi46C45916Cw6/1n12AvmnQk3xv1S2pzyUSs8ismTsQGH2n6Jxjbts7u3vNJngJblkY9OyatwGDT5qo5pVuZar/5n4hvM8I7xXo5rrnm9lKbzbO6p8J1CmwfNYxpLKvKj8jMcallDA1ombAdE68N/yCyqbgkNCwM6fYFfEEmEpB7Nr3f81QDheR9i92TdaNQ++wTcyqTVTklgTfntG140xqiBvBLB+4RmVRf51e6gQBjDVd+od0c/sLQS6zZx1aktvSUukQVjNt1kcTmtdhjDehDHpZ+BSO6xM8ic6pJ+63Yck14Rzl7XpHsTyc0t9ZVfJzPxgUznlzxze/U/fN6l/9qlvfPW8UeETbhsqv84G5aMQ+OCQ0LMKjQF8WHcNyvOIlDCg8SYv/DZVBOagBcQgMs97YtOScZFbBkHvLhGHVMrZwSGxcdNC4V0JQUfSnU35BZcMaF6SWOideyzura/EfnUWrrPpYk0vjA1UgMPr2rXZtkYjMdiX1Akz8T+XX18Uqy4AmNUSPtWKjSd6xWmcluhuYReoO4V3+wALDL3USgUzwo41Gl8Zr0/nnA49flRWSnOu/bXralVJZLdS+g9NYdCEpSeBpRI7JyGp1wol49I55a5lYPt0nuXG2vuFPF/CIrWbJIKy0fc46GGPfSoLlGjFgl1EzRWJTf+CxZHeEu2uuHP6BoJT5CCtYcEhoGY9F/YeU3my3Unv4I6tz0+JySwJX4x+PKmZVqwey6ygDL7XCmobFe6XTNwjyMCiHsiO/pboCA2pc7RaCK4rPHJKnebTw8wfyoU5p4s1l2vTVBgW+H9E0YorEpv6dNC5ToKLzVTIFiuF1pPbrOQuD7KpAYO8GXnGfUb1uEPk+IYo9lt0Grt0+BUZN5r21kVSNBXHEXW8EBtT/YFAVJBmY+5fWvenMiUBDd2fZnr2w6EKIB4mLOOcZW9t5yO5HoXwK6XxCD8n4hB4AAAAAgwmAhkgyK+2sHhFwTmxacvv9Dv9WD4U4Hj2u1Sc2LTlkCg/ZIWhcptGbW1Q6JDYusQwKZw+TV+fStO6WnhubkU+AwMWiYdwgaVp3SxYcEhoK4pO65cCgKkM8IuAdEhsXCw4JDa3yi8e5LbaoyBQeqYVX8RlMr3UHu+6Z3f2jf2Cf9wEmvFxy9cVEZjs0W/t+dotDKdzLI8Zotu38Y7jk8crXMdwQQmOFQBOXIiCExhF9hUok+NK7PRGu+TJtxymhSx2eL/PcsjDsDYZS0HfB42wrsxaZqXC5+hGUSCJH6WTEqPyMGqDwP9hWfSzvIjOQx4dJTsHZONH+jMqiNpjUC8+m9YEopXreJtq3jqQ/rb/kLDqdDVB4kptqX8xiVH5GwvaNE+iQ2LheLjn39YLDr76fXYB8adCTqW/VLbPPJRI7yKyZpxAYfW7onGN72zu7Cc0mePRuWRgB7Jq3qINPmmXmlW5+qv/mCCG8z+bvFejZuuebzkpvNtTqnwnWKbB8rzGksjEqPyMwxqWUwDWiZjd0Trym/ILKsOCQ0BUzp9hK8QSY90Hs2g5/zVAvF5H2jXZN1k1D77BUzKpN3+SWBOOe0bUbTGqIuMEsH39GZVEEnV7qXQGMNXP6h3Qu+wtBWrNnHVKS29Iz6RBWE23WR4ya12F6N6EMjln4FInrEzzuzqknNbdhye3hHOU8ekexWZzS3z9V8nN5GBTOv3PHN+pT981bX/2qFN89b4Z4RNuByq/zPrloxCw4JDRfwqNAchYdwwy84iWLKDxJQf8NlXE5qAHeCAyznNi05JBkVsFhe8uEcNUytnRIbFxC0LhXp1BR9GVTfkGkwxoXXpY6J2vLO6tF8R+dWKus+gOTS+P6VSAwbfatdnaRiMxMJfUC1/xP5cvXxSpEgCY1o4+1YlpJ3rEbZyW6DphF6sDhXf51AsMv8BKBTJejjUb5xmvTX+cDj5yVFZJ6679tWdqVUoMt1L4h01h0aSlJ4MhEjsmJanXCeXj0jj5rmVhx3Se5T7a+4a0X8IisZskgOrR9zkoYY98xguUaM2CXUX9FYlN34LFkroS7a6Ac/oErlPkIaFhwSP0Zj0Vsh5Te+LdSe9Mjq3MC4nJLj1fjH6sqZlUoB7LrwgMvtXuahsUIpdM3h/IwKKWyI79qugIDglztFhwris+0kqd58vDzB+KhTmn0zWXavtUGBWIf0TT+isSmU500LlWgovPhMgWK63Wk9uw5C4PvqkBgnwZecRBRvW6K+T4hBj2W3QWu3T69Rk3mjbWRVF0FccTUbwQGFf9gUPskGZjpl9a9Q8yJQJ53Z9lCvbDoi4gHiVs45xnu23nICkehfA/pfEIeyfiEAAAAAIaDCYDtSDIrcKweEXJObFr/+/0OOFYPhdUePa45JzYt2WQKD6YhaFxU0ZtbLjokNmexDArnD5NXltK07pGeG5vFT4DAIKJh3EtpWncaFhwSugrikyrlwKDgQzwiFx0SGw0LDgnHrfKLqLkttqnIFB4ZhVfxB0yvdd277plg/aN/Jp/3AfW8XHI7xURmfjRb+yl2i0PG3Msj/Gi27fFjuOTcytcxhRBCYyJAE5cRIITGJH2FSj340rsyEa75oW3HKS9LHZ4w89yyUuwNhuPQd8EWbCuzuZmpcEj6EZRkIkfpjMSo/D8aoPAs2FZ9kO8iM07Hh0nRwdk4ov6Mygs2mNSBz6b13iileo4m2re/pD+tneQsOpINUHjMm2pfRmJUfhPC9o246JDY914uOa/1gsOAvp9dk3xp0C2pb9USs88lmTvIrH2nEBhjbuicu3vbO3gJzSYY9G5ZtwHsmpqog09uZeaV5n6q/88IIbzo5u8Vm9m65zbOSm8J1OqffNYpsLKvMaQjMSo/lDDGpWbANaK8N3ROyqb8gtCw4JDYFTOnmErxBNr3QexQDn/N9i8XkdaNdk2wTUPvTVTMqgTf5Ja1457RiBtMah+4wSxRf0Zl6gSdXjVdAYx0c/qHQS77Cx1as2fSUpLbVjPpEEcTbdZhjJrXDHo3oRSOWfg8iesTJ+7Oqck1t2Hl7eEcsTx6R99ZnNJzP1XyznkYFDe/c8fN6lP3qltf/W8U3z3bhnhE84HKr8Q+uWg0LDgkQF/Co8NyFh0lDLziSYsoPJVB/w0BcTmos94IDOSc2LTBkGRWhGF7y7Zw1TJcdEhsV0LQuPSnUFFBZVN+F6TDGideljqra8s7nUXxH/pYq6zjA5NLMPpVIHZt9q3MdpGIAkwl9eXX/E8qy9fFNUSAJmKjj7WxWkneuhtnJeoOmEX+wOFdL3UCw0zwEoFGl6ON0/nGa49f5wOSnJUVbXrrv1JZ2pW+gy3UdCHTWOBpKUnJyESOwolqdY55ePRYPmuZuXHdJ+FPtr6IrRfwIKxmyc46tH3fShhjGjGC5VEzYJdTf0ViZHfgsWuuhLuBoBz+CCuU+UhoWHBF/RmP3myHlHv4t1Jz0yOrSwLich+PV+NVqypm6ygHsrXCAy/Fe5qGNwil0yiH8jC/pbIjA2q6AhaCXO3PHCuKebSSpwfy8PNp4qFO2vTNZQW+1QY0Yh/Rpv6KxC5TnTTzVaCiiuEyBfbrdaSD7DkLYO+qQHGfBl5uEFG9IYr5Pt0GPZY+Ba7d5r1GTVSNtZHEXQVxBtRvBFAV/2CY+yQZvemX1kBDzInZnndn6EK9sImLiAcZWzjnyO7beXwKR6FCD+l8hB7J+AAAAACAhoMJK+1IMhFwrB5ack5sDv/7/YU4Vg+u1R49LTknNg/ZZApcpiFoW1TRmzYuOiQKZ7EMV+cPk+6W0rSbkZ4bwMVPgNwgomF3S2laEhoWHJO6CuKgKuXAIuBDPBsXHRIJDQsOi8et8raouS0eqcgU8RmFV3UHTK+Z3bvuf2D9owEmn/dy9bxcZjvFRPt+NFtDKXaLI8bcy+38aLbk8WO4MdzK12OFEEKXIkATxhEghEokfYW7PfjS+TIRrimhbceeL0sdsjDz3IZS7A3B49B3sxZsK3C5mamUSPoR6WQiR/yMxKjwPxqgfSzYVjOQ7yJJTseHONHB2cqi/ozUCzaY9YHPpnreKKW3jibarb+kPzqd5Cx4kg1QX8yban5GYlSNE8L22LjokDn3Xi7Dr/WCXYC+n9CTfGnVLalvJRKzz6yZO8gYfacQnGNu6Du7e9smeAnNWRj0bpq3AexPmqiDlW5l5v/mfqq8zwghFejm7+eb2bpvNs5KnwnU6rB81imksq8xPyMxKqWUMMaiZsA1Trw3dILKpvyQ0LDgp9gVMwSYSvHs2vdBzVAOf5H2LxdN1o1277BNQ6pNVMyWBN/k0bXjnmqIG0wsH7jBZVF/Rl7qBJ2MNV0Bh3Rz+gtBLvtnHVqz29JSkhBWM+nWRxNt12GMmqEMejf4FI5ZEzyJ66kn7s5hyTW3HOXt4UexPHrS31mc8nM/VRTOeRjHN79z983qU/2qW189bxTfRNuGeK/zgcpoxD65JDQsOKNAX8Idw3IW4iUMvDxJiygNlUH/qAFxOQyz3gi05JzYVsGQZMuEYXsytnDVbFx0SLhXQtDGY2Ol+Hx8hO53d5n2e3uN//LyDdZra73eb2+xkcXFVGAwMFACAQEDzmdnqVYrK33n/v4ZtdfXYk2rq+bsdnaaj8rKRR+Cgp2JyclA+n19h+/6+hWyWVnrjkdHyfvw8AtBra3ss9TUZ1+iov1Fr6/qI5ycv1OkpPfkcnKWm8DAW3W3t8Lh/f0cPZOTrkwmJmpsNjZafj8/QfX39wKDzMxPaDQ0XFGlpfTR5eU0+fHxCOJxcZOr2NhzYjExUyoVFT8IBAQMlcfHUkYjI2Wdw8NeMBgYKDeWlqEKBQUPL5qatQ4HBwkkEhI2G4CAm9/i4j3N6+smTicnaX+yss3qdXWfEgkJGx2Dg55YLCx0NBoaLjYbGy3cbm6ytFpa7lugoPukUlL2djs7TbfW1mF9s7POUikpe93j4z5eLy9xE4SEl6ZTU/W50dFoAAAAAMHt7SxAICBg4/z8H3mxsci2W1vt1Gpqvo3Ly0Znvr7Zcjk5S5RKSt6YTEzUsFhY6IXPz0q70NBrxe/vKk+qquXt+/sWhkNDxZpNTddmMzNVEYWFlIpFRc/p+fkQBAICBv5/f4GgUFDweDw8RCWfn7pLqKjjolFR812jo/6AQEDABY+Pij+Skq0hnZ28cDg4SPH19QRjvLzfd7a2wa/a2nVCISFjIBAQMOX//xr98/MOv9LSbYHNzUwYDAwUJhMTNcPs7C++X1/hNZeXoohERMwuFxc5k8TEV1Wnp/L8fn6Cej09R8hkZKy6XV3nMhkZK+Zzc5XAYGCgGYGBmJ5PT9Gj3Nx/RCIiZlQqKn47kJCrC4iIg4xGRsrH7u4pa7i40ygUFDyn3t55vF5e4hYLCx2t29t22+DgO2QyMlZ0OjpOFAoKHpJJSdsMBgYKSCQkbLhcXOSfwsJdvdPTbkOsrO/EYmKmOZGRqDGVlaTT5OQ38nl5i9Xn5zKLyMhDbjc3WdptbbcBjY2MsdXVZJxOTtJJqang2GxstKxWVvrz9PQHz+rqJcplZa/0enqOR66u6RAICBhvurrV8Hh4iEolJW9cLi5yOBwcJFempvFztLTHl8bGUcvo6COh3d186HR0nD4fHyGWS0vdYb293A2Li4YPioqF4HBwkHw+PkJxtbXEzGZmqpBISNgGAwMF9/b2ARwODhLCYWGjajU1X65XV/lpubnQF4aGkZnBwVg6HR0nJ56eudnh4Tjr+PgTK5iYsyIRETPSaWm7qdnZcAeOjokzlJSnLZubtjweHiIVh4eSyenpIIfOzkmqVVX/UCgoeKXf33oDjIyPWaGh+AmJiYAaDQ0XZb+/2tfm5jGEQkLG0GhouIJBQcMpmZmwWi0tdx4PDxF7sLDLqFRU/G27u9YsFhY6pcZjY4T4fHyZ7nd3jfZ7ew3/8vK91mtrsd5vb1SRxcVQYDAwAwIBAanOZ2d9VisrGef+/mK119fmTaurmux2dkWPysqdH4KCQInJyYf6fX0V7/r667JZWcmOR0cL+/Dw7EGtrWez1NT9X6Ki6kWvr78jnJz3U6SkluRyclubwMDCdbe3HOH9/a49k5NqTCYmWmw2NkF+Pz8C9ff3T4PMzFxoNDT0UaWlNNHl5Qj58fGT4nFxc6vY2FNiMTE/KhUVDAgEBFKVx8dlRiMjXp3DwygwGBihN5aWDwoFBbUvmpoJDgcHNiQSEpsbgIA93+LiJs3r62lOJyfNf7Kyn+p1dRsSCQmeHYODdFgsLC40GhotNhsbstxubu60Wlr7W6Cg9qRSUk12Oztht9bWzn2zs3tSKSk+3ePjcV4vL5cThIT1plNTaLnR0QAAAAAswe3tYEAgIB/j/PzIebGx7bZbW77UampGjcvL2We+vktyOTnelEpK1JhMTOiwWFhKhc/Pa7vQ0CrF7+/lT6qqFu37+8WGQ0PXmk1NVWYzM5QRhYXPikVFEOn5+QYEAgKB/n9/8KBQUER4PDy6JZ+f40uoqPOiUVH+XaOjwIBAQIoFj4+tP5KSvCGdnUhwODgE8fX132O8vMF3trZ1r9raY0IhITAgEBAa5f//Dv3z822/0tJMgc3NFBgMDDUmExMvw+zs4b5fX6I1l5fMiEREOS4XF1eTxMTyVaengvx+fkd6PT2syGRk57pdXSsyGRmV5nNzoMBgYJgZgYHRnk9Pf6Pc3GZEIiJ+VCoqqzuQkIMLiIjKjEZGKcfu7tNruLg8KBQUeafe3uK8Xl4dFgsLdq3b2zvb4OBWZDIyTnQ6Oh4UCgrbkklJCgwGBmxIJCTkuFxcXZ/Cwm6909PvQ6yspsRiYqg5kZGkMZWVN9Pk5IvyeXky1efnQ4vIyFluNze32m1tjAGNjWSx1dXSnE5O4EmpqbTYbGz6rFZWB/P09CXP6uqvymVljvR6eulHrq4YEAgI1W+6uojweHhvSiUlclwuLiQ4HBzxV6amx3O0tFGXxsYjy+jofKHd3ZzodHQhPh8f3ZZLS9xhvb2GDYuLhQ+KipDgcHBCfD4+xHG1tarMZmbYkEhIBQYDAwH39vYSHA4Oo8JhYV9qNTX5rldX0Gm5uZEXhoZYmcHBJzodHbknnp442eHhE+v4+LMrmJgzIhERu9JpaXCp2dmJB46OpzOUlLYtm5siPB4ekhWHhyDJ6elJh87O/6pVVXhQKCh6pd/fjwOMjPhZoaGACYmJFxoNDdplv78x1+bmxoRCQrjQaGjDgkFBsCmZmXdaLS0RHg8Py3uwsPyoVFTWbbu7OiwWFmOlxmN8hPh8d5nud3uN9nvyDf/ya73Wa2+x3m/FVJHFMFBgMAEDAgFnqc5nK31WK/4Z5/7XYrXXq+ZNq3aa7HbKRY/Kgp0fgslAicl9h/p9+hXv+lnrsllHyY5H8Av78K3sQa3UZ7PUov1foq/qRa+cvyOcpPdTpHKW5HLAW5vAt8J1t/0c4f2Trj2TJmpMJjZabDY/QX4/9wL198xPg8w0XGg0pfRRpeU00eXxCPnxcZPicdhzq9gxU2IxFT8qFQQMCATHUpXHI2VGI8NencMYKDAYlqE3lgUPCgWatS+aBwkOBxI2JBKAmxuA4j3f4usmzesnaU4nss1/snWf6nUJGxIJg54dgyx0WCwaLjQaGy02G26y3G5a7rRaoPtboFL2pFI7TXY71mG31rPOfbMpe1Ip4z7d4y9xXi+ElxOEU/WmU9FoudEAAAAA7SzB7SBgQCD8H+P8sch5sVvttltqvtRqy0aNy77ZZ745S3I5St6USkzUmExY6LBYz0qFz9Bru9DvKsXvquVPqvsW7ftDxYZDTdeaTTNVZjOFlBGFRc+KRfkQ6fkCBgQCf4H+f1DwoFA8RHg8n7oln6jjS6hR86JRo/5do0DAgECPigWPkq0/kp28IZ04SHA49QTx9bzfY7y2wXe22nWv2iFjQiEQMCAQ/xrl//MO/fPSbb/SzUyBzQwUGAwTNSYT7C/D7F/hvl+XojWXRMyIRBc5LhfEV5PEp/JVp36C/H49R3o9ZKzIZF3nul0ZKzIZc5Xmc2CgwGCBmBmBT9GeT9x/o9wiZkQiKn5UKpCrO5CIgwuIRsqMRu4px+6402u4FDwoFN55p95e4rxeCx0WC9t2rdvgO9vgMlZkMjpOdDoKHhQKSduSSQYKDAYkbEgkXOS4XMJdn8LTbr3TrO9DrGKmxGKRqDmRlaQxleQ30+R5i/J55zLV58hDi8g3WW43bbfabY2MAY3VZLHVTtKcTqngSalstNhsVvqsVvQH8/TqJc/qZa/KZXqO9Hqu6UeuCBgQCLrVb7p4iPB4JW9KJS5yXC4cJDgcpvFXprTHc7TGUZfG6CPL6N18od10nOh0HyE+H0vdlku93GG9i4YNi4qFD4pwkOBwPkJ8PrXEcbVmqsxmSNiQSAMFBgP2Aff2DhIcDmGjwmE1X2o1V/muV7nQabmGkReGwViZwR0nOh2euSee4TjZ4fgT6/iYsyuYETMiEWm70mnZcKnZjokHjpSnM5Sbti2bHiI8HoeSFYfpIMnpzkmHzlX/qlUoeFAo33ql34yPA4yh+FmhiYAJiQ0XGg2/2mW/5jHX5kLGhEJouNBoQcOCQZmwKZktd1otDxEeD7DLe7BU/KhUu9ZtuxY6LBZjY6XGfHyE+Hd3me57e4328vIN/2trvdZvb7HexcVUkTAwUGABAQMCZ2epzisrfVb+/hnn19ditaur5k12dprsyspFj4KCnR/JyUCJfX2H+vr6Fe9ZWeuyR0fJjvDwC/utrexB1NRns6Ki/V+vr+pFnJy/I6Sk91NycpbkwMBbm7e3wnX9/Rzhk5OuPSYmakw2NlpsPz9Bfvf3AvXMzE+DNDRcaKWl9FHl5TTR8fEI+XFxk+LY2HOrMTFTYhUVPyoEBAwIx8dSlSMjZUbDw16dGBgoMJaWoTcFBQ8Kmpq1LwcHCQ4SEjYkgICbG+LiPd/r6ybNJydpTrKyzX91dZ/qCQkbEoODnh0sLHRYGhouNBsbLTZubrLcWlrutKCg+1tSUvakOztNdtbWYbezs859KSl7UuPjPt0vL3FehISXE1NT9abR0Wi5AAAAAO3tLMEgIGBA/Pwf47GxyHlbW+22amq+1MvLRo2+vtlnOTlLckpK3pRMTNSYWFjosM/PSoXQ0Gu77+8qxaqq5U/7+xbtQ0PFhk1N15ozM1VmhYWUEUVFz4r5+RDpAgIGBH9/gf5QUPCgPDxEeJ+fuiWoqONLUVHzoqOj/l1AQMCAj4+KBZKSrT+dnbwhODhIcPX1BPG8vN9jtrbBd9rada8hIWNCEBAwIP//GuXz8w790tJtv83NTIEMDBQYExM1JuzsL8NfX+G+l5eiNUREzIgXFzkuxMRXk6en8lV+foL8PT1HemRkrMhdXee6GRkrMnNzleZgYKDAgYGYGU9P0Z7c3H+jIiJmRCoqflSQkKs7iIiDC0ZGyozu7inHuLjTaxQUPCje3nmnXl7ivAsLHRbb23at4OA72zIyVmQ6Ok50CgoeFElJ25IGBgoMJCRsSFxc5LjCwl2f09Nuvays70NiYqbEkZGoOZWVpDHk5DfTeXmL8ufnMtXIyEOLNzdZbm1tt9qNjYwB1dVksU5O0pypqeBJbGy02FZW+qz09Afz6uolz2Vlr8p6eo70rq7pRwgIGBC6utVveHiI8CUlb0ouLnJcHBwkOKam8Ve0tMdzxsZRl+joI8vd3XyhdHSc6B8fIT5LS92Wvb3cYYuLhg2KioUPcHCQ4D4+Qny1tcRxZmaqzEhI2JADAwUG9vYB9w4OEhxhYaPCNTVfaldX+a65udBphoaRF8HBWJkdHSc6np65J+HhONn4+BPrmJizKxERMyJpabvS2dlwqY6OiQeUlKczm5u2LR4eIjyHh5IV6ekgyc7OSYdVVf+qKCh4UN/feqWMjI8DoaH4WYmJgAkNDRcav7/aZebmMddCQsaEaGi40EFBw4KZmbApLS13Wg8PER6wsMt7VFT8qLu71m0WFjosUglq1TA2pTi/QKOegfPX+3zjOYKbL/+HNI5DRMTe6ctUe5QypsIjPe5MlQtC+sNOCC6hZijZJLJ2W6JJbYvRJXL49mSGaJgW1KRczF1ltpJscEhQ/e252l4VRlenjZ2EkNirAIy80wr35FgFuLNFBtAsHo/KPw8Cwa+9AwETims6kRFBT2fc6pfyz87wtOZzlqx0IuetNYXi+TfoHHXfbkfxGnEdKcWJb7diDqoYvhv8Vj5LxtJ5IJrbwP54zVr0H92oM4gHxzGxEhBZJ4DsX2BRf6kZtUoNLeV6n5PJnO+g4DtNrir1sMjruzyDU5lhFysEfrp31ibhaRRjVSEMfQIAAAABAAAAgAAAALUbAgAQAAAAAAAAABAAAADYwQIAAwAAAAEAAADAAAAAzRsCABAAAAAAAAAAEAAAANjBAgAEAAAAAQAAAAABAADBGwIAEAAAAAAAAAAQAAAA2MECACsAAAAIAAAAgAAAACQYAgAMAAAAAQAAABAAAADwwQIALAAAAAgAAADAAAAAPBgCAAwAAAABAAAAEAAAAPDBAgAtAAAACAAAAAABAAAwGAIADAAAAAEAAAAQAAAA8MECAAIAAADgwAIAAwAAAADBAgAEAAAAIMECACsAAABAwQIALAAAAGDBAgAtAAAAgMEC");
  base64DecodeToExistingUint8Array(bufferView, 180696, "AgAAAGACAABhAgAAYgIAAGMCAABkAgAAAgAAAAAAAABlAgAAZQIAAGYCAABnAg==");
  base64DecodeToExistingUint8Array(bufferView, 180752, "BAAABAEABAIgBAMhBAQiBAUjBAYABAcABAgABAkABAoABAsABAwABA0ABA4ABA8ABBAAFBEABBIABBMABBQABBUABBYABBcABBgABBkABBoABBsABBwkBB0lBB4mBB8nBCAABCEABCIABCMABCQABCUABCYABCcABCgABCkABCoABCsABCwABC0ABC4ABC8Au84gINKgP/+AcLg//8AOLh4ONj//4AOLn//wAOLv//M5n//wNLM4P8M5v4M5qFMM4J2MM4IOMM4KFLgP4j4OIRwUPwEH8F/CArmDnkAgfgwFABwkCAYRlBgPhEoYACgggCE4MB4QOGhCTCAQNB4g0DAAUQAQMcDgOBxA0DAAUgAQMwIAMDyAlCAAZQCSIMIgcgEoR2FgICBmEHoBnFIIUDEQUOUoMf5F/gF+oUD/EOCYUNCINAqHBgcCwkIjBYBg0AjxqBgFhgMMgcIkEYLAJVBUwNEgFCgUQAIOAiFgNgU4gGIgGEgkggkhBYKiBKoNwgMQgMIhGAhFD//BM4MIgPggUgFAMRUQOEM4OAgMogfAglAFQIpBkJFBYAMCwEGEwIBBoFCJoKbBMoME8EdIIOAmGAw0BwkQhkMHQNgnSrBwGhgMGgsIiEwQoMUoFn/0A/x2Bg/yiEf4EYgEngJrBAAkEAYSBBoDECAAjzDBwOAYgLrFToIOCZ4IRBdYrzDvACB+AOFwIFDBwMHJI38Agd8gE/JIwAEn8D/AOM//gBxd//46GAAv//4NLgP/V4IAKgf/L4gOJLBkH/6TFAA0PM5sfM5qFBwCFNBpaFBM5gOBM4I=");
  base64DecodeToExistingUint8Array(bufferView, 181383, "D+YAACQAcAAAASADgAAAABABPAPAPPAPAPIAIAAAA4gIiBEQf/BEQIiAjgAABgYSECTAMmAZIEJDAwAAADwOhCIIRhBzIAGAHoAACQAcAAAAB8AwYIAiACAACACIAgwYB8AAACQAMAH4AMACQAAAAgAEAAgA/gAgAEAAgAAAAEgA4AAAEAAgAEAAgAEAAAAAYADAAAABAAwAYAMAGADAAAAA/gICCGIRhBAQH8AAAEABAAQAD/4AABA4QZCEIRBBwIAABAQQBCEIQhB7wAAADABoARAMID/4AIAAAfCCIIRBCIIQ+AAAP+CIIRBCIII+AAAQACB4QwCYAcAAAAPeCEIQhCEIPeAAAPCCEIQhCEIP+AAAGGAwwAAAwoGGAAAAgAKACIAggICAAACIARACIARACIARAAABAQEEARABQAEAAABAAQACCYQgCIAOAAAAP+CAIRxCRISJB/AAAAf4MQCCAMQAf4AAD/4QhCEIQhB7wAAB/wQBCAIQBBAQAAD/4QBCAIICA/gAAD/4QhCEIQhCAIAAD/4RACIARACAAAAB/wQBCAIQhBHwAAD/4AgAEAAgD/4AACAIf/CAIAACAwQBCAIQBD/wAAD/4AgAKAGMDAYAAD/4ABAAIABAAIAAD/4MAAYAMAD/4AAD/4MAAYAAwD/4AAB/wQBCAIQBB/wAAD/4QgCEAQgB4AAAB/wQBCAoQCB/oAAD/4QgCEAQ4B44AABwQRBCEIQRBBwAACAAQAD/4QACAAAAD/wABAAIABD/wAAD4AA8AAYA8D4AAAD/gADABgAwABgADD/gAADA4GYAMAGYDA4AADgADAAH4DADgAAACAYQNCOIWBDAIAAD/8QAiAEAADAAGAAMAAYAAwABAAAQAiAEf/gAACABgAQABgACAAAAABAAIABAAIABAAIAACAAIAAgAAAAJwCRASICSAP4AAD/4BCAQICBAPwAAAPwCBAQICBAIQAAAPwCBAQIBCD/4AAAPwCRASICRAOQAAAQAP/CQASACQAAAAOsCKQRSCKQeSCBgAAf/AIACAAQAB/AAAABAQIT/AAIABAAAAAgACAAQQCT/gAAf/ABAAYAMgCDAAAABCAIf/AAIABAAAD/AQAD/AQAB/AAAD/AIACAAQAB/AAAB+AQICBAQIB+AAAD/wIQCBAQIB+AAAB+AQICBAIQD/wAAD/AIACAAQABAAAABiASICRARIBGAAACAD/wCBAQICBAAAD+AAIABAAQD/AAADgADgADADgDgAAAD8AAYAcAAYD8AAADDAEgAYAEgDDAAADwYBsACABgDwAAACDAQoCZAUIDBAAAOTiNiQAQAAf/AAAQASNiOTgAAAgAIABAAEAAQACAAgAAABBB/4RBCAIQBBA4AADigD0AD8D0DigAABgASACQAMAAAAXACoAJAAAAVACoAKAAAAIACAAAAAf+ABAAIACAf4AAAMABgAAAJAD4ABAAAAOACIAOAAAAAf6MQKCAMQAf4AAAf4MQKCCMQAf4AAAf5MQSCBMQAf4AAIf6MQKCCMQAf4AAA/yYgEECYgA/wAAAf5MQWCBMQAf4AAP/CCAQQD/4QhCEIAAB/wQBKANQBRAQAAAf/SEJQhCEIQBAAAf/CEJQhSEIQBAAAf/KEKQhKEIQBAAA/+UIQhCUIQgCAACQBL/4QBAAAQBL/6QBAABQBT/5QBAACgCH/ygCAAD/4QhCEIICA/gAABf/RgBDAQGAf/AAAP+SAJQBCAIP+AAAP+CAJQBSAIP+AAAP+KAKQBKAIP+AAAP+KAKQBKAKP+AAAf8UAQgCUAQf8AABCAEgAYADAAkAIQAAAH/BBwJyBwQf8AAAD/xABUAJABD/wAAD/wABIAKABD/wAAD/xABQAJABT/wAAH/iACAASACH/gAADgADAIH6DADgAAAf/wgQECAgQD8AAAP/CAARBCIIOhADwAAAJwSRBSICSAP4AAAJwCRBSISSAP4AAAJwKRCSIKSAP4AABJwSRBSISSAP4AAAJwKRASIKSAP4AAAE4JIipEJJAH8AAAJwCRASIB+ASICRAOQAAAPwCBIQOCBAIQAAAPwSRBSICRAOQAAAPwCRBSISRAOQAAAPwKRCSIKRAOQAAAPwKRASIKRAOQAAAAISBBf4ABAAIAAAAICBBf4QBAAIAAAAIKBCf4IBAAIAAAAIKBAf4IBAAIAAAH4VAioENAhf4AABf4RABQASAAP4AAAPwSBCQIKBAPwAAAPwCBBQISBAPwAAAPwKBCQIKBAPwAAAPwKBCQIKBCPwAAAPwKBAQIKBAPwAAAEAAgA1gGsAEAAgAAAABAHwBFAJIBRAHwBAAAAD+CAIIBAAQD/AAAD+AAIIBCAQD/AAAD+BAIQBBAQD/AAAD+BAIABBAQD/AAADwYBsICCBgDwAAAf/ARACIAOAAAAeDINgAQIMAeA=");
  base64DecodeToExistingUint8Array(bufferView, 183232, "AwIGCAgICAMFBQYIAwYDBwcFBgYHBgYGBgYDAwYHBgcHBgYGBgYGBgYEBgYGBgYGBgYGBgYGBggGBgYEBwQGBwQGBgYGBgYHBgYGBgYGBgYGBgYGBgYGBgYGBgQCBAg=");
  base64DecodeToExistingUint8Array(bufferView, 183363, "BwAG");
  base64DecodeToExistingUint8Array(bufferView, 183376, "BQAEBAMGAAMABAQAAAAAAAYGBgYGBgcGBgYGBgQEBAQGBgYGBgYGBwYGBgYGBgYHBgYGBgYGCAYGBgYGBgYGBgYGBgYGBgYHCAYGBgYGBQY=");
  base64DecodeToExistingUint8Array(bufferView, 183471, "f+cH/nAAAA+AAPgAAAAAAAAPgAD4AAAAAAQQAEEAf/8H//AEEABBAH//B//wBBAAQQAAAADggB8MAxhgIIIP//j//4IIIDDGAYfACDgAAAAYAAPAMCQPA8PAGPAAPGAPDwPAkDAPAABgAAAAA8AcfgPsMGOBBBgQY8MD5mAcPAAP8ADDAAAA+AAPgAAAAAB/AB/8A4DgYAMEABAAAAQAEGADA4DgH/wAfwAAAAAIAAiIAMmABrAAPgABwAA+AAawAMmACIgACAAAAAAIAACAAAgAAIAA/4AP+AAIAACAAAgAAIAAAAAAAIAA+AAPAAAAAIAACAAAgAAIAACAAAgAAIAACAAAgAAIAAAAAABwAAcAAAAAAwAA8AA8AA8AA8AA8AA8AAMAAAAAAf/AP/4GAzBAYQQMEEGBBDAQZgMD/+Af/AAAAAgBAYAQMAEH//B//wAAEAABAAAQAAABwDA8BwYA0EAZBAMQQGEEDBBhgQPwEB4BAAAAEAQDAGBgAwQIEECBBAgQQIEGHDA/fgHjwAAAAAeAAPgAGIADCABggAwIAYCAMAgH//B//wAAAH8EB/BgQQMEEBBBAQQQEEEBBBgwQP4EB8AAAAH/wD/+BhAwQQEEEBBBAQQQEEGDBA/gAHwAAABwAAcAAEAABAAAQB8EB/BB4AR4AH4AB4AAAAAB48A/fgYcMECBBAgQQIEECBBhwwP34B48AAAAHwAD+BBgwQQEEEBBBAQQQEEGBDA//gH/wAAAAHDgBw4AAAAAAIBw+AcPAAAAAIAAHAADYABjAAwYAYDAMAYGADBAAQAAAAIQACEAAhAAIQACEAAhAAIQACEAAhAAIQAAAAQAEGADAwBgGAwAwYAGMAA2AAHAAAgAAAABwAA8AAYAAEAABAZwQOcEGABjAAPgABwAAAAAH/wD/+BgAwQAEEPhBH8QTBkEgJBoCQP/kB/5AAAAH/8D//BgQAQEAEBABAQAQEAGBAA//wH/8AAAB//wf/8EEBBBAQQQEEEBBBAQY4MD7+AcfAAAAB/8A//gYAMEABBAAQQAEEABBgAwOA4BgMAAAAf/8H//BAAQQAEEABBAAQQAEGADA//gH/wAAAB//wf/8ECBBAgQQIEECBBAgQQIEEABBAAQAAAH//B//wQIAECABAgAQIAECABAgAQAAEAAAAAAH/wD/+BgAwQAEEABBAgQQIEGCDA4/gGPwAAAB//wf/8ACAAAgAAIAACAAAgAAIAH//B//wAAAEABBAAQf/8H//BAAQQAEAAAAAHAAB4AADAAAQAAEEABBAAwf/4H/8BAAAQAAAAAB//wf/8AHAADYABjAAwYAYDAMAYGADBAAQAAAH//B//wAAEAABAAAQAAEAABAAAQAAEAABAAAAf/8D//AYAADAAAYAADAABgAAwAAYAAP/8H//AAAAf/8H//AGAAAwAAGAAAwAAGAAAwB//wf/8AAAAf/AP/4GADBAAQQAEEABBAAQYAMD/+Af/AAAAH//B//wQIAECABAgAQIAECABhgAPwAB4AAAAAH/wD/+BgAwQAEEAFBABwQAMGADg//sH/xAAAB//wf/8EDABA4AQLAECYBAjAYYYD8DAeAQAAAB4EA/BgYYMECBBAgQQIEECBBgwwMH4BA8AAAAQAAEAABAAAQAAH//B//wQAAEAABAAAQAAAAAB//Af/4AADAAAQAAEAABAAAQAAMH/+B//AAAAHgAB/gAB/AAB8AADwAA8AB8AH8Af4AHgAAAAAf/8H/+AADAABgAAwAAYAADAAAYAADAf/4H//AAAAYAMHgPAePAB3AAHAABwAB3AB48B4DwYAMAAABgAAeAAB4AAHgAAf8AH/AHgAHgAHgABgAAAAAEAPBAHwQDEEBhBAwQQYEEMBBGAQfAEHgBAAAAf/8H//BAAQQAEEABAAAAMAADwAAPAAA8AADwAAPAAA8AADAAAAQAEEABBAAQf/8H//AAAACAABgAAwAAYAAMAADAAAYAADAAAYAACAAAAAAAAEAABAAAQAAEAABAAAQAAEAABAAAQAAEAAAIAADAAAYAACAAAAAAABwAQ+AEYwBEEARBAEQQBEEAZBAD/wAf8AAAB//wf/8AQBAEAQBAEAQBAEAQBgMAP+AB/AAAAAH8AD/gBgMAQBAEAQBAEAQBAGAwAwYAEEAAAAAfwAP+AGAwBAEAQBAEAQBAEAQBB//wf/8AAAAB/AA/4AYjAEIQBCEAQhAEIQBiEAPjAB4gAAAAQAAEAABAAD//B//wRAAEQABEAAQAAAAAAB/AA/4QYDEEARBAEQQBEEARBAMwf/4H/8AAAH//B//wBAAAQAAEAABAAAQAAGAAA/8AH/AAAABAEAQBB3/wd/8AABAAAQAAAAAAwAAOAAAwAAEEABBAA3f/53/8AAAH//B//wACAABwAA2AAYwAMGAGAwBAEAAABAAQQAEH//B//wAAEAABAAAAB/8Af/AEAABAAAf/AH/wBAAAYAAD/wAf8AAAAH/wB/8AQAAEAABAAAQAAEAABgAAP/AB/wAAAAH8AD/gBgMAQBAEAQBAEAQBAGAwA/4AH8AAAAB//wf/8EAQBAEAQBAEAQBAEAYDAD/gAfwAAAAB/AA/4AYDAEAQBAEAQBAEAQBAEAf/8H//AAAAf/AH/wAYAAMAAGAABAAAQAAEAABAAAQAAAAAA8IAfjAEIQBCEAQhAEIQBCEAQhAGPwAh4AAAAEAABAAAQAB//gf/8AQBAEAQBAEAABAAAAB/wAf+AAAwAAEAABAAAQAAEAABAH/wB/8AAAAHAAB8AADwAAPAAA8AAPAAPAAPAAfAAHAAAAAAf+AH/wAAEAABAAfwAH8AABAAAQB/8Af+AAAABgMAcHABjAANgABwAAcAANgAGMAHBwBgMAAAAH/AB/4QADEAARAAEQABEAARAAMwf/4H/8AAAAQDAEBwBA0AQZAEMQBGEATBAFgQBwEAYBAAAAAIAACAAf/AP34GADBAAQQAEAAAB//wf/8AAABAAQQAEGADA/fgH/wACAAAgAAAAHAADwAAgAAIAADgAAcAABAAAQAA8AAOAAAAAAc/8HP/AAAAAfwAP+AGAwBAEB//wf/8BAEAYDADBgAQQAAAAAgQH/8D//BggQQIEECBBggQMAEBAHAABwAAABACAb9gD/wAQIAECABAgAQIAECAD/wBv2AQAgAAAGAAB4JAHiQAckAB/wAf8AckAeJAeCQGAAAAAAfj8H4/AAAAd8IP/jCIMQiBEIwRDH/wQ+4AAADgAA4AAAAAAAAA4AAOAAAAAAB/gAgEAT8gF/oBQKAUCgFAoBc6ATMgCAQAf4AAAADyAJ+gCQoAkKAJCgCQoAkKAP+gB/oAAAAAAgAAcAANgAGMADJgBnMATZABjAAwYAYDAEAQAAAAIAACAAAgAAIAACAAAgAAIAACAAA/AAPwAAAAAIAACAAAgAAIAACAAAgAAIAACAAAAAB/gAgEAX+gF/oBRCAUYgFHIBfaATigCAQAf4");
  base64DecodeToExistingUint8Array(bufferView, 186133, "B4AA/AAIQACEAAhAAPwAB4AAAAAACBAAgQAIEACBAP+QD/kACBAAgQAIEACBAAAAYgAOYACOAAmgAPIABiAAAAAEQADGAAkgAJIAD+AAbAAAAAAgAAYAAMAACAAAAAAAf/8H//AAEAABAAAQAAEAADAABgB/8Af/AAAAPwAH+ABAgAQIAH//B//wQAAEAAB//wf/8AAAABwAAcAAAAAAABAADwAA4AAAIAAGIAD+AA/gAAIAAAAAPiAH8gDBoAgKAICgCAoAwaAH8gA+IAAAAAQBAGAwAwYAGMAE2QBnMAMmABjAANgABwAAIAAAAAAGAgDAYBgP4wD+ZgAM4AGaADMgBn+Ax/gAAAAAwCAYBgMA/mAP7YgBuYAyOAYmgMPIGBiAAABEBgxgwJIYCSMA/mYGzOABmgAzIAZ/gMf4AAAAAcAAPgAGMADBBzgQcwEAABAAAwAB4AAcAAAAA//gf/6MCAyAgGgIAoCACAgAwIAH/+A//gAAAD/+B//gwIAICAKAgGgIDICAjAgAf/4D/+AAAAP/4H/+LAgGgIDICAyAgGgIAsCAB//gP/4AAAA//mf/7sCAiAgMgIBoCAKAgOwIDH/+A//gAAAD/+B//uwIDoCACAgAgIDoCA7AgAf/4D/+AAAAP/4H/+bAgPgICYCAmAgPgIBsCAB//gP/4AAAH/8D//BggAQIAECABAgAf/8H//BAgQQIEECBBAgQAAAB/8A//gYAMEABFAAfQAHkABBgAwOA4BgMAAAAD//g//6IECyBAmgQIoECCBAggQIIACCAAgAAAP/+D//ggQIIECKBAmgQLIECiBAggAIIACAAAA//4P/+KBAmgQLIECyBAmgQIoECCAAggAIAAAD//g//7oEC6BAggQIIEC6BAugQIIACCAAgAACIACyAAm//4v/+CAAggAIAAACAAggAIv/+b//sgAKIACAAACgAJoACz//s//5oACKAAgAADoAC6AAg//4P/+6AAugAIAAAAIAH//B//wQIEECBBAgQQIEEABBgAwP/4B/8AAAAD//m//7gwAgGAMAwBgGAIAwOAGDP/+D//gAAAD/4B//IwAbIACaAAigAIIACDABgf/wD/4AAAAP/gH/8DABggAIoACaAAsgAKMAGB//AP/gAAAA/+Af/wsAGaAAsgALIACaAAiwAYH/8A/+AAAAD/4Z//OwAaIACyAAmgAIoAC7ABsf/wD/4AAAAP/gH/87ABugAIIACCAAugALsAGB//AP/gAAACAgAwYAGMAA2AAHAABwAA2AAYwAMGACAgAAAAABAH/wD/+BgMwQGEEDBBBgQQwEGYDA//gH/wBAAAAAAD/+A//yAAGwAAmAAIgACAAAgAAYP/8D/+AAAAP/4D//AAAYAACIAAmAALAACgABg//wP/4AAAA//gP/8IABmAALAACwAAmAAIgAGD//A//gAAAD/+A//zgAG4AAgAAIAAC4AAuAAYP/8D/+AAAAMAADwAAPAAA8AID/mA/7A8Ag8AA8AAMAAAAAH//B//wCBAAgQAIEACBAAgQAMMAB+AAPAAAAAP/8H//BBBAQQMEEBBBAQYwED+DAc/gAHwAAAAAHABD4ERjBkQQNEEBRBAEQQBkEAP/AB/wAAAAAcAEPgBGMARBAUQQNEEGRBBGQQA/8AH/AAAAABwAQ+AUYwNEEGRBBkQQNEEBZBAD/wAf8AAAAAHAND4HRjBEQQZEEDRBAUQQdkEGP/AB/wAAAAAcAEPgdGMHRBAEQQBEEHRBB2QQA/8AH/AAAAABwAQ+A0YwfEEExBBMQQfEEDZBAD/wAf8AAAAAPgBH8ARBAEQQBkEAP/AH/gBCMAQhAEIQB+MAPiAAAAAfwAP+AGAwBAEQQB8EAeBAEAYDADBgAQQAAAAB/AA/4EYjBkIQNCEBQhAEIQBiEAPjAB4gAAAAH8AD/gBiMAQhAUIQNCEGQhBGIQA+MAHiAAAAAfwAP+AWIwNCEGQhBkIQNCEBYhAD4wAeIAAAAB/AA/4HYjB0IQBCEAQhB0IQdiEAPjAB4gAAAEQBBkAQN/8Bf/AAAQAAEAAAAEAQBAEBf/A3/wYAEEABAAAAFAEDQBBn/wZ/8DABAQAQAAAHQBB0AQB/8Af/BwAQcAEAAAAB/AU/4HYDAkAQdAEFwBAMAQBgMAP+AB/AAAAAf/A3/wdAAEQABkAANAABQAB2AAY/8AH/AAAAAfwAP+BGAwZAEDQBAUAQBAEAYDAD/gAfwAAAAB/AA/4AYDAEAQFAEDQBBkAQRgMAP+AB/AAAAAH8AD/gFgMDQBBkAQZAEDQBAWAwA/4AH8AAAAAfwDP+B2AwRAEGQBA0AQFAEHYDBj/gAfwAAAAB/AA/4HYDB0AQBAEAQBB0AQdgMAP+AB/AAAAACAAAgAAIAACAAcnAHJwACAAAgAAIAACAAAAAAf0AP+AGDwBBkAQxAEYQBMEAeDAD/gBfwAAAAH/AB/4EADBgAQMAEBABAAAQAAEAf/AH/wAAAAf8AH/gAAMAABAQAQMAEGABBAAQB/8Af/AAAAB/wAf+AQAwMAEGABBgAQMAEBABAH/wB/8AAAAH/AB/4HADBwAQAAEAABBwAQcAEAf/AH/wAAAAf8AH/hAAMQABEQARMAEWABFAAzB//gf/wAAAf//3//8EAQBAEAQBAEAQBAEAYDAD/gAfwAAAAH/AB/4XADFwARAAEQABFwARcAMwf/4H/8");
  base64DecodeToExistingUint8Array(bufferView, 188192, "BgMHCwsLCwMGBgwLBAsDCQsJCwsLCwsLCwsDBAoLCgsMCwsLCwsLCwsHDAsLDAsLCwsLCwsLCwwLCwsGCQYLCwULCwsLCwoLCwcJCgcLCwsLCwsLCgsLCwsLCwgDCAs=");
  base64DecodeToExistingUint8Array(bufferView, 188321, "AwsLDAsDCAcMCgwLCQwJCAsHBwULCwMEBgoMCwsLCwsLCwsLCw0LCwsLCwcHBwcMCwsLCwsLCw0LCwsLCwsLCwsLCwsLDQsLCwsLBwcHBwsLCwsLCwsLCwsLCwsLCwtKYW4ARmViAE1hcgBBcHIATWF5AEp1bgBKdWwAQXVnAFNlcABPY3QATm92AERlYwBTdW4ATW9uAFR1ZQBXZWQAVGh1AEZyaQBTYXQAAAAAAHgCAAB5AgAAegIAAHsCAAB8AgAAfQIAAH4CAAB/AgAAgAIAAIECAACCAgAAgwIAAIQCAACFAgAAhgIAAIcCAACIAg==");
  base64DecodeToExistingUint8Array(bufferView, 188578, "HwDgB/8HAPgf+OD///8=");
  base64DecodeToExistingUint8Array(bufferView, 188610, "KEJRjNe9QMwgiiAD4Af/Bx8AEYgf+AD4QPzg////AAAGAAwAEwAZAB8AgAGGAYwBkwGZAZ8BIAMmAywDMwM5Az8DwATGBMwE0wTZBN8EYAZmBmwGcwZ5Bn8G4AfmB+wH8wf5B/8HADAGMAwwEzAZMB8wgDGGMYwxkzGZMZ8xIDMmMywzMzM5Mz8zwDTGNMw00zTZNN80YDZmNmw2czZ5Nn824DfmN+w38zf5N/83AGAGYAxgE2AZYB9ggGGGYYxhk2GZYZ9hIGMmYyxjM2M5Yz9jwGTGZMxk02TZZN9kYGZmZmxmc2Z5Zn9m4GfmZ+xn82f5Z/9nAJgGmAyYE5gZmB+YgJmGmYyZk5mZmZ+ZIJsmmyybM5s5mz+bwJzGnMyc05zZnN+cYJ5mnmyec555nn+e4J/mn+yf85/5n/+fAMgGyAzIE8gZyB/IgMmGyYzJk8mZyZ/JIMsmyyzLM8s5yz/LwMzGzMzM08zZzN/MYM5mzmzOc855zn/O4M/mz+zP88/5z//PAPgG+Az4E/gZ+B/4gPmG+Yz5k/mZ+Z/5IPsm+yz7M/s5+z/7wPzG/Mz80/zZ/N/8YP5m/mz+c/55/n/+4P/m/+z/8//5////");
  base64DecodeToExistingUint8Array(bufferView, 189150, "//8AACsAgQCsAHkATgAMABIAFwAEACcAtwCQAMAA0gDXAAAABQAeACMAtAC5ANIA1wAAAAkABwAIAAwACwAOAA8=");
  base64DecodeToExistingUint8Array(bufferView, 189224, "nAIAAJ0CAACeAgAAnwIAAKACAAChAgAAPRsCAGobAgBVFwIAVhsCAEwbAgCwGgIA2RkCANQWAgCQFgIALRsCAOUWAgBEFwIAehsCACcXAgCJGwIAGBcCABAYAgBeGwIAWxgCAHUVAgBhIgIAqh8CAEIaAgC9FgIAoBcCACkVAgBkGQIAyRkCAIcZAgBhFgIASBgCAH8YAgAZGAIA/BkCAEgbAgBtFwIAthYCAAYbAgD0GgIAFBoCALsXAgCtGwIAZRUCAOQZAgDcFwIAohoCAIkXAgDQFgIASyECAAgWAgAlFQIA8xkCAPkXAgCRFQIAdBUCAMwXAgASFQIA1BcCAEgWAgCiGQIAXiECAK4WAgCoGAIAnRgCADMWAgCqGgIApBcCAFAVAgAeGgIAUhoCAFUWAgCwGAIAkxgCAIwZAgDIFwIAlxUCAJYVAgBEGgIANhUCAKgXAgDSFQIAyRoCABoVAgDkGAIAhRYCALMVAgAeGwIApxUCAOIYAgCwFwIAXxUCAJAUAgA0GgIAZRoCAHoYAgDVGgIAcBoCAJYWAgBpFQIAjxoCAEEbAgB7FgIASBUCAOwZAgCKGAIAUyECAAsXAgDqGgIAURYCAC4aAgDZGAIAdhUCAH4aAgCmGQIA2xkCALIZAgAYGwIAcxkCAMYZAgBXGgIAsSACAJUgAgDfGgIAQSECAJsUAgDAFwIAUhgC");
  base64DecodeToExistingUint8Array(bufferView, 189772, "qwIAAKwCAACtAgAAqQIAAK4CAACvAgAAsAIAALECAACyAgAAswIAALQCAAC1Ag==");
  base64DecodeToExistingUint8Array(bufferView, 189828, "tgIAALcCAAC4AgAAuQI=");
  base64DecodeToExistingUint8Array(bufferView, 189852, "ugIAALoCAAC7AgAAvAIAAAAAAABPZmZsaW5lTWVtb3J5QWxsb2NhdGlvbgCA////fwAAAAAAAAD/AAAAAID///9/AACA////fwAAAACA////fwAAgP///38AAAAAAACA////fwAAAID///9/AAAAAAAAAADVAgAA1gIAALoCAAC6AgAAugIAALoC");
  base64DecodeToExistingUint8Array(bufferView, 190000, "1wIAANgCAADZAgAA2gIAANsCAADcAg==");
  base64DecodeToExistingUint8Array(bufferView, 190032, "5QIAAOYCAADnAg==");
  base64DecodeToExistingUint8Array(bufferView, 190052, "6AIAAOkCAAC6Ag==");
  base64DecodeToExistingUint8Array(bufferView, 190072, "6gIAAOsCAADsAgAA7QIAAO4CAADvAgAA8AIAAPEC");
  base64DecodeToExistingUint8Array(bufferView, 190112, "6gIAAOsCAADsAgAA8gIAAPMCAAC6AgAAugIAALoC");
  base64DecodeToExistingUint8Array(bufferView, 190152, "ugIAALoCAADsAgAA9AIAAPUCAAAAAAAAT7thBWes3T8YLURU+yHpP5v2gdILc+8/GC1EVPsh+T/iZS8ifyt6PAdcFDMmpoE8vcvweogHcDwHXBQzJqaRPBgtRFT7Iek/GC1EVPsh6b/SITN/fNkCQNIhM3982QLA");
  base64DecodeToExistingUint8Array(bufferView, 190287, "gBgtRFT7IQlAGC1EVPshCcD+gitlRxVnQAAAAAAAADhDAAD6/kIudr86O568mvcMvb39/////98/PFRVVVVVxT+RKxfPVVWlPxfQpGcREYE/AAAAAAAAyELvOfr+Qi7mPyTEgv+9v84/tfQM1whrrD/MUEbSq7KDP4Q6Tpvg11U/");
  base64DecodeToExistingUint8Array(bufferView, 190430, "8D9uv4gaTzubPDUz+6k99u8/XdzYnBNgcbxhgHc+muzvP9FmhxB6XpC8hX9u6BXj7z8T9mc1UtKMPHSFFdOw2e8/+o75I4DOi7ze9t0pa9DvP2HI5mFO92A8yJt1GEXH7z+Z0zNb5KOQPIPzxso+vu8/bXuDXaaalzwPiflsWLXvP/zv/ZIatY4890dyK5Ks7z/RnC9wPb4+PKLR0zLso+8/C26QiTQDarwb0/6vZpvvPw69LypSVpW8UVsS0AGT7z9V6k6M74BQvMwxbMC9iu8/FvTVuSPJkbzgLamumoLvP69VXOnj04A8UY6lyJh67z9Ik6XqFRuAvHtRfTy4cu8/PTLeVfAfj7zqjYw4+WrvP79TEz+MiYs8dctv61tj7z8m6xF2nNmWvNRcBITgW+8/YC86PvfsmjyquWgxh1TvP504hsuC54+8Hdn8IlBN7z+Nw6ZEQW+KPNaMYog7Ru8/fQTksAV6gDyW3H2RST/vP5SoqOP9jpY8OGJ1bno47z99SHTyGF6HPD+msk/OMe8/8ucfmCtHgDzdfOJlRSvvP14IcT97uJa8gWP14d8k7z8xqwlt4feCPOHeH/WdHu8/+r9vGpshPbyQ2drQfxjvP7QKDHKCN4s8CwPkpoUS7z+Py86JkhRuPFYvPqmvDO8/tquwTXVNgzwVtzEK/gbvP0x0rOIBQoY8MdhM/HAB7z9K+NNdOd2PPP8WZLII/O4/BFuOO4Cjhrzxn5JfxfbuP2hQS8ztSpK8y6k6N6fx7j+OLVEb+AeZvGbYBW2u7O4/0jaUPujRcbz3n+U02+fuPxUbzrMZGZm85agTwy3j7j9tTCqnSJ+FPCI0Ekym3u4/imkoemASk7wcgKwERdruP1uJF0iPp1i8Ki73IQrW7j8bmklnmyx8vJeoUNn10e4/EazCYO1jQzwtiWFgCM7uP+9kBjsJZpY8VwAd7UHK7j95A6Ha4cxuPNA8wbWixu4/MBIPP47/kzze09fwKsPuP7CvervOkHY8Jyo21dq/7j934FTrvR2TPA3d/ZmyvO4/jqNxADSUj7ynLJ12srnuP0mjk9zM3oe8QmbPotq27j9fOA+9xt54vIJPnVYrtO4/9lx77EYShrwPkl3KpLHuP47X/RgFNZM82ie1Nkev7j8Fm4ovt5h7PP3Hl9QSre4/CVQc4uFjkDwpVEjdB6vuP+rGGVCFxzQ8t0ZZiiap7j81wGQr5jKUPEghrRVvp+4/n3aZYUrkjLwJ3Ha54aXuP6hN7zvFM4y8hVU6sH6k7j+u6SuJeFOEvCDDzDRGo+4/WFhWeN3Ok7wlIlWCOKLuP2QZfoCqEFc8c6lM1FWh7j8oIl6/77OTvM07f2aeoO4/grk0h60Sary/2gt1EqDuP+6pbbjvZ2O8LxplPLKf7j9RiOBUPdyAvISUUfl9n+4/zz5afmQfeLx0X+zodZ/uP7B9i8BK7oa8dIGlSJqf7j+K5lUeMhmGvMlnQlbrn+4/09QJXsuckDw/Xd5PaaDuPx2lTbncMnu8hwHrcxSh7j9rwGdU/eyUPDLBMAHtoe4/VWzWq+HrZTxiTs8286LuP0LPsy/FoYi8Eho+VCek7j80NzvxtmmTvBPOTJmJpe4/Hv8ZOoRegLytxyNGGqfuP25XcthQ1JS87ZJEm9mo7j8Aig5bZ62QPJlmitnHqu4/tOrwwS+3jTzboCpC5azuP//nxZxgtmW8jES1FjKv7j9EX/NZg/Z7PDZ3FZmuse4/gz0epx8Jk7zG/5ELW7TuPykebIu4qV285cXNsDe37j9ZuZB8+SNsvA9SyMtEuu4/qvn0IkNDkrxQTt6fgr3uP0uOZtdsyoW8ugfKcPHA7j8nzpEr/K9xPJDwo4KRxO4/u3MK4TXSbTwjI+MZY8juP2MiYiIExYe8ZeVde2bM7j/VMeLjhhyLPDMtSuyb0O4/Fbu809G7kbxdJT6yA9XuP9Ix7pwxzJA8WLMwE57Z7j+zWnNuhGmEPL/9eVVr3u4/tJ2Ol83fgrx689O/a+PuP4czy5J3Gow8rdNamZ/o7j/62dFKj3uQvGa2jSkH7u4/uq7cVtnDVbz7FU+4ovPuP0D2pj0OpJC8OlnljXL57j80k6049NZovEde+/J2/+4/NYpYa+LukbxKBqEwsAXvP83dXwrX/3Q80sFLkB4M7z+smJL6+72RvAke11vCEu8/swyvMK5uczycUoXdmxnvP5T9n1wy4448etD/X6sg7z+sWQnRj+CEPEvRVy7xJ+8/ZxpOOK/NYzy15waUbS/vP2gZkmwsa2c8aZDv3CA37z/StcyDGIqAvPrDXVULP+8/b/r/P12tj7x8iQdKLUfvP0mpdTiuDZC88okNCIdP7z+nBz2mhaN0PIek+9wYWO8/DyJAIJ6RgryYg8kW42DvP6ySwdVQWo48hTLbA+Zp7z9LawGsWTqEPGC0AfMhc+8/Hz60ByHVgrxfm3szl3zvP8kNRzu5Kom8KaH1FEaG7z/TiDpgBLZ0PPY/i+cukO8/cXKdUezFgzyDTMf7UZrvP/CR048S94+82pCkoq+k7z99dCPimK6NvPFnji1Ir+8/CCCqQbzDjjwnWmHuG7rvPzLrqcOUK4Q8l7prNyvF7z/uhdExqWSKPEBFblt20O8/7eM75Lo3jrwUvpyt/dvvP53NkU07iXc82JCegcHn7z+JzGBBwQVTPPFxjyvC8+8/AAAAAAAA8D90hRXTsNnvPw+J+WxYte8/UVsS0AGT7z97UX08uHLvP6q5aDGHVO8/OGJ1bno47z/h3h/1nR7vPxW3MQr+Bu8/y6k6N6fx7j8iNBJMpt7uPy2JYWAIzu4/Jyo21dq/7j+CT51WK7TuPylUSN0Hq+4/hVU6sH6k7j/NO39mnqDuP3Rf7Oh1n+4/hwHrcxSh7j8TzkyZiaXuP9ugKkLlrO4/5cXNsDe37j+Q8KOCkcTuP10lPrID1e4/rdNamZ/o7j9HXvvydv/uP5xShd2bGe8/aZDv3CA37z+HpPvcGFjvP1+bezOXfO8/2pCkoq+k7z9ARW5bdtDvPwAAAAAAAOhClCORS/hqrD/zxPpQzr/OP9ZSDP9CLuY/AAAAAAAAOEP+gitlRxVHQJQjkUv4arw+88T6UM6/Lj/WUgz/Qi6WPwAAAAAAAAAAAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBGT7cAnmY/AC3qXwC6J3UA5evHAD178QD3OQcAklKKAPtr6gAfsV8ACF2NADADVgB7/EYA8KtrACC8zwA29JoA46kdAF5hkQAIG+YAhZllAKAUXwCNQGgAgNj/ACdzTQAGBjEAylYVAMmocwB74mAAa4zAABnERwDNZ8MACejcAFmDKgCLdsQAphyWAESv3QAZV9EApT4FAAUH/wAzfj8AwjLoAJhP3gC7fTIAJj3DAB5r7wCf+F4ANR86AH/yygDxhx0AfJAhAGokfADVbvoAMC13ABU7QwC1FMYAwxmdAK3EwgAsTUEADABdAIZ9RgDjcS0Am8aaADNiAAC00nwAtKeXADdV1QDXPvYAoxAYAE12/ABknSoAcNerAGN8+AB6sFcAFxXnAMBJVgA71tkAp4Q4ACQjywDWincAWlQjAAAfuQDxChsAGc7fAJ8x/wBmHmoAmVdhAKz7RwB+f9gAImW3ADLoiQDmv2AA78TNAGw2CQBdP9QAFt7XAFg73gDem5IA0iIoACiG6ADiWE0AxsoyAAjjFgDgfcsAF8BQAPMdpwAY4FsALhM0AIMSYgCDSAEA9Y5bAK2wfwAe6fIASEpDABBn0wCq3dgArl9CAGphzgAKKKQA05m0AAam8gBcd38Ao8KDAGE8iACKc3gAr4xaAG/XvQAtpmMA9L/LAI2B7wAmwWcAVcpFAMrZNgAoqNIAwmGNABLJdwAEJhQAEkabAMRZxADIxUQATbKRAAAX8wDUQ60AKUnlAP3VEAAAvvwAHpTMAHDO7gATPvUA7PGAALPnwwDH+CgAkwWUAMFxPgAuCbMAC0XzAIgSnACrIHsALrWfAEeSwgB7Mi8ADFVtAHKnkABr5x8AMcuWAHkWSgBBeeIA9N+JAOiUlwDi5oQAmTGXAIjtawBfXzYAu/0OAEiatABnpGwAcXJCAI1dMgCfFbgAvOUJAI0xJQD3dDkAMAUcAA0MAQBLCGgALO5YAEeqkAB05wIAvdYkAPd9pgBuSHIAnxbvAI6UpgC0kfYA0VNRAM8K8gAgmDMA9Ut+ALJjaADdPl8AQF0DAIWJfwBVUikAN2TAAG3YEAAySDIAW0x1AE5x1ABFVG4ACwnBACr1aQAUZtUAJwedAF0EUAC0O9sA6nbFAIf5FwBJa30AHSe6AJZpKQDGzKwArRRUAJDiagCI2YkALHJQAASkvgB3B5QA8zBwAAD8JwDqcagAZsJJAGTgPQCX3YMAoz+XAEOU/QANhowAMUHeAJI5nQDdcIwAF7fnAAjfOwAVNysAXICgAFqAkwAQEZIAD+jYAGyArwDb/0sAOJAPAFkYdgBipRUAYcu7AMeJuQAQQL0A0vIEAEl1JwDrtvYA2yK7AAoUqgCJJi8AZIN2AAk7MwAOlBoAUTqqAB2jwgCv7a4AXCYSAG3CTQAtepwAwFaXAAM/gwAJ8PYAK0CMAG0xmQA5tAcADCAVANjDWwD1ksQAxq1LAE7KpQCnN80A5qk2AKuSlADdQmgAGWPeAHaM7wBoi1IA/Ns3AK6hqwDfFTEAAK6hAAz72gBkTWYA7QW3ACllMABXVr8AR/86AGr5uQB1vvMAKJPfAKuAMABmjPYABMsVAPoiBgDZ5B0APbOkAFcbjwA2zQkATkLpABO+pAAzI7UA8KoaAE9lqADSwaUACz8PAFt4zQAj+XYAe4sEAIkXcgDGplMAb27iAO/rAACbSlgAxNq3AKpmugB2z88A0QIdALHxLQCMmcEAw613AIZI2gD3XaAAxoD0AKzwLwDd7JoAP1y8ANDebQCQxx8AKtu2AKMlOgAAr5oArVOTALZXBAApLbQAS4B+ANoHpwB2qg4Ae1mhABYSKgDcty0A+uX9AInb/gCJvv0A5HZsAAap/AA+gHAAhW4VAP2H/wAoPgcAYWczACoYhgBNveoAs+evAI9tbgCVZzkAMb9bAITXSAAw3xYAxy1DACVhNQDJcM4AMMu4AL9s/QCkAKIABWzkAFrdoAAhb0cAYhLSALlchABwYUkAa1bgAJlSAQBQVTcAHtW3ADPxxAATbl8AXTDkAIUuqQAdssMAoTI2AAi3pADqsdQAFvchAI9p5AAn/3cADAOAAI1ALQBPzaAAIKWZALOi0wAvXQoAtPlCABHaywB9vtAAm9vBAKsXvQDKooEACGpcAC5VFwAnAFUAfxTwAOEHhgAUC2QAlkGNAIe+3gDa/SoAayW2AHuJNAAF8/4Aub+eAGhqTwBKKqgAT8RaAC34vADXWpgA9MeVAA1NjQAgOqYApFdfABQ/sQCAOJUAzCABAHHdhgDJ3rYAv2D1AE1lEQABB2sAjLCsALLA0ABRVUgAHvsOAJVywwCjBjsAwEA1AAbcewDgRcwATin6ANbKyADo80EAfGTeAJtk2ADZvjEApJfDAHdY1ABp48UA8NoTALo6PABGGEYAVXVfANK99QBuksYArC5dAA5E7QAcPkIAYcSHACn96QDn1vMAInzKAG+RNQAI4MUA/9eNAG5q4gCw/cYAkwjBAHxddABrrbIAzW6dAD5yewDGEWoA98+pAClz3wC1yboAtwBRAOKyDQB0uiQA5X1gAHTYigANFSwAgRgMAH5mlAABKRYAn3p2AP39vgBWRe8A2X42AOzZEwCLurkAxJf8ADGoJwDxbsMAlMU2ANioVgC0qLUAz8wOABKJLQBvVzQALFaJAJnO4wDWILkAa16qAD4qnAARX8wA/QtKAOH0+wCOO20A4oYsAOnUhAD8tKkA7+7RAC41yQAvOWEAOCFEABvZyACB/AoA+0pqAC8c2ABTtIQATpmMAFQizAAqVdwAwMbWAAsZlgAacLgAaZVkACZaYAA/Uu4AfxEPAPS1EQD8y/UANLwtADS87gDoXcwA3V5gAGeOmwCSM+8AyRe4AGFYmwDhV7wAUYPGANg+EADdcUgALRzdAK8YoQAhLEYAWfPXANl6mACeVMAAT4b6AFYG/ADlea4AiSI2ADitIgBnk9wAVeiqAIImOADK55sAUQ2kAJkzsQCp1w4AaQVIAGWy8AB/iKcAiEyXAPnRNgAhkrMAe4JKAJjPIQBAn9wA3EdVAOF0OgBn60IA/p3fAF7UXwB7Z6QAuqx6AFX2ogAriCMAQbpVAFluCAAhKoYAOUeDAInj5gDlntQASftAAP9W6QAcD8oAxVmKAJT6KwDTwcUAD8XPANtargBHxYYAhUNiACGGOwAseZQAEGGHACpMewCALBoAQ78SAIgmkAB4PIkAqMTkAOXbewDEOsIAJvTqAPdnigANkr8AZaMrAD2TsQC9fAsApFHcACfdYwBp4d0AmpQZAKgplQBozigACe20AESfIABOmMoAcIJjAH58IwAPuTIAp/WOABRW5wAh8QgAtZ0qAG9+TQClGVEAtfmrAILf1gCW3WEAFjYCAMQ6nwCDoqEAcu1tADmNegCCuKkAazJcAEYnWwAANO0A0gB3APz0VQABWU0A4HGA");
  base64DecodeToExistingUint8Array(bufferView, 195587, "QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNQ==");
  base64DecodeToExistingUint8Array(bufferView, 195649, "gAEAbUQCAO++rd6+uv7KFf//AP//////////AQCgAKAAIAPQBwAABAAAAAoAAAAgAwAA4Pz//+gDAAAA4AIAMOACALk7AgAVAAAAAAAAAAU=");
  base64DecodeToExistingUint8Array(bufferView, 195740, "9gI=");
  base64DecodeToExistingUint8Array(bufferView, 195764, "9wIAAPgCAACo+AU=");
  base64DecodeToExistingUint8Array(bufferView, 195788, "Ag==");
  base64DecodeToExistingUint8Array(bufferView, 195804, "//////////8=");
  base64DecodeToExistingUint8Array(bufferView, 195872, "kPwC");
}

  var scratchBuffer = new ArrayBuffer(16);
  var i32ScratchView = new Int32Array(scratchBuffer);
  var f32ScratchView = new Float32Array(scratchBuffer);
  var f64ScratchView = new Float64Array(scratchBuffer);
  
  function wasm2js_scratch_load_i32(index) {
    return i32ScratchView[index];
  }
      
  function wasm2js_scratch_store_i32(index, value) {
    i32ScratchView[index] = value;
  }
      
  function wasm2js_scratch_load_f64() {
    return f64ScratchView[0];
  }
      
  function wasm2js_scratch_store_f64(value) {
    f64ScratchView[0] = value;
  }
      
  function wasm2js_scratch_store_f32(value) {
    f32ScratchView[2] = value;
  }
      
function asmFunc(env) {
 var memory = env.memory;
 var buffer = memory.buffer;
 var HEAP8 = new Int8Array(buffer);
 var HEAP16 = new Int16Array(buffer);
 var HEAP32 = new Int32Array(buffer);
 var HEAPU8 = new Uint8Array(buffer);
 var HEAPU16 = new Uint16Array(buffer);
 var HEAPU32 = new Uint32Array(buffer);
 var HEAPF32 = new Float32Array(buffer);
 var HEAPF64 = new Float64Array(buffer);
 var Math_imul = Math.imul;
 var Math_fround = Math.fround;
 var Math_abs = Math.abs;
 var Math_clz32 = Math.clz32;
 var Math_min = Math.min;
 var Math_max = Math.max;
 var Math_floor = Math.floor;
 var Math_ceil = Math.ceil;
 var Math_trunc = Math.trunc;
 var Math_sqrt = Math.sqrt;
 var abort = env.abort;
 var nan = NaN;
 var infinity = Infinity;
 var emscripten_asm_const_int = env.emscripten_asm_const_int;
 var emscripten_asm_const_double = env.emscripten_asm_const_double;
 var abort = env.abort;
 var __wasi_fd_close = env.fd_close;
 var __wasi_fd_write = env.fd_write;
 var setTempRet0 = env.setTempRet0;
 var legalimport$__wasi_fd_seek = env.fd_seek;
 var __stack_pointer = 5634240;
 var __stack_end = 0;
 var __stack_base = 0;
 var i64toi32_i32$HIGH_BITS = 0;
 // EMSCRIPTEN_START_FUNCS
function jswCallFunctionHack($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $5 = __stack_pointer - 576 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 568 >> 2] = $0;
 HEAP16[$5 + 566 >> 1] = $1;
 HEAP32[$5 + 560 >> 2] = $2;
 HEAP32[$5 + 556 >> 2] = $3;
 HEAP32[$5 + 552 >> 2] = $4;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        label$8: {
         label$9: {
          label$10: {
           label$11: {
            label$12: {
             label$13: {
              label$14: {
               label$15: {
                label$16: {
                 label$17: {
                  label$18: {
                   label$19: {
                    label$20: {
                     label$21: {
                      label$22: {
                       label$23: {
                        label$24: {
                         label$25: {
                          label$26: {
                           label$27: {
                            label$28: {
                             label$29: {
                              label$30: {
                               label$31: {
                                label$32: {
                                 label$33: {
                                  label$34: {
                                   label$35: {
                                    label$36: {
                                     label$37: {
                                      label$38: {
                                       label$39: {
                                        label$40: {
                                         label$41: {
                                          label$42: {
                                           label$43: {
                                            label$44: {
                                             label$45: {
                                              label$46: {
                                               label$47: {
                                                label$48: {
                                                 label$49: {
                                                  label$50: {
                                                   label$51: {
                                                    label$52: {
                                                     label$53: {
                                                      label$54: {
                                                       label$55: {
                                                        label$56: {
                                                         label$57: {
                                                          label$58: {
                                                           label$59: {
                                                            label$60: {
                                                             label$61: {
                                                              label$62: {
                                                               label$63: {
                                                                label$64: {
                                                                 label$65: {
                                                                  label$66: {
                                                                   label$67: {
                                                                    label$68: {
                                                                     label$69: {
                                                                      label$70: {
                                                                       label$71: {
                                                                        label$72: {
                                                                         label$73: {
                                                                          label$74: {
                                                                           label$75: {
                                                                            label$76: {
                                                                             label$77: {
                                                                              label$78: {
                                                                               label$79: {
                                                                                label$80: {
                                                                                 label$81: {
                                                                                  label$82: {
                                                                                   label$83: {
                                                                                    label$84: {
                                                                                     label$85: {
                                                                                      label$86: {
                                                                                       label$87: {
                                                                                        label$88: {
                                                                                         label$89: {
                                                                                          label$90: {
                                                                                           label$91: {
                                                                                            label$92: {
                                                                                             label$93: {
                                                                                              label$94: {
                                                                                               label$95: {
                                                                                                label$96: {
                                                                                                 label$97: {
                                                                                                  label$98: {
                                                                                                   label$99: {
                                                                                                    label$100: {
                                                                                                     label$101: {
                                                                                                      label$102: {
                                                                                                       label$103: {
                                                                                                        label$104: {
                                                                                                         label$105: {
                                                                                                          label$106: {
                                                                                                           label$107: {
                                                                                                            label$108: {
                                                                                                             label$109: {
                                                                                                              label$110: {
                                                                                                               label$111: {
                                                                                                                label$112: {
                                                                                                                 label$113: {
                                                                                                                  label$114: {
                                                                                                                   label$115: {
                                                                                                                    label$116: {
                                                                                                                     label$117: {
                                                                                                                      label$118: {
                                                                                                                       label$119: {
                                                                                                                        label$120: {
                                                                                                                         label$121: {
                                                                                                                          label$122: {
                                                                                                                           label$123: {
                                                                                                                            label$124: {
                                                                                                                             label$125: {
                                                                                                                              label$126: {
                                                                                                                               $0 = HEAPU16[$5 + 566 >> 1];
                                                                                                                               if ($0) {
                                                                                                                                if (($0 | 0) == 1) {
                                                                                                                                 break label$113;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 3) {
                                                                                                                                 break label$110;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 4) {
                                                                                                                                 break label$107;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 7) {
                                                                                                                                 break label$80;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 8) {
                                                                                                                                 break label$114;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 9) {
                                                                                                                                 break label$106;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 11) {
                                                                                                                                 break label$89;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 12) {
                                                                                                                                 break label$49;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 15) {
                                                                                                                                 break label$72;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 16) {
                                                                                                                                 break label$71;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 17) {
                                                                                                                                 break label$99;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 23) {
                                                                                                                                 break label$58;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 24) {
                                                                                                                                 break label$116;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 25) {
                                                                                                                                 break label$24;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 28) {
                                                                                                                                 break label$25;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32) {
                                                                                                                                 break label$112;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33) {
                                                                                                                                 break label$86;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 36) {
                                                                                                                                 break label$61;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 41) {
                                                                                                                                 break label$35;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 47) {
                                                                                                                                 break label$39;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 56) {
                                                                                                                                 break label$115;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 57) {
                                                                                                                                 break label$60;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 60) {
                                                                                                                                 break label$57;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 63) {
                                                                                                                                 break label$62;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 72) {
                                                                                                                                 break label$103;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 73) {
                                                                                                                                 break label$102;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 75) {
                                                                                                                                 break label$26;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 91) {
                                                                                                                                 break label$108;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 96) {
                                                                                                                                 break label$109;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 97) {
                                                                                                                                 break label$3;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 120) {
                                                                                                                                 break label$52;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 136) {
                                                                                                                                 break label$43;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 200) {
                                                                                                                                 break label$50;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 201) {
                                                                                                                                 break label$28;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 204) {
                                                                                                                                 break label$47;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 264) {
                                                                                                                                 break label$42;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 265) {
                                                                                                                                 break label$48;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 288) {
                                                                                                                                 break label$105;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 289) {
                                                                                                                                 break label$122;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 292) {
                                                                                                                                 break label$120;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 456) {
                                                                                                                                 break label$40;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 463) {
                                                                                                                                 break label$55;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 481) {
                                                                                                                                 break label$104;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 511) {
                                                                                                                                 break label$121;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 584) {
                                                                                                                                 break label$51;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 585) {
                                                                                                                                 break label$70;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 609) {
                                                                                                                                 break label$56;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 744) {
                                                                                                                                 break label$37;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 841) {
                                                                                                                                 break label$34;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 1e3) {
                                                                                                                                 break label$38;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 1481) {
                                                                                                                                 break label$41;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 1608) {
                                                                                                                                 break label$53;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 1609) {
                                                                                                                                 break label$45;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 1640) {
                                                                                                                                 break label$36;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 2127) {
                                                                                                                                 break label$54;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 2313) {
                                                                                                                                 break label$84;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 4095) {
                                                                                                                                 break label$59;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 4681) {
                                                                                                                                 break label$4;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 6216) {
                                                                                                                                 break label$111;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 6433) {
                                                                                                                                 break label$19;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 16968) {
                                                                                                                                 break label$46;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 18507) {
                                                                                                                                 break label$27;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 20473) {
                                                                                                                                 break label$44;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 28673) {
                                                                                                                                 break label$101;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 28676) {
                                                                                                                                 break label$68;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 28677) {
                                                                                                                                 break label$117;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 28679) {
                                                                                                                                 break label$69;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32768) {
                                                                                                                                 break label$118;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32769) {
                                                                                                                                 break label$93;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32771) {
                                                                                                                                 break label$119;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32772) {
                                                                                                                                 break label$79;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32775) {
                                                                                                                                 break label$78;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32776) {
                                                                                                                                 break label$126;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32777) {
                                                                                                                                 break label$98;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32779) {
                                                                                                                                 break label$67;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32780) {
                                                                                                                                 break label$10;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32784) {
                                                                                                                                 break label$29;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32785) {
                                                                                                                                 break label$88;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32788) {
                                                                                                                                 break label$94;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32792) {
                                                                                                                                 break label$123;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32793) {
                                                                                                                                 break label$18;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32801) {
                                                                                                                                 break label$100;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32807) {
                                                                                                                                 break label$73;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32831) {
                                                                                                                                 break label$77;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32840) {
                                                                                                                                 break label$125;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32841) {
                                                                                                                                 break label$92;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32843) {
                                                                                                                                 break label$63;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32844) {
                                                                                                                                 break label$64;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32856) {
                                                                                                                                 break label$32;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32865) {
                                                                                                                                 break label$90;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32871) {
                                                                                                                                 break label$74;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32888) {
                                                                                                                                 break label$31;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32904) {
                                                                                                                                 break label$66;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32905) {
                                                                                                                                 break label$65;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32968) {
                                                                                                                                 break label$30;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32969) {
                                                                                                                                 break label$6;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 32993) {
                                                                                                                                 break label$82;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33032) {
                                                                                                                                 break label$83;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33033) {
                                                                                                                                 break label$96;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33035) {
                                                                                                                                 break label$95;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33057) {
                                                                                                                                 break label$7;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33060) {
                                                                                                                                 break label$15;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33097) {
                                                                                                                                 break label$23;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33240) {
                                                                                                                                 break label$33;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33352) {
                                                                                                                                 break label$124;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33353) {
                                                                                                                                 break label$12;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33356) {
                                                                                                                                 break label$13;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33383) {
                                                                                                                                 break label$75;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33545) {
                                                                                                                                 break label$87;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33569) {
                                                                                                                                 break label$14;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33768) {
                                                                                                                                 break label$20;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 33889) {
                                                                                                                                 break label$91;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 34400) {
                                                                                                                                 break label$81;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 35105) {
                                                                                                                                 break label$21;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 37479) {
                                                                                                                                 break label$76;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 39177) {
                                                                                                                                 break label$5;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 47369) {
                                                                                                                                 break label$9;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 49929) {
                                                                                                                                 break label$11;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 51465) {
                                                                                                                                 break label$17;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 51489) {
                                                                                                                                 break label$16;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 55560) {
                                                                                                                                 break label$22;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 61441) {
                                                                                                                                 break label$97;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 61444) {
                                                                                                                                 break label$85;
                                                                                                                                }
                                                                                                                                if (($0 | 0) == 65529) {
                                                                                                                                 break label$8;
                                                                                                                                }
                                                                                                                                break label$2;
                                                                                                                               }
                                                                                                                               HEAP32[$5 + 548 >> 2] = 0;
                                                                                                                               FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]();
                                                                                                                               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 548 >> 2];
                                                                                                                               break label$1;
                                                                                                                              }
                                                                                                                              HEAP32[$5 + 544 >> 2] = 0;
                                                                                                                              $1 = HEAP32[$5 + 568 >> 2];
                                                                                                                              $0 = HEAP32[$5 + 560 >> 2];
                                                                                                                              if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                               $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                                              } else {
                                                                                                                               $2 = 0;
                                                                                                                              }
                                                                                                                              FUNCTION_TABLE[$1 | 0]($0, $2);
                                                                                                                              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 544 >> 2];
                                                                                                                              break label$1;
                                                                                                                             }
                                                                                                                             HEAP32[$5 + 540 >> 2] = 0;
                                                                                                                             $2 = HEAP32[$5 + 568 >> 2];
                                                                                                                             $1 = HEAP32[$5 + 560 >> 2];
                                                                                                                             if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                              $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                                             } else {
                                                                                                                              $0 = 0;
                                                                                                                             }
                                                                                                                             if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                                              $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                                                             } else {
                                                                                                                              $3 = 0;
                                                                                                                             }
                                                                                                                             FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                                                                                                                             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 540 >> 2];
                                                                                                                             break label$1;
                                                                                                                            }
                                                                                                                            HEAP32[$5 + 536 >> 2] = 0;
                                                                                                                            $3 = HEAP32[$5 + 568 >> 2];
                                                                                                                            $2 = HEAP32[$5 + 560 >> 2];
                                                                                                                            if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                             $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                                            } else {
                                                                                                                             $1 = 0;
                                                                                                                            }
                                                                                                                            if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                                             $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                                                            } else {
                                                                                                                             $0 = 0;
                                                                                                                            }
                                                                                                                            if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                                                                             $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                                                                                                            } else {
                                                                                                                             $4 = 0;
                                                                                                                            }
                                                                                                                            FUNCTION_TABLE[$3 | 0]($2, $1, $0, $4);
                                                                                                                            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 536 >> 2];
                                                                                                                            break label$1;
                                                                                                                           }
                                                                                                                           HEAP32[$5 + 532 >> 2] = 0;
                                                                                                                           $1 = HEAP32[$5 + 568 >> 2];
                                                                                                                           $0 = HEAP32[$5 + 560 >> 2];
                                                                                                                           if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                            $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                                           } else {
                                                                                                                            $2 = 0;
                                                                                                                           }
                                                                                                                           FUNCTION_TABLE[$1 | 0]($0, jsvGetBool($2) & 1);
                                                                                                                           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 532 >> 2];
                                                                                                                           break label$1;
                                                                                                                          }
                                                                                                                          HEAP32[$5 + 528 >> 2] = 0;
                                                                                                                          $1 = HEAP32[$5 + 568 >> 2];
                                                                                                                          if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                           $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                                          } else {
                                                                                                                           $0 = 0;
                                                                                                                          }
                                                                                                                          $0 = jsvGetInteger($0);
                                                                                                                          if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                                           $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                                                          } else {
                                                                                                                           $2 = 0;
                                                                                                                          }
                                                                                                                          HEAP32[$5 + 528 >> 2] = FUNCTION_TABLE[$1 | 0]($0, jsvGetInteger($2));
                                                                                                                          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 528 >> 2];
                                                                                                                          break label$1;
                                                                                                                         }
                                                                                                                         HEAP32[$5 + 524 >> 2] = 0;
                                                                                                                         $0 = HEAP32[$5 + 568 >> 2];
                                                                                                                         if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                          $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                                         } else {
                                                                                                                          $1 = 0;
                                                                                                                         }
                                                                                                                         $7 = jsvGetFloat($1);
                                                                                                                         if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                                          $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                                                         } else {
                                                                                                                          $1 = 0;
                                                                                                                         }
                                                                                                                         HEAP32[$5 + 524 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$0 | 0]($7, jsvGetFloat($1)));
                                                                                                                         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 524 >> 2];
                                                                                                                         break label$1;
                                                                                                                        }
                                                                                                                        HEAP32[$5 + 520 >> 2] = 0;
                                                                                                                        $1 = HEAP32[$5 + 568 >> 2];
                                                                                                                        if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                         $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                                        } else {
                                                                                                                         $0 = 0;
                                                                                                                        }
                                                                                                                        $0 = jsvGetInteger($0);
                                                                                                                        if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                                         $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                                                        } else {
                                                                                                                         $2 = 0;
                                                                                                                        }
                                                                                                                        HEAP32[$5 + 520 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$1 | 0]($0, jsvGetInteger($2)) | 0);
                                                                                                                        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 520 >> 2];
                                                                                                                        break label$1;
                                                                                                                       }
                                                                                                                       HEAP32[$5 + 516 >> 2] = 0;
                                                                                                                       HEAP32[$5 + 516 >> 2] = jsvNewFromBool(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2]) & 1);
                                                                                                                       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 516 >> 2];
                                                                                                                       break label$1;
                                                                                                                      }
                                                                                                                      HEAP32[$5 + 512 >> 2] = 0;
                                                                                                                      FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2]);
                                                                                                                      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 512 >> 2];
                                                                                                                      break label$1;
                                                                                                                     }
                                                                                                                     HEAP32[$5 + 508 >> 2] = 0;
                                                                                                                     HEAP32[$5 + 508 >> 2] = jsvNewFromPin(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]() & 255);
                                                                                                                     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 508 >> 2];
                                                                                                                     break label$1;
                                                                                                                    }
                                                                                                                    HEAP32[$5 + 504 >> 2] = 0;
                                                                                                                    $0 = HEAP32[$5 + 568 >> 2];
                                                                                                                    if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                     $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                                    } else {
                                                                                                                     $1 = 0;
                                                                                                                    }
                                                                                                                    FUNCTION_TABLE[$0 | 0](jsvGetBool($1) & 1);
                                                                                                                    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 504 >> 2];
                                                                                                                    break label$1;
                                                                                                                   }
                                                                                                                   HEAP32[$5 + 500 >> 2] = 0;
                                                                                                                   $0 = HEAP32[$5 + 568 >> 2];
                                                                                                                   if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                    $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                                   } else {
                                                                                                                    $1 = 0;
                                                                                                                   }
                                                                                                                   FUNCTION_TABLE[$0 | 0](jsvGetFloat($1));
                                                                                                                   HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 500 >> 2];
                                                                                                                   break label$1;
                                                                                                                  }
                                                                                                                  HEAP32[$5 + 496 >> 2] = 0;
                                                                                                                  $0 = HEAP32[$5 + 568 >> 2];
                                                                                                                  if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                   $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                                  } else {
                                                                                                                   $1 = 0;
                                                                                                                  }
                                                                                                                  FUNCTION_TABLE[$0 | 0]($1);
                                                                                                                  HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 496 >> 2];
                                                                                                                  break label$1;
                                                                                                                 }
                                                                                                                 HEAP32[$5 + 492 >> 2] = 0;
                                                                                                                 HEAP32[$5 + 492 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]();
                                                                                                                 HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 492 >> 2];
                                                                                                                 break label$1;
                                                                                                                }
                                                                                                                HEAP32[$5 + 488 >> 2] = 0;
                                                                                                                $0 = HEAP32[$5 + 568 >> 2];
                                                                                                                if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                 $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                                } else {
                                                                                                                 $1 = 0;
                                                                                                                }
                                                                                                                FUNCTION_TABLE[$0 | 0](jsvGetInteger($1));
                                                                                                                HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 488 >> 2];
                                                                                                                break label$1;
                                                                                                               }
                                                                                                               HEAP32[$5 + 484 >> 2] = 0;
                                                                                                               $3 = HEAP32[$5 + 568 >> 2];
                                                                                                               if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                                $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                               } else {
                                                                                                                $1 = 0;
                                                                                                               }
                                                                                                               if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                                $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                                               } else {
                                                                                                                $0 = 0;
                                                                                                               }
                                                                                                               if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                                                                $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                                                                                               } else {
                                                                                                                $2 = 0;
                                                                                                               }
                                                                                                               $2 = jsvGetInteger($2);
                                                                                                               if (HEAP32[$5 + 552 >> 2] > 3) {
                                                                                                                $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2];
                                                                                                               } else {
                                                                                                                $4 = 0;
                                                                                                               }
                                                                                                               FUNCTION_TABLE[$3 | 0]($1, $0, $2, $4);
                                                                                                               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 484 >> 2];
                                                                                                               break label$1;
                                                                                                              }
                                                                                                              HEAP32[$5 + 480 >> 2] = 0;
                                                                                                              HEAP32[$5 + 480 >> 2] = jsvNewFromBool(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]() & 1);
                                                                                                              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 480 >> 2];
                                                                                                              break label$1;
                                                                                                             }
                                                                                                             HEAP32[$5 + 476 >> 2] = 0;
                                                                                                             $1 = HEAP32[$5 + 568 >> 2];
                                                                                                             if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                              $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                             } else {
                                                                                                              $0 = 0;
                                                                                                             }
                                                                                                             $0 = jsvGetInteger($0);
                                                                                                             if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                              $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                                             } else {
                                                                                                              $2 = 0;
                                                                                                             }
                                                                                                             FUNCTION_TABLE[$1 | 0]($0, $2);
                                                                                                             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 476 >> 2];
                                                                                                             break label$1;
                                                                                                            }
                                                                                                            HEAP32[$5 + 472 >> 2] = 0;
                                                                                                            $1 = HEAP32[$5 + 568 >> 2];
                                                                                                            if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                             $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                            } else {
                                                                                                             $0 = 0;
                                                                                                            }
                                                                                                            $0 = jsvGetBool($0) & 1;
                                                                                                            if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                             $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                                            } else {
                                                                                                             $2 = 0;
                                                                                                            }
                                                                                                            HEAP32[$5 + 472 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$1 | 0]($0, $2) & 1);
                                                                                                            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 472 >> 2];
                                                                                                            break label$1;
                                                                                                           }
                                                                                                           HEAP32[$5 + 468 >> 2] = 0;
                                                                                                           HEAP32[$5 + 468 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]() | 0);
                                                                                                           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 468 >> 2];
                                                                                                           break label$1;
                                                                                                          }
                                                                                                          HEAP32[$5 + 464 >> 2] = 0;
                                                                                                          $0 = HEAP32[$5 + 568 >> 2];
                                                                                                          if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                           $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                          } else {
                                                                                                           $1 = 0;
                                                                                                          }
                                                                                                          HEAP32[$5 + 464 >> 2] = FUNCTION_TABLE[$0 | 0]($1);
                                                                                                          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 464 >> 2];
                                                                                                          break label$1;
                                                                                                         }
                                                                                                         HEAP32[$5 + 460 >> 2] = 0;
                                                                                                         $1 = HEAP32[$5 + 568 >> 2];
                                                                                                         if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                          $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                         } else {
                                                                                                          $0 = 0;
                                                                                                         }
                                                                                                         $0 = jsvGetInteger($0);
                                                                                                         if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                          $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                                         } else {
                                                                                                          $2 = 0;
                                                                                                         }
                                                                                                         FUNCTION_TABLE[$1 | 0]($0, jsvGetInteger($2));
                                                                                                         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 460 >> 2];
                                                                                                         break label$1;
                                                                                                        }
                                                                                                        HEAP32[$5 + 456 >> 2] = 0;
                                                                                                        $1 = HEAP32[$5 + 568 >> 2];
                                                                                                        if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                         $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                        } else {
                                                                                                         $0 = 0;
                                                                                                        }
                                                                                                        $0 = jsvGetInteger($0);
                                                                                                        if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                         $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                                        } else {
                                                                                                         $2 = 0;
                                                                                                        }
                                                                                                        HEAP32[$5 + 456 >> 2] = FUNCTION_TABLE[$1 | 0]($0, jsvGetFloat($2));
                                                                                                        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 456 >> 2];
                                                                                                        break label$1;
                                                                                                       }
                                                                                                       HEAP32[$5 + 452 >> 2] = 0;
                                                                                                       $1 = HEAP32[$5 + 568 >> 2];
                                                                                                       if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                        $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                       } else {
                                                                                                        $0 = 0;
                                                                                                       }
                                                                                                       if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                        $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                                       } else {
                                                                                                        $2 = 0;
                                                                                                       }
                                                                                                       FUNCTION_TABLE[$1 | 0]($0, $2);
                                                                                                       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 452 >> 2];
                                                                                                       break label$1;
                                                                                                      }
                                                                                                      HEAP32[$5 + 448 >> 2] = 0;
                                                                                                      $1 = HEAP32[$5 + 568 >> 2];
                                                                                                      if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                       $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                      } else {
                                                                                                       $0 = 0;
                                                                                                      }
                                                                                                      if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                       $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                                      } else {
                                                                                                       $2 = 0;
                                                                                                      }
                                                                                                      HEAP32[$5 + 448 >> 2] = FUNCTION_TABLE[$1 | 0]($0, $2);
                                                                                                      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 448 >> 2];
                                                                                                      break label$1;
                                                                                                     }
                                                                                                     HEAP32[$5 + 444 >> 2] = 0;
                                                                                                     HEAP32[$5 + 444 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]();
                                                                                                     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 444 >> 2];
                                                                                                     break label$1;
                                                                                                    }
                                                                                                    HEAP32[$5 + 440 >> 2] = 0;
                                                                                                    $1 = HEAP32[$5 + 568 >> 2];
                                                                                                    $0 = HEAP32[$5 + 560 >> 2];
                                                                                                    if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                     $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                    } else {
                                                                                                     $2 = 0;
                                                                                                    }
                                                                                                    HEAP32[$5 + 440 >> 2] = FUNCTION_TABLE[$1 | 0]($0, jsvGetInteger($2));
                                                                                                    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 440 >> 2];
                                                                                                    break label$1;
                                                                                                   }
                                                                                                   HEAP32[$5 + 436 >> 2] = 0;
                                                                                                   label$198: {
                                                                                                    if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                     $0 = jsvNewArray(HEAP32[$5 + 556 >> 2], HEAP32[$5 + 552 >> 2]);
                                                                                                     break label$198;
                                                                                                    }
                                                                                                    $0 = jsvNewEmptyArray();
                                                                                                   }
                                                                                                   HEAP32[$5 + 432 >> 2] = $0;
                                                                                                   HEAP32[$5 + 436 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 432 >> 2]);
                                                                                                   jsvUnLock(HEAP32[$5 + 432 >> 2]);
                                                                                                   HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 436 >> 2];
                                                                                                   break label$1;
                                                                                                  }
                                                                                                  HEAP32[$5 + 428 >> 2] = 0;
                                                                                                  $1 = HEAP32[$5 + 568 >> 2];
                                                                                                  $0 = HEAP32[$5 + 560 >> 2];
                                                                                                  if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                   $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                  } else {
                                                                                                   $2 = 0;
                                                                                                  }
                                                                                                  HEAP32[$5 + 428 >> 2] = FUNCTION_TABLE[$1 | 0]($0, $2);
                                                                                                  HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 428 >> 2];
                                                                                                  break label$1;
                                                                                                 }
                                                                                                 HEAP32[$5 + 424 >> 2] = 0;
                                                                                                 HEAP32[$5 + 424 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2]);
                                                                                                 HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 424 >> 2];
                                                                                                 break label$1;
                                                                                                }
                                                                                                HEAP32[$5 + 420 >> 2] = 0;
                                                                                                $2 = HEAP32[$5 + 568 >> 2];
                                                                                                $1 = HEAP32[$5 + 560 >> 2];
                                                                                                if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                 $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                                } else {
                                                                                                 $0 = 0;
                                                                                                }
                                                                                                if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                 $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                                } else {
                                                                                                 $3 = 0;
                                                                                                }
                                                                                                HEAP32[$5 + 420 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetInteger($3));
                                                                                                HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 420 >> 2];
                                                                                                break label$1;
                                                                                               }
                                                                                               HEAP32[$5 + 416 >> 2] = 0;
                                                                                               $2 = HEAP32[$5 + 568 >> 2];
                                                                                               $1 = HEAP32[$5 + 560 >> 2];
                                                                                               if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                               } else {
                                                                                                $0 = 0;
                                                                                               }
                                                                                               if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                                $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                               } else {
                                                                                                $3 = 0;
                                                                                               }
                                                                                               HEAP32[$5 + 416 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetInteger($3)) & 1);
                                                                                               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 416 >> 2];
                                                                                               break label$1;
                                                                                              }
                                                                                              HEAP32[$5 + 412 >> 2] = 0;
                                                                                              label$210: {
                                                                                               if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                                $0 = jsvNewArray(HEAP32[$5 + 556 >> 2], HEAP32[$5 + 552 >> 2]);
                                                                                                break label$210;
                                                                                               }
                                                                                               $0 = jsvNewEmptyArray();
                                                                                              }
                                                                                              HEAP32[$5 + 408 >> 2] = $0;
                                                                                              HEAP32[$5 + 412 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2], HEAP32[$5 + 408 >> 2]) | 0);
                                                                                              jsvUnLock(HEAP32[$5 + 408 >> 2]);
                                                                                              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 412 >> 2];
                                                                                              break label$1;
                                                                                             }
                                                                                             HEAP32[$5 + 404 >> 2] = 0;
                                                                                             HEAP32[$5 + 404 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2]);
                                                                                             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 404 >> 2];
                                                                                             break label$1;
                                                                                            }
                                                                                            HEAP32[$5 + 400 >> 2] = 0;
                                                                                            $2 = HEAP32[$5 + 568 >> 2];
                                                                                            $1 = HEAP32[$5 + 560 >> 2];
                                                                                            if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                             $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                            } else {
                                                                                             $0 = 0;
                                                                                            }
                                                                                            if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                             $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                            } else {
                                                                                             $3 = 0;
                                                                                            }
                                                                                            HEAP32[$5 + 400 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                                                                                            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 400 >> 2];
                                                                                            break label$1;
                                                                                           }
                                                                                           HEAP32[$5 + 396 >> 2] = 0;
                                                                                           label$216: {
                                                                                            if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                                             $0 = jsvNewArray(HEAP32[$5 + 556 >> 2] + 8 | 0, HEAP32[$5 + 552 >> 2] - 2 | 0);
                                                                                             break label$216;
                                                                                            }
                                                                                            $0 = jsvNewEmptyArray();
                                                                                           }
                                                                                           HEAP32[$5 + 392 >> 2] = $0;
                                                                                           $2 = HEAP32[$5 + 568 >> 2];
                                                                                           $1 = HEAP32[$5 + 560 >> 2];
                                                                                           if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                            $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                           } else {
                                                                                            $0 = 0;
                                                                                           }
                                                                                           $0 = jsvGetInteger($0);
                                                                                           if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                            $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                           } else {
                                                                                            $3 = 0;
                                                                                           }
                                                                                           HEAP32[$5 + 396 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, $3, HEAP32[$5 + 392 >> 2]);
                                                                                           jsvUnLock(HEAP32[$5 + 392 >> 2]);
                                                                                           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 396 >> 2];
                                                                                           break label$1;
                                                                                          }
                                                                                          HEAP32[$5 + 388 >> 2] = 0;
                                                                                          $2 = HEAP32[$5 + 568 >> 2];
                                                                                          $1 = HEAP32[$5 + 560 >> 2];
                                                                                          if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                           $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                          } else {
                                                                                           $0 = 0;
                                                                                          }
                                                                                          $0 = jsvGetInteger($0);
                                                                                          if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                           $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                          } else {
                                                                                           $3 = 0;
                                                                                          }
                                                                                          HEAP32[$5 + 388 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                                                                                          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 388 >> 2];
                                                                                          break label$1;
                                                                                         }
                                                                                         HEAP32[$5 + 384 >> 2] = 0;
                                                                                         $0 = HEAP32[$5 + 568 >> 2];
                                                                                         if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                          $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                         } else {
                                                                                          $1 = 0;
                                                                                         }
                                                                                         HEAP32[$5 + 384 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$0 | 0]($1) & 1);
                                                                                         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 384 >> 2];
                                                                                         break label$1;
                                                                                        }
                                                                                        HEAP32[$5 + 380 >> 2] = 0;
                                                                                        label$228: {
                                                                                         if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                          $0 = jsvNewArray(HEAP32[$5 + 556 >> 2], HEAP32[$5 + 552 >> 2]);
                                                                                          break label$228;
                                                                                         }
                                                                                         $0 = jsvNewEmptyArray();
                                                                                        }
                                                                                        HEAP32[$5 + 376 >> 2] = $0;
                                                                                        HEAP32[$5 + 380 >> 2] = FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2], HEAP32[$5 + 376 >> 2]);
                                                                                        jsvUnLock(HEAP32[$5 + 376 >> 2]);
                                                                                        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 380 >> 2];
                                                                                        break label$1;
                                                                                       }
                                                                                       HEAP32[$5 + 372 >> 2] = 0;
                                                                                       $3 = HEAP32[$5 + 568 >> 2];
                                                                                       $2 = HEAP32[$5 + 560 >> 2];
                                                                                       if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                        $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                       } else {
                                                                                        $0 = 0;
                                                                                       }
                                                                                       if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                        $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                       } else {
                                                                                        $1 = 0;
                                                                                       }
                                                                                       $1 = jsvGetInteger($1);
                                                                                       if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                                        $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                                                                       } else {
                                                                                        $4 = 0;
                                                                                       }
                                                                                       HEAP32[$5 + 372 >> 2] = FUNCTION_TABLE[$3 | 0]($2, $0, $1, $4);
                                                                                       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 372 >> 2];
                                                                                       break label$1;
                                                                                      }
                                                                                      HEAP32[$5 + 368 >> 2] = 0;
                                                                                      $0 = HEAP32[$5 + 568 >> 2];
                                                                                      if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                       $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                      } else {
                                                                                       $1 = 0;
                                                                                      }
                                                                                      HEAP32[$5 + 368 >> 2] = FUNCTION_TABLE[$0 | 0](jsvGetInteger($1));
                                                                                      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 368 >> 2];
                                                                                      break label$1;
                                                                                     }
                                                                                     HEAP32[$5 + 364 >> 2] = 0;
                                                                                     HEAP32[$5 + 364 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2]) | 0);
                                                                                     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 364 >> 2];
                                                                                     break label$1;
                                                                                    }
                                                                                    HEAP32[$5 + 360 >> 2] = 0;
                                                                                    $2 = HEAP32[$5 + 568 >> 2];
                                                                                    if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                     $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                    } else {
                                                                                     $0 = 0;
                                                                                    }
                                                                                    if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                     $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                    } else {
                                                                                     $1 = 0;
                                                                                    }
                                                                                    $1 = jsvGetInteger($1);
                                                                                    if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                                     $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                                                                    } else {
                                                                                     $3 = 0;
                                                                                    }
                                                                                    HEAP32[$5 + 360 >> 2] = FUNCTION_TABLE[$2 | 0]($0, $1, jsvGetInteger($3));
                                                                                    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 360 >> 2];
                                                                                    break label$1;
                                                                                   }
                                                                                   HEAP32[$5 + 356 >> 2] = 0;
                                                                                   $2 = HEAP32[$5 + 568 >> 2];
                                                                                   $1 = HEAP32[$5 + 560 >> 2];
                                                                                   if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                    $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                   } else {
                                                                                    $0 = 0;
                                                                                   }
                                                                                   if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                    $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                   } else {
                                                                                    $3 = 0;
                                                                                   }
                                                                                   FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetInteger($3));
                                                                                   HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 356 >> 2];
                                                                                   break label$1;
                                                                                  }
                                                                                  HEAP32[$5 + 352 >> 2] = 0;
                                                                                  $2 = HEAP32[$5 + 568 >> 2];
                                                                                  $1 = HEAP32[$5 + 560 >> 2];
                                                                                  if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                   $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                  } else {
                                                                                   $0 = 0;
                                                                                  }
                                                                                  $0 = jsvGetInteger($0);
                                                                                  if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                   $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                  } else {
                                                                                   $3 = 0;
                                                                                  }
                                                                                  HEAP32[$5 + 352 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetBool($3) & 1);
                                                                                  HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 352 >> 2];
                                                                                  break label$1;
                                                                                 }
                                                                                 HEAP32[$5 + 348 >> 2] = 0;
                                                                                 $3 = HEAP32[$5 + 568 >> 2];
                                                                                 $2 = HEAP32[$5 + 560 >> 2];
                                                                                 if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                                  $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                                 } else {
                                                                                  $0 = 0;
                                                                                 }
                                                                                 $1 = jsvGetInteger($0);
                                                                                 if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                                  $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                                 } else {
                                                                                  $0 = 0;
                                                                                 }
                                                                                 if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                                  $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                                                                 } else {
                                                                                  $4 = 0;
                                                                                 }
                                                                                 FUNCTION_TABLE[$3 | 0]($2, $1, $0, jsvGetBool($4) & 1);
                                                                                 HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 348 >> 2];
                                                                                 break label$1;
                                                                                }
                                                                                HEAP32[$5 + 344 >> 2] = 0;
                                                                                HEAP32[$5 + 344 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]());
                                                                                HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 344 >> 2];
                                                                                break label$1;
                                                                               }
                                                                               HEAP32[$5 + 340 >> 2] = 0;
                                                                               HEAP32[$5 + 340 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2]) | 0);
                                                                               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 340 >> 2];
                                                                               break label$1;
                                                                              }
                                                                              HEAP32[$5 + 336 >> 2] = 0;
                                                                              HEAP32[$5 + 336 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2]));
                                                                              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 336 >> 2];
                                                                              break label$1;
                                                                             }
                                                                             HEAP32[$5 + 332 >> 2] = 0;
                                                                             $1 = HEAP32[$5 + 568 >> 2];
                                                                             $0 = HEAP32[$5 + 560 >> 2];
                                                                             if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                              $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                             } else {
                                                                              $2 = 0;
                                                                             }
                                                                             HEAP32[$5 + 332 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$1 | 0]($0, jsvGetFloat($2)));
                                                                             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 332 >> 2];
                                                                             break label$1;
                                                                            }
                                                                            HEAP32[$5 + 328 >> 2] = 0;
                                                                            $4 = HEAP32[$5 + 568 >> 2];
                                                                            $3 = HEAP32[$5 + 560 >> 2];
                                                                            if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                             $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                            } else {
                                                                             $0 = 0;
                                                                            }
                                                                            $2 = jsvGetInteger($0);
                                                                            if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                             $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                            } else {
                                                                             $1 = 0;
                                                                            }
                                                                            if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                             $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                                                            } else {
                                                                             $0 = 0;
                                                                            }
                                                                            if (HEAP32[$5 + 552 >> 2] > 3) {
                                                                             $6 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2];
                                                                            } else {
                                                                             $6 = 0;
                                                                            }
                                                                            HEAP32[$5 + 328 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$4 | 0]($3, $2, $1, $0, $6));
                                                                            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 328 >> 2];
                                                                            break label$1;
                                                                           }
                                                                           HEAP32[$5 + 324 >> 2] = 0;
                                                                           $3 = HEAP32[$5 + 568 >> 2];
                                                                           $2 = HEAP32[$5 + 560 >> 2];
                                                                           if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                            $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                           } else {
                                                                            $0 = 0;
                                                                           }
                                                                           $1 = jsvGetInteger($0);
                                                                           if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                            $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                           } else {
                                                                            $0 = 0;
                                                                           }
                                                                           if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                            $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                                                           } else {
                                                                            $4 = 0;
                                                                           }
                                                                           HEAP32[$5 + 324 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$3 | 0]($2, $1, $0, $4));
                                                                           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 324 >> 2];
                                                                           break label$1;
                                                                          }
                                                                          HEAP32[$5 + 320 >> 2] = 0;
                                                                          $2 = HEAP32[$5 + 568 >> 2];
                                                                          $1 = HEAP32[$5 + 560 >> 2];
                                                                          if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                           $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                          } else {
                                                                           $0 = 0;
                                                                          }
                                                                          $0 = jsvGetInteger($0);
                                                                          if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                           $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                          } else {
                                                                           $3 = 0;
                                                                          }
                                                                          HEAP32[$5 + 320 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$2 | 0]($1, $0, $3));
                                                                          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 320 >> 2];
                                                                          break label$1;
                                                                         }
                                                                         HEAP32[$5 + 316 >> 2] = 0;
                                                                         $1 = HEAP32[$5 + 568 >> 2];
                                                                         $0 = HEAP32[$5 + 560 >> 2];
                                                                         if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                          $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                         } else {
                                                                          $2 = 0;
                                                                         }
                                                                         HEAP32[$5 + 316 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$1 | 0]($0, jsvGetInteger($2)));
                                                                         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 316 >> 2];
                                                                         break label$1;
                                                                        }
                                                                        HEAP32[$5 + 312 >> 2] = 0;
                                                                        $0 = HEAP32[$5 + 568 >> 2];
                                                                        if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                         $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                        } else {
                                                                         $1 = 0;
                                                                        }
                                                                        HEAP32[$5 + 312 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$0 | 0]($1));
                                                                        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 312 >> 2];
                                                                        break label$1;
                                                                       }
                                                                       HEAP32[$5 + 308 >> 2] = 0;
                                                                       label$282: {
                                                                        if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                         $0 = jsvNewArray(HEAP32[$5 + 556 >> 2], HEAP32[$5 + 552 >> 2]);
                                                                         break label$282;
                                                                        }
                                                                        $0 = jsvNewEmptyArray();
                                                                       }
                                                                       HEAP32[$5 + 304 >> 2] = $0;
                                                                       FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 304 >> 2]);
                                                                       jsvUnLock(HEAP32[$5 + 304 >> 2]);
                                                                       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 308 >> 2];
                                                                       break label$1;
                                                                      }
                                                                      HEAP32[$5 + 300 >> 2] = 0;
                                                                      $2 = HEAP32[$5 + 568 >> 2];
                                                                      if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                       $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                      } else {
                                                                       $1 = 0;
                                                                      }
                                                                      if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                       $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                      } else {
                                                                       $0 = 0;
                                                                      }
                                                                      if (HEAP32[$5 + 552 >> 2] > 2) {
                                                                       $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                                                      } else {
                                                                       $3 = 0;
                                                                      }
                                                                      HEAP32[$5 + 300 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                                                                      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 300 >> 2];
                                                                      break label$1;
                                                                     }
                                                                     HEAP32[$5 + 296 >> 2] = 0;
                                                                     HEAP32[$5 + 296 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]());
                                                                     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 296 >> 2];
                                                                     break label$1;
                                                                    }
                                                                    HEAP32[$5 + 292 >> 2] = 0;
                                                                    HEAP32[$5 + 292 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]]() | 0);
                                                                    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 292 >> 2];
                                                                    break label$1;
                                                                   }
                                                                   HEAP32[$5 + 288 >> 2] = 0;
                                                                   $1 = HEAP32[$5 + 568 >> 2];
                                                                   $0 = HEAP32[$5 + 560 >> 2];
                                                                   if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                    $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                   } else {
                                                                    $2 = 0;
                                                                   }
                                                                   HEAP32[$5 + 288 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$1 | 0]($0, $2) & 1);
                                                                   HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 288 >> 2];
                                                                   break label$1;
                                                                  }
                                                                  HEAP32[$5 + 284 >> 2] = 0;
                                                                  label$292: {
                                                                   if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                    $0 = jsvNewArray(HEAP32[$5 + 556 >> 2] + 4 | 0, HEAP32[$5 + 552 >> 2] - 1 | 0);
                                                                    break label$292;
                                                                   }
                                                                   $0 = jsvNewEmptyArray();
                                                                  }
                                                                  HEAP32[$5 + 280 >> 2] = $0;
                                                                  $1 = HEAP32[$5 + 568 >> 2];
                                                                  $0 = HEAP32[$5 + 560 >> 2];
                                                                  if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                   $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                  } else {
                                                                   $2 = 0;
                                                                  }
                                                                  FUNCTION_TABLE[$1 | 0]($0, $2, HEAP32[$5 + 280 >> 2]);
                                                                  jsvUnLock(HEAP32[$5 + 280 >> 2]);
                                                                  HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 284 >> 2];
                                                                  break label$1;
                                                                 }
                                                                 HEAP32[$5 + 276 >> 2] = 0;
                                                                 label$296: {
                                                                  if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                   $0 = jsvNewArray(HEAP32[$5 + 556 >> 2] + 4 | 0, HEAP32[$5 + 552 >> 2] - 1 | 0);
                                                                   break label$296;
                                                                  }
                                                                  $0 = jsvNewEmptyArray();
                                                                 }
                                                                 HEAP32[$5 + 272 >> 2] = $0;
                                                                 $1 = HEAP32[$5 + 568 >> 2];
                                                                 $0 = HEAP32[$5 + 560 >> 2];
                                                                 if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                  $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                 } else {
                                                                  $2 = 0;
                                                                 }
                                                                 HEAP32[$5 + 276 >> 2] = FUNCTION_TABLE[$1 | 0]($0, $2, HEAP32[$5 + 272 >> 2]);
                                                                 jsvUnLock(HEAP32[$5 + 272 >> 2]);
                                                                 HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 276 >> 2];
                                                                 break label$1;
                                                                }
                                                                HEAP32[$5 + 268 >> 2] = 0;
                                                                $2 = HEAP32[$5 + 568 >> 2];
                                                                $1 = HEAP32[$5 + 560 >> 2];
                                                                if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                 $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                                } else {
                                                                 $0 = 0;
                                                                }
                                                                if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                 $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                                } else {
                                                                 $3 = 0;
                                                                }
                                                                HEAP32[$5 + 268 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$2 | 0]($1, $0, $3) | 0);
                                                                HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 268 >> 2];
                                                                break label$1;
                                                               }
                                                               HEAP32[$5 + 264 >> 2] = 0;
                                                               $2 = HEAP32[$5 + 568 >> 2];
                                                               $1 = HEAP32[$5 + 560 >> 2];
                                                               if (HEAP32[$5 + 552 >> 2] > 0) {
                                                                $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                               } else {
                                                                $0 = 0;
                                                               }
                                                               if (HEAP32[$5 + 552 >> 2] > 1) {
                                                                $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                               } else {
                                                                $3 = 0;
                                                               }
                                                               HEAP32[$5 + 264 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$2 | 0]($1, $0, $3) & 1);
                                                               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 264 >> 2];
                                                               break label$1;
                                                              }
                                                              HEAP32[$5 + 260 >> 2] = 0;
                                                              $0 = HEAP32[$5 + 568 >> 2];
                                                              if (HEAP32[$5 + 552 >> 2] > 0) {
                                                               $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                              } else {
                                                               $1 = 0;
                                                              }
                                                              HEAP32[$5 + 260 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$0 | 0](jsvGetFloat($1)));
                                                              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 260 >> 2];
                                                              break label$1;
                                                             }
                                                             HEAP32[$5 + 256 >> 2] = 0;
                                                             $0 = HEAP32[$5 + 568 >> 2];
                                                             if (HEAP32[$5 + 552 >> 2] > 0) {
                                                              $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                             } else {
                                                              $1 = 0;
                                                             }
                                                             HEAP32[$5 + 256 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$0 | 0](jsvGetInteger($1)) | 0);
                                                             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 256 >> 2];
                                                             break label$1;
                                                            }
                                                            HEAP32[$5 + 252 >> 2] = 0;
                                                            $0 = HEAP32[$5 + 568 >> 2];
                                                            if (HEAP32[$5 + 552 >> 2] > 0) {
                                                             $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                            } else {
                                                             $1 = 0;
                                                            }
                                                            HEAP32[$5 + 252 >> 2] = FUNCTION_TABLE[$0 | 0](jsvGetFloat($1));
                                                            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 252 >> 2];
                                                            break label$1;
                                                           }
                                                           HEAP32[$5 + 248 >> 2] = 0;
                                                           $0 = HEAP32[$5 + 568 >> 2];
                                                           if (HEAP32[$5 + 552 >> 2] > 0) {
                                                            $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                           } else {
                                                            $1 = 0;
                                                           }
                                                           $8 = jsvGetFloat($1);
                                                           if (HEAP32[$5 + 552 >> 2] > 1) {
                                                            $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                           } else {
                                                            $1 = 0;
                                                           }
                                                           $7 = jsvGetFloat($1);
                                                           if (HEAP32[$5 + 552 >> 2] > 2) {
                                                            $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                                           } else {
                                                            $1 = 0;
                                                           }
                                                           HEAP32[$5 + 248 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$0 | 0]($8, $7, jsvGetFloat($1)));
                                                           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 248 >> 2];
                                                           break label$1;
                                                          }
                                                          HEAP32[$5 + 244 >> 2] = 0;
                                                          label$320: {
                                                           if (HEAP32[$5 + 552 >> 2] > 0) {
                                                            $0 = jsvNewArray(HEAP32[$5 + 556 >> 2], HEAP32[$5 + 552 >> 2]);
                                                            break label$320;
                                                           }
                                                           $0 = jsvNewEmptyArray();
                                                          }
                                                          HEAP32[$5 + 240 >> 2] = $0;
                                                          HEAP32[$5 + 244 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 240 >> 2]));
                                                          jsvUnLock(HEAP32[$5 + 240 >> 2]);
                                                          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 244 >> 2];
                                                          break label$1;
                                                         }
                                                         HEAP32[$5 + 236 >> 2] = 0;
                                                         $0 = HEAP32[$5 + 568 >> 2];
                                                         if (HEAP32[$5 + 552 >> 2] > 0) {
                                                          $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                         } else {
                                                          $1 = 0;
                                                         }
                                                         HEAP32[$5 + 236 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$0 | 0](jsvGetFloat($1)) | 0);
                                                         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 236 >> 2];
                                                         break label$1;
                                                        }
                                                        HEAP32[$5 + 232 >> 2] = 0;
                                                        $2 = HEAP32[$5 + 568 >> 2];
                                                        if (HEAP32[$5 + 552 >> 2] > 0) {
                                                         $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                        } else {
                                                         $0 = 0;
                                                        }
                                                        $1 = jsvGetInteger($0);
                                                        if (HEAP32[$5 + 552 >> 2] > 1) {
                                                         $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                        } else {
                                                         $0 = 0;
                                                        }
                                                        if (HEAP32[$5 + 552 >> 2] > 2) {
                                                         $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                                        } else {
                                                         $3 = 0;
                                                        }
                                                        HEAP32[$5 + 232 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                                                        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 232 >> 2];
                                                        break label$1;
                                                       }
                                                       HEAP32[$5 + 228 >> 2] = 0;
                                                       $1 = HEAP32[$5 + 568 >> 2];
                                                       if (HEAP32[$5 + 552 >> 2] > 0) {
                                                        $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                       } else {
                                                        $0 = 0;
                                                       }
                                                       if (HEAP32[$5 + 552 >> 2] > 1) {
                                                        $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                       } else {
                                                        $2 = 0;
                                                       }
                                                       HEAP32[$5 + 228 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$1 | 0]($0, jsvGetFloat($2)));
                                                       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 228 >> 2];
                                                       break label$1;
                                                      }
                                                      HEAP32[$5 + 224 >> 2] = 0;
                                                      $2 = HEAP32[$5 + 568 >> 2];
                                                      if (HEAP32[$5 + 552 >> 2] > 0) {
                                                       $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                      } else {
                                                       $1 = 0;
                                                      }
                                                      if (HEAP32[$5 + 552 >> 2] > 1) {
                                                       $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                      } else {
                                                       $0 = 0;
                                                      }
                                                      if (HEAP32[$5 + 552 >> 2] > 2) {
                                                       $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                                      } else {
                                                       $3 = 0;
                                                      }
                                                      HEAP32[$5 + 224 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetInteger($3)));
                                                      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 224 >> 2];
                                                      break label$1;
                                                     }
                                                     HEAP32[$5 + 220 >> 2] = 0;
                                                     $2 = HEAP32[$5 + 568 >> 2];
                                                     if (HEAP32[$5 + 552 >> 2] > 0) {
                                                      $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                     } else {
                                                      $1 = 0;
                                                     }
                                                     if (HEAP32[$5 + 552 >> 2] > 1) {
                                                      $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                     } else {
                                                      $0 = 0;
                                                     }
                                                     if (HEAP32[$5 + 552 >> 2] > 2) {
                                                      $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                                     } else {
                                                      $3 = 0;
                                                     }
                                                     FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetBool($3) & 1);
                                                     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 220 >> 2];
                                                     break label$1;
                                                    }
                                                    HEAP32[$5 + 216 >> 2] = 0;
                                                    $0 = HEAP32[$5 + 568 >> 2];
                                                    if (HEAP32[$5 + 552 >> 2] > 0) {
                                                     $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                    } else {
                                                     $1 = 0;
                                                    }
                                                    $7 = jsvGetFloat($1);
                                                    if (HEAP32[$5 + 552 >> 2] > 1) {
                                                     $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                    } else {
                                                     $1 = 0;
                                                    }
                                                    FUNCTION_TABLE[$0 | 0]($7, $1);
                                                    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 216 >> 2];
                                                    break label$1;
                                                   }
                                                   HEAP32[$5 + 212 >> 2] = 0;
                                                   $2 = HEAP32[$5 + 568 >> 2];
                                                   if (HEAP32[$5 + 552 >> 2] > 0) {
                                                    $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                   } else {
                                                    $1 = 0;
                                                   }
                                                   if (HEAP32[$5 + 552 >> 2] > 1) {
                                                    $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                   } else {
                                                    $0 = 0;
                                                   }
                                                   if (HEAP32[$5 + 552 >> 2] > 2) {
                                                    $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                                   } else {
                                                    $3 = 0;
                                                   }
                                                   FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                                                   HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 212 >> 2];
                                                   break label$1;
                                                  }
                                                  HEAP32[$5 + 208 >> 2] = 0;
                                                  $1 = HEAP32[$5 + 568 >> 2];
                                                  if (HEAP32[$5 + 552 >> 2] > 0) {
                                                   $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                  } else {
                                                   $0 = 0;
                                                  }
                                                  if (HEAP32[$5 + 552 >> 2] > 1) {
                                                   $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                  } else {
                                                   $2 = 0;
                                                  }
                                                  FUNCTION_TABLE[$1 | 0]($0, jsvGetBool($2) & 1);
                                                  HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 208 >> 2];
                                                  break label$1;
                                                 }
                                                 HEAP32[$5 + 204 >> 2] = 0;
                                                 $0 = HEAP32[$5 + 568 >> 2];
                                                 if (HEAP32[$5 + 552 >> 2] > 0) {
                                                  $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                 } else {
                                                  $1 = 0;
                                                 }
                                                 HEAP32[$5 + 204 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$0 | 0]($1) | 0);
                                                 HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 204 >> 2];
                                                 break label$1;
                                                }
                                                HEAP32[$5 + 200 >> 2] = 0;
                                                $1 = HEAP32[$5 + 568 >> 2];
                                                if (HEAP32[$5 + 552 >> 2] > 0) {
                                                 $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                                } else {
                                                 $0 = 0;
                                                }
                                                if (HEAP32[$5 + 552 >> 2] > 1) {
                                                 $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                                } else {
                                                 $2 = 0;
                                                }
                                                HEAP32[$5 + 200 >> 2] = FUNCTION_TABLE[$1 | 0]($0, jsvGetInteger($2));
                                                HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 200 >> 2];
                                                break label$1;
                                               }
                                               HEAP32[$5 + 196 >> 2] = 0;
                                               $1 = HEAP32[$5 + 568 >> 2];
                                               if (HEAP32[$5 + 552 >> 2] > 0) {
                                                $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                               } else {
                                                $0 = 0;
                                               }
                                               if (HEAP32[$5 + 552 >> 2] > 1) {
                                                $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                               } else {
                                                $2 = 0;
                                               }
                                               HEAP32[$5 + 196 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$1 | 0]($0, jsvGetBool($2) & 1) | 0);
                                               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 196 >> 2];
                                               break label$1;
                                              }
                                              HEAP32[$5 + 192 >> 2] = 0;
                                              $3 = HEAP32[$5 + 568 >> 2];
                                              if (HEAP32[$5 + 552 >> 2] > 0) {
                                               $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                              } else {
                                               $2 = 0;
                                              }
                                              if (HEAP32[$5 + 552 >> 2] > 1) {
                                               $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                              } else {
                                               $1 = 0;
                                              }
                                              if (HEAP32[$5 + 552 >> 2] > 2) {
                                               $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                              } else {
                                               $0 = 0;
                                              }
                                              if (HEAP32[$5 + 552 >> 2] > 3) {
                                               $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2];
                                              } else {
                                               $4 = 0;
                                              }
                                              FUNCTION_TABLE[$3 | 0]($2, $1, $0, jsvGetInteger($4));
                                              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 192 >> 2];
                                              break label$1;
                                             }
                                             HEAP32[$5 + 188 >> 2] = 0;
                                             $2 = HEAP32[$5 + 568 >> 2];
                                             if (HEAP32[$5 + 552 >> 2] > 0) {
                                              $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                             } else {
                                              $1 = 0;
                                             }
                                             if (HEAP32[$5 + 552 >> 2] > 1) {
                                              $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                             } else {
                                              $0 = 0;
                                             }
                                             if (HEAP32[$5 + 552 >> 2] > 2) {
                                              $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                             } else {
                                              $3 = 0;
                                             }
                                             HEAP32[$5 + 188 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetBool($3) & 1);
                                             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 188 >> 2];
                                             break label$1;
                                            }
                                            HEAP32[$5 + 184 >> 2] = 0;
                                            $0 = HEAP32[$5 + 568 >> 2];
                                            if (HEAP32[$5 + 552 >> 2] > 0) {
                                             $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                            } else {
                                             $1 = 0;
                                            }
                                            $9 = jsvGetFloat($1);
                                            if (HEAP32[$5 + 552 >> 2] > 1) {
                                             $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                            } else {
                                             $1 = 0;
                                            }
                                            $8 = jsvGetFloat($1);
                                            if (HEAP32[$5 + 552 >> 2] > 2) {
                                             $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                            } else {
                                             $1 = 0;
                                            }
                                            $7 = jsvGetFloat($1);
                                            if (HEAP32[$5 + 552 >> 2] > 3) {
                                             $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2];
                                            } else {
                                             $1 = 0;
                                            }
                                            HEAP32[$5 + 184 >> 2] = FUNCTION_TABLE[$0 | 0]($9, $8, $7, jsvGetInteger($1));
                                            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 184 >> 2];
                                            break label$1;
                                           }
                                           HEAP32[$5 + 180 >> 2] = 0;
                                           label$392: {
                                            if (HEAP32[$5 + 552 >> 2] > 1) {
                                             $0 = jsvNewArray(HEAP32[$5 + 556 >> 2] + 4 | 0, HEAP32[$5 + 552 >> 2] - 1 | 0);
                                             break label$392;
                                            }
                                            $0 = jsvNewEmptyArray();
                                           }
                                           HEAP32[$5 + 176 >> 2] = $0;
                                           $0 = HEAP32[$5 + 568 >> 2];
                                           if (HEAP32[$5 + 552 >> 2] > 0) {
                                            $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                           } else {
                                            $1 = 0;
                                           }
                                           FUNCTION_TABLE[$0 | 0]($1, HEAP32[$5 + 176 >> 2]);
                                           jsvUnLock(HEAP32[$5 + 176 >> 2]);
                                           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 180 >> 2];
                                           break label$1;
                                          }
                                          HEAP32[$5 + 172 >> 2] = 0;
                                          $1 = HEAP32[$5 + 568 >> 2];
                                          if (HEAP32[$5 + 552 >> 2] > 0) {
                                           $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                          } else {
                                           $0 = 0;
                                          }
                                          if (HEAP32[$5 + 552 >> 2] > 1) {
                                           $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                          } else {
                                           $2 = 0;
                                          }
                                          FUNCTION_TABLE[$1 | 0]($0, jsvGetInteger($2));
                                          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 172 >> 2];
                                          break label$1;
                                         }
                                         HEAP32[$5 + 168 >> 2] = 0;
                                         label$400: {
                                          if (HEAP32[$5 + 552 >> 2] > 2) {
                                           $0 = jsvNewArray(HEAP32[$5 + 556 >> 2] + 8 | 0, HEAP32[$5 + 552 >> 2] - 2 | 0);
                                           break label$400;
                                          }
                                          $0 = jsvNewEmptyArray();
                                         }
                                         HEAP32[$5 + 164 >> 2] = $0;
                                         $1 = HEAP32[$5 + 568 >> 2];
                                         if (HEAP32[$5 + 552 >> 2] > 0) {
                                          $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                         } else {
                                          $0 = 0;
                                         }
                                         if (HEAP32[$5 + 552 >> 2] > 1) {
                                          $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                         } else {
                                          $2 = 0;
                                         }
                                         HEAP32[$5 + 168 >> 2] = FUNCTION_TABLE[$1 | 0]($0, jsvGetFloat($2), HEAP32[$5 + 164 >> 2]);
                                         jsvUnLock(HEAP32[$5 + 164 >> 2]);
                                         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 168 >> 2];
                                         break label$1;
                                        }
                                        HEAP32[$5 + 160 >> 2] = 0;
                                        $1 = HEAP32[$5 + 568 >> 2];
                                        if (HEAP32[$5 + 552 >> 2] > 0) {
                                         $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                        } else {
                                         $0 = 0;
                                        }
                                        if (HEAP32[$5 + 552 >> 2] > 1) {
                                         $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                        } else {
                                         $2 = 0;
                                        }
                                        FUNCTION_TABLE[$1 | 0]($0, jsvGetFloat($2));
                                        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 160 >> 2];
                                        break label$1;
                                       }
                                       HEAP32[$5 + 156 >> 2] = 0;
                                       $0 = HEAP32[$5 + 568 >> 2];
                                       if (HEAP32[$5 + 552 >> 2] > 0) {
                                        $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                       } else {
                                        $1 = 0;
                                       }
                                       HEAP32[$5 + 156 >> 2] = jsvNewFromFloat(+FUNCTION_TABLE[$0 | 0](jshGetPinFromVar($1) & 255));
                                       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 156 >> 2];
                                       break label$1;
                                      }
                                      HEAP32[$5 + 152 >> 2] = 0;
                                      $1 = HEAP32[$5 + 568 >> 2];
                                      if (HEAP32[$5 + 552 >> 2] > 0) {
                                       $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                      } else {
                                       $0 = 0;
                                      }
                                      $0 = jshGetPinFromVar($0) & 255;
                                      if (HEAP32[$5 + 552 >> 2] > 1) {
                                       $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                      } else {
                                       $2 = 0;
                                      }
                                      $7 = jsvGetFloat($2);
                                      if (HEAP32[$5 + 552 >> 2] > 2) {
                                       $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                      } else {
                                       $2 = 0;
                                      }
                                      FUNCTION_TABLE[$1 | 0]($0, $7, $2);
                                      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 152 >> 2];
                                      break label$1;
                                     }
                                     HEAP32[$5 + 148 >> 2] = 0;
                                     $2 = HEAP32[$5 + 568 >> 2];
                                     if (HEAP32[$5 + 552 >> 2] > 0) {
                                      $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                     } else {
                                      $0 = 0;
                                     }
                                     $1 = jshGetPinFromVar($0) & 255;
                                     if (HEAP32[$5 + 552 >> 2] > 1) {
                                      $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                     } else {
                                      $0 = 0;
                                     }
                                     $0 = jsvGetBool($0) & 1;
                                     if (HEAP32[$5 + 552 >> 2] > 2) {
                                      $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                     } else {
                                      $3 = 0;
                                     }
                                     FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                                     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 148 >> 2];
                                     break label$1;
                                    }
                                    HEAP32[$5 + 144 >> 2] = 0;
                                    $2 = HEAP32[$5 + 568 >> 2];
                                    if (HEAP32[$5 + 552 >> 2] > 0) {
                                     $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                    } else {
                                     $0 = 0;
                                    }
                                    $1 = jshGetPinFromVar($0) & 255;
                                    if (HEAP32[$5 + 552 >> 2] > 1) {
                                     $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                    } else {
                                     $0 = 0;
                                    }
                                    if (HEAP32[$5 + 552 >> 2] > 2) {
                                     $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                    } else {
                                     $3 = 0;
                                    }
                                    FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetBool($3) & 1);
                                    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 144 >> 2];
                                    break label$1;
                                   }
                                   HEAP32[$5 + 140 >> 2] = 0;
                                   $0 = HEAP32[$5 + 568 >> 2];
                                   if (HEAP32[$5 + 552 >> 2] > 0) {
                                    $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                   } else {
                                    $1 = 0;
                                   }
                                   HEAP32[$5 + 140 >> 2] = FUNCTION_TABLE[$0 | 0](jshGetPinFromVar($1) & 255);
                                   HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 140 >> 2];
                                   break label$1;
                                  }
                                  HEAP32[$5 + 136 >> 2] = 0;
                                  $2 = HEAP32[$5 + 568 >> 2];
                                  if (HEAP32[$5 + 552 >> 2] > 0) {
                                   $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                  } else {
                                   $0 = 0;
                                  }
                                  if (HEAP32[$5 + 552 >> 2] > 1) {
                                   $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                  } else {
                                   $1 = 0;
                                  }
                                  $1 = jshGetPinFromVar($1) & 255;
                                  if (HEAP32[$5 + 552 >> 2] > 2) {
                                   $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                                  } else {
                                   $3 = 0;
                                  }
                                  HEAP32[$5 + 136 >> 2] = FUNCTION_TABLE[$2 | 0]($0, $1, $3);
                                  HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 136 >> 2];
                                  break label$1;
                                 }
                                 HEAP32[$5 + 132 >> 2] = 0;
                                 $2 = HEAP32[$5 + 568 >> 2];
                                 $1 = HEAP32[$5 + 560 >> 2];
                                 if (HEAP32[$5 + 552 >> 2] > 0) {
                                  $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                 } else {
                                  $0 = 0;
                                 }
                                 $0 = jsvGetBool($0) & 1;
                                 if (HEAP32[$5 + 552 >> 2] > 1) {
                                  $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                 } else {
                                  $3 = 0;
                                 }
                                 FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetFloat($3));
                                 HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 132 >> 2];
                                 break label$1;
                                }
                                HEAP32[$5 + 128 >> 2] = 0;
                                $2 = HEAP32[$5 + 568 >> 2];
                                $1 = HEAP32[$5 + 560 >> 2];
                                if (HEAP32[$5 + 552 >> 2] > 0) {
                                 $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                                } else {
                                 $0 = 0;
                                }
                                $0 = jsvGetBool($0) & 1;
                                if (HEAP32[$5 + 552 >> 2] > 1) {
                                 $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                                } else {
                                 $3 = 0;
                                }
                                FUNCTION_TABLE[$2 | 0]($1, $0, $3);
                                HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 128 >> 2];
                                break label$1;
                               }
                               HEAP32[$5 + 124 >> 2] = 0;
                               $1 = HEAP32[$5 + 568 >> 2];
                               $0 = HEAP32[$5 + 560 >> 2];
                               if (HEAP32[$5 + 552 >> 2] > 0) {
                                $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                               } else {
                                $2 = 0;
                               }
                               $7 = jsvGetFloat($2);
                               if (HEAP32[$5 + 552 >> 2] > 1) {
                                $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                               } else {
                                $2 = 0;
                               }
                               FUNCTION_TABLE[$1 | 0]($0, $7, $2);
                               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 124 >> 2];
                               break label$1;
                              }
                              HEAP32[$5 + 120 >> 2] = 0;
                              $2 = HEAP32[$5 + 568 >> 2];
                              $1 = HEAP32[$5 + 560 >> 2];
                              if (HEAP32[$5 + 552 >> 2] > 0) {
                               $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                              } else {
                               $0 = 0;
                              }
                              if (HEAP32[$5 + 552 >> 2] > 1) {
                               $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                              } else {
                               $3 = 0;
                              }
                              FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetBool($3) & 1);
                              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 120 >> 2];
                              break label$1;
                             }
                             HEAP32[$5 + 116 >> 2] = 0;
                             label$454: {
                              if (HEAP32[$5 + 552 >> 2] > 0) {
                               $0 = jsvNewArray(HEAP32[$5 + 556 >> 2], HEAP32[$5 + 552 >> 2]);
                               break label$454;
                              }
                              $0 = jsvNewEmptyArray();
                             }
                             HEAP32[$5 + 112 >> 2] = $0;
                             FUNCTION_TABLE[HEAP32[$5 + 568 >> 2]](HEAP32[$5 + 560 >> 2], HEAP32[$5 + 112 >> 2]);
                             jsvUnLock(HEAP32[$5 + 112 >> 2]);
                             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 116 >> 2];
                             break label$1;
                            }
                            HEAP32[$5 + 108 >> 2] = 0;
                            $1 = HEAP32[$5 + 568 >> 2];
                            if (HEAP32[$5 + 552 >> 2] > 0) {
                             $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                            } else {
                             $0 = 0;
                            }
                            if (HEAP32[$5 + 552 >> 2] > 1) {
                             $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                            } else {
                             $2 = 0;
                            }
                            HEAP32[$5 + 108 >> 2] = FUNCTION_TABLE[$1 | 0]($0, jsvGetBool($2) & 1);
                            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 108 >> 2];
                            break label$1;
                           }
                           HEAP32[$5 + 104 >> 2] = 0;
                           $3 = HEAP32[$5 + 568 >> 2];
                           if (HEAP32[$5 + 552 >> 2] > 0) {
                            $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                           } else {
                            $1 = 0;
                           }
                           if (HEAP32[$5 + 552 >> 2] > 1) {
                            $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                           } else {
                            $0 = 0;
                           }
                           if (HEAP32[$5 + 552 >> 2] > 2) {
                            $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                           } else {
                            $2 = 0;
                           }
                           $2 = jsvGetInteger($2);
                           if (HEAP32[$5 + 552 >> 2] > 3) {
                            $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2];
                           } else {
                            $4 = 0;
                           }
                           HEAP32[$5 + 104 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$3 | 0]($1, $0, $2, jsvGetInteger($4)) & 1);
                           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 104 >> 2];
                           break label$1;
                          }
                          HEAP32[$5 + 100 >> 2] = 0;
                          $1 = HEAP32[$5 + 568 >> 2];
                          if (HEAP32[$5 + 552 >> 2] > 0) {
                           $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                          } else {
                           $0 = 0;
                          }
                          if (HEAP32[$5 + 552 >> 2] > 1) {
                           $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                          } else {
                           $2 = 0;
                          }
                          HEAP32[$5 + 100 >> 2] = jsvNewFromBool(FUNCTION_TABLE[$1 | 0]($0, $2) & 1);
                          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 100 >> 2];
                          break label$1;
                         }
                         HEAP32[$5 + 96 >> 2] = 0;
                         $0 = HEAP32[$5 + 568 >> 2];
                         if (HEAP32[$5 + 552 >> 2] > 0) {
                          $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                         } else {
                          $1 = 0;
                         }
                         HEAP32[$5 + 96 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$0 | 0](jsvGetBool($1) & 1) | 0);
                         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 96 >> 2];
                         break label$1;
                        }
                        HEAP32[$5 + 92 >> 2] = 0;
                        $0 = HEAP32[$5 + 568 >> 2];
                        if (HEAP32[$5 + 552 >> 2] > 0) {
                         $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                        } else {
                         $1 = 0;
                        }
                        HEAP32[$5 + 92 >> 2] = FUNCTION_TABLE[$0 | 0](jsvGetBool($1) & 1);
                        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 92 >> 2];
                        break label$1;
                       }
                       HEAP32[$5 + 88 >> 2] = 0;
                       $2 = HEAP32[$5 + 568 >> 2];
                       $1 = HEAP32[$5 + 560 >> 2];
                       if (HEAP32[$5 + 552 >> 2] > 0) {
                        $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                       } else {
                        $0 = 0;
                       }
                       if (HEAP32[$5 + 552 >> 2] > 1) {
                        $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                       } else {
                        $3 = 0;
                       }
                       HEAP32[$5 + 88 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, jshGetPinFromVar($3) & 255);
                       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 88 >> 2];
                       break label$1;
                      }
                      HEAP32[$5 + 84 >> 2] = 0;
                      $4 = HEAP32[$5 + 568 >> 2];
                      $3 = HEAP32[$5 + 560 >> 2];
                      if (HEAP32[$5 + 552 >> 2] > 0) {
                       $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                      } else {
                       $0 = 0;
                      }
                      if (HEAP32[$5 + 552 >> 2] > 1) {
                       $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                      } else {
                       $1 = 0;
                      }
                      $2 = jsvGetInteger($1);
                      if (HEAP32[$5 + 552 >> 2] > 2) {
                       $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                      } else {
                       $1 = 0;
                      }
                      $1 = jsvGetInteger($1);
                      if (HEAP32[$5 + 552 >> 2] > 3) {
                       $6 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2];
                      } else {
                       $6 = 0;
                      }
                      FUNCTION_TABLE[$4 | 0]($3, $0, $2, $1, jshGetPinFromVar($6) & 255);
                      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 84 >> 2];
                      break label$1;
                     }
                     HEAP32[$5 + 80 >> 2] = 0;
                     $3 = HEAP32[$5 + 568 >> 2];
                     $2 = HEAP32[$5 + 560 >> 2];
                     if (HEAP32[$5 + 552 >> 2] > 0) {
                      $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                     } else {
                      $0 = 0;
                     }
                     $1 = jsvGetInteger($0);
                     if (HEAP32[$5 + 552 >> 2] > 1) {
                      $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                     } else {
                      $0 = 0;
                     }
                     $0 = jsvGetInteger($0);
                     if (HEAP32[$5 + 552 >> 2] > 2) {
                      $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                     } else {
                      $4 = 0;
                     }
                     HEAP32[$5 + 80 >> 2] = FUNCTION_TABLE[$3 | 0]($2, $1, $0, jsvGetInteger($4));
                     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 80 >> 2];
                     break label$1;
                    }
                    HEAP32[$5 + 76 >> 2] = 0;
                    $2 = HEAP32[$5 + 568 >> 2];
                    $1 = HEAP32[$5 + 560 >> 2];
                    if (HEAP32[$5 + 552 >> 2] > 0) {
                     $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                    } else {
                     $0 = 0;
                    }
                    $0 = jshGetPinFromVar($0) & 255;
                    if (HEAP32[$5 + 552 >> 2] > 1) {
                     $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                    } else {
                     $3 = 0;
                    }
                    $7 = jsvGetFloat($3);
                    if (HEAP32[$5 + 552 >> 2] > 2) {
                     $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                    } else {
                     $3 = 0;
                    }
                    FUNCTION_TABLE[$2 | 0]($1, $0, $7, $3);
                    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 76 >> 2];
                    break label$1;
                   }
                   HEAP32[$5 + 72 >> 2] = 0;
                   $3 = HEAP32[$5 + 568 >> 2];
                   if (HEAP32[$5 + 552 >> 2] > 0) {
                    $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                   } else {
                    $0 = 0;
                   }
                   $2 = jsvGetInteger($0);
                   if (HEAP32[$5 + 552 >> 2] > 1) {
                    $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                   } else {
                    $0 = 0;
                   }
                   $1 = jsvGetInteger($0);
                   if (HEAP32[$5 + 552 >> 2] > 2) {
                    $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                   } else {
                    $0 = 0;
                   }
                   $0 = jsvGetInteger($0);
                   if (HEAP32[$5 + 552 >> 2] > 3) {
                    $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2];
                   } else {
                    $4 = 0;
                   }
                   HEAP32[$5 + 72 >> 2] = FUNCTION_TABLE[$3 | 0]($2, $1, $0, $4);
                   HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 72 >> 2];
                   break label$1;
                  }
                  HEAP32[$5 + 68 >> 2] = 0;
                  $1 = HEAP32[$5 + 568 >> 2];
                  $0 = HEAP32[$5 + 560 >> 2];
                  if (HEAP32[$5 + 552 >> 2] > 0) {
                   $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                  } else {
                   $2 = 0;
                  }
                  HEAP32[$5 + 68 >> 2] = FUNCTION_TABLE[$1 | 0]($0, jsvGetBool($2) & 1);
                  HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 68 >> 2];
                  break label$1;
                 }
                 HEAP32[$5 + 64 >> 2] = 0;
                 $4 = HEAP32[$5 + 568 >> 2];
                 $3 = HEAP32[$5 + 560 >> 2];
                 if (HEAP32[$5 + 552 >> 2] > 0) {
                  $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                 } else {
                  $0 = 0;
                 }
                 if (HEAP32[$5 + 552 >> 2] > 1) {
                  $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                 } else {
                  $1 = 0;
                 }
                 $2 = jsvGetInteger($1);
                 if (HEAP32[$5 + 552 >> 2] > 2) {
                  $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                 } else {
                  $1 = 0;
                 }
                 $1 = jsvGetInteger($1);
                 if (HEAP32[$5 + 552 >> 2] > 3) {
                  $6 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2];
                 } else {
                  $6 = 0;
                 }
                 HEAP32[$5 + 64 >> 2] = FUNCTION_TABLE[$4 | 0]($3, $0, $2, $1, jsvGetInteger($6));
                 HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 64 >> 2];
                 break label$1;
                }
                HEAP32[$5 + 60 >> 2] = 0;
                $4 = HEAP32[$5 + 568 >> 2];
                $3 = HEAP32[$5 + 560 >> 2];
                if (HEAP32[$5 + 552 >> 2] > 0) {
                 $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
                } else {
                 $0 = 0;
                }
                $2 = jsvGetInteger($0);
                if (HEAP32[$5 + 552 >> 2] > 1) {
                 $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
                } else {
                 $0 = 0;
                }
                $1 = jsvGetInteger($0);
                if (HEAP32[$5 + 552 >> 2] > 2) {
                 $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
                } else {
                 $0 = 0;
                }
                $0 = jsvGetInteger($0);
                if (HEAP32[$5 + 552 >> 2] > 3) {
                 $6 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2];
                } else {
                 $6 = 0;
                }
                HEAP32[$5 + 60 >> 2] = FUNCTION_TABLE[$4 | 0]($3, $2, $1, $0, jsvGetInteger($6));
                HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 60 >> 2];
                break label$1;
               }
               HEAP32[$5 + 56 >> 2] = 0;
               $2 = HEAP32[$5 + 568 >> 2];
               $1 = HEAP32[$5 + 560 >> 2];
               if (HEAP32[$5 + 552 >> 2] > 0) {
                $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
               } else {
                $0 = 0;
               }
               $0 = jsvGetInteger($0);
               if (HEAP32[$5 + 552 >> 2] > 1) {
                $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
               } else {
                $3 = 0;
               }
               HEAP32[$5 + 56 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetInteger($3)) | 0);
               HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 56 >> 2];
               break label$1;
              }
              HEAP32[$5 + 52 >> 2] = 0;
              $3 = HEAP32[$5 + 568 >> 2];
              $2 = HEAP32[$5 + 560 >> 2];
              if (HEAP32[$5 + 552 >> 2] > 0) {
               $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
              } else {
               $0 = 0;
              }
              $1 = jsvGetInteger($0);
              if (HEAP32[$5 + 552 >> 2] > 1) {
               $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
              } else {
               $0 = 0;
              }
              $0 = jsvGetInteger($0);
              if (HEAP32[$5 + 552 >> 2] > 2) {
               $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
              } else {
               $4 = 0;
              }
              HEAP32[$5 + 52 >> 2] = FUNCTION_TABLE[$3 | 0]($2, $1, $0, $4);
              HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 52 >> 2];
              break label$1;
             }
             HEAP32[$5 + 48 >> 2] = 0;
             $3 = HEAP32[$5 + 568 >> 2];
             $2 = HEAP32[$5 + 560 >> 2];
             if (HEAP32[$5 + 552 >> 2] > 0) {
              $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
             } else {
              $1 = 0;
             }
             if (HEAP32[$5 + 552 >> 2] > 1) {
              $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
             } else {
              $0 = 0;
             }
             if (HEAP32[$5 + 552 >> 2] > 2) {
              $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
             } else {
              $4 = 0;
             }
             HEAP32[$5 + 48 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$3 | 0]($2, $1, $0, $4) | 0);
             HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 48 >> 2];
             break label$1;
            }
            HEAP32[$5 + 44 >> 2] = 0;
            $3 = HEAP32[$5 + 568 >> 2];
            $2 = HEAP32[$5 + 560 >> 2];
            if (HEAP32[$5 + 552 >> 2] > 0) {
             $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
            } else {
             $1 = 0;
            }
            if (HEAP32[$5 + 552 >> 2] > 1) {
             $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
            } else {
             $0 = 0;
            }
            if (HEAP32[$5 + 552 >> 2] > 2) {
             $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
            } else {
             $4 = 0;
            }
            HEAP32[$5 + 44 >> 2] = FUNCTION_TABLE[$3 | 0]($2, $1, $0, $4);
            HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 44 >> 2];
            break label$1;
           }
           HEAP32[$5 + 40 >> 2] = 0;
           $4 = HEAP32[$5 + 568 >> 2];
           $3 = HEAP32[$5 + 560 >> 2];
           if (HEAP32[$5 + 552 >> 2] > 0) {
            $1 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
           } else {
            $1 = 0;
           }
           if (HEAP32[$5 + 552 >> 2] > 1) {
            $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
           } else {
            $0 = 0;
           }
           $2 = jsvGetInteger($0);
           if (HEAP32[$5 + 552 >> 2] > 2) {
            $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
           } else {
            $0 = 0;
           }
           if (HEAP32[$5 + 552 >> 2] > 3) {
            $6 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2];
           } else {
            $6 = 0;
           }
           HEAP32[$5 + 40 >> 2] = FUNCTION_TABLE[$4 | 0]($3, $1, $2, $0, jsvGetInteger($6));
           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 40 >> 2];
           break label$1;
          }
          HEAP32[$5 + 36 >> 2] = 0;
          $1 = HEAP32[$5 + 568 >> 2];
          $0 = HEAP32[$5 + 560 >> 2];
          if (HEAP32[$5 + 552 >> 2] > 0) {
           $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
          } else {
           $2 = 0;
          }
          HEAP32[$5 + 36 >> 2] = jsvNewFromInteger(FUNCTION_TABLE[$1 | 0]($0, $2) | 0);
          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 36 >> 2];
          break label$1;
         }
         HEAP32[$5 + 32 >> 2] = 0;
         $4 = HEAP32[$5 + 568 >> 2];
         $3 = HEAP32[$5 + 560 >> 2];
         if (HEAP32[$5 + 552 >> 2] > 0) {
          $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
         } else {
          $0 = 0;
         }
         if (HEAP32[$5 + 552 >> 2] > 1) {
          $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
         } else {
          $1 = 0;
         }
         $2 = jsvGetInteger($1);
         if (HEAP32[$5 + 552 >> 2] > 2) {
          $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
         } else {
          $1 = 0;
         }
         $1 = jsvGetInteger($1);
         if (HEAP32[$5 + 552 >> 2] > 3) {
          $6 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2];
         } else {
          $6 = 0;
         }
         HEAP32[$5 + 32 >> 2] = FUNCTION_TABLE[$4 | 0]($3, $0, $2, $1, jsvGetBool($6) & 1);
         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 32 >> 2];
         break label$1;
        }
        HEAP32[$5 + 28 >> 2] = 0;
        $1 = HEAP32[$5 + 568 >> 2];
        $0 = HEAP32[$5 + 560 >> 2];
        if (HEAP32[$5 + 552 >> 2] > 0) {
         $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
        } else {
         $2 = 0;
        }
        $9 = jsvGetFloat($2);
        if (HEAP32[$5 + 552 >> 2] > 1) {
         $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
        } else {
         $2 = 0;
        }
        $8 = jsvGetFloat($2);
        if (HEAP32[$5 + 552 >> 2] > 2) {
         $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
        } else {
         $2 = 0;
        }
        $7 = jsvGetFloat($2);
        if (HEAP32[$5 + 552 >> 2] > 3) {
         $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2];
        } else {
         $2 = 0;
        }
        HEAP32[$5 + 28 >> 2] = FUNCTION_TABLE[$1 | 0]($0, $9, $8, $7, jsvGetFloat($2));
        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 28 >> 2];
        break label$1;
       }
       HEAP32[$5 + 24 >> 2] = 0;
       $2 = HEAP32[$5 + 568 >> 2];
       $1 = HEAP32[$5 + 560 >> 2];
       if (HEAP32[$5 + 552 >> 2] > 0) {
        $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
       } else {
        $0 = 0;
       }
       $0 = jsvGetInteger($0);
       if (HEAP32[$5 + 552 >> 2] > 1) {
        $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
       } else {
        $3 = 0;
       }
       HEAP32[$5 + 24 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetInteger($3));
       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 24 >> 2];
       break label$1;
      }
      HEAP32[$5 + 20 >> 2] = 0;
      $2 = HEAP32[$5 + 568 >> 2];
      $1 = HEAP32[$5 + 560 >> 2];
      if (HEAP32[$5 + 552 >> 2] > 0) {
       $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
      } else {
       $0 = 0;
      }
      if (HEAP32[$5 + 552 >> 2] > 1) {
       $3 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
      } else {
       $3 = 0;
      }
      HEAP32[$5 + 20 >> 2] = FUNCTION_TABLE[$2 | 0]($1, $0, jsvGetBool($3) & 1);
      HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 20 >> 2];
      break label$1;
     }
     HEAP32[$5 + 16 >> 2] = 0;
     $4 = HEAP32[$5 + 568 >> 2];
     $3 = HEAP32[$5 + 560 >> 2];
     if (HEAP32[$5 + 552 >> 2] > 0) {
      $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
     } else {
      $0 = 0;
     }
     if (HEAP32[$5 + 552 >> 2] > 1) {
      $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
     } else {
      $1 = 0;
     }
     $2 = jsvGetInteger($1);
     if (HEAP32[$5 + 552 >> 2] > 2) {
      $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
     } else {
      $1 = 0;
     }
     $1 = jsvGetInteger($1);
     if (HEAP32[$5 + 552 >> 2] > 3) {
      $6 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2];
     } else {
      $6 = 0;
     }
     HEAP32[$5 + 16 >> 2] = FUNCTION_TABLE[$4 | 0]($3, $0, $2, $1, $6);
     HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 16 >> 2];
     break label$1;
    }
    HEAP32[$5 + 12 >> 2] = 0;
    $3 = HEAP32[$5 + 568 >> 2];
    if (HEAP32[$5 + 552 >> 2] > 0) {
     $2 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
    } else {
     $2 = 0;
    }
    if (HEAP32[$5 + 552 >> 2] > 1) {
     $1 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
    } else {
     $1 = 0;
    }
    if (HEAP32[$5 + 552 >> 2] > 2) {
     $0 = HEAP32[HEAP32[$5 + 556 >> 2] + 8 >> 2];
    } else {
     $0 = 0;
    }
    if (HEAP32[$5 + 552 >> 2] > 3) {
     $4 = HEAP32[HEAP32[$5 + 556 >> 2] + 12 >> 2];
    } else {
     $4 = 0;
    }
    HEAP32[$5 + 12 >> 2] = FUNCTION_TABLE[$3 | 0]($2, $1, $0, $4);
    HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 12 >> 2];
    break label$1;
   }
   HEAP32[$5 + 8 >> 2] = 0;
   $1 = HEAP32[$5 + 568 >> 2];
   if (HEAP32[$5 + 552 >> 2] > 0) {
    $0 = HEAP32[HEAP32[$5 + 556 >> 2] >> 2];
   } else {
    $0 = 0;
   }
   $0 = jsvGetInteger($0);
   if (HEAP32[$5 + 552 >> 2] > 1) {
    $2 = HEAP32[HEAP32[$5 + 556 >> 2] + 4 >> 2];
   } else {
    $2 = 0;
   }
   HEAP32[$5 + 8 >> 2] = FUNCTION_TABLE[$1 | 0]($0, $2);
   HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 8 >> 2];
   break label$1;
  }
  HEAP32[$5 >> 2] = HEAPU16[$5 + 566 >> 1];
  jsExceptionHere(1, 134993, $5);
  HEAP32[$5 + 572 >> 2] = 0;
 }
 __stack_pointer = $5 + 576 | 0;
 return HEAP32[$5 + 572 >> 2];
}

function mbedtls_sha512_process($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $4 = __stack_pointer - 736 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 732 >> 2] = $0;
 HEAP32[$4 + 728 >> 2] = $1;
 HEAP32[$4 + 724 >> 2] = 0;
 while (1) {
  if (HEAP32[$4 + 724 >> 2] < 16) {
   $2 = HEAP32[$4 + 728 >> 2] + ((HEAP32[$4 + 724 >> 2] << 3) + 7 | 0) | 0;
   $1 = HEAPU8[$2 | 0];
   $5 = $1;
   $2 = HEAP32[$4 + 728 >> 2] + (HEAP32[$4 + 724 >> 2] << 3) | 0;
   $0 = HEAPU8[$2 | 0];
   $0 = $0 << 24;
   $2 = $0;
   $1 = HEAP32[$4 + 728 >> 2] + ((HEAP32[$4 + 724 >> 2] << 3) + 1 | 0) | 0;
   $0 = HEAPU8[$1 | 0];
   $0 = $0 << 16;
   $1 = $0;
   $0 = $2;
   $1 = $1 | $0;
   $2 = $1;
   $0 = HEAP32[$4 + 728 >> 2] + ((HEAP32[$4 + 724 >> 2] << 3) + 2 | 0) | 0;
   $1 = HEAPU8[$0 | 0];
   $0 = $1;
   $1 = $0 << 8;
   $0 = $1;
   $1 = $2;
   $0 = $1 | $0;
   $2 = $0;
   $1 = HEAP32[$4 + 728 >> 2] + ((HEAP32[$4 + 724 >> 2] << 3) + 3 | 0) | 0;
   $0 = HEAPU8[$1 | 0];
   $1 = $0;
   $0 = $2;
   $1 = $1 | $0;
   $2 = $1;
   $0 = HEAP32[$4 + 728 >> 2] + ((HEAP32[$4 + 724 >> 2] << 3) + 4 | 0) | 0;
   $1 = HEAPU8[$0 | 0];
   $0 = $1;
   $7 = $0 << 24;
   $1 = $0 >>> 8 | 0;
   $0 = $1;
   $1 = $2;
   $0 = $1 | $0;
   $3 = $0;
   $2 = 0;
   $6 = 0;
   $2 = $2 | $6;
   $2 = $2 | 0;
   $2 = $2 | 0;
   $6 = $7;
   $2 = $2 | $6;
   $1 = HEAP32[$4 + 728 >> 2] + ((HEAP32[$4 + 724 >> 2] << 3) + 5 | 0) | 0;
   $0 = HEAPU8[$1 | 0];
   $6 = $0 << 16;
   $0 = $0 >>> 16 | 0;
   $1 = $0;
   $0 = $3;
   $1 = $1 | $0;
   $3 = $1;
   $0 = HEAP32[$4 + 728 >> 2] + ((HEAP32[$4 + 724 >> 2] << 3) + 6 | 0) | 0;
   $1 = HEAPU8[$0 | 0];
   $0 = $1;
   $7 = $0 << 8;
   $1 = $0 >>> 24 | 0;
   $0 = $1;
   $1 = $3;
   $0 = $1 | $0;
   $1 = $5;
   $2 = $2 | $6;
   $6 = $7;
   $6 = $2 | $6;
   $2 = $1 | $6;
   $1 = ($4 - -64 | 0) + (HEAP32[$4 + 724 >> 2] << 3) | 0;
   HEAP32[$1 >> 2] = $2;
   $2 = $0;
   HEAP32[$1 + 4 >> 2] = $2;
   HEAP32[$4 + 724 >> 2] = HEAP32[$4 + 724 >> 2] + 1;
   continue;
  }
  break;
 }
 while (1) {
  if (HEAP32[$4 + 724 >> 2] < 80) {
   $0 = ((HEAP32[$4 + 724 >> 2] << 3) + $4 | 0) + -64 | 0;
   $2 = HEAP32[$0 >> 2];
   $11 = $2;
   $1 = HEAP32[$0 + 4 >> 2];
   $9 = $1;
   $0 = ((HEAP32[$4 + 724 >> 2] << 3) + $4 | 0) + 8 | 0;
   $1 = HEAP32[$0 >> 2];
   $8 = $1;
   $2 = HEAP32[$0 + 4 >> 2];
   $7 = $2;
   $0 = ((HEAP32[$4 + 724 >> 2] << 3) + $4 | 0) + 48 | 0;
   $2 = HEAP32[$0 >> 2];
   $0 = $2;
   $2 = $0 << 13;
   $3 = $2;
   $1 = ((HEAP32[$4 + 724 >> 2] << 3) + $4 | 0) + 48 | 0;
   $2 = HEAP32[$1 >> 2];
   $0 = HEAP32[$1 + 4 >> 2];
   $1 = $2;
   $2 = $0 >>> 19 | 0;
   $6 = ($0 & 524287) << 13 | $1 >>> 19;
   $0 = 0;
   $12 = $0 | $6;
   $1 = $2;
   $2 = $3;
   $1 = $1 | $2;
   $5 = $1;
   $2 = ((HEAP32[$4 + 724 >> 2] << 3) + $4 | 0) + 48 | 0;
   $1 = HEAP32[$2 >> 2];
   $0 = HEAP32[$2 + 4 >> 2];
   $10 = $1 << 3;
   $1 = $0 << 3 | $1 >>> 29;
   $3 = $1;
   $0 = ((HEAP32[$4 + 724 >> 2] << 3) + $4 | 0) + 48 | 0;
   $1 = HEAP32[$0 >> 2];
   $2 = HEAP32[$0 + 4 >> 2];
   $6 = $2 >>> 29 | 0;
   $1 = 0;
   $0 = $1;
   $1 = $3;
   $0 = $1 | $0;
   $3 = $0;
   $1 = $12;
   $2 = $10;
   $6 = $2 | $6;
   $10 = $1 ^ $6;
   $0 = $5;
   $2 = $3;
   $2 = $0 ^ $2;
   $3 = $2;
   $0 = ((HEAP32[$4 + 724 >> 2] << 3) + $4 | 0) + 48 | 0;
   $2 = HEAP32[$0 >> 2];
   $1 = HEAP32[$0 + 4 >> 2];
   $0 = $2;
   $6 = ($1 & 63) << 26 | $0 >>> 6;
   $2 = $1 >>> 6 | 0;
   $0 = $2;
   $2 = $3;
   $0 = $0 ^ $2;
   $2 = $8;
   $1 = $10;
   $6 = $1 ^ $6;
   $3 = $2 + $6 | 0;
   $1 = $0;
   $0 = $7;
   $5 = $1 + $0 | 0;
   $5 = $3 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
   $8 = $5;
   $0 = ((HEAP32[$4 + 724 >> 2] << 3) + $4 | 0) - 56 | 0;
   $5 = HEAP32[$0 >> 2];
   $0 = $5;
   $5 = $0 << 31;
   $1 = $5;
   $2 = ((HEAP32[$4 + 724 >> 2] << 3) + $4 | 0) - 56 | 0;
   $5 = HEAP32[$2 >> 2];
   $0 = HEAP32[$2 + 4 >> 2];
   $2 = $5;
   $5 = $0 >>> 1 | 0;
   $6 = ($0 & 1) << 31 | $2 >>> 1;
   $0 = 0;
   $10 = $0 | $6;
   $2 = $5;
   $5 = $1;
   $2 = $2 | $5;
   $7 = $2;
   $5 = ((HEAP32[$4 + 724 >> 2] << 3) + $4 | 0) - 56 | 0;
   $2 = HEAP32[$5 >> 2];
   $2 = $2 << 24;
   $1 = $2;
   $0 = ((HEAP32[$4 + 724 >> 2] << 3) + $4 | 0) - 56 | 0;
   $2 = HEAP32[$0 >> 2];
   $5 = HEAP32[$0 + 4 >> 2];
   $0 = $2;
   $6 = ($5 & 255) << 24 | $0 >>> 8;
   $2 = $5 >>> 8 | 0;
   $0 = $2;
   $2 = $1;
   $0 = $0 | $2;
   $1 = $0;
   $2 = $10;
   $5 = 0;
   $6 = $6 | $5;
   $10 = $2 ^ $6;
   $0 = $7;
   $5 = $1;
   $5 = $0 ^ $5;
   $1 = $5;
   $0 = ((HEAP32[$4 + 724 >> 2] << 3) + $4 | 0) - 56 | 0;
   $5 = HEAP32[$0 >> 2];
   $2 = HEAP32[$0 + 4 >> 2];
   $0 = $5;
   $6 = ($2 & 127) << 25 | $0 >>> 7;
   $5 = $2 >>> 7 | 0;
   $0 = $5;
   $5 = $1;
   $0 = $0 ^ $5;
   $5 = $0;
   $2 = $10;
   $6 = $2 ^ $6;
   $1 = $6 + $3 | 0;
   $0 = $8;
   $2 = $5;
   $3 = $0 + $2 | 0;
   $2 = $1;
   $3 = $1 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
   $5 = $3;
   $3 = $9;
   $1 = $3 + $5 | 0;
   $0 = $11;
   $6 = $2;
   $2 = $0 + $6 | 0;
   $1 = $2 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
   $0 = ($4 - -64 | 0) + (HEAP32[$4 + 724 >> 2] << 3) | 0;
   HEAP32[$0 >> 2] = $2;
   HEAP32[$0 + 4 >> 2] = $1;
   HEAP32[$4 + 724 >> 2] = HEAP32[$4 + 724 >> 2] + 1;
   continue;
  }
  break;
 }
 $3 = HEAP32[$4 + 732 >> 2];
 $1 = HEAP32[$3 + 16 >> 2];
 $0 = HEAP32[$3 + 20 >> 2];
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 60 >> 2] = $0;
 $3 = HEAP32[$4 + 732 >> 2];
 $0 = HEAP32[$3 + 24 >> 2];
 $1 = HEAP32[$3 + 28 >> 2];
 HEAP32[$4 + 48 >> 2] = $0;
 HEAP32[$4 + 52 >> 2] = $1;
 $3 = HEAP32[$4 + 732 >> 2];
 $1 = HEAP32[$3 + 32 >> 2];
 $0 = HEAP32[$3 + 36 >> 2];
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 44 >> 2] = $0;
 $3 = HEAP32[$4 + 732 >> 2];
 $0 = HEAP32[$3 + 40 >> 2];
 $1 = HEAP32[$3 + 44 >> 2];
 HEAP32[$4 + 32 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 $3 = HEAP32[$4 + 732 >> 2];
 $1 = HEAP32[$3 + 48 >> 2];
 $0 = HEAP32[$3 + 52 >> 2];
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 28 >> 2] = $0;
 $3 = HEAP32[$4 + 732 >> 2];
 $0 = HEAP32[$3 + 56 >> 2];
 $1 = HEAP32[$3 + 60 >> 2];
 HEAP32[$4 + 16 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 $3 = HEAP32[$4 + 732 >> 2];
 $1 = HEAP32[$3 + 64 >> 2];
 $0 = HEAP32[$3 + 68 >> 2];
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 12 >> 2] = $0;
 $3 = HEAP32[$4 + 732 >> 2];
 $0 = HEAP32[$3 + 72 >> 2];
 $1 = HEAP32[$3 + 76 >> 2];
 HEAP32[$4 >> 2] = $0;
 HEAP32[$4 + 4 >> 2] = $1;
 HEAP32[$4 + 724 >> 2] = 0;
 while (1) {
  $3 = ($4 - -64 | 0) + (HEAP32[$4 + 724 >> 2] << 3) | 0;
  $1 = HEAP32[$3 >> 2];
  $13 = $1;
  $0 = HEAP32[$3 + 4 >> 2];
  $14 = $0;
  $3 = (HEAP32[$4 + 724 >> 2] << 3) + 170928 | 0;
  $0 = HEAP32[$3 >> 2];
  $15 = $0;
  $1 = HEAP32[$3 + 4 >> 2];
  $12 = $1;
  $1 = HEAP32[$4 >> 2];
  $9 = $1;
  $0 = HEAP32[$4 + 4 >> 2];
  $8 = $0;
  $0 = HEAP32[$4 + 24 >> 2];
  $5 = $0 << 23;
  $1 = HEAP32[$4 + 28 >> 2];
  $0 = $1 << 23 | $0 >>> 9;
  $2 = $0;
  $0 = HEAP32[$4 + 24 >> 2];
  $3 = HEAP32[$4 + 28 >> 2];
  $6 = $3 >>> 9 | 0;
  $3 = $5;
  $10 = $6 | $3;
  $0 = 0;
  $1 = $0;
  $0 = $2;
  $1 = $1 | $0;
  $7 = $1;
  $1 = HEAP32[$4 + 24 >> 2];
  $0 = $1;
  $1 = $0 << 18;
  $2 = $1;
  $1 = HEAP32[$4 + 24 >> 2];
  $3 = $1;
  $0 = HEAP32[$4 + 28 >> 2];
  $1 = $0 >>> 14 | 0;
  $6 = ($0 & 16383) << 18 | $3 >>> 14;
  $3 = $1;
  $0 = 0;
  $11 = $0 | $6;
  $1 = $2;
  $3 = $1 | $3;
  $5 = $3;
  $3 = HEAP32[$4 + 24 >> 2];
  $1 = $3;
  $3 = $1 << 14;
  $2 = $3;
  $3 = HEAP32[$4 + 24 >> 2];
  $0 = $3;
  $1 = HEAP32[$4 + 28 >> 2];
  $3 = $1 >>> 18 | 0;
  $6 = ($1 & 262143) << 14 | $0 >>> 18;
  $0 = $3;
  $3 = $2;
  $0 = $0 | $3;
  $1 = 0;
  $6 = $1 | $6;
  $3 = $11;
  $6 = $6 ^ $3;
  $1 = $0;
  $0 = $5;
  $1 = $1 ^ $0;
  $3 = $1;
  $1 = $7;
  $3 = $1 ^ $3;
  $1 = $9;
  $0 = $10;
  $6 = $0 ^ $6;
  $5 = $1 + $6 | 0;
  $0 = $3;
  $3 = $8;
  $2 = $0 + $3 | 0;
  $2 = $5 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
  $10 = $2;
  $2 = HEAP32[$4 + 8 >> 2];
  $11 = $2;
  $1 = HEAP32[$4 + 12 >> 2];
  $9 = $1;
  $1 = HEAP32[$4 + 24 >> 2];
  $8 = $1;
  $2 = HEAP32[$4 + 28 >> 2];
  $7 = $2;
  $2 = HEAP32[$4 + 16 >> 2];
  $3 = $2;
  $1 = HEAP32[$4 + 20 >> 2];
  $0 = $1;
  $1 = HEAP32[$4 + 8 >> 2];
  $6 = $1;
  $2 = HEAP32[$4 + 12 >> 2];
  $1 = $2;
  $2 = $0;
  $1 = $1 ^ $2;
  $0 = $1;
  $2 = $8;
  $6 = $6 ^ $3;
  $6 = $2 & $6;
  $1 = $7;
  $3 = $0;
  $3 = $1 & $3;
  $2 = $3;
  $3 = $9;
  $2 = $2 ^ $3;
  $1 = $11;
  $6 = $1 ^ $6;
  $3 = $5;
  $0 = $6 + $3 | 0;
  $1 = $2;
  $2 = $10;
  $5 = $1 + $2 | 0;
  $1 = $0;
  $5 = $0 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  $3 = $5;
  $5 = $12;
  $0 = $3 + $5 | 0;
  $2 = $15;
  $6 = $1;
  $1 = $2 + $6 | 0;
  $0 = $1 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  $6 = $1;
  $2 = $0;
  $0 = $14;
  $1 = $0 + $2 | 0;
  $5 = $13;
  $3 = $6 + $5 | 0;
  HEAP32[$4 + 712 >> 2] = $3;
  $1 = $3 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
  HEAP32[$4 + 716 >> 2] = $1;
  $1 = HEAP32[$4 + 56 >> 2];
  $0 = $1;
  $5 = HEAP32[$4 + 60 >> 2];
  $3 = $5;
  $1 = HEAP32[$4 + 52 >> 2];
  $2 = $1;
  $5 = HEAP32[$4 + 48 >> 2];
  $9 = $0 & $5;
  $1 = $3;
  $5 = $2;
  $5 = $1 & $5;
  $8 = $5;
  $5 = HEAP32[$4 + 40 >> 2];
  $7 = $5;
  $0 = HEAP32[$4 + 44 >> 2];
  $3 = $0;
  $0 = HEAP32[$4 + 56 >> 2];
  $2 = $0;
  $5 = HEAP32[$4 + 60 >> 2];
  $1 = $5;
  $5 = HEAP32[$4 + 48 >> 2];
  $6 = $5;
  $0 = HEAP32[$4 + 52 >> 2];
  $5 = $0;
  $0 = $1;
  $5 = $0 | $5;
  $0 = $7;
  $1 = $2;
  $6 = $1 | $6;
  $1 = $5;
  $5 = $3;
  $1 = $1 & $5;
  $2 = $1;
  $6 = $0 & $6;
  $5 = $9;
  $10 = $6 | $5;
  $1 = $8;
  $0 = $2;
  $0 = $1 | $0;
  $8 = $0;
  $0 = HEAP32[$4 + 56 >> 2];
  $3 = $0 << 25;
  $5 = HEAP32[$4 + 60 >> 2];
  $0 = $5 << 25 | $0 >>> 7;
  $2 = $0;
  $0 = HEAP32[$4 + 56 >> 2];
  $1 = HEAP32[$4 + 60 >> 2];
  $6 = $1 >>> 7 | 0;
  $0 = 0;
  $5 = $0;
  $1 = $3;
  $11 = $1 | $6;
  $0 = $2;
  $5 = $0 | $5;
  $7 = $5;
  $5 = HEAP32[$4 + 56 >> 2];
  $0 = $5;
  $5 = $0 << 4;
  $2 = $5;
  $5 = HEAP32[$4 + 56 >> 2];
  $1 = $5;
  $0 = HEAP32[$4 + 60 >> 2];
  $5 = $0 >>> 28 | 0;
  $6 = ($0 & 268435455) << 4 | $1 >>> 28;
  $0 = 0;
  $6 = $0 | $6;
  $1 = $5;
  $5 = $2;
  $1 = $1 | $5;
  $3 = $1;
  $1 = HEAP32[$4 + 56 >> 2];
  $9 = $1 << 30;
  $0 = HEAP32[$4 + 60 >> 2];
  $1 = $0 << 30 | $1 >>> 2;
  $2 = $1;
  $1 = HEAP32[$4 + 56 >> 2];
  $5 = HEAP32[$4 + 60 >> 2];
  $1 = 0;
  $0 = $1;
  $1 = $2;
  $0 = $1 | $0;
  $2 = $0;
  $1 = $6;
  $6 = $5 >>> 2 | 0;
  $5 = $9;
  $6 = $6 | $5;
  $6 = $1 ^ $6;
  $0 = $3;
  $5 = $2;
  $5 = $0 ^ $5;
  $1 = $5;
  $5 = $7;
  $1 = $1 ^ $5;
  $3 = $1;
  $0 = $11;
  $6 = $0 ^ $6;
  $5 = $10;
  $2 = $6 + $5 | 0;
  $1 = $8;
  $0 = $3;
  $3 = $1 + $0 | 0;
  HEAP32[$4 + 704 >> 2] = $2;
  $3 = $2 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
  HEAP32[$4 + 708 >> 2] = $3;
  $3 = HEAP32[$4 + 712 >> 2];
  $1 = $3;
  $5 = HEAP32[$4 + 716 >> 2];
  $0 = $5;
  $5 = HEAP32[$4 + 32 >> 2];
  $6 = $5;
  $3 = HEAP32[$4 + 36 >> 2];
  $5 = $3;
  $3 = $0;
  $2 = $3 + $5 | 0;
  $0 = $1 + $6 | 0;
  $2 = $0 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
  HEAP32[$4 + 32 >> 2] = $0;
  HEAP32[$4 + 36 >> 2] = $2;
  $1 = HEAP32[$4 + 716 >> 2];
  $0 = $1;
  $1 = HEAP32[$4 + 704 >> 2];
  $6 = $1;
  $2 = HEAP32[$4 + 712 >> 2];
  $3 = $2;
  $5 = $1 + $3 | 0;
  $2 = HEAP32[$4 + 708 >> 2];
  $1 = $2;
  $2 = $0;
  $0 = $1 + $2 | 0;
  HEAP32[$4 >> 2] = $5;
  $0 = $5 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  HEAP32[$4 + 4 >> 2] = $0;
  HEAP32[$4 + 724 >> 2] = HEAP32[$4 + 724 >> 2] + 1;
  $2 = ($4 - -64 | 0) + (HEAP32[$4 + 724 >> 2] << 3) | 0;
  $0 = HEAP32[$2 >> 2];
  $16 = $0;
  $3 = HEAP32[$2 + 4 >> 2];
  $13 = $3;
  $2 = (HEAP32[$4 + 724 >> 2] << 3) + 170928 | 0;
  $3 = HEAP32[$2 >> 2];
  $14 = $3;
  $0 = HEAP32[$2 + 4 >> 2];
  $15 = $0;
  $0 = HEAP32[$4 + 8 >> 2];
  $9 = $0;
  $3 = HEAP32[$4 + 12 >> 2];
  $8 = $3;
  $3 = HEAP32[$4 + 32 >> 2];
  $5 = $3 << 23;
  $0 = HEAP32[$4 + 36 >> 2];
  $3 = $0 << 23 | $3 >>> 9;
  $1 = $3;
  $3 = HEAP32[$4 + 32 >> 2];
  $2 = HEAP32[$4 + 36 >> 2];
  $6 = $2 >>> 9 | 0;
  $2 = $5;
  $10 = $2 | $6;
  $3 = 0;
  $0 = $3;
  $3 = $1;
  $0 = $0 | $3;
  $7 = $0;
  $0 = HEAP32[$4 + 32 >> 2];
  $0 = $0 << 18;
  $5 = $0;
  $0 = HEAP32[$4 + 32 >> 2];
  $2 = $0;
  $3 = HEAP32[$4 + 36 >> 2];
  $0 = $3 >>> 14 | 0;
  $1 = $0;
  $6 = ($3 & 16383) << 18 | $2 >>> 14;
  $3 = 0;
  $11 = $6 | $3;
  $0 = $5;
  $2 = $1;
  $2 = $0 | $2;
  $5 = $2;
  $2 = HEAP32[$4 + 32 >> 2];
  $0 = $2;
  $2 = $0 << 14;
  $1 = $2;
  $2 = HEAP32[$4 + 32 >> 2];
  $3 = $2;
  $0 = HEAP32[$4 + 36 >> 2];
  $2 = $0 >>> 18 | 0;
  $6 = ($0 & 262143) << 14 | $3 >>> 18;
  $3 = $2;
  $2 = $1;
  $3 = $2 | $3;
  $2 = $11;
  $0 = 0;
  $6 = $0 | $6;
  $6 = $2 ^ $6;
  $0 = $3;
  $3 = $5;
  $0 = $0 ^ $3;
  $2 = $0;
  $0 = $7;
  $2 = $0 ^ $2;
  $5 = $2;
  $0 = $9;
  $3 = $10;
  $6 = $6 ^ $3;
  $1 = $0 + $6 | 0;
  $2 = $8;
  $3 = $5;
  $5 = $2 + $3 | 0;
  $5 = $1 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  $12 = $5;
  $5 = HEAP32[$4 + 16 >> 2];
  $10 = $5;
  $0 = HEAP32[$4 + 20 >> 2];
  $11 = $0;
  $0 = HEAP32[$4 + 32 >> 2];
  $9 = $0;
  $5 = HEAP32[$4 + 36 >> 2];
  $8 = $5;
  $5 = HEAP32[$4 + 24 >> 2];
  $7 = $5;
  $0 = HEAP32[$4 + 28 >> 2];
  $2 = $0;
  $0 = HEAP32[$4 + 16 >> 2];
  $6 = $0;
  $5 = HEAP32[$4 + 20 >> 2];
  $0 = $5;
  $5 = $2;
  $0 = $0 ^ $5;
  $3 = $0;
  $2 = $7;
  $6 = $2 ^ $6;
  $5 = $9;
  $6 = $6 & $5;
  $0 = $8;
  $2 = $3;
  $2 = $0 & $2;
  $5 = $2;
  $2 = $11;
  $5 = $2 ^ $5;
  $0 = $10;
  $6 = $0 ^ $6;
  $3 = $1 + $6 | 0;
  $0 = $5;
  $5 = $12;
  $1 = $0 + $5 | 0;
  $0 = $3;
  $1 = $3 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
  $2 = $1;
  $1 = $15;
  $3 = $1 + $2 | 0;
  $6 = $0;
  $5 = $14;
  $0 = $6 + $5 | 0;
  $3 = $0 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
  $6 = $0;
  $5 = $3;
  $3 = $13;
  $0 = $3 + $5 | 0;
  $1 = $16;
  $2 = $1 + $6 | 0;
  $0 = $2 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  HEAP32[$4 + 712 >> 2] = $2;
  HEAP32[$4 + 716 >> 2] = $0;
  $1 = HEAP32[$4 + 4 >> 2];
  $2 = $1;
  $1 = HEAP32[$4 + 56 >> 2];
  $0 = HEAP32[$4 >> 2];
  $11 = $1 & $0;
  $0 = HEAP32[$4 + 60 >> 2];
  $1 = $0;
  $0 = $2;
  $1 = $1 & $0;
  $9 = $1;
  $1 = HEAP32[$4 + 48 >> 2];
  $8 = $1;
  $3 = HEAP32[$4 + 52 >> 2];
  $7 = $3;
  $3 = HEAP32[$4 >> 2];
  $5 = $3;
  $1 = HEAP32[$4 + 4 >> 2];
  $0 = $1;
  $1 = HEAP32[$4 + 56 >> 2];
  $6 = $1;
  $3 = HEAP32[$4 + 60 >> 2];
  $1 = $3;
  $3 = $0;
  $1 = $1 | $3;
  $2 = $1;
  $0 = $5;
  $6 = $0 | $6;
  $3 = $8;
  $1 = $7;
  $0 = $2;
  $0 = $1 & $0;
  $2 = $0;
  $1 = $11;
  $6 = $6 & $3;
  $12 = $1 | $6;
  $0 = $9;
  $3 = $2;
  $3 = $0 | $3;
  $8 = $3;
  $3 = HEAP32[$4 >> 2];
  $0 = $3;
  $5 = $0 << 25;
  $1 = HEAP32[$4 + 4 >> 2];
  $3 = $1 << 25 | $0 >>> 7;
  $2 = $3;
  $3 = HEAP32[$4 >> 2];
  $0 = HEAP32[$4 + 4 >> 2];
  $6 = $0 >>> 7 | 0;
  $0 = $5;
  $10 = $0 | $6;
  $3 = 0;
  $1 = $3;
  $3 = $2;
  $1 = $1 | $3;
  $7 = $1;
  $1 = HEAP32[$4 >> 2];
  $1 = $1 << 4;
  $5 = $1;
  $1 = HEAP32[$4 >> 2];
  $0 = $1;
  $3 = HEAP32[$4 + 4 >> 2];
  $1 = $3 >>> 28 | 0;
  $2 = $1;
  $6 = ($3 & 268435455) << 4 | $0 >>> 28;
  $3 = 0;
  $11 = $6 | $3;
  $1 = $5;
  $0 = $2;
  $0 = $1 | $0;
  $5 = $0;
  $0 = HEAP32[$4 >> 2];
  $9 = $0 << 30;
  $3 = HEAP32[$4 + 4 >> 2];
  $0 = $3 << 30 | $0 >>> 2;
  $2 = $0;
  $0 = HEAP32[$4 >> 2];
  $1 = HEAP32[$4 + 4 >> 2];
  $6 = $1 >>> 2 | 0;
  $0 = 0;
  $3 = $0;
  $0 = $2;
  $3 = $0 | $3;
  $0 = $11;
  $1 = $9;
  $6 = $1 | $6;
  $6 = $0 ^ $6;
  $1 = $3;
  $3 = $5;
  $1 = $1 ^ $3;
  $0 = $1;
  $1 = $7;
  $0 = $1 ^ $0;
  $2 = $0;
  $1 = $12;
  $3 = $10;
  $6 = $6 ^ $3;
  $5 = $1 + $6 | 0;
  $0 = $8;
  $3 = $2;
  $2 = $0 + $3 | 0;
  HEAP32[$4 + 704 >> 2] = $5;
  $2 = $5 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
  HEAP32[$4 + 708 >> 2] = $2;
  $1 = HEAP32[$4 + 716 >> 2];
  $5 = $1;
  $2 = HEAP32[$4 + 712 >> 2];
  $0 = $2;
  $1 = HEAP32[$4 + 40 >> 2];
  $6 = $1;
  $3 = $0 + $1 | 0;
  $2 = HEAP32[$4 + 44 >> 2];
  $1 = $2;
  $2 = $5;
  $5 = $1 + $2 | 0;
  HEAP32[$4 + 40 >> 2] = $3;
  $5 = $3 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  HEAP32[$4 + 44 >> 2] = $5;
  $5 = HEAP32[$4 + 712 >> 2];
  $2 = $5;
  $0 = HEAP32[$4 + 716 >> 2];
  $1 = $0;
  $0 = HEAP32[$4 + 704 >> 2];
  $6 = $0;
  $5 = HEAP32[$4 + 708 >> 2];
  $0 = $5;
  $5 = $1;
  $3 = $0 + $5 | 0;
  $1 = $2 + $6 | 0;
  $3 = $1 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
  HEAP32[$4 + 8 >> 2] = $1;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 724 >> 2] = HEAP32[$4 + 724 >> 2] + 1;
  $5 = ($4 - -64 | 0) + (HEAP32[$4 + 724 >> 2] << 3) | 0;
  $3 = HEAP32[$5 >> 2];
  $13 = $3;
  $2 = HEAP32[$5 + 4 >> 2];
  $14 = $2;
  $5 = (HEAP32[$4 + 724 >> 2] << 3) + 170928 | 0;
  $2 = HEAP32[$5 >> 2];
  $15 = $2;
  $3 = HEAP32[$5 + 4 >> 2];
  $12 = $3;
  $3 = HEAP32[$4 + 16 >> 2];
  $9 = $3;
  $2 = HEAP32[$4 + 20 >> 2];
  $8 = $2;
  $2 = HEAP32[$4 + 40 >> 2];
  $1 = $2 << 23;
  $3 = HEAP32[$4 + 44 >> 2];
  $2 = $3 << 23 | $2 >>> 9;
  $0 = $2;
  $2 = HEAP32[$4 + 40 >> 2];
  $5 = HEAP32[$4 + 44 >> 2];
  $2 = 0;
  $3 = $2;
  $6 = $5 >>> 9 | 0;
  $5 = $1;
  $10 = $6 | $5;
  $2 = $0;
  $3 = $2 | $3;
  $7 = $3;
  $3 = HEAP32[$4 + 40 >> 2];
  $3 = $3 << 18;
  $0 = $3;
  $3 = HEAP32[$4 + 40 >> 2];
  $5 = $3;
  $2 = HEAP32[$4 + 44 >> 2];
  $3 = $2 >>> 14 | 0;
  $6 = ($2 & 16383) << 18 | $5 >>> 14;
  $5 = $3;
  $2 = 0;
  $11 = $2 | $6;
  $3 = $0;
  $5 = $3 | $5;
  $1 = $5;
  $5 = HEAP32[$4 + 40 >> 2];
  $3 = $5;
  $5 = $3 << 14;
  $0 = $5;
  $5 = HEAP32[$4 + 40 >> 2];
  $2 = $5;
  $3 = HEAP32[$4 + 44 >> 2];
  $5 = $3 >>> 18 | 0;
  $6 = ($3 & 262143) << 14 | $2 >>> 18;
  $2 = $5;
  $5 = $0;
  $2 = $2 | $5;
  $0 = $2;
  $3 = 0;
  $6 = $6 | $3;
  $5 = $11;
  $6 = $6 ^ $5;
  $2 = $1;
  $3 = $0;
  $3 = $2 ^ $3;
  $5 = $3;
  $3 = $7;
  $5 = $3 ^ $5;
  $2 = $10;
  $6 = $2 ^ $6;
  $3 = $9;
  $0 = $6 + $3 | 0;
  $2 = $5;
  $5 = $8;
  $1 = $2 + $5 | 0;
  $1 = $0 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
  $10 = $1;
  $1 = HEAP32[$4 + 24 >> 2];
  $11 = $1;
  $3 = HEAP32[$4 + 28 >> 2];
  $9 = $3;
  $3 = HEAP32[$4 + 40 >> 2];
  $8 = $3;
  $1 = HEAP32[$4 + 44 >> 2];
  $7 = $1;
  $1 = HEAP32[$4 + 32 >> 2];
  $5 = $1;
  $3 = HEAP32[$4 + 36 >> 2];
  $2 = $3;
  $3 = HEAP32[$4 + 24 >> 2];
  $6 = $3;
  $1 = HEAP32[$4 + 28 >> 2];
  $3 = $1;
  $1 = $2;
  $3 = $1 ^ $3;
  $2 = $3;
  $1 = $8;
  $6 = $6 ^ $5;
  $6 = $1 & $6;
  $3 = $7;
  $5 = $2;
  $5 = $3 & $5;
  $1 = $5;
  $5 = $9;
  $1 = $1 ^ $5;
  $5 = $1;
  $3 = $11;
  $6 = $6 ^ $3;
  $2 = $6 + $0 | 0;
  $1 = $10;
  $3 = $5;
  $0 = $1 + $3 | 0;
  $3 = $2;
  $0 = $2 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  $5 = $0;
  $0 = $12;
  $2 = $0 + $5 | 0;
  $1 = $15;
  $6 = $3;
  $3 = $1 + $6 | 0;
  $5 = $3;
  $2 = $3 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
  $1 = $2;
  $2 = $14;
  $3 = $1 + $2 | 0;
  $0 = $13;
  $6 = $5;
  $5 = $0 + $6 | 0;
  HEAP32[$4 + 712 >> 2] = $5;
  $3 = $5 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
  HEAP32[$4 + 716 >> 2] = $3;
  $0 = HEAP32[$4 + 12 >> 2];
  $1 = $0;
  $3 = HEAP32[$4 + 8 >> 2];
  $0 = HEAP32[$4 >> 2];
  $9 = $3 & $0;
  $3 = HEAP32[$4 + 4 >> 2];
  $0 = $3;
  $3 = $1;
  $0 = $0 & $3;
  $8 = $0;
  $0 = HEAP32[$4 + 56 >> 2];
  $7 = $0;
  $2 = HEAP32[$4 + 60 >> 2];
  $5 = $2;
  $2 = HEAP32[$4 + 8 >> 2];
  $3 = $2;
  $0 = HEAP32[$4 + 12 >> 2];
  $1 = $0;
  $0 = HEAP32[$4 >> 2];
  $6 = $0;
  $2 = HEAP32[$4 + 4 >> 2];
  $0 = $2;
  $2 = $1;
  $0 = $0 | $2;
  $1 = $0;
  $2 = $7;
  $6 = $6 | $3;
  $0 = $5;
  $3 = $1;
  $3 = $0 & $3;
  $0 = $9;
  $6 = $2 & $6;
  $12 = $0 | $6;
  $2 = $3;
  $3 = $8;
  $2 = $2 | $3;
  $8 = $2;
  $2 = HEAP32[$4 + 8 >> 2];
  $3 = $2;
  $5 = $3 << 25;
  $0 = HEAP32[$4 + 12 >> 2];
  $2 = $0 << 25 | $3 >>> 7;
  $1 = $2;
  $2 = HEAP32[$4 + 8 >> 2];
  $3 = HEAP32[$4 + 12 >> 2];
  $6 = $3 >>> 7 | 0;
  $3 = $5;
  $10 = $6 | $3;
  $2 = 0;
  $0 = $2;
  $2 = $1;
  $0 = $0 | $2;
  $7 = $0;
  $0 = HEAP32[$4 + 8 >> 2];
  $0 = $0 << 4;
  $1 = $0;
  $0 = HEAP32[$4 + 8 >> 2];
  $3 = $0;
  $2 = HEAP32[$4 + 12 >> 2];
  $0 = $2 >>> 28 | 0;
  $6 = ($2 & 268435455) << 4 | $3 >>> 28;
  $3 = $0;
  $2 = 0;
  $11 = $2 | $6;
  $0 = $1;
  $3 = $0 | $3;
  $5 = $3;
  $3 = HEAP32[$4 + 8 >> 2];
  $0 = $3;
  $9 = $0 << 30;
  $2 = HEAP32[$4 + 12 >> 2];
  $3 = $2 << 30 | $0 >>> 2;
  $1 = $3;
  $3 = HEAP32[$4 + 8 >> 2];
  $0 = HEAP32[$4 + 12 >> 2];
  $6 = $0 >>> 2 | 0;
  $3 = 0;
  $2 = $3;
  $3 = $1;
  $2 = $2 | $3;
  $0 = $9;
  $6 = $0 | $6;
  $3 = $11;
  $6 = $6 ^ $3;
  $0 = $2;
  $2 = $5;
  $0 = $0 ^ $2;
  $3 = $0;
  $0 = $7;
  $3 = $0 ^ $3;
  $0 = $12;
  $2 = $10;
  $6 = $2 ^ $6;
  $1 = $0 + $6 | 0;
  $2 = $3;
  $3 = $8;
  $5 = $2 + $3 | 0;
  HEAP32[$4 + 704 >> 2] = $1;
  $5 = $1 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  HEAP32[$4 + 708 >> 2] = $5;
  $0 = HEAP32[$4 + 716 >> 2];
  $1 = $0;
  $0 = HEAP32[$4 + 48 >> 2];
  $6 = $0;
  $5 = HEAP32[$4 + 712 >> 2];
  $3 = $5;
  $2 = $0 + $3 | 0;
  $5 = HEAP32[$4 + 52 >> 2];
  $0 = $5;
  $5 = $1;
  $1 = $0 + $5 | 0;
  HEAP32[$4 + 48 >> 2] = $2;
  $1 = $2 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
  HEAP32[$4 + 52 >> 2] = $1;
  $1 = HEAP32[$4 + 712 >> 2];
  $5 = $1;
  $3 = HEAP32[$4 + 716 >> 2];
  $7 = $3;
  $1 = HEAP32[$4 + 708 >> 2];
  $2 = $1;
  $3 = HEAP32[$4 + 704 >> 2];
  $6 = $3;
  $0 = $3 + $5 | 0;
  $1 = $7;
  $3 = $2;
  $2 = $1 + $3 | 0;
  HEAP32[$4 + 16 >> 2] = $0;
  $2 = $0 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 724 >> 2] = HEAP32[$4 + 724 >> 2] + 1;
  $1 = ($4 - -64 | 0) + (HEAP32[$4 + 724 >> 2] << 3) | 0;
  $2 = HEAP32[$1 >> 2];
  $13 = $2;
  $5 = HEAP32[$1 + 4 >> 2];
  $14 = $5;
  $1 = (HEAP32[$4 + 724 >> 2] << 3) + 170928 | 0;
  $5 = HEAP32[$1 >> 2];
  $15 = $5;
  $2 = HEAP32[$1 + 4 >> 2];
  $12 = $2;
  $2 = HEAP32[$4 + 24 >> 2];
  $9 = $2;
  $5 = HEAP32[$4 + 28 >> 2];
  $8 = $5;
  $5 = HEAP32[$4 + 48 >> 2];
  $1 = $5;
  $3 = $1 << 23;
  $2 = HEAP32[$4 + 52 >> 2];
  $5 = $2 << 23 | $1 >>> 9;
  $0 = $5;
  $5 = HEAP32[$4 + 48 >> 2];
  $1 = HEAP32[$4 + 52 >> 2];
  $6 = $1 >>> 9 | 0;
  $1 = $3;
  $10 = $1 | $6;
  $5 = 0;
  $2 = $5;
  $5 = $0;
  $2 = $2 | $5;
  $7 = $2;
  $2 = HEAP32[$4 + 48 >> 2];
  $2 = $2 << 18;
  $0 = $2;
  $2 = HEAP32[$4 + 48 >> 2];
  $1 = $2;
  $5 = HEAP32[$4 + 52 >> 2];
  $2 = $5 >>> 14 | 0;
  $6 = ($5 & 16383) << 18 | $1 >>> 14;
  $5 = 0;
  $11 = $6 | $5;
  $1 = $2;
  $2 = $0;
  $1 = $1 | $2;
  $3 = $1;
  $1 = HEAP32[$4 + 48 >> 2];
  $1 = $1 << 14;
  $0 = $1;
  $1 = HEAP32[$4 + 48 >> 2];
  $5 = $1;
  $2 = HEAP32[$4 + 52 >> 2];
  $1 = $2 >>> 18 | 0;
  $6 = ($2 & 262143) << 14 | $5 >>> 18;
  $5 = $1;
  $1 = $0;
  $5 = $1 | $5;
  $1 = $11;
  $2 = 0;
  $6 = $2 | $6;
  $6 = $1 ^ $6;
  $2 = $5;
  $5 = $3;
  $2 = $2 ^ $5;
  $1 = $2;
  $2 = $7;
  $1 = $1 ^ $2;
  $0 = $1;
  $2 = $9;
  $5 = $10;
  $6 = $6 ^ $5;
  $3 = $2 + $6 | 0;
  $1 = $8;
  $5 = $0;
  $0 = $1 + $5 | 0;
  $0 = $3 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  $10 = $0;
  $0 = HEAP32[$4 + 32 >> 2];
  $11 = $0;
  $2 = HEAP32[$4 + 36 >> 2];
  $9 = $2;
  $2 = HEAP32[$4 + 48 >> 2];
  $8 = $2;
  $0 = HEAP32[$4 + 52 >> 2];
  $7 = $0;
  $0 = HEAP32[$4 + 40 >> 2];
  $5 = $0;
  $2 = HEAP32[$4 + 44 >> 2];
  $1 = $2;
  $2 = HEAP32[$4 + 32 >> 2];
  $6 = $2;
  $0 = HEAP32[$4 + 36 >> 2];
  $2 = $0;
  $0 = $1;
  $2 = $0 ^ $2;
  $0 = $8;
  $1 = $5;
  $6 = $1 ^ $6;
  $6 = $0 & $6;
  $1 = $2;
  $2 = $7;
  $1 = $1 & $2;
  $0 = $1;
  $1 = $9;
  $0 = $1 ^ $0;
  $7 = $0;
  $1 = $3;
  $2 = $11;
  $6 = $2 ^ $6;
  $5 = $1 + $6 | 0;
  $0 = $10;
  $2 = $7;
  $3 = $0 + $2 | 0;
  $2 = $5;
  $3 = $5 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
  $1 = $3;
  $3 = $12;
  $5 = $1 + $3 | 0;
  $0 = $15;
  $6 = $2;
  $2 = $0 + $6 | 0;
  $5 = $2 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  $6 = $2;
  $0 = $5;
  $5 = $14;
  $2 = $0 + $5 | 0;
  $3 = $13;
  $1 = $6 + $3 | 0;
  $2 = $1 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
  HEAP32[$4 + 712 >> 2] = $1;
  HEAP32[$4 + 716 >> 2] = $2;
  $2 = HEAP32[$4 + 16 >> 2];
  $5 = $2;
  $3 = HEAP32[$4 + 20 >> 2];
  $1 = $3;
  $2 = HEAP32[$4 + 12 >> 2];
  $0 = $2;
  $3 = HEAP32[$4 + 8 >> 2];
  $9 = $3 & $5;
  $2 = $1;
  $3 = $0;
  $3 = $2 & $3;
  $8 = $3;
  $3 = HEAP32[$4 >> 2];
  $7 = $3;
  $5 = HEAP32[$4 + 4 >> 2];
  $1 = $5;
  $5 = HEAP32[$4 + 16 >> 2];
  $2 = $5;
  $3 = HEAP32[$4 + 20 >> 2];
  $0 = $3;
  $3 = HEAP32[$4 + 8 >> 2];
  $6 = $3;
  $5 = HEAP32[$4 + 12 >> 2];
  $3 = $5;
  $5 = $0;
  $3 = $3 | $5;
  $6 = $2 | $6;
  $5 = $7;
  $2 = $3;
  $3 = $1;
  $2 = $2 & $3;
  $0 = $2;
  $6 = $6 & $5;
  $3 = $9;
  $10 = $6 | $3;
  $2 = $8;
  $5 = $0;
  $5 = $2 | $5;
  $8 = $5;
  $5 = HEAP32[$4 + 16 >> 2];
  $2 = $5;
  $1 = $2 << 25;
  $3 = HEAP32[$4 + 20 >> 2];
  $5 = $3 << 25 | $2 >>> 7;
  $0 = $5;
  $5 = HEAP32[$4 + 16 >> 2];
  $2 = HEAP32[$4 + 20 >> 2];
  $6 = $2 >>> 7 | 0;
  $2 = $1;
  $11 = $2 | $6;
  $5 = 0;
  $3 = $5;
  $5 = $0;
  $3 = $3 | $5;
  $7 = $3;
  $3 = HEAP32[$4 + 16 >> 2];
  $3 = $3 << 4;
  $0 = $3;
  $3 = HEAP32[$4 + 16 >> 2];
  $2 = $3;
  $5 = HEAP32[$4 + 20 >> 2];
  $3 = $5 >>> 28 | 0;
  $6 = ($5 & 268435455) << 4 | $2 >>> 28;
  $5 = 0;
  $6 = $6 | $5;
  $2 = $3;
  $3 = $0;
  $2 = $2 | $3;
  $1 = $2;
  $2 = HEAP32[$4 + 16 >> 2];
  $3 = $2;
  $9 = $3 << 30;
  $5 = HEAP32[$4 + 20 >> 2];
  $2 = $5 << 30 | $3 >>> 2;
  $0 = $2;
  $2 = HEAP32[$4 + 16 >> 2];
  $3 = HEAP32[$4 + 20 >> 2];
  $2 = 0;
  $5 = $2;
  $2 = $0;
  $5 = $2 | $5;
  $2 = $6;
  $6 = $3 >>> 2 | 0;
  $3 = $9;
  $6 = $6 | $3;
  $6 = $2 ^ $6;
  $3 = $5;
  $5 = $1;
  $3 = $3 ^ $5;
  $2 = $3;
  $3 = $7;
  $2 = $2 ^ $3;
  $1 = $2;
  $5 = $11;
  $6 = $6 ^ $5;
  $3 = $10;
  $0 = $6 + $3 | 0;
  $2 = $8;
  $5 = $1;
  $1 = $2 + $5 | 0;
  HEAP32[$4 + 704 >> 2] = $0;
  $1 = $0 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
  HEAP32[$4 + 708 >> 2] = $1;
  $1 = HEAP32[$4 + 712 >> 2];
  $2 = $1;
  $3 = HEAP32[$4 + 716 >> 2];
  $7 = $3;
  $1 = HEAP32[$4 + 60 >> 2];
  $0 = $1;
  $3 = HEAP32[$4 + 56 >> 2];
  $6 = $3;
  $5 = $2 + $3 | 0;
  $1 = $7;
  $3 = $0;
  $0 = $1 + $3 | 0;
  HEAP32[$4 + 56 >> 2] = $5;
  $0 = $5 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  HEAP32[$4 + 60 >> 2] = $0;
  $0 = HEAP32[$4 + 712 >> 2];
  $1 = $0;
  $2 = HEAP32[$4 + 716 >> 2];
  $7 = $2;
  $0 = HEAP32[$4 + 708 >> 2];
  $5 = $0;
  $2 = HEAP32[$4 + 704 >> 2];
  $6 = $2;
  $3 = $1 + $2 | 0;
  $0 = $7;
  $2 = $5;
  $5 = $0 + $2 | 0;
  HEAP32[$4 + 24 >> 2] = $3;
  $5 = $3 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  HEAP32[$4 + 28 >> 2] = $5;
  HEAP32[$4 + 724 >> 2] = HEAP32[$4 + 724 >> 2] + 1;
  $0 = ($4 - -64 | 0) + (HEAP32[$4 + 724 >> 2] << 3) | 0;
  $5 = HEAP32[$0 >> 2];
  $13 = $5;
  $1 = HEAP32[$0 + 4 >> 2];
  $14 = $1;
  $0 = (HEAP32[$4 + 724 >> 2] << 3) + 170928 | 0;
  $1 = HEAP32[$0 >> 2];
  $15 = $1;
  $5 = HEAP32[$0 + 4 >> 2];
  $12 = $5;
  $5 = HEAP32[$4 + 32 >> 2];
  $9 = $5;
  $1 = HEAP32[$4 + 36 >> 2];
  $8 = $1;
  $1 = HEAP32[$4 + 56 >> 2];
  $0 = $1;
  $3 = $0 << 23;
  $5 = HEAP32[$4 + 60 >> 2];
  $1 = $5 << 23 | $0 >>> 9;
  $2 = $1;
  $1 = HEAP32[$4 + 56 >> 2];
  $0 = HEAP32[$4 + 60 >> 2];
  $6 = $0 >>> 9 | 0;
  $1 = 0;
  $5 = $1;
  $0 = $3;
  $10 = $0 | $6;
  $1 = $2;
  $5 = $1 | $5;
  $7 = $5;
  $5 = HEAP32[$4 + 56 >> 2];
  $1 = $5;
  $5 = $1 << 18;
  $2 = $5;
  $5 = HEAP32[$4 + 56 >> 2];
  $0 = $5;
  $1 = HEAP32[$4 + 60 >> 2];
  $5 = $1 >>> 14 | 0;
  $6 = ($1 & 16383) << 18 | $0 >>> 14;
  $1 = 0;
  $11 = $1 | $6;
  $0 = $5;
  $5 = $2;
  $0 = $0 | $5;
  $3 = $0;
  $0 = HEAP32[$4 + 56 >> 2];
  $0 = $0 << 14;
  $2 = $0;
  $0 = HEAP32[$4 + 56 >> 2];
  $1 = $0;
  $5 = HEAP32[$4 + 60 >> 2];
  $0 = $5 >>> 18 | 0;
  $6 = ($5 & 262143) << 14 | $1 >>> 18;
  $1 = $0;
  $0 = $2;
  $1 = $1 | $0;
  $2 = $1;
  $0 = $11;
  $5 = 0;
  $6 = $6 | $5;
  $6 = $0 ^ $6;
  $1 = $3;
  $5 = $2;
  $5 = $1 ^ $5;
  $0 = $5;
  $5 = $7;
  $0 = $0 ^ $5;
  $1 = $10;
  $6 = $1 ^ $6;
  $5 = $9;
  $2 = $6 + $5 | 0;
  $1 = $0;
  $0 = $8;
  $3 = $1 + $0 | 0;
  $3 = $2 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
  $10 = $3;
  $3 = HEAP32[$4 + 40 >> 2];
  $11 = $3;
  $5 = HEAP32[$4 + 44 >> 2];
  $9 = $5;
  $5 = HEAP32[$4 + 56 >> 2];
  $8 = $5;
  $3 = HEAP32[$4 + 60 >> 2];
  $7 = $3;
  $3 = HEAP32[$4 + 48 >> 2];
  $1 = $3;
  $5 = HEAP32[$4 + 52 >> 2];
  $0 = $5;
  $5 = HEAP32[$4 + 40 >> 2];
  $6 = $5;
  $3 = HEAP32[$4 + 44 >> 2];
  $5 = $3;
  $3 = $0;
  $5 = $3 ^ $5;
  $0 = $1;
  $6 = $0 ^ $6;
  $3 = $8;
  $6 = $6 & $3;
  $0 = $5;
  $5 = $7;
  $0 = $0 & $5;
  $3 = $0;
  $0 = $9;
  $3 = $0 ^ $3;
  $7 = $3;
  $0 = $2;
  $5 = $11;
  $6 = $6 ^ $5;
  $1 = $0 + $6 | 0;
  $3 = $10;
  $5 = $7;
  $2 = $3 + $5 | 0;
  $2 = $1 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
  $6 = $1;
  $3 = $15;
  $5 = $1 + $3 | 0;
  $0 = $2;
  $2 = $12;
  $1 = $0 + $2 | 0;
  $0 = $5;
  $1 = $5 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
  $3 = $1;
  $1 = $14;
  $5 = $1 + $3 | 0;
  $2 = $13;
  $6 = $0;
  $0 = $2 + $6 | 0;
  $5 = $0 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  HEAP32[$4 + 712 >> 2] = $0;
  HEAP32[$4 + 716 >> 2] = $5;
  $2 = HEAP32[$4 + 28 >> 2];
  $0 = $2;
  $5 = HEAP32[$4 + 24 >> 2];
  $1 = $5;
  $2 = HEAP32[$4 + 16 >> 2];
  $9 = $1 & $2;
  $5 = HEAP32[$4 + 20 >> 2];
  $2 = $5;
  $5 = $0;
  $2 = $2 & $5;
  $8 = $2;
  $2 = HEAP32[$4 + 8 >> 2];
  $7 = $2;
  $1 = HEAP32[$4 + 12 >> 2];
  $3 = $1;
  $1 = HEAP32[$4 + 24 >> 2];
  $5 = $1;
  $2 = HEAP32[$4 + 28 >> 2];
  $0 = $2;
  $2 = HEAP32[$4 + 16 >> 2];
  $6 = $2;
  $1 = HEAP32[$4 + 20 >> 2];
  $2 = $1;
  $1 = $0;
  $2 = $1 | $2;
  $0 = $2;
  $1 = $7;
  $6 = $6 | $5;
  $2 = $3;
  $5 = $0;
  $5 = $2 & $5;
  $2 = $9;
  $6 = $1 & $6;
  $12 = $2 | $6;
  $1 = $5;
  $5 = $8;
  $1 = $1 | $5;
  $8 = $1;
  $1 = HEAP32[$4 + 24 >> 2];
  $3 = $1 << 25;
  $2 = HEAP32[$4 + 28 >> 2];
  $1 = $2 << 25 | $1 >>> 7;
  $0 = $1;
  $1 = HEAP32[$4 + 24 >> 2];
  $5 = HEAP32[$4 + 28 >> 2];
  $1 = 0;
  $2 = $1;
  $6 = $5 >>> 7 | 0;
  $5 = $3;
  $10 = $6 | $5;
  $1 = $0;
  $2 = $1 | $2;
  $7 = $2;
  $2 = HEAP32[$4 + 24 >> 2];
  $1 = $2;
  $2 = $1 << 4;
  $0 = $2;
  $2 = HEAP32[$4 + 24 >> 2];
  $5 = $2;
  $1 = HEAP32[$4 + 28 >> 2];
  $2 = $1 >>> 28 | 0;
  $6 = ($1 & 268435455) << 4 | $5 >>> 28;
  $5 = $2;
  $1 = 0;
  $11 = $1 | $6;
  $2 = $0;
  $5 = $2 | $5;
  $3 = $5;
  $5 = HEAP32[$4 + 24 >> 2];
  $2 = $5;
  $9 = $2 << 30;
  $1 = HEAP32[$4 + 28 >> 2];
  $5 = $1 << 30 | $2 >>> 2;
  $0 = $5;
  $5 = HEAP32[$4 + 24 >> 2];
  $2 = HEAP32[$4 + 28 >> 2];
  $6 = $2 >>> 2 | 0;
  $5 = 0;
  $1 = $5;
  $5 = $0;
  $1 = $1 | $5;
  $0 = $1;
  $2 = $9;
  $6 = $2 | $6;
  $5 = $11;
  $6 = $6 ^ $5;
  $1 = $3;
  $2 = $0;
  $2 = $1 ^ $2;
  $5 = $2;
  $2 = $7;
  $5 = $2 ^ $5;
  $2 = $12;
  $1 = $10;
  $6 = $1 ^ $6;
  $3 = $2 + $6 | 0;
  $1 = $5;
  $5 = $8;
  $0 = $1 + $5 | 0;
  HEAP32[$4 + 704 >> 2] = $3;
  $0 = $3 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  HEAP32[$4 + 708 >> 2] = $0;
  $0 = HEAP32[$4 + 712 >> 2];
  $5 = $0;
  $2 = HEAP32[$4 + 716 >> 2];
  $7 = $2;
  $0 = HEAP32[$4 + 4 >> 2];
  $3 = $0;
  $2 = HEAP32[$4 >> 2];
  $6 = $2;
  $1 = $2 + $5 | 0;
  $0 = $7;
  $2 = $3;
  $3 = $0 + $2 | 0;
  HEAP32[$4 >> 2] = $1;
  $3 = $1 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
  HEAP32[$4 + 4 >> 2] = $3;
  $3 = HEAP32[$4 + 712 >> 2];
  $2 = $3;
  $5 = HEAP32[$4 + 716 >> 2];
  $0 = $5;
  $5 = HEAP32[$4 + 704 >> 2];
  $6 = $5;
  $3 = HEAP32[$4 + 708 >> 2];
  $5 = $3;
  $3 = $0;
  $1 = $3 + $5 | 0;
  $0 = $2;
  $2 = $0 + $6 | 0;
  $1 = $2 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
  HEAP32[$4 + 32 >> 2] = $2;
  HEAP32[$4 + 36 >> 2] = $1;
  HEAP32[$4 + 724 >> 2] = HEAP32[$4 + 724 >> 2] + 1;
  $3 = ($4 - -64 | 0) + (HEAP32[$4 + 724 >> 2] << 3) | 0;
  $1 = HEAP32[$3 >> 2];
  $13 = $1;
  $0 = HEAP32[$3 + 4 >> 2];
  $14 = $0;
  $3 = (HEAP32[$4 + 724 >> 2] << 3) + 170928 | 0;
  $0 = HEAP32[$3 >> 2];
  $15 = $0;
  $1 = HEAP32[$3 + 4 >> 2];
  $12 = $1;
  $1 = HEAP32[$4 + 40 >> 2];
  $9 = $1;
  $0 = HEAP32[$4 + 44 >> 2];
  $8 = $0;
  $0 = HEAP32[$4 >> 2];
  $5 = $0 << 23;
  $1 = HEAP32[$4 + 4 >> 2];
  $0 = $1 << 23 | $0 >>> 9;
  $2 = $0;
  $0 = HEAP32[$4 >> 2];
  $3 = HEAP32[$4 + 4 >> 2];
  $6 = $3 >>> 9 | 0;
  $3 = $5;
  $10 = $6 | $3;
  $0 = 0;
  $1 = $0;
  $0 = $2;
  $1 = $1 | $0;
  $7 = $1;
  $1 = HEAP32[$4 >> 2];
  $0 = $1;
  $1 = $0 << 18;
  $2 = $1;
  $1 = HEAP32[$4 >> 2];
  $3 = $1;
  $0 = HEAP32[$4 + 4 >> 2];
  $1 = $0 >>> 14 | 0;
  $6 = ($0 & 16383) << 18 | $3 >>> 14;
  $3 = $1;
  $0 = 0;
  $11 = $0 | $6;
  $1 = $2;
  $3 = $1 | $3;
  $5 = $3;
  $3 = HEAP32[$4 >> 2];
  $1 = $3;
  $3 = $1 << 14;
  $2 = $3;
  $3 = HEAP32[$4 >> 2];
  $0 = $3;
  $1 = HEAP32[$4 + 4 >> 2];
  $3 = $1 >>> 18 | 0;
  $6 = ($1 & 262143) << 14 | $0 >>> 18;
  $0 = $3;
  $3 = $2;
  $0 = $0 | $3;
  $1 = 0;
  $6 = $1 | $6;
  $3 = $11;
  $6 = $6 ^ $3;
  $1 = $0;
  $0 = $5;
  $1 = $1 ^ $0;
  $3 = $1;
  $1 = $7;
  $3 = $1 ^ $3;
  $1 = $9;
  $0 = $10;
  $6 = $0 ^ $6;
  $5 = $1 + $6 | 0;
  $0 = $3;
  $3 = $8;
  $2 = $0 + $3 | 0;
  $2 = $5 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
  $10 = $2;
  $2 = HEAP32[$4 + 48 >> 2];
  $11 = $2;
  $1 = HEAP32[$4 + 52 >> 2];
  $9 = $1;
  $1 = HEAP32[$4 >> 2];
  $8 = $1;
  $2 = HEAP32[$4 + 4 >> 2];
  $7 = $2;
  $2 = HEAP32[$4 + 56 >> 2];
  $3 = $2;
  $1 = HEAP32[$4 + 60 >> 2];
  $0 = $1;
  $1 = HEAP32[$4 + 48 >> 2];
  $6 = $1;
  $2 = HEAP32[$4 + 52 >> 2];
  $1 = $2;
  $2 = $0;
  $1 = $1 ^ $2;
  $0 = $1;
  $2 = $8;
  $6 = $6 ^ $3;
  $6 = $2 & $6;
  $1 = $7;
  $3 = $0;
  $3 = $1 & $3;
  $2 = $3;
  $3 = $9;
  $2 = $2 ^ $3;
  $1 = $11;
  $6 = $1 ^ $6;
  $3 = $5;
  $0 = $6 + $3 | 0;
  $1 = $2;
  $2 = $10;
  $5 = $1 + $2 | 0;
  $1 = $0;
  $5 = $0 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  $3 = $5;
  $5 = $12;
  $0 = $3 + $5 | 0;
  $2 = $15;
  $6 = $1;
  $1 = $2 + $6 | 0;
  $0 = $1 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  $6 = $1;
  $2 = $0;
  $0 = $14;
  $1 = $0 + $2 | 0;
  $5 = $13;
  $3 = $6 + $5 | 0;
  HEAP32[$4 + 712 >> 2] = $3;
  $1 = $3 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
  HEAP32[$4 + 716 >> 2] = $1;
  $1 = HEAP32[$4 + 32 >> 2];
  $0 = $1;
  $5 = HEAP32[$4 + 36 >> 2];
  $3 = $5;
  $1 = HEAP32[$4 + 28 >> 2];
  $2 = $1;
  $5 = HEAP32[$4 + 24 >> 2];
  $9 = $0 & $5;
  $1 = $3;
  $5 = $2;
  $5 = $1 & $5;
  $8 = $5;
  $5 = HEAP32[$4 + 16 >> 2];
  $7 = $5;
  $0 = HEAP32[$4 + 20 >> 2];
  $3 = $0;
  $0 = HEAP32[$4 + 32 >> 2];
  $2 = $0;
  $5 = HEAP32[$4 + 36 >> 2];
  $1 = $5;
  $5 = HEAP32[$4 + 24 >> 2];
  $6 = $5;
  $0 = HEAP32[$4 + 28 >> 2];
  $5 = $0;
  $0 = $1;
  $5 = $0 | $5;
  $0 = $7;
  $1 = $2;
  $6 = $1 | $6;
  $1 = $5;
  $5 = $3;
  $1 = $1 & $5;
  $2 = $1;
  $6 = $0 & $6;
  $5 = $9;
  $10 = $6 | $5;
  $1 = $8;
  $0 = $2;
  $0 = $1 | $0;
  $8 = $0;
  $0 = HEAP32[$4 + 32 >> 2];
  $3 = $0 << 25;
  $5 = HEAP32[$4 + 36 >> 2];
  $0 = $5 << 25 | $0 >>> 7;
  $2 = $0;
  $0 = HEAP32[$4 + 32 >> 2];
  $1 = HEAP32[$4 + 36 >> 2];
  $6 = $1 >>> 7 | 0;
  $0 = 0;
  $5 = $0;
  $1 = $3;
  $11 = $1 | $6;
  $0 = $2;
  $5 = $0 | $5;
  $7 = $5;
  $5 = HEAP32[$4 + 32 >> 2];
  $0 = $5;
  $5 = $0 << 4;
  $2 = $5;
  $5 = HEAP32[$4 + 32 >> 2];
  $1 = $5;
  $0 = HEAP32[$4 + 36 >> 2];
  $5 = $0 >>> 28 | 0;
  $6 = ($0 & 268435455) << 4 | $1 >>> 28;
  $0 = 0;
  $6 = $0 | $6;
  $1 = $5;
  $5 = $2;
  $1 = $1 | $5;
  $3 = $1;
  $1 = HEAP32[$4 + 32 >> 2];
  $9 = $1 << 30;
  $0 = HEAP32[$4 + 36 >> 2];
  $1 = $0 << 30 | $1 >>> 2;
  $2 = $1;
  $1 = HEAP32[$4 + 32 >> 2];
  $5 = HEAP32[$4 + 36 >> 2];
  $1 = 0;
  $0 = $1;
  $1 = $2;
  $0 = $1 | $0;
  $2 = $0;
  $1 = $6;
  $6 = $5 >>> 2 | 0;
  $5 = $9;
  $6 = $6 | $5;
  $6 = $1 ^ $6;
  $0 = $3;
  $5 = $2;
  $5 = $0 ^ $5;
  $1 = $5;
  $5 = $7;
  $1 = $1 ^ $5;
  $3 = $1;
  $0 = $11;
  $6 = $0 ^ $6;
  $5 = $10;
  $2 = $6 + $5 | 0;
  $1 = $8;
  $0 = $3;
  $3 = $1 + $0 | 0;
  HEAP32[$4 + 704 >> 2] = $2;
  $3 = $2 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
  HEAP32[$4 + 708 >> 2] = $3;
  $3 = HEAP32[$4 + 712 >> 2];
  $1 = $3;
  $5 = HEAP32[$4 + 716 >> 2];
  $0 = $5;
  $5 = HEAP32[$4 + 8 >> 2];
  $6 = $5;
  $3 = HEAP32[$4 + 12 >> 2];
  $5 = $3;
  $3 = $0;
  $2 = $3 + $5 | 0;
  $0 = $1 + $6 | 0;
  $2 = $0 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
  HEAP32[$4 + 8 >> 2] = $0;
  HEAP32[$4 + 12 >> 2] = $2;
  $1 = HEAP32[$4 + 716 >> 2];
  $0 = $1;
  $1 = HEAP32[$4 + 704 >> 2];
  $6 = $1;
  $2 = HEAP32[$4 + 712 >> 2];
  $3 = $2;
  $5 = $1 + $3 | 0;
  $2 = HEAP32[$4 + 708 >> 2];
  $1 = $2;
  $2 = $0;
  $0 = $1 + $2 | 0;
  HEAP32[$4 + 40 >> 2] = $5;
  $0 = $5 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  HEAP32[$4 + 44 >> 2] = $0;
  HEAP32[$4 + 724 >> 2] = HEAP32[$4 + 724 >> 2] + 1;
  $2 = ($4 - -64 | 0) + (HEAP32[$4 + 724 >> 2] << 3) | 0;
  $0 = HEAP32[$2 >> 2];
  $16 = $0;
  $3 = HEAP32[$2 + 4 >> 2];
  $13 = $3;
  $2 = (HEAP32[$4 + 724 >> 2] << 3) + 170928 | 0;
  $3 = HEAP32[$2 >> 2];
  $14 = $3;
  $0 = HEAP32[$2 + 4 >> 2];
  $15 = $0;
  $0 = HEAP32[$4 + 48 >> 2];
  $9 = $0;
  $3 = HEAP32[$4 + 52 >> 2];
  $8 = $3;
  $3 = HEAP32[$4 + 8 >> 2];
  $5 = $3 << 23;
  $0 = HEAP32[$4 + 12 >> 2];
  $3 = $0 << 23 | $3 >>> 9;
  $1 = $3;
  $3 = HEAP32[$4 + 8 >> 2];
  $2 = HEAP32[$4 + 12 >> 2];
  $6 = $2 >>> 9 | 0;
  $2 = $5;
  $10 = $2 | $6;
  $3 = 0;
  $0 = $3;
  $3 = $1;
  $0 = $0 | $3;
  $7 = $0;
  $0 = HEAP32[$4 + 8 >> 2];
  $0 = $0 << 18;
  $5 = $0;
  $0 = HEAP32[$4 + 8 >> 2];
  $2 = $0;
  $3 = HEAP32[$4 + 12 >> 2];
  $0 = $3 >>> 14 | 0;
  $1 = $0;
  $6 = ($3 & 16383) << 18 | $2 >>> 14;
  $3 = 0;
  $11 = $6 | $3;
  $0 = $5;
  $2 = $1;
  $2 = $0 | $2;
  $5 = $2;
  $2 = HEAP32[$4 + 8 >> 2];
  $0 = $2;
  $2 = $0 << 14;
  $1 = $2;
  $2 = HEAP32[$4 + 8 >> 2];
  $3 = $2;
  $0 = HEAP32[$4 + 12 >> 2];
  $2 = $0 >>> 18 | 0;
  $6 = ($0 & 262143) << 14 | $3 >>> 18;
  $3 = $2;
  $2 = $1;
  $3 = $2 | $3;
  $2 = $11;
  $0 = 0;
  $6 = $0 | $6;
  $6 = $2 ^ $6;
  $0 = $3;
  $3 = $5;
  $0 = $0 ^ $3;
  $2 = $0;
  $0 = $7;
  $2 = $0 ^ $2;
  $5 = $2;
  $0 = $9;
  $3 = $10;
  $6 = $6 ^ $3;
  $1 = $0 + $6 | 0;
  $2 = $8;
  $3 = $5;
  $5 = $2 + $3 | 0;
  $5 = $1 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  $12 = $5;
  $5 = HEAP32[$4 + 56 >> 2];
  $10 = $5;
  $0 = HEAP32[$4 + 60 >> 2];
  $11 = $0;
  $0 = HEAP32[$4 + 8 >> 2];
  $9 = $0;
  $5 = HEAP32[$4 + 12 >> 2];
  $8 = $5;
  $5 = HEAP32[$4 >> 2];
  $7 = $5;
  $0 = HEAP32[$4 + 4 >> 2];
  $2 = $0;
  $0 = HEAP32[$4 + 56 >> 2];
  $6 = $0;
  $5 = HEAP32[$4 + 60 >> 2];
  $0 = $5;
  $5 = $2;
  $0 = $0 ^ $5;
  $3 = $0;
  $2 = $7;
  $6 = $2 ^ $6;
  $5 = $9;
  $6 = $6 & $5;
  $0 = $8;
  $2 = $3;
  $2 = $0 & $2;
  $5 = $2;
  $2 = $11;
  $5 = $2 ^ $5;
  $0 = $10;
  $6 = $0 ^ $6;
  $3 = $1 + $6 | 0;
  $0 = $5;
  $5 = $12;
  $1 = $0 + $5 | 0;
  $0 = $3;
  $1 = $3 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
  $2 = $1;
  $1 = $15;
  $3 = $1 + $2 | 0;
  $6 = $0;
  $5 = $14;
  $0 = $6 + $5 | 0;
  $3 = $0 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
  $6 = $0;
  $5 = $3;
  $3 = $13;
  $0 = $3 + $5 | 0;
  $1 = $16;
  $2 = $1 + $6 | 0;
  $0 = $2 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  HEAP32[$4 + 712 >> 2] = $2;
  HEAP32[$4 + 716 >> 2] = $0;
  $1 = HEAP32[$4 + 44 >> 2];
  $2 = $1;
  $1 = HEAP32[$4 + 32 >> 2];
  $0 = HEAP32[$4 + 40 >> 2];
  $11 = $1 & $0;
  $0 = HEAP32[$4 + 36 >> 2];
  $1 = $0;
  $0 = $2;
  $1 = $1 & $0;
  $9 = $1;
  $1 = HEAP32[$4 + 24 >> 2];
  $8 = $1;
  $3 = HEAP32[$4 + 28 >> 2];
  $7 = $3;
  $3 = HEAP32[$4 + 40 >> 2];
  $5 = $3;
  $1 = HEAP32[$4 + 44 >> 2];
  $0 = $1;
  $1 = HEAP32[$4 + 32 >> 2];
  $6 = $1;
  $3 = HEAP32[$4 + 36 >> 2];
  $1 = $3;
  $3 = $0;
  $1 = $1 | $3;
  $2 = $1;
  $0 = $5;
  $6 = $0 | $6;
  $3 = $8;
  $1 = $7;
  $0 = $2;
  $0 = $1 & $0;
  $2 = $0;
  $1 = $11;
  $6 = $6 & $3;
  $12 = $1 | $6;
  $0 = $9;
  $3 = $2;
  $3 = $0 | $3;
  $8 = $3;
  $3 = HEAP32[$4 + 40 >> 2];
  $0 = $3;
  $5 = $0 << 25;
  $1 = HEAP32[$4 + 44 >> 2];
  $3 = $1 << 25 | $0 >>> 7;
  $2 = $3;
  $3 = HEAP32[$4 + 40 >> 2];
  $0 = HEAP32[$4 + 44 >> 2];
  $6 = $0 >>> 7 | 0;
  $0 = $5;
  $10 = $0 | $6;
  $3 = 0;
  $1 = $3;
  $3 = $2;
  $1 = $1 | $3;
  $7 = $1;
  $1 = HEAP32[$4 + 40 >> 2];
  $1 = $1 << 4;
  $5 = $1;
  $1 = HEAP32[$4 + 40 >> 2];
  $0 = $1;
  $3 = HEAP32[$4 + 44 >> 2];
  $1 = $3 >>> 28 | 0;
  $2 = $1;
  $6 = ($3 & 268435455) << 4 | $0 >>> 28;
  $3 = 0;
  $11 = $6 | $3;
  $1 = $5;
  $0 = $2;
  $0 = $1 | $0;
  $5 = $0;
  $0 = HEAP32[$4 + 40 >> 2];
  $9 = $0 << 30;
  $3 = HEAP32[$4 + 44 >> 2];
  $0 = $3 << 30 | $0 >>> 2;
  $2 = $0;
  $0 = HEAP32[$4 + 40 >> 2];
  $1 = HEAP32[$4 + 44 >> 2];
  $6 = $1 >>> 2 | 0;
  $0 = 0;
  $3 = $0;
  $0 = $2;
  $3 = $0 | $3;
  $0 = $11;
  $1 = $9;
  $6 = $1 | $6;
  $6 = $0 ^ $6;
  $1 = $3;
  $3 = $5;
  $1 = $1 ^ $3;
  $0 = $1;
  $1 = $7;
  $0 = $1 ^ $0;
  $2 = $0;
  $1 = $12;
  $3 = $10;
  $6 = $6 ^ $3;
  $5 = $1 + $6 | 0;
  $0 = $8;
  $3 = $2;
  $2 = $0 + $3 | 0;
  HEAP32[$4 + 704 >> 2] = $5;
  $2 = $5 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
  HEAP32[$4 + 708 >> 2] = $2;
  $1 = HEAP32[$4 + 716 >> 2];
  $5 = $1;
  $2 = HEAP32[$4 + 712 >> 2];
  $0 = $2;
  $1 = HEAP32[$4 + 16 >> 2];
  $6 = $1;
  $3 = $0 + $1 | 0;
  $2 = HEAP32[$4 + 20 >> 2];
  $1 = $2;
  $2 = $5;
  $5 = $1 + $2 | 0;
  HEAP32[$4 + 16 >> 2] = $3;
  $5 = $3 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  HEAP32[$4 + 20 >> 2] = $5;
  $5 = HEAP32[$4 + 712 >> 2];
  $2 = $5;
  $0 = HEAP32[$4 + 716 >> 2];
  $1 = $0;
  $0 = HEAP32[$4 + 704 >> 2];
  $6 = $0;
  $5 = HEAP32[$4 + 708 >> 2];
  $0 = $5;
  $5 = $1;
  $3 = $0 + $5 | 0;
  $1 = $2 + $6 | 0;
  $3 = $1 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
  HEAP32[$4 + 48 >> 2] = $1;
  HEAP32[$4 + 52 >> 2] = $3;
  HEAP32[$4 + 724 >> 2] = HEAP32[$4 + 724 >> 2] + 1;
  $5 = ($4 - -64 | 0) + (HEAP32[$4 + 724 >> 2] << 3) | 0;
  $3 = HEAP32[$5 >> 2];
  $13 = $3;
  $2 = HEAP32[$5 + 4 >> 2];
  $14 = $2;
  $5 = (HEAP32[$4 + 724 >> 2] << 3) + 170928 | 0;
  $2 = HEAP32[$5 >> 2];
  $15 = $2;
  $3 = HEAP32[$5 + 4 >> 2];
  $12 = $3;
  $3 = HEAP32[$4 + 56 >> 2];
  $9 = $3;
  $2 = HEAP32[$4 + 60 >> 2];
  $8 = $2;
  $2 = HEAP32[$4 + 16 >> 2];
  $1 = $2 << 23;
  $3 = HEAP32[$4 + 20 >> 2];
  $2 = $3 << 23 | $2 >>> 9;
  $0 = $2;
  $2 = HEAP32[$4 + 16 >> 2];
  $5 = HEAP32[$4 + 20 >> 2];
  $2 = 0;
  $3 = $2;
  $6 = $5 >>> 9 | 0;
  $5 = $1;
  $10 = $6 | $5;
  $2 = $0;
  $3 = $2 | $3;
  $7 = $3;
  $3 = HEAP32[$4 + 16 >> 2];
  $3 = $3 << 18;
  $0 = $3;
  $3 = HEAP32[$4 + 16 >> 2];
  $5 = $3;
  $2 = HEAP32[$4 + 20 >> 2];
  $3 = $2 >>> 14 | 0;
  $6 = ($2 & 16383) << 18 | $5 >>> 14;
  $5 = $3;
  $2 = 0;
  $11 = $2 | $6;
  $3 = $0;
  $5 = $3 | $5;
  $1 = $5;
  $5 = HEAP32[$4 + 16 >> 2];
  $3 = $5;
  $5 = $3 << 14;
  $0 = $5;
  $5 = HEAP32[$4 + 16 >> 2];
  $2 = $5;
  $3 = HEAP32[$4 + 20 >> 2];
  $5 = $3 >>> 18 | 0;
  $6 = ($3 & 262143) << 14 | $2 >>> 18;
  $2 = $5;
  $5 = $0;
  $2 = $2 | $5;
  $0 = $2;
  $3 = 0;
  $6 = $6 | $3;
  $5 = $11;
  $6 = $6 ^ $5;
  $2 = $1;
  $3 = $0;
  $3 = $2 ^ $3;
  $5 = $3;
  $3 = $7;
  $5 = $3 ^ $5;
  $2 = $10;
  $6 = $2 ^ $6;
  $3 = $9;
  $0 = $6 + $3 | 0;
  $2 = $5;
  $5 = $8;
  $1 = $2 + $5 | 0;
  $1 = $0 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
  $10 = $1;
  $1 = HEAP32[$4 >> 2];
  $11 = $1;
  $3 = HEAP32[$4 + 4 >> 2];
  $9 = $3;
  $3 = HEAP32[$4 + 16 >> 2];
  $8 = $3;
  $1 = HEAP32[$4 + 20 >> 2];
  $7 = $1;
  $1 = HEAP32[$4 + 8 >> 2];
  $5 = $1;
  $3 = HEAP32[$4 + 12 >> 2];
  $2 = $3;
  $3 = HEAP32[$4 >> 2];
  $6 = $3;
  $1 = HEAP32[$4 + 4 >> 2];
  $3 = $1;
  $1 = $2;
  $3 = $1 ^ $3;
  $2 = $3;
  $1 = $8;
  $6 = $6 ^ $5;
  $6 = $1 & $6;
  $3 = $7;
  $5 = $2;
  $5 = $3 & $5;
  $1 = $5;
  $5 = $9;
  $1 = $1 ^ $5;
  $5 = $1;
  $3 = $11;
  $6 = $6 ^ $3;
  $2 = $6 + $0 | 0;
  $1 = $10;
  $3 = $5;
  $0 = $1 + $3 | 0;
  $3 = $2;
  $0 = $2 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
  $5 = $0;
  $0 = $12;
  $2 = $0 + $5 | 0;
  $1 = $15;
  $6 = $3;
  $3 = $1 + $6 | 0;
  $5 = $3;
  $2 = $3 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
  $1 = $2;
  $2 = $14;
  $3 = $1 + $2 | 0;
  $0 = $13;
  $6 = $5;
  $5 = $0 + $6 | 0;
  HEAP32[$4 + 712 >> 2] = $5;
  $3 = $5 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
  HEAP32[$4 + 716 >> 2] = $3;
  $0 = HEAP32[$4 + 52 >> 2];
  $1 = $0;
  $3 = HEAP32[$4 + 48 >> 2];
  $0 = HEAP32[$4 + 40 >> 2];
  $9 = $3 & $0;
  $3 = HEAP32[$4 + 44 >> 2];
  $0 = $3;
  $3 = $1;
  $0 = $0 & $3;
  $8 = $0;
  $0 = HEAP32[$4 + 32 >> 2];
  $7 = $0;
  $2 = HEAP32[$4 + 36 >> 2];
  $5 = $2;
  $2 = HEAP32[$4 + 48 >> 2];
  $3 = $2;
  $0 = HEAP32[$4 + 52 >> 2];
  $1 = $0;
  $0 = HEAP32[$4 + 40 >> 2];
  $6 = $0;
  $2 = HEAP32[$4 + 44 >> 2];
  $0 = $2;
  $2 = $1;
  $0 = $0 | $2;
  $1 = $0;
  $2 = $7;
  $6 = $6 | $3;
  $0 = $5;
  $3 = $1;
  $3 = $0 & $3;
  $0 = $9;
  $6 = $2 & $6;
  $12 = $0 | $6;
  $2 = $3;
  $3 = $8;
  $2 = $2 | $3;
  $8 = $2;
  $2 = HEAP32[$4 + 48 >> 2];
  $3 = $2;
  $5 = $3 << 25;
  $0 = HEAP32[$4 + 52 >> 2];
  $2 = $0 << 25 | $3 >>> 7;
  $1 = $2;
  $2 = HEAP32[$4 + 48 >> 2];
  $3 = HEAP32[$4 + 52 >> 2];
  $6 = $3 >>> 7 | 0;
  $3 = $5;
  $10 = $6 | $3;
  $2 = 0;
  $0 = $2;
  $2 = $1;
  $0 = $0 | $2;
  $7 = $0;
  $0 = HEAP32[$4 + 48 >> 2];
  $0 = $0 << 4;
  $1 = $0;
  $0 = HEAP32[$4 + 48 >> 2];
  $3 = $0;
  $2 = HEAP32[$4 + 52 >> 2];
  $0 = $2 >>> 28 | 0;
  $6 = ($2 & 268435455) << 4 | $3 >>> 28;
  $3 = $0;
  $2 = 0;
  $11 = $2 | $6;
  $0 = $1;
  $3 = $0 | $3;
  $5 = $3;
  $3 = HEAP32[$4 + 48 >> 2];
  $0 = $3;
  $9 = $0 << 30;
  $2 = HEAP32[$4 + 52 >> 2];
  $3 = $2 << 30 | $0 >>> 2;
  $1 = $3;
  $3 = HEAP32[$4 + 48 >> 2];
  $0 = HEAP32[$4 + 52 >> 2];
  $6 = $0 >>> 2 | 0;
  $3 = 0;
  $2 = $3;
  $3 = $1;
  $2 = $2 | $3;
  $0 = $9;
  $6 = $0 | $6;
  $3 = $11;
  $6 = $6 ^ $3;
  $0 = $2;
  $2 = $5;
  $0 = $0 ^ $2;
  $3 = $0;
  $0 = $7;
  $3 = $0 ^ $3;
  $0 = $12;
  $2 = $10;
  $6 = $2 ^ $6;
  $1 = $0 + $6 | 0;
  $2 = $3;
  $3 = $8;
  $5 = $2 + $3 | 0;
  HEAP32[$4 + 704 >> 2] = $1;
  $5 = $1 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  HEAP32[$4 + 708 >> 2] = $5;
  $0 = HEAP32[$4 + 716 >> 2];
  $1 = $0;
  $0 = HEAP32[$4 + 24 >> 2];
  $6 = $0;
  $5 = HEAP32[$4 + 712 >> 2];
  $3 = $5;
  $2 = $0 + $3 | 0;
  $5 = HEAP32[$4 + 28 >> 2];
  $0 = $5;
  $5 = $1;
  $1 = $0 + $5 | 0;
  HEAP32[$4 + 24 >> 2] = $2;
  $1 = $2 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
  HEAP32[$4 + 28 >> 2] = $1;
  $1 = HEAP32[$4 + 712 >> 2];
  $5 = $1;
  $3 = HEAP32[$4 + 716 >> 2];
  $7 = $3;
  $1 = HEAP32[$4 + 708 >> 2];
  $2 = $1;
  $3 = HEAP32[$4 + 704 >> 2];
  $6 = $3;
  $0 = $3 + $5 | 0;
  $1 = $7;
  $3 = $2;
  $2 = $1 + $3 | 0;
  HEAP32[$4 + 56 >> 2] = $0;
  $2 = $0 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
  HEAP32[$4 + 60 >> 2] = $2;
  HEAP32[$4 + 724 >> 2] = HEAP32[$4 + 724 >> 2] + 1;
  if (HEAP32[$4 + 724 >> 2] < 80) {
   continue;
  }
  break;
 }
 $7 = HEAP32[$4 + 732 >> 2];
 $2 = HEAP32[$4 + 56 >> 2];
 $3 = $2;
 $5 = HEAP32[$4 + 60 >> 2];
 $0 = $5;
 $1 = $7;
 $5 = HEAP32[$1 + 16 >> 2];
 $6 = $5;
 $2 = HEAP32[$1 + 20 >> 2];
 $5 = $2;
 $2 = $0;
 $0 = $2 + $5 | 0;
 $1 = $3;
 $3 = $1 + $6 | 0;
 $1 = $7;
 HEAP32[$1 + 16 >> 2] = $3;
 $0 = $3 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
 HEAP32[$1 + 20 >> 2] = $0;
 $7 = HEAP32[$4 + 732 >> 2];
 $0 = HEAP32[$4 + 48 >> 2];
 $5 = $0;
 $1 = HEAP32[$4 + 52 >> 2];
 $3 = $1;
 $2 = $7;
 $1 = HEAP32[$2 + 24 >> 2];
 $6 = $1;
 $0 = HEAP32[$2 + 28 >> 2];
 $1 = $0;
 $0 = $3;
 $3 = $1 + $0 | 0;
 $2 = $5;
 $5 = $2 + $6 | 0;
 $2 = $7;
 HEAP32[$2 + 24 >> 2] = $5;
 $3 = $5 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
 HEAP32[$2 + 28 >> 2] = $3;
 $8 = HEAP32[$4 + 732 >> 2];
 $3 = HEAP32[$4 + 40 >> 2];
 $7 = $3;
 $2 = HEAP32[$4 + 44 >> 2];
 $1 = $2;
 $0 = $8;
 $2 = HEAP32[$0 + 32 >> 2];
 $6 = $2;
 $3 = HEAP32[$0 + 36 >> 2];
 $2 = $3;
 $3 = $1;
 $5 = $2 + $3 | 0;
 $0 = $7;
 $1 = $0 + $6 | 0;
 $5 = $1 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
 $0 = $8;
 HEAP32[$0 + 32 >> 2] = $1;
 HEAP32[$0 + 36 >> 2] = $5;
 $7 = HEAP32[$4 + 732 >> 2];
 $5 = HEAP32[$4 + 32 >> 2];
 $2 = $5;
 $0 = HEAP32[$4 + 36 >> 2];
 $1 = $0;
 $3 = $7;
 $0 = HEAP32[$3 + 40 >> 2];
 $6 = $0;
 $5 = HEAP32[$3 + 44 >> 2];
 $0 = $5;
 $5 = $1;
 $1 = $0 + $5 | 0;
 $3 = $2;
 $2 = $6 + $3 | 0;
 $1 = $2 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
 $3 = $7;
 HEAP32[$3 + 40 >> 2] = $2;
 HEAP32[$3 + 44 >> 2] = $1;
 $8 = HEAP32[$4 + 732 >> 2];
 $1 = HEAP32[$4 + 24 >> 2];
 $7 = $1;
 $3 = HEAP32[$4 + 28 >> 2];
 $0 = $3;
 $5 = $8;
 $3 = HEAP32[$5 + 48 >> 2];
 $6 = $3;
 $1 = HEAP32[$5 + 52 >> 2];
 $3 = $1;
 $1 = $0;
 $2 = $1 + $3 | 0;
 $5 = $7;
 $0 = $6 + $5 | 0;
 $2 = $0 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
 $5 = $8;
 HEAP32[$5 + 48 >> 2] = $0;
 HEAP32[$5 + 52 >> 2] = $2;
 $7 = HEAP32[$4 + 732 >> 2];
 $2 = HEAP32[$4 + 16 >> 2];
 $3 = $2;
 $5 = HEAP32[$4 + 20 >> 2];
 $0 = $5;
 $1 = $7;
 $5 = HEAP32[$1 + 56 >> 2];
 $6 = $5;
 $2 = HEAP32[$1 + 60 >> 2];
 $5 = $2;
 $2 = $0;
 $0 = $2 + $5 | 0;
 $1 = $3;
 $3 = $1 + $6 | 0;
 $1 = $7;
 HEAP32[$1 + 56 >> 2] = $3;
 $0 = $3 >>> 0 < $6 >>> 0 ? $0 + 1 | 0 : $0;
 HEAP32[$1 + 60 >> 2] = $0;
 $7 = HEAP32[$4 + 732 >> 2];
 $0 = HEAP32[$4 + 8 >> 2];
 $5 = $0;
 $1 = HEAP32[$4 + 12 >> 2];
 $3 = $1;
 $2 = $7;
 $1 = HEAP32[$2 + 64 >> 2];
 $6 = $1;
 $0 = HEAP32[$2 + 68 >> 2];
 $1 = $0;
 $0 = $3;
 $3 = $1 + $0 | 0;
 $2 = $5;
 $5 = $2 + $6 | 0;
 $2 = $7;
 HEAP32[$2 + 64 >> 2] = $5;
 $3 = $5 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
 HEAP32[$2 + 68 >> 2] = $3;
 $8 = HEAP32[$4 + 732 >> 2];
 $3 = HEAP32[$4 >> 2];
 $7 = $3;
 $2 = HEAP32[$4 + 4 >> 2];
 $1 = $2;
 $0 = $8;
 $2 = HEAP32[$0 + 72 >> 2];
 $6 = $2;
 $3 = HEAP32[$0 + 76 >> 2];
 $2 = $3;
 $3 = $1;
 $5 = $2 + $3 | 0;
 $0 = $7;
 $1 = $0 + $6 | 0;
 $5 = $1 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
 $0 = $8;
 HEAP32[$0 + 72 >> 2] = $1;
 HEAP32[$0 + 76 >> 2] = $5;
 __stack_pointer = $4 + 736 | 0;
}

function jsiIdle() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $0 = __stack_pointer - 320 | 0;
 __stack_pointer = $0;
 if (HEAPU8[364430] < 255) {
  HEAP8[364430] = HEAPU8[364430] + 1;
 }
 HEAP8[$0 + 319 | 0] = 0;
 HEAP32[$0 + 308 >> 2] = jshGetEventsUsed();
 while (1) {
  $5 = HEAP32[$0 + 308 >> 2];
  HEAP32[$0 + 308 >> 2] = $5 - 1;
  $1 = 0;
  if (($5 | 0) > 0) {
   $1 = jshPopIOEvent($0 + 312 | 0);
  }
  if ($1 & 1) {
   jsiSetBusy(1, 1);
   HEAP8[$0 + 319 | 0] = 1;
   HEAP8[$0 + 307 | 0] = HEAPU8[$0 + 312 | 0] & 31;
   HEAP8[364430] = 0;
   label$5: {
    if (HEAPU8[$0 + 307 | 0] == HEAPU8[195664]) {
     jsiHandleIOEventForConsole($0 + 312 | 0);
     break label$5;
    }
    label$7: {
     if (!(HEAPU8[$0 + 307 | 0] < 17 | HEAPU8[$0 + 307 | 0] > 22)) {
      HEAP32[$0 + 300 >> 2] = jsvSkipNameAndUnLock(jsiGetClassNameFromDevice(HEAPU8[$0 + 307 | 0]));
      if (jsvIsObject(HEAP32[$0 + 300 >> 2]) & 1) {
       $5 = jsiHandleIOEventForSerial(HEAP32[$0 + 300 >> 2], $0 + 312 | 0);
       HEAP32[$0 + 308 >> 2] = HEAP32[$0 + 308 >> 2] - $5;
      }
      jsvUnLock(HEAP32[$0 + 300 >> 2]);
      break label$7;
     }
     label$10: {
      if (!(HEAPU8[$0 + 307 | 0] < 23 | HEAPU8[$0 + 307 | 0] > 23)) {
       HEAP32[$0 + 296 >> 2] = jsvSkipNameAndUnLock(jsiGetClassNameFromDevice(HEAPU8[$0 + 312 | 0] - 1 & 31));
       if (jsvIsObject(HEAP32[$0 + 296 >> 2]) & 1) {
        if (HEAPU8[$0 + 312 | 0] & 32) {
         jsiExecuteEventCallbackName(HEAP32[$0 + 296 >> 2], 13e4, 0, 0);
        }
        if (HEAPU8[$0 + 312 | 0] & 64) {
         jsiExecuteEventCallbackName(HEAP32[$0 + 296 >> 2], 116108, 0, 0);
        }
       }
       jsvUnLock(HEAP32[$0 + 296 >> 2]);
       break label$10;
      }
      label$15: {
       if (HEAPU8[$0 + 307 | 0] == 24) {
        jswOnCustomEvent($0 + 312 | 0);
        break label$15;
       }
       label$17: {
        if (HEAPU8[$0 + 307 | 0] == 25) {
         jsbangle_exec_pending($0 + 312 | 0);
         break label$17;
        }
        if (!(!HEAPU8[$0 + 307 | 0] | HEAPU8[$0 + 307 | 0] > 16)) {
         HEAP32[$0 + 292 >> 2] = jsvLock(HEAPU16[182205]);
         jsvObjectIteratorNew($0 + 288 | 0, HEAP32[$0 + 292 >> 2]);
         while (1) {
          if (jsvObjectIteratorHasValue_3($0 + 288 | 0) & 1) {
           HEAP8[$0 + 287 | 0] = 0;
           HEAP32[$0 + 280 >> 2] = jsvObjectIteratorGetValue_3($0 + 288 | 0);
           HEAP8[$0 + 279 | 0] = jshGetPinFromVarAndUnLock(jsvObjectGetChildIfExists(HEAP32[$0 + 280 >> 2], 128488));
           if (jshIsEventForPin($0 + 312 | 0, HEAPU8[$0 + 279 | 0]) & 1) {
            $4 = jshGetSystemTime();
            HEAP32[$0 + 264 >> 2] = $4;
            $2 = i64toi32_i32$HIGH_BITS;
            HEAP32[$0 + 268 >> 2] = $2;
            $2 = HEAP32[$0 + 264 >> 2];
            if ($2 >>> 0 < (HEAPU8[$0 + 313 | 0] | HEAPU8[$0 + 314 | 0] << 8 | (HEAPU8[$0 + 315 | 0] << 16 | HEAPU8[$0 + 316 | 0] << 24)) >>> 0) {
             $4 = HEAP32[$0 + 264 >> 2];
             $5 = $4;
             $2 = HEAP32[$0 + 268 >> 2];
             $1 = 1;
             $1 = $2 - $1 | 0;
             $3 = $5;
             HEAP32[$0 + 264 >> 2] = $3;
             HEAP32[$0 + 268 >> 2] = $1;
            }
            $1 = HEAPU8[$0 + 313 | 0] | HEAPU8[$0 + 314 | 0] << 8 | (HEAPU8[$0 + 315 | 0] << 16 | HEAPU8[$0 + 316 | 0] << 24);
            $2 = $1;
            $5 = HEAP32[$0 + 264 >> 2];
            $1 = HEAP32[$0 + 268 >> 2];
            $5 = $1;
            $6 = $11;
            $1 = $2;
            $1 = $6 | $1;
            HEAP32[$0 + 256 >> 2] = $1;
            $2 = $5;
            HEAP32[$0 + 260 >> 2] = $2;
            HEAP8[$0 + 255 | 0] = (HEAPU8[$0 + 312 | 0] & 32) != 0;
            HEAP8[$0 + 254 | 0] = 0;
            HEAP8[$0 + 254 | 0] = (HEAPU8[$0 + 312 | 0] & 64) != 0;
            HEAP8[$0 + 253 | 0] = 0;
            HEAP32[$0 + 248 >> 2] = jsvObjectGetIntegerChild(HEAP32[$0 + 280 >> 2], 132809);
            label$24: {
             if (HEAP32[$0 + 248 >> 2] <= 0) {
              HEAP8[$0 + 253 | 0] = (HEAPU8[$0 + 254 | 0] ^ -1) & 1;
              jsvObjectSetChildAndUnLock(HEAP32[$0 + 280 >> 2], 131993, jsvNewFromBool(HEAP8[$0 + 255 | 0] & 1));
              break label$24;
             }
             HEAP8[$0 + 247 | 0] = jsvObjectGetBoolChild(HEAP32[$0 + 280 >> 2], 131993) & 1;
             HEAP32[$0 + 240 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 280 >> 2], 117223);
             label$26: {
              if (HEAP32[$0 + 240 >> 2]) {
               $2 = HEAP32[91118];
               $5 = $2;
               $1 = HEAP32[91119];
               $3 = $1;
               $1 = jsvGetLongIntegerAndUnLock(jsvObjectGetChildIfExists(HEAP32[$0 + 240 >> 2], 132372));
               $6 = $1;
               $2 = i64toi32_i32$HIGH_BITS;
               $1 = $2;
               $2 = $3;
               $3 = $2 + $1 | 0;
               $4 = $5 + $6 | 0;
               $3 = $4 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
               HEAP32[$0 + 232 >> 2] = $4;
               HEAP32[$0 + 236 >> 2] = $3;
               $3 = HEAP32[$0 + 248 >> 2];
               $5 = $3 >> 31;
               $7 = $3;
               $8 = $5;
               $5 = HEAP32[$0 + 256 >> 2];
               $2 = $5;
               $3 = HEAP32[$0 + 260 >> 2];
               $4 = $3;
               $5 = HEAP32[91119];
               $9 = $5;
               $3 = HEAP32[91118];
               $6 = $3;
               $1 = $2 - $3 | 0;
               $10 = $1;
               $5 = $4;
               $3 = $9;
               $4 = $3 + ($2 >>> 0 < $6 >>> 0) | 0;
               $4 = $5 - $4 | 0;
               $2 = $4;
               $4 = $8;
               $1 = $4 + $2 | 0;
               $5 = $7;
               $6 = $10;
               $3 = $5 + $6 | 0;
               $1 = $3 >>> 0 < $6 >>> 0 ? $1 + 1 | 0 : $1;
               jsvUnLock(jsvObjectSetChild(HEAP32[$0 + 240 >> 2], 132372, jsvNewFromLongInteger($3, $1)));
               jsvObjectSetChildAndUnLock(HEAP32[$0 + 240 >> 2], 131993, jsvNewFromBool(HEAP8[$0 + 255 | 0] & 1));
               label$28: {
                if (!(HEAP8[$0 + 254 | 0] & 1)) {
                 $5 = HEAP32[$0 + 260 >> 2];
                 $2 = $5;
                 $1 = HEAP32[$0 + 256 >> 2];
                 $4 = $1;
                 $5 = HEAP32[$0 + 232 >> 2];
                 $6 = $5;
                 $1 = HEAP32[$0 + 236 >> 2];
                 $5 = $1;
                 $1 = $2;
                 if ($4 >>> 0 <= $6 >>> 0 & ($5 | 0) >= ($1 | 0) | ($1 | 0) < ($5 | 0) | (HEAP8[$0 + 255 | 0] & 1) == (HEAP8[$0 + 247 | 0] & 1)) {
                  break label$28;
                 }
                }
                HEAP8[$0 + 253 | 0] = (HEAPU8[$0 + 254 | 0] ^ -1) & 1;
                $4 = HEAP32[$0 + 232 >> 2];
                $6 = $4;
                $1 = HEAP32[$0 + 236 >> 2];
                $3 = $1;
                $1 = HEAP32[$0 + 248 >> 2];
                $4 = $1 >> 31;
                $7 = $4;
                $5 = $1;
                $2 = $6 - $1 | 0;
                $4 = $3;
                $1 = $7;
                $3 = $1 + ($5 >>> 0 > $6 >>> 0) | 0;
                $3 = $4 - $3 | 0;
                HEAP32[$0 + 256 >> 2] = $2;
                HEAP32[$0 + 260 >> 2] = $3;
                jsvObjectSetChildAndUnLock(HEAP32[$0 + 280 >> 2], 131993, jsvNewFromBool(HEAP8[$0 + 255 | 0] & 1));
                jsiClearTimeout(HEAP32[$0 + 240 >> 2]);
                jsvObjectRemoveChild(HEAP32[$0 + 280 >> 2], 117223);
               }
               break label$26;
              }
              label$30: {
               if (!(HEAP8[$0 + 254 | 0] & 1 | (HEAP8[$0 + 255 | 0] & 1) == (HEAP8[$0 + 247 | 0] & 1))) {
                HEAP32[$0 + 240 >> 2] = jsvNewObject();
                if (HEAP32[$0 + 240 >> 2]) {
                 jsvObjectSetChild(HEAP32[$0 + 240 >> 2], 129672, HEAP32[$0 + 280 >> 2]);
                 $3 = HEAP32[$0 + 248 >> 2];
                 $6 = $3 >> 31;
                 $7 = $3;
                 $8 = $6;
                 $6 = HEAP32[$0 + 256 >> 2];
                 $4 = $6;
                 $3 = HEAP32[$0 + 260 >> 2];
                 $2 = $3;
                 $6 = HEAP32[91119];
                 $9 = $6;
                 $3 = HEAP32[91118];
                 $5 = $3;
                 $1 = $4 - $3 | 0;
                 $10 = $1;
                 $6 = $2;
                 $3 = $9;
                 $2 = $3 + ($5 >>> 0 > $4 >>> 0) | 0;
                 $2 = $6 - $2 | 0;
                 $4 = $2;
                 $2 = $8;
                 $1 = $4 + $2 | 0;
                 $5 = $10;
                 $6 = $7;
                 $3 = $5 + $6 | 0;
                 $1 = $5 >>> 0 > $3 >>> 0 ? $1 + 1 | 0 : $1;
                 jsvObjectSetChildAndUnLock(HEAP32[$0 + 240 >> 2], 132372, jsvNewFromLongInteger($3, $1));
                 jsvObjectSetChildAndUnLock(HEAP32[$0 + 240 >> 2], 135710, jsvObjectGetChildIfExists(HEAP32[$0 + 280 >> 2], 135710));
                 jsvObjectSetChildAndUnLock(HEAP32[$0 + 240 >> 2], 132377, jsvObjectGetChildIfExists(HEAP32[$0 + 280 >> 2], 132377));
                 jsvObjectSetChildAndUnLock(HEAP32[$0 + 240 >> 2], 128488, jsvNewFromPin(HEAPU8[$0 + 279 | 0]));
                 jsvObjectSetChildAndUnLock(HEAP32[$0 + 240 >> 2], 131993, jsvNewFromBool(HEAP8[$0 + 255 | 0] & 1));
                 jsiTimerAdd(HEAP32[$0 + 240 >> 2]);
                 jsvObjectSetChild(HEAP32[$0 + 280 >> 2], 117223, HEAP32[$0 + 240 >> 2]);
                }
                break label$30;
               }
               if (HEAP8[$0 + 254 | 0] & 1) {
                jsvObjectSetChildAndUnLock(HEAP32[$0 + 280 >> 2], 131993, jsvNewFromBool(HEAP8[$0 + 255 | 0] & 1));
               }
              }
             }
             jsvUnLock(HEAP32[$0 + 240 >> 2]);
            }
            if (HEAP8[$0 + 253 | 0] & 1) {
             $1 = HEAP32[$0 + 256 >> 2];
             $6 = HEAP32[$0 + 260 >> 2];
             HEAP32[$0 + 228 >> 2] = jsvNewFromFloat(jshGetMillisecondsFromTime($1, $6) / 1e3);
             if (jsiShouldExecuteWatch(HEAP32[$0 + 280 >> 2], HEAP8[$0 + 255 | 0] & 1) & 1) {
              HEAP32[$0 + 224 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 280 >> 2], 135710);
              HEAP8[$0 + 223 | 0] = jsvObjectGetBoolChild(HEAP32[$0 + 280 >> 2], 120696) & 1;
              HEAP32[$0 + 216 >> 2] = jsvNewObject();
              if (HEAP32[$0 + 216 >> 2]) {
               jsvObjectSetChildAndUnLock(HEAP32[$0 + 216 >> 2], 131993, jsvNewFromBool(HEAP8[$0 + 255 | 0] & 1));
               jsvObjectSetChildAndUnLock(HEAP32[$0 + 216 >> 2], 132377, jsvObjectGetChildIfExists(HEAP32[$0 + 280 >> 2], 132377));
               jsvObjectSetChild(HEAP32[$0 + 216 >> 2], 132372, HEAP32[$0 + 228 >> 2]);
               jsvObjectSetChildAndUnLock(HEAP32[$0 + 216 >> 2], 128488, jsvNewFromPin(HEAPU8[$0 + 279 | 0]));
               HEAP8[$0 + 215 | 0] = jshGetEventDataPin(HEAPU8[$0 + 307 | 0]);
               if (jshIsPinValid(HEAPU8[$0 + 215 | 0]) & 1) {
                jsvObjectSetChildAndUnLock(HEAP32[$0 + 216 >> 2], 135835, jsvNewFromBool((HEAPU8[$0 + 312 | 0] & 64) != 0));
               }
              }
              if (!(jsiExecuteEventCallback(0, HEAP32[$0 + 224 >> 2], 1, $0 + 216 | 0) & 1 | !(HEAP8[$0 + 223 | 0] & 1))) {
               jsError(140188, 0);
               HEAP8[364342] = HEAPU8[364342] | 4;
               HEAP8[$0 + 223 | 0] = 0;
              }
              jsvUnLock(HEAP32[$0 + 216 >> 2]);
              if (!(HEAP8[$0 + 223 | 0] & 1)) {
               jsvObjectIteratorRemoveAndGotoNext($0 + 288 | 0, HEAP32[$0 + 292 >> 2]);
               HEAP8[$0 + 287 | 0] = 1;
               if (!(jsiIsWatchingPin(HEAPU8[$0 + 279 | 0]) & 1)) {
                jshPinWatch(HEAPU8[$0 + 279 | 0], 0, 0);
               }
              }
              jsvUnLock(HEAP32[$0 + 224 >> 2]);
             }
             jsvObjectSetChildAndUnLock(HEAP32[$0 + 280 >> 2], 132377, HEAP32[$0 + 228 >> 2]);
            }
           }
           jsvUnLock(HEAP32[$0 + 280 >> 2]);
           if (!(HEAP8[$0 + 287 | 0] & 1)) {
            jsvObjectIteratorNext($0 + 288 | 0);
           }
           continue;
          }
          break;
         }
         jsvObjectIteratorFree_3($0 + 288 | 0);
         jsvUnLock(HEAP32[$0 + 292 >> 2]);
        }
       }
      }
     }
    }
   }
   continue;
  }
  break;
 }
 if ((jshGetEventsUsed() | 0) < 95) {
  jshSetFlowControlAllReady();
 }
 HEAP32[$0 + 200 >> 2] = -1;
 HEAP32[$0 + 204 >> 2] = 2147483647;
 $6 = jshGetSystemTime();
 HEAP32[$0 + 192 >> 2] = $6;
 $1 = i64toi32_i32$HIGH_BITS;
 HEAP32[$0 + 196 >> 2] = $1;
 $1 = HEAP32[$0 + 192 >> 2];
 $2 = $1;
 $6 = HEAP32[$0 + 196 >> 2];
 $3 = $6;
 $1 = HEAP32[91119];
 $7 = $1;
 $6 = HEAP32[91118];
 $5 = $6;
 $4 = $2 - $5 | 0;
 HEAP32[$0 + 184 >> 2] = $4;
 $1 = $3;
 $6 = $7;
 $3 = $6 + ($2 >>> 0 < $5 >>> 0) | 0;
 $3 = $1 - $3 | 0;
 HEAP32[$0 + 188 >> 2] = $3;
 $2 = HEAP32[$0 + 196 >> 2];
 $3 = HEAP32[$0 + 192 >> 2];
 HEAP32[91118] = $3;
 HEAP32[91119] = $2;
 HEAP32[$0 + 180 >> 2] = jsvLock(HEAPU16[182204]);
 jsvObjectIteratorNew($0 + 176 | 0, HEAP32[$0 + 180 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue_3($0 + 176 | 0) & 1) {
   HEAP32[$0 + 172 >> 2] = jsvObjectIteratorGetValue_3($0 + 176 | 0);
   $2 = jsvGetLongIntegerAndUnLock(jsvObjectGetChildIfExists(HEAP32[$0 + 172 >> 2], 132372));
   HEAP32[$0 + 160 >> 2] = $2;
   $3 = i64toi32_i32$HIGH_BITS;
   HEAP32[$0 + 164 >> 2] = $3;
   $3 = HEAP32[$0 + 160 >> 2];
   $1 = $3;
   $2 = HEAP32[$0 + 164 >> 2];
   $4 = $2;
   $3 = HEAP32[$0 + 188 >> 2];
   $7 = $3;
   $2 = HEAP32[$0 + 184 >> 2];
   $5 = $2;
   $6 = $1 - $2 | 0;
   HEAP32[$0 + 152 >> 2] = $6;
   $3 = $4;
   $2 = $7;
   $4 = $2 + ($1 >>> 0 < $5 >>> 0) | 0;
   $4 = $3 - $4 | 0;
   HEAP32[$0 + 156 >> 2] = $4;
   $4 = HEAP32[$0 + 152 >> 2];
   $1 = HEAP32[$0 + 156 >> 2];
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 172 >> 2], 132372, jsvNewFromLongInteger($4, $1));
   jsvUnLock(HEAP32[$0 + 172 >> 2]);
   jsvObjectIteratorNext($0 + 176 | 0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree_3($0 + 176 | 0);
 while (1) {
  HEAP16[182206] = HEAPU16[182206] & -5;
  jsvObjectIteratorNew($0 + 176 | 0, HEAP32[$0 + 180 >> 2]);
  while (1) {
   $5 = 0;
   if (jsvObjectIteratorHasValue_3($0 + 176 | 0) & 1) {
    $5 = (HEAPU16[182206] & 4) != 0 ^ -1;
   }
   if ($5 & 1) {
    HEAP8[$0 + 151 | 0] = 0;
    HEAP32[$0 + 144 >> 2] = jsvObjectIteratorGetValue_3($0 + 176 | 0);
    $1 = jsvGetLongIntegerAndUnLock(jsvObjectGetChildIfExists(HEAP32[$0 + 144 >> 2], 132372));
    HEAP32[$0 + 136 >> 2] = $1;
    $4 = i64toi32_i32$HIGH_BITS;
    HEAP32[$0 + 140 >> 2] = $4;
    $4 = HEAP32[$0 + 136 >> 2];
    $3 = $4;
    $1 = HEAP32[$0 + 140 >> 2];
    if (!$3 & ($1 | 0) <= 0 | ($1 | 0) < 0) {
     jsiSetBusy(1, 1);
     HEAP8[$0 + 319 | 0] = 1;
     HEAP32[$0 + 132 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 144 >> 2], 135710);
     HEAP32[$0 + 128 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 144 >> 2], 129672);
     HEAP8[$0 + 127 | 0] = 1;
     HEAP32[$0 + 120 >> 2] = 0;
     if (HEAP32[$0 + 128 >> 2]) {
      HEAP8[$0 + 119 | 0] = jsvObjectGetBoolChild(HEAP32[$0 + 128 >> 2], 131993) & 1;
      HEAP8[$0 + 118 | 0] = jsvObjectGetBoolChild(HEAP32[$0 + 144 >> 2], 131993) & 1;
      jsvObjectSetChildAndUnLock(HEAP32[$0 + 128 >> 2], 131993, jsvNewFromBool(HEAP8[$0 + 118 | 0] & 1));
      HEAP8[$0 + 127 | 0] = 0;
      if ((HEAP8[$0 + 119 | 0] & 1) != (HEAP8[$0 + 118 | 0] & 1)) {
       HEAP32[$0 + 112 >> 2] = jsvObjectGetIntegerChild(HEAP32[$0 + 128 >> 2], 132809);
       $3 = HEAP32[91118];
       $5 = $3;
       $1 = HEAP32[91119];
       $6 = $1;
       $3 = HEAP32[$0 + 140 >> 2];
       $7 = $3;
       $1 = HEAP32[$0 + 136 >> 2];
       $4 = $1;
       $2 = $1 + $5 | 0;
       $3 = $6;
       $1 = $7;
       $6 = $3 + $1 | 0;
       $6 = $2 >>> 0 < $4 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = $6;
       $6 = HEAP32[$0 + 112 >> 2];
       $5 = $6 >> 31;
       $7 = $5;
       $4 = $6;
       $1 = $2 - $4 | 0;
       $5 = $3;
       $6 = $7;
       $2 = $6 + ($4 >>> 0 > $2 >>> 0) | 0;
       $2 = $5 - $2 | 0;
       HEAP32[$0 + 108 >> 2] = jsvNewFromFloat(jshGetMillisecondsFromTime($1, $2) / 1e3);
       if (jsiShouldExecuteWatch(HEAP32[$0 + 128 >> 2], HEAP8[$0 + 118 | 0] & 1) & 1) {
        HEAP32[$0 + 120 >> 2] = jsvNewObject();
        if (HEAP32[$0 + 120 >> 2]) {
         HEAP8[$0 + 127 | 0] = 1;
         jsvObjectSetChildAndUnLock(HEAP32[$0 + 120 >> 2], 131993, jsvNewFromBool(HEAP8[$0 + 118 | 0] & 1));
         jsvObjectSetChildAndUnLock(HEAP32[$0 + 120 >> 2], 132377, jsvObjectGetChildIfExists(HEAP32[$0 + 128 >> 2], 132377));
         jsvObjectSetChild(HEAP32[$0 + 120 >> 2], 132372, HEAP32[$0 + 108 >> 2]);
         jsvObjectSetChildAndUnLock(HEAP32[$0 + 120 >> 2], 128488, jsvObjectGetChildIfExists(HEAP32[$0 + 128 >> 2], 128488));
        }
       }
       jsvObjectSetChildAndUnLock(HEAP32[$0 + 128 >> 2], 132377, HEAP32[$0 + 108 >> 2]);
      }
     }
     HEAP8[$0 + 107 | 0] = 0;
     if (HEAP8[$0 + 127 | 0] & 1) {
      label$55: {
       if (HEAP32[$0 + 120 >> 2]) {
        HEAP8[$0 + 106 | 0] = jsiExecuteEventCallback(0, HEAP32[$0 + 132 >> 2], 1, $0 + 120 | 0) & 1;
        break label$55;
       }
       HEAP32[$0 + 100 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 144 >> 2], 120162);
       HEAP8[$0 + 106 | 0] = jsiExecuteEventCallbackArgsArray(0, HEAP32[$0 + 132 >> 2], HEAP32[$0 + 100 >> 2]) & 1;
       jsvUnLock(HEAP32[$0 + 100 >> 2]);
      }
      if (!(HEAP8[$0 + 106 | 0] & 1)) {
       HEAP32[$0 + 96 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 144 >> 2], 120745);
       if (HEAP32[$0 + 96 >> 2]) {
        jsvUnLock(HEAP32[$0 + 96 >> 2]);
        jsError(140140, 0);
        HEAP8[364342] = HEAPU8[364342] | 4;
        HEAP8[$0 + 107 | 0] = 1;
       }
      }
     }
     jsvUnLock(HEAP32[$0 + 120 >> 2]);
     if (HEAP32[$0 + 128 >> 2]) {
      jsvObjectRemoveChild(HEAP32[$0 + 128 >> 2], 117223);
      if (HEAP8[$0 + 127 | 0] & 1) {
       HEAP8[$0 + 95 | 0] = jsvObjectGetBoolChild(HEAP32[$0 + 128 >> 2], 120696) & 1;
       if (!(HEAP8[$0 + 95 | 0] & 1)) {
        HEAP32[$0 + 88 >> 2] = jsvLock(HEAPU16[182205]);
        HEAP32[$0 + 84 >> 2] = jsvGetIndexOf(HEAP32[$0 + 88 >> 2], HEAP32[$0 + 128 >> 2], 1);
        if (HEAP32[$0 + 84 >> 2]) {
         jsvRemoveChildAndUnLock(HEAP32[$0 + 88 >> 2], HEAP32[$0 + 84 >> 2]);
        }
        jsvUnLock(HEAP32[$0 + 88 >> 2]);
        HEAP8[$0 + 83 | 0] = jshGetPinFromVarAndUnLock(jsvObjectGetChildIfExists(HEAP32[$0 + 128 >> 2], 128488));
        if (!(jsiIsWatchingPin(HEAPU8[$0 + 83 | 0]) & 1)) {
         jshPinWatch(HEAPU8[$0 + 83 | 0], 0, 0);
        }
       }
      }
      jsvUnLock(HEAP32[$0 + 128 >> 2]);
     }
     HEAP32[$0 + 76 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 144 >> 2], 120745);
     label$64: {
      if (!(!HEAP32[$0 + 76 >> 2] | HEAP8[$0 + 107 | 0] & 1)) {
       $2 = HEAP32[$0 + 136 >> 2];
       $5 = $2;
       $3 = HEAP32[$0 + 140 >> 2];
       $1 = $3;
       $3 = jsvGetLongInteger(HEAP32[$0 + 76 >> 2]);
       $4 = $3;
       $2 = i64toi32_i32$HIGH_BITS;
       $3 = $2;
       $2 = $1;
       $1 = $2 + $3 | 0;
       $6 = $4 + $5 | 0;
       HEAP32[$0 + 136 >> 2] = $6;
       $1 = $4 >>> 0 > $6 >>> 0 ? $1 + 1 | 0 : $1;
       HEAP32[$0 + 140 >> 2] = $1;
       $1 = HEAP32[$0 + 136 >> 2];
       $5 = HEAP32[$0 + 140 >> 2];
       jsvObjectSetChildAndUnLock(HEAP32[$0 + 144 >> 2], 132372, jsvNewFromLongInteger($1, $5));
       break label$64;
      }
      jsvObjectIteratorRemoveAndGotoNext($0 + 176 | 0, HEAP32[$0 + 180 >> 2]);
      HEAP8[$0 + 151 | 0] = 1;
      HEAP32[$0 + 136 >> 2] = -1;
      HEAP32[$0 + 140 >> 2] = -1;
     }
     jsvUnLock2(HEAP32[$0 + 132 >> 2], HEAP32[$0 + 76 >> 2]);
    }
    $5 = HEAP32[$0 + 136 >> 2];
    $1 = HEAP32[$0 + 140 >> 2];
    label$66: {
     if (($1 | 0) < 0) {
      break label$66;
     }
     $2 = HEAP32[$0 + 136 >> 2];
     $4 = $2;
     $1 = HEAP32[$0 + 140 >> 2];
     $3 = $1;
     $2 = HEAP32[$0 + 204 >> 2];
     $6 = $2;
     $1 = HEAP32[$0 + 200 >> 2];
     $5 = $1;
     $2 = $3;
     $1 = $6;
     if ($5 >>> 0 <= $4 >>> 0 & ($2 | 0) >= ($1 | 0) | ($1 | 0) < ($2 | 0)) {
      break label$66;
     }
     $2 = HEAP32[$0 + 140 >> 2];
     $4 = HEAP32[$0 + 136 >> 2];
     HEAP32[$0 + 200 >> 2] = $4;
     HEAP32[$0 + 204 >> 2] = $2;
    }
    if (!(HEAP8[$0 + 151 | 0] & 1)) {
     jsvObjectIteratorNext($0 + 176 | 0);
    }
    jsvUnLock(HEAP32[$0 + 144 >> 2]);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_3($0 + 176 | 0);
  if (HEAPU16[182206] & 4) {
   continue;
  }
  break;
 }
 jsvUnLock(HEAP32[$0 + 180 >> 2]);
 if (jswIdle() & 1) {
  HEAP8[$0 + 319 | 0] = 1;
 }
 label$69: {
  if (!(HEAP8[$0 + 319 | 0] & 1)) {
   if (jsvArrayIsEmpty(HEAP32[91101]) & 1) {
    break label$69;
   }
  }
  HEAP8[364430] = 0;
 }
 if (HEAP8[$0 + 319 | 0] & 1) {
  jsiSetBusy(1, 0);
 }
 if (!(jspIsInterrupted() & 1)) {
  jsiExecuteEvents();
 }
 if (HEAPU16[182206] & 224) {
  jsiSetBusy(1, 1);
  HEAP16[$0 + 74 >> 1] = HEAPU16[182206];
  if ((HEAPU16[$0 + 74 >> 1] & 128) == 128) {
   jsiKill();
   jsvReset();
   jshReset();
   jsiSemiInit(0, 0);
   HEAP16[182206] = HEAPU16[182206] & 65407;
  }
  if ((HEAPU16[$0 + 74 >> 1] & 32) == 32) {
   jsvGarbageCollect();
   jsiSoftKill();
   jspSoftKill();
   jsvSoftKill();
   jsfSaveToFlash();
   jshReset();
   jsvSoftInit();
   jspSoftInit();
   jsiSoftInit(0);
   HEAP16[182206] = HEAPU16[182206] & 65503;
  }
  if ((HEAPU16[$0 + 74 >> 1] & 64) == 64) {
   HEAP32[$0 + 68 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 134302);
   label$77: {
    if (HEAP32[$0 + 68 >> 2]) {
     jsfNameFromVarAndUnLock($0 + 40 | 0, HEAP32[$0 + 68 >> 2]);
     jsiKill();
     jsvReset();
     jshReset();
     jsiSemiInit(0, $0 + 40 | 0);
     HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 64 >> 2];
     $4 = HEAP32[$0 + 60 >> 2];
     $2 = HEAP32[$0 + 56 >> 2];
     HEAP32[$0 + 24 >> 2] = $2;
     HEAP32[$0 + 28 >> 2] = $4;
     $2 = HEAP32[$0 + 52 >> 2];
     $4 = HEAP32[$0 + 48 >> 2];
     HEAP32[$0 + 16 >> 2] = $4;
     HEAP32[$0 + 20 >> 2] = $2;
     $4 = HEAP32[$0 + 44 >> 2];
     $2 = HEAP32[$0 + 40 >> 2];
     HEAP32[$0 + 8 >> 2] = $2;
     HEAP32[$0 + 12 >> 2] = $4;
     HEAP32[$0 + 36 >> 2] = jsfReadFile($0 + 8 | 0, 0, 0);
     if (HEAP32[$0 + 36 >> 2]) {
      jsvUnLock2(jspEvaluateVar(HEAP32[$0 + 36 >> 2], 0, 0), HEAP32[$0 + 36 >> 2]);
     }
     break label$77;
    }
    jsiSoftKill();
    jspSoftKill();
    jsvSoftKill();
    jsvReset();
    jshReset();
    jsfLoadStateFromFlash();
    jsvSoftInit();
    jspSoftInit();
    jsiSoftInit(0);
   }
   HEAP16[182206] = HEAPU16[182206] & 65471;
  }
  jsiSetBusy(1, 0);
 }
 if (HEAPU16[182206] & 512) {
  jshKickWatchDog();
 }
 label$81: {
  label$82: {
   if (HEAPU8[364430] != 1) {
    break label$82;
   }
   $4 = HEAP32[$0 + 200 >> 2];
   $5 = $4;
   $2 = HEAP32[$0 + 204 >> 2];
   $1 = $2;
   $2 = jshGetTimeFromMilliseconds(10);
   $3 = $2;
   $4 = i64toi32_i32$HIGH_BITS;
   $2 = $4;
   $4 = $1;
   $1 = $3;
   if (($4 | 0) <= ($2 | 0) & $5 >>> 0 <= $1 >>> 0 | ($2 | 0) > ($4 | 0)) {
    break label$82;
   }
   if (jsvMoreFreeVariablesThan(600) & 1) {
    break label$82;
   }
   jsiSetBusy(1, 1);
   jsvGarbageCollect();
   jsiSetBusy(1, 0);
   break label$81;
  }
  if (!HEAPU8[364430]) {
   break label$81;
  }
  if (jshHasEvents() & 1) {
   break label$81;
  }
  $5 = HEAP32[$0 + 200 >> 2];
  $4 = HEAP32[$0 + 204 >> 2];
  jshSleep($5, $4);
 }
 __stack_pointer = $0 + 320 | 0;
}

function jslGetNextToken() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = HEAP16[HEAP32[49079] + 2 >> 1];
 HEAP16[HEAP32[49079] + 2 >> 1] = 0;
 HEAP8[HEAP32[49079] + 80 | 0] = 0;
 if (HEAP32[HEAP32[49079] + 76 >> 2]) {
  jsvUnLock(HEAP32[HEAP32[49079] + 76 >> 2]);
  HEAP32[HEAP32[49079] + 76 >> 2] = 0;
 }
 HEAP32[HEAP32[49079] + 8 >> 2] = HEAP32[HEAP32[49079] + 4 >> 2];
 HEAP8[$0 + 11 | 0] = HEAPU8[HEAP32[49079]];
 if (HEAPU8[$0 + 11 | 0] > 124) {
  HEAP8[$0 + 11 | 0] = 0;
 }
 label$3: {
  label$4: {
   label$5: {
    label$6: {
     label$7: {
      label$8: {
       label$9: {
        label$10: {
         label$11: {
          label$12: {
           label$13: {
            label$14: {
             label$15: {
              label$16: {
               label$17: {
                label$18: {
                 label$19: {
                  while (1) {
                   label$21: {
                    $1 = jsvStringIteratorGetIndex(HEAP32[49079] + 88 | 0);
                    HEAP32[HEAP32[49079] + 4 >> 2] = $1 - 1;
                    label$22: {
                     switch (HEAPU8[HEAPU8[$0 + 11 | 0] + 113584 | 0]) {
                     case 12:
                      break label$10;

                     case 13:
                      break label$11;

                     case 10:
                      break label$12;

                     case 9:
                      break label$13;

                     case 8:
                      break label$14;

                     case 7:
                      break label$15;

                     case 6:
                      break label$16;

                     case 4:
                      break label$17;

                     case 3:
                      break label$18;

                     case 2:
                      break label$19;

                     case 0:
                      break label$21;

                     case 1:
                      break label$22;

                     case 17:
                      break label$4;

                     case 15:
                      break label$5;

                     case 16:
                      break label$6;

                     case 11:
                      break label$7;

                     case 14:
                      break label$8;

                     case 5:
                      break label$9;

                     default:
                      break label$3;
                     }
                    }
                    jslSkipWhiteSpace();
                    HEAP8[$0 + 11 | 0] = HEAPU8[HEAP32[49079]];
                    if (HEAPU8[$0 + 11 | 0] > 124) {
                     HEAP8[$0 + 11 | 0] = 0;
                    }
                    if (HEAPU8[$0 + 11 | 0] == 47) {
                     HEAP8[$0 + 11 | 0] = 125;
                    }
                    continue;
                   }
                   break;
                  }
                  jslSingleChar();
                  label$25: {
                   if (HEAP16[HEAP32[49079] + 2 >> 1] == 175) {
                    HEAP8[HEAP32[49079] + 81 | 0] = 1;
                    break label$25;
                   }
                   if (!(HEAP16[HEAP32[49079] + 2 >> 1] != 209 & HEAP16[HEAP32[49079] + 2 >> 1] != 210)) {
                    jslGetRawString();
                   }
                  }
                  break label$3;
                 }
                 while (1) {
                  $1 = 1;
                  label$30: {
                   if (isAlphaInline(HEAP8[HEAP32[49079]]) & 1) {
                    break label$30;
                   }
                   $1 = 1;
                   if (isNumericInline(HEAP8[HEAP32[49079]]) & 1) {
                    break label$30;
                   }
                   $1 = HEAP8[HEAP32[49079]] == 36;
                  }
                  if ($1) {
                   jslTokenAppendChar(HEAP8[HEAP32[49079]]);
                   jslGetNextCh();
                   continue;
                  }
                  break;
                 }
                 HEAP16[HEAP32[49079] + 2 >> 1] = 128;
                 if (!HEAPU8[HEAP32[49079] + 13 | 0]) {
                  break label$3;
                 }
                 label$32: {
                  label$33: {
                   switch (HEAP8[HEAP32[49079] + 12 | 0] - 98 | 0) {
                   case 0:
                    jslCheckToken(129136, 168);
                    break label$32;

                   case 1:
                    if (!(jslCheckToken(132099, 188) & 1)) {
                     if (!(jslCheckToken(129673, 178) & 1)) {
                      if (!(jslCheckToken(119910, 194) & 1)) {
                       if (!(jslCheckToken(117313, 174) & 1)) {
                        jslCheckToken(131766, 169);
                       }
                      }
                     }
                    }
                    break label$32;

                   case 2:
                    if (!(jslCheckToken(117668, 189) & 1)) {
                     if (!(jslCheckToken(131987, 190) & 1)) {
                      if (!(jslCheckToken(128056, 165) & 1)) {
                       jslCheckToken(121118, 193);
                      }
                     }
                    }
                    break label$32;

                   case 3:
                    if (!(jslCheckToken(132087, 164) & 1)) {
                     jslCheckToken(120470, 195);
                    }
                    break label$32;

                   case 4:
                    if (!(jslCheckToken(132086, 181) & 1)) {
                     if (!(jslCheckToken(116217, 179) & 1)) {
                      if (!(jslCheckToken(120976, 167) & 1)) {
                       jslCheckToken(128355, 170);
                      }
                     }
                    }
                    break label$32;

                   case 7:
                    if (!(jslCheckToken(130213, 163) & 1)) {
                     if (!(jslCheckToken(128568, 185) & 1)) {
                      jslCheckToken(130100, 186);
                     }
                    }
                    break label$32;

                   case 10:
                    jslCheckToken(117893, 173);
                    break label$32;

                   case 12:
                    if (!(jslCheckToken(116774, 184) & 1)) {
                     jslCheckToken(128730, 182);
                    }
                    break label$32;

                   case 13:
                    jslCheckToken(130213, 198);
                    break label$32;

                   case 16:
                    jslCheckToken(128081, 171);
                    break label$32;

                   case 17:
                    if (!(jslCheckToken(135676, 197) & 1)) {
                     if (!(jslCheckToken(121032, 196) & 1)) {
                      jslCheckToken(129537, 187);
                     }
                    }
                    break label$32;

                   case 18:
                    label$64: {
                     if (jslCheckToken(120153, 175) & 1) {
                      HEAP8[HEAP32[49079] + 81 | 0] = 1;
                      break label$64;
                     }
                     if (!(jslCheckToken(116524, 176) & 1)) {
                      if (!(jslCheckToken(131762, 180) & 1)) {
                       if (!(jslCheckToken(116151, 177) & 1)) {
                        jslCheckToken(130094, 191);
                       }
                      }
                     }
                    }
                    break label$32;

                   case 19:
                    jslCheckToken(133949, 183);
                    break label$32;

                   case 21:
                    jslCheckToken(132410, 166);
                    break label$32;

                   case 20:
                    break label$33;

                   default:
                    break label$32;
                   }
                  }
                  if (!(jslCheckToken(121465, 172) & 1)) {
                   jslCheckToken(133320, 192);
                  }
                 }
                 break label$3;
                }
                HEAP8[$0 + 10 | 0] = 1;
                label$70: {
                 if (HEAP8[HEAP32[49079]] == 46) {
                  jslGetNextCh();
                  label$72: {
                   if (isNumericInline(HEAP8[HEAP32[49079]]) & 1) {
                    HEAP16[HEAP32[49079] + 2 >> 1] = 130;
                    jslTokenAppendChar(46);
                    break label$72;
                   }
                   HEAP16[HEAP32[49079] + 2 >> 1] = 46;
                   break label$3;
                  }
                  break label$70;
                 }
                 if (HEAP8[HEAP32[49079]] == 48) {
                  jslTokenAppendChar(HEAP8[HEAP32[49079]]);
                  jslGetNextCh();
                  label$75: {
                   label$76: {
                    if (HEAP8[HEAP32[49079]] == 120 | HEAP8[HEAP32[49079]] == 88 | (HEAP8[HEAP32[49079]] == 98 | HEAP8[HEAP32[49079]] == 66)) {
                     break label$76;
                    }
                    if (HEAP8[HEAP32[49079]] == 111) {
                     break label$76;
                    }
                    if (HEAP8[HEAP32[49079]] != 79) {
                     break label$75;
                    }
                   }
                   HEAP8[$0 + 10 | 0] = 0;
                   jslTokenAppendChar(HEAP8[HEAP32[49079]]);
                   jslGetNextCh();
                  }
                 }
                 HEAP16[HEAP32[49079] + 2 >> 1] = 129;
                 while (1) {
                  $1 = 1;
                  label$78: {
                   if (isNumericInline(HEAP8[HEAP32[49079]]) & 1) {
                    break label$78;
                   }
                   if (!(HEAP8[$0 + 10 | 0] & 1)) {
                    $1 = 1;
                    if (isHexadecimal(HEAP8[HEAP32[49079]]) & 1) {
                     break label$78;
                    }
                   }
                   $1 = HEAP8[HEAP32[49079]] == 95;
                  }
                  if ($1) {
                   if (HEAP8[HEAP32[49079]] != 95) {
                    jslTokenAppendChar(HEAP8[HEAP32[49079]]);
                   }
                   jslGetNextCh();
                   continue;
                  }
                  break;
                 }
                 if (!(!(HEAP8[$0 + 10 | 0] & 1) | HEAP8[HEAP32[49079]] != 46)) {
                  HEAP16[HEAP32[49079] + 2 >> 1] = 130;
                  jslTokenAppendChar(46);
                  jslGetNextCh();
                 }
                }
                if (HEAP16[HEAP32[49079] + 2 >> 1] == 130) {
                 while (1) {
                  $1 = 1;
                  if (!(isNumeric(HEAP8[HEAP32[49079]]) & 1)) {
                   $1 = HEAP8[HEAP32[49079]] == 95;
                  }
                  if ($1) {
                   if (HEAP8[HEAP32[49079]] != 95) {
                    jslTokenAppendChar(HEAP8[HEAP32[49079]]);
                   }
                   jslGetNextCh();
                   continue;
                  }
                  break;
                 }
                }
                if (!(!(HEAP8[$0 + 10 | 0] & 1) | HEAP8[HEAP32[49079]] != 101 & HEAP8[HEAP32[49079]] != 69)) {
                 HEAP16[HEAP32[49079] + 2 >> 1] = 130;
                 jslTokenAppendChar(HEAP8[HEAP32[49079]]);
                 jslGetNextCh();
                 if (!(HEAP8[HEAP32[49079]] != 45 & HEAP8[HEAP32[49079]] != 43)) {
                  jslTokenAppendChar(HEAP8[HEAP32[49079]]);
                  jslGetNextCh();
                 }
                 while (1) {
                  $1 = 1;
                  if (!(isNumeric(HEAP8[HEAP32[49079]]) & 1)) {
                   $1 = HEAP8[HEAP32[49079]] == 95;
                  }
                  if ($1) {
                   if (HEAP8[HEAP32[49079]] != 95) {
                    jslTokenAppendChar(HEAP8[HEAP32[49079]]);
                   }
                   jslGetNextCh();
                   continue;
                  }
                  break;
                 }
                }
                break label$3;
               }
               jslLexString();
               break label$3;
              }
              jslSingleChar();
              if (HEAP8[HEAP32[49079]] == 61) {
               HEAP16[HEAP32[49079] + 2 >> 1] = 140;
               jslGetNextCh();
               if (HEAP8[HEAP32[49079]] == 61) {
                HEAP16[HEAP32[49079] + 2 >> 1] = 141;
                jslGetNextCh();
               }
              }
              break label$3;
             }
             jslSingleChar();
             label$98: {
              if (HEAP8[HEAP32[49079]] == 61) {
               HEAP16[HEAP32[49079] + 2 >> 1] = 150;
               jslGetNextCh();
               break label$98;
              }
              if (HEAP8[HEAP32[49079]] == 43) {
               HEAP16[HEAP32[49079] + 2 >> 1] = 152;
               jslGetNextCh();
              }
             }
             break label$3;
            }
            jslSingleChar();
            label$101: {
             if (HEAP8[HEAP32[49079]] == 61) {
              HEAP16[HEAP32[49079] + 2 >> 1] = 151;
              jslGetNextCh();
              break label$101;
             }
             if (HEAP8[HEAP32[49079]] == 45) {
              HEAP16[HEAP32[49079] + 2 >> 1] = 153;
              jslGetNextCh();
             }
            }
            break label$3;
           }
           jslSingleChar();
           label$104: {
            if (HEAP8[HEAP32[49079]] == 61) {
             HEAP16[HEAP32[49079] + 2 >> 1] = 157;
             jslGetNextCh();
             break label$104;
            }
            if (HEAP8[HEAP32[49079]] == 38) {
             HEAP16[HEAP32[49079] + 2 >> 1] = 158;
             jslGetNextCh();
            }
           }
           break label$3;
          }
          jslSingleChar();
          label$107: {
           if (HEAP8[HEAP32[49079]] == 61) {
            HEAP16[HEAP32[49079] + 2 >> 1] = 159;
            jslGetNextCh();
            break label$107;
           }
           if (HEAP8[HEAP32[49079]] == 124) {
            HEAP16[HEAP32[49079] + 2 >> 1] = 160;
            jslGetNextCh();
           }
          }
          break label$3;
         }
         jslSingleChar();
         if (HEAP8[HEAP32[49079]] == 61) {
          HEAP16[HEAP32[49079] + 2 >> 1] = 161;
          jslGetNextCh();
         }
         break label$3;
        }
        jslSingleChar();
        if (HEAP8[HEAP32[49079]] == 61) {
         HEAP16[HEAP32[49079] + 2 >> 1] = 154;
         jslGetNextCh();
        }
        break label$3;
       }
       jslSingleChar();
       if (HEAP8[HEAP32[49079]] == 63) {
        HEAP16[HEAP32[49079] + 2 >> 1] = 208;
        jslGetNextCh();
       }
       break label$3;
      }
      label$113: {
       label$114: {
        label$115: {
         if (!HEAP32[$0 + 12 >> 2]) {
          break label$115;
         }
         label$116: {
          if (HEAP32[$0 + 12 >> 2] < 138 | HEAP32[$0 + 12 >> 2] > 208 | (HEAP32[$0 + 12 >> 2] == 180 | HEAP32[$0 + 12 >> 2] == 181)) {
           break label$116;
          }
          if (HEAP32[$0 + 12 >> 2] == 182) {
           break label$116;
          }
          if (HEAP32[$0 + 12 >> 2] != 183) {
           break label$115;
          }
         }
         if (HEAP32[$0 + 12 >> 2] == 33 | HEAP32[$0 + 12 >> 2] == 37 | (HEAP32[$0 + 12 >> 2] == 38 | HEAP32[$0 + 12 >> 2] == 42)) {
          break label$115;
         }
         if (HEAP32[$0 + 12 >> 2] == 43 | HEAP32[$0 + 12 >> 2] == 45 | (HEAP32[$0 + 12 >> 2] == 47 | HEAP32[$0 + 12 >> 2] == 60)) {
          break label$115;
         }
         if (HEAP32[$0 + 12 >> 2] == 61 | HEAP32[$0 + 12 >> 2] == 62 | (HEAP32[$0 + 12 >> 2] == 63 | HEAP32[$0 + 12 >> 2] == 91)) {
          break label$115;
         }
         if (HEAP32[$0 + 12 >> 2] == 123 | HEAP32[$0 + 12 >> 2] == 125 | (HEAP32[$0 + 12 >> 2] == 40 | HEAP32[$0 + 12 >> 2] == 44)) {
          break label$115;
         }
         if (HEAP32[$0 + 12 >> 2] == 59) {
          break label$115;
         }
         if (HEAP32[$0 + 12 >> 2] != 58) {
          break label$114;
         }
        }
        jslLexRegex();
        break label$113;
       }
       jslSingleChar();
       if (HEAP8[HEAP32[49079]] == 61) {
        HEAP16[HEAP32[49079] + 2 >> 1] = 155;
        jslGetNextCh();
       }
      }
      break label$3;
     }
     jslSingleChar();
     if (HEAP8[HEAP32[49079]] == 61) {
      HEAP16[HEAP32[49079] + 2 >> 1] = 156;
      jslGetNextCh();
     }
     break label$3;
    }
    jslSingleChar();
    label$119: {
     if (HEAP8[HEAP32[49079]] == 61) {
      HEAP16[HEAP32[49079] + 2 >> 1] = 138;
      jslGetNextCh();
      if (HEAP8[HEAP32[49079]] == 61) {
       HEAP16[HEAP32[49079] + 2 >> 1] = 139;
       jslGetNextCh();
      }
      break label$119;
     }
     if (HEAP8[HEAP32[49079]] == 62) {
      HEAP16[HEAP32[49079] + 2 >> 1] = 162;
      jslGetNextCh();
     }
    }
    break label$3;
   }
   jslSingleChar();
   label$123: {
    if (HEAP8[HEAP32[49079]] == 61) {
     HEAP16[HEAP32[49079] + 2 >> 1] = 142;
     jslGetNextCh();
     break label$123;
    }
    if (HEAP8[HEAP32[49079]] == 60) {
     HEAP16[HEAP32[49079] + 2 >> 1] = 143;
     jslGetNextCh();
     if (HEAP8[HEAP32[49079]] == 61) {
      HEAP16[HEAP32[49079] + 2 >> 1] = 144;
      jslGetNextCh();
     }
    }
   }
   break label$3;
  }
  jslSingleChar();
  label$127: {
   if (HEAP8[HEAP32[49079]] == 61) {
    HEAP16[HEAP32[49079] + 2 >> 1] = 145;
    jslGetNextCh();
    break label$127;
   }
   if (HEAP8[HEAP32[49079]] == 62) {
    HEAP16[HEAP32[49079] + 2 >> 1] = 146;
    jslGetNextCh();
    label$130: {
     if (HEAP8[HEAP32[49079]] == 61) {
      HEAP16[HEAP32[49079] + 2 >> 1] = 148;
      jslGetNextCh();
      break label$130;
     }
     if (HEAP8[HEAP32[49079]] == 62) {
      jslGetNextCh();
      label$133: {
       if (HEAP8[HEAP32[49079]] == 61) {
        HEAP16[HEAP32[49079] + 2 >> 1] = 149;
        jslGetNextCh();
        break label$133;
       }
       HEAP16[HEAP32[49079] + 2 >> 1] = 147;
      }
     }
    }
   }
  }
 }
 __stack_pointer = $0 + 16 | 0;
}

function jsfGetJSONWithCallback($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0;
 $6 = __stack_pointer - 352 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 348 >> 2] = $0;
 HEAP32[$6 + 344 >> 2] = $1;
 HEAP32[$6 + 340 >> 2] = $2;
 HEAP32[$6 + 336 >> 2] = $3;
 HEAP32[$6 + 332 >> 2] = $4;
 HEAP32[$6 + 328 >> 2] = $5;
 HEAP32[$6 + 324 >> 2] = HEAP32[$6 + 340 >> 2] + 16384;
 if (!HEAP32[$6 + 336 >> 2]) {
  HEAP32[$6 + 336 >> 2] = 146388;
 }
 label$2: {
  if (jsvIsUndefined(HEAP32[$6 + 348 >> 2]) & 1) {
   cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 64 ? 128729 : 133948, 0);
   break label$2;
  }
  label$4: {
   $0 = HEAP32[$6 + 348 >> 2];
   label$5: {
    if ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 512) {
     break label$5;
    }
    if (jsuGetFreeStack() >>> 0 < 512) {
     break label$5;
    }
    if (!(jspIsInterrupted() & 1)) {
     break label$4;
    }
   }
   cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], 146361, 0);
   break label$2;
  }
  $0 = HEAP32[$6 + 348 >> 2];
  $1 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8 | 512;
  HEAP8[$0 + 12 | 0] = $1;
  HEAP8[$0 + 13 | 0] = $1 >>> 8;
  label$6: {
   if (jsvIsArray(HEAP32[$6 + 348 >> 2]) & 1) {
    HEAP32[$6 + 320 >> 2] = jsvGetArrayLength(HEAP32[$6 + 348 >> 2]);
    $7 = HEAP32[$6 + 340 >> 2] & 8 ? HEAP32[$6 + 320 >> 2] > 15 : $7;
    HEAP8[$6 + 319 | 0] = $7;
    HEAP8[$6 + 318 | 0] = 0;
    cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 4 ? 146216 : 136267, 0);
    HEAP32[$6 + 312 >> 2] = -1;
    HEAP8[$6 + 311 | 0] = 1;
    HEAP8[$6 + 310 | 0] = 1;
    jsvObjectIteratorNew($6 + 304 | 0, HEAP32[$6 + 348 >> 2]);
    while (1) {
     $0 = 0;
     label$10: {
      if (HEAP32[$6 + 320 >> 2] <= (HEAP32[$6 + 312 >> 2] + 1 | 0)) {
       break label$10;
      }
      $0 = 0;
      if (!(HEAP8[$6 + 311 | 0] & 1)) {
       break label$10;
      }
      $0 = jspIsInterrupted() ^ -1;
     }
     if ($0 & 1) {
      HEAP32[$6 + 300 >> 2] = jsvObjectIteratorGetKey_5($6 + 304 | 0);
      label$12: {
       label$13: {
        if (jsvObjectIteratorHasValue_8($6 + 304 | 0) & 1) {
         if (!(jsvIsNumeric(HEAP32[$6 + 300 >> 2]) & 1)) {
          break label$13;
         }
        }
        label$15: {
         if (jsvObjectIteratorHasValue_8($6 + 304 | 0) & 1) {
          $0 = jsvGetInteger(HEAP32[$6 + 300 >> 2]);
          break label$15;
         }
         $0 = HEAP32[$6 + 320 >> 2] - 1 | 0;
        }
        HEAP32[$6 + 296 >> 2] = $0;
        HEAP32[$6 + 292 >> 2] = jsvObjectIteratorGetValue_8($6 + 304 | 0);
        while (1) {
         if (HEAP32[$6 + 312 >> 2] < HEAP32[$6 + 296 >> 2]) {
          HEAP32[$6 + 312 >> 2] = HEAP32[$6 + 312 >> 2] + 1;
          if (!(!(!(HEAP8[$6 + 319 | 0] & 1) | HEAP32[$6 + 312 >> 2] < 5) & HEAP32[$6 + 312 >> 2] < (HEAP32[$6 + 320 >> 2] - 5 | 0))) {
           if (!(HEAP8[$6 + 310 | 0] & 1)) {
            cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 4 ? 146375 : 141344, 0);
           }
           HEAP8[$6 + 310 | 0] = 0;
           if (!(!(HEAP8[$6 + 319 | 0] & 1) | HEAP32[$6 + 312 >> 2] != (HEAP32[$6 + 320 >> 2] - 5 | 0))) {
            cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[48929], 0);
           }
           $0 = 0;
           if (HEAP32[$6 + 340 >> 2] & 1) {
            $0 = jsonNeedsNewLine(HEAP32[$6 + 292 >> 2]);
           }
           HEAP8[$6 + 291 | 0] = $0 & 1;
           if (HEAP32[$6 + 340 >> 2] & 2) {
            HEAP8[$6 + 318 | 0] = 1;
            HEAP8[$6 + 291 | 0] = 1;
           }
           if (HEAP8[$6 + 291 | 0] & 1 ? 1 : HEAP8[$6 + 318 | 0] & 1) {
            jsonNewLine(HEAP32[$6 + 324 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2]);
            HEAP8[$6 + 318 | 0] = 0;
           }
           label$27: {
            if (HEAP32[$6 + 312 >> 2] == HEAP32[$6 + 296 >> 2]) {
             HEAP32[$6 + 284 >> 2] = jsvNewFromInteger(HEAP32[$6 + 296 >> 2]);
             jsfGetJSONWithCallback(HEAP32[$6 + 292 >> 2], HEAP32[$6 + 284 >> 2], HEAP32[$6 + 324 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2]);
             jsvUnLock(HEAP32[$6 + 284 >> 2]);
             break label$27;
            }
            cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 64 ? 128729 : 133948, 0);
           }
           HEAP8[$6 + 318 | 0] = HEAP8[$6 + 291 | 0] & 1;
          }
          continue;
         }
         break;
        }
        jsvUnLock(HEAP32[$6 + 292 >> 2]);
        jsvObjectIteratorNext($6 + 304 | 0);
        break label$12;
       }
       HEAP8[$6 + 311 | 0] = 0;
      }
      jsvUnLock(HEAP32[$6 + 300 >> 2]);
      continue;
     }
     break;
    }
    if (HEAP32[$6 + 340 >> 2] & 4) {
     jsfGetJSONForObjectItWithCallback($6 + 304 | 0, HEAP32[$6 + 340 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 324 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP8[$6 + 310 | 0] & 1);
    }
    jsvObjectIteratorFree_8($6 + 304 | 0);
    if (HEAP8[$6 + 318 | 0] & 1) {
     jsonNewLine(HEAP32[$6 + 340 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2]);
    }
    cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 4 ? 136251 : 136252, 0);
    break label$6;
   }
   label$31: {
    if (jsvIsArrayBuffer(HEAP32[$6 + 348 >> 2]) & 1) {
     HEAP8[$6 + 223 | 0] = 1;
     jsvArrayBufferIteratorNew($6 + 224 | 0, HEAP32[$6 + 348 >> 2], 0);
     while (1) {
      if (jsvArrayBufferIteratorHasElement($6 + 224 | 0) & 1) {
       if (jsvArrayBufferIteratorGetFloatValue($6 + 224 | 0) != 0) {
        HEAP8[$6 + 223 | 0] = 0;
       }
       jsvArrayBufferIteratorNext($6 + 224 | 0);
       continue;
      }
      break;
     }
     jsvArrayBufferIteratorFree($6 + 224 | 0);
     HEAP8[$6 + 222 | 0] = (HEAP32[$6 + 340 >> 2] & 128) != 0;
     label$36: {
      if (!(!(HEAP8[$6 + 223 | 0] & 1) | HEAP8[$6 + 222 | 0] & 1)) {
       $0 = HEAP32[$6 + 332 >> 2];
       $1 = HEAP32[$6 + 328 >> 2];
       $2 = jswGetBasicObjectName(HEAP32[$6 + 348 >> 2]);
       HEAP32[$6 + 20 >> 2] = jsvGetArrayBufferLength(HEAP32[$6 + 348 >> 2]);
       HEAP32[$6 + 16 >> 2] = $2;
       cbprintf($0, $1, 143157, $6 + 16 | 0);
       break label$36;
      }
      HEAP32[$6 + 216 >> 2] = jswGetBasicObjectName(HEAP32[$6 + 348 >> 2]);
      HEAP8[$6 + 215 | 0] = !strcmp(HEAP32[$6 + 216 >> 2], 121317);
      if (HEAP8[$6 + 215 | 0] & 1) {
       HEAP32[$6 + 216 >> 2] = 116290;
      }
      $0 = HEAP32[$6 + 332 >> 2];
      $1 = HEAP32[$6 + 328 >> 2];
      $2 = HEAP8[$6 + 222 | 0] & 1;
      HEAP32[$6 >> 2] = HEAP32[$6 + 216 >> 2];
      cbprintf($0, $1, $2 ? 136267 : 136260, $6);
      if (HEAP32[$6 + 340 >> 2] & 2) {
       jsonNewLine(HEAP32[$6 + 324 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2]);
      }
      HEAP32[$6 + 208 >> 2] = jsvGetArrayBufferLength(HEAP32[$6 + 348 >> 2]);
      $7 = HEAP32[$6 + 340 >> 2] & 8 ? HEAPU32[$6 + 208 >> 2] > 15 : $7;
      HEAP8[$6 + 207 | 0] = $7;
      jsvArrayBufferIteratorNew($6 + 224 | 0, HEAP32[$6 + 348 >> 2], 0);
      while (1) {
       $0 = 0;
       if (jsvArrayBufferIteratorHasElement($6 + 224 | 0) & 1) {
        $0 = jspIsInterrupted() ^ -1;
       }
       if ($0 & 1) {
        if (!(!(!(HEAP8[$6 + 207 | 0] & 1) | HEAPU32[$6 + 272 >> 2] < 5) & HEAPU32[$6 + 272 >> 2] < HEAP32[$6 + 208 >> 2] - 5 >>> 0)) {
         if (HEAP32[$6 + 272 >> 2]) {
          cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 4 ? 146375 : 141344, 0);
         }
         if (HEAP32[$6 + 340 >> 2] & 2) {
          jsonNewLine(HEAP32[$6 + 324 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2]);
         }
         if (!(!(HEAP8[$6 + 207 | 0] & 1) | HEAP32[$6 + 272 >> 2] != (HEAP32[$6 + 208 >> 2] - 5 | 0))) {
          cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[48929], 0);
         }
         HEAP32[$6 + 200 >> 2] = jsvArrayBufferIteratorGetValue($6 + 224 | 0, 0);
         jsfGetJSONWithCallback(HEAP32[$6 + 200 >> 2], 0, HEAP32[$6 + 324 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2]);
         jsvUnLock(HEAP32[$6 + 200 >> 2]);
        }
        jsvArrayBufferIteratorNext($6 + 224 | 0);
        continue;
       }
       break;
      }
      if (HEAP32[$6 + 340 >> 2] & 2) {
       jsonNewLine(HEAP32[$6 + 340 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2]);
      }
      jsvArrayBufferIteratorFree($6 + 224 | 0);
      cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP8[$6 + 222 | 0] & 1 ? 136252 : 144383, 0);
      if (!(!(HEAP8[$6 + 215 | 0] & 1) | HEAP8[$6 + 222 | 0] & 1)) {
       cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], 121186, 0);
      }
     }
     break label$31;
    }
    label$51: {
     if (jsvIsObject(HEAP32[$6 + 348 >> 2]) & 1) {
      label$53: {
       if (HEAP32[$6 + 340 >> 2] & 32) {
        $0 = jsiGetDeviceFromClass(HEAP32[$6 + 348 >> 2]) & 255;
        break label$53;
       }
       $0 = 0;
      }
      HEAP8[$6 + 199 | 0] = $0;
      label$55: {
       if (HEAPU8[$6 + 199 | 0]) {
        $0 = HEAP32[$6 + 332 >> 2];
        $1 = HEAP32[$6 + 328 >> 2];
        HEAP32[$6 + 32 >> 2] = jshGetDeviceString(HEAPU8[$6 + 199 | 0]);
        cbprintf($0, $1, 120693, $6 + 32 | 0);
        break label$55;
       }
       HEAP8[$6 + 198 | 0] = 1;
       if (HEAP32[$6 + 340 >> 2] & 256) {
        HEAP32[$6 + 192 >> 2] = jsvObjectGetChildIfExists(HEAP32[$6 + 348 >> 2], 135865);
        if (jsvHasChildren(HEAP32[$6 + 192 >> 2]) & 1) {
         HEAP32[$6 + 188 >> 2] = jsvObjectGetChildIfExists(HEAP32[$6 + 192 >> 2], 120855);
         if (HEAP32[$6 + 188 >> 2]) {
          HEAP32[$6 + 184 >> 2] = jsvGetIndexOf(HEAP32[91086], HEAP32[$6 + 188 >> 2], 1);
          if (HEAP32[$6 + 184 >> 2]) {
           $0 = HEAP32[$6 + 332 >> 2];
           $1 = HEAP32[$6 + 328 >> 2];
           HEAP32[$6 + 64 >> 2] = HEAP32[$6 + 184 >> 2];
           cbprintf($0, $1, 146251, $6 - -64 | 0);
          }
          jsvUnLock2(HEAP32[$6 + 184 >> 2], HEAP32[$6 + 188 >> 2]);
          HEAP32[$6 + 180 >> 2] = jspGetNamedField(HEAP32[$6 + 348 >> 2], 129776, 0);
          label$61: {
           if (!(jsvIsFunction(HEAP32[$6 + 180 >> 2]) & 1)) {
            break label$61;
           }
           $0 = HEAP32[$6 + 180 >> 2];
           if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 1) {
            break label$61;
           }
           HEAP32[$6 + 176 >> 2] = jspExecuteFunction(HEAP32[$6 + 180 >> 2], HEAP32[$6 + 348 >> 2], 0, 0);
           $0 = HEAP32[$6 + 332 >> 2];
           $1 = HEAP32[$6 + 328 >> 2];
           HEAP32[$6 + 48 >> 2] = HEAP32[$6 + 176 >> 2];
           cbprintf($0, $1, 116903, $6 + 48 | 0);
           jsvUnLock(HEAP32[$6 + 176 >> 2]);
           HEAP8[$6 + 198 | 0] = 0;
          }
          jsvUnLock(HEAP32[$6 + 180 >> 2]);
         }
        }
        jsvUnLock(HEAP32[$6 + 192 >> 2]);
       }
       if (HEAP8[$6 + 198 | 0] & 1) {
        HEAP32[$6 + 172 >> 2] = 0;
        if (HEAP32[$6 + 340 >> 2] & 8192) {
         HEAP32[$6 + 172 >> 2] = jspGetNamedField(HEAP32[$6 + 348 >> 2], 136977, 0);
        }
        label$64: {
         if (jsvIsFunction(HEAP32[$6 + 172 >> 2]) & 1) {
          label$66: {
           if (HEAP32[$6 + 344 >> 2]) {
            $0 = jsvAsString(HEAP32[$6 + 344 >> 2]);
            break label$66;
           }
           $0 = 0;
          }
          HEAP32[$6 + 168 >> 2] = $0;
          HEAP32[$6 + 164 >> 2] = jspExecuteFunction(HEAP32[$6 + 172 >> 2], HEAP32[$6 + 348 >> 2], 1, $6 + 168 | 0);
          jsvUnLock(HEAP32[$6 + 168 >> 2]);
          if (HEAP32[$6 + 164 >> 2] == HEAP32[$6 + 348 >> 2]) {
           $0 = HEAP32[$6 + 348 >> 2];
           $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & -513;
           HEAP8[$0 + 12 | 0] = $1;
           HEAP8[$0 + 13 | 0] = $1 >>> 8;
          }
          jsfGetJSONWithCallback(HEAP32[$6 + 164 >> 2], 0, HEAP32[$6 + 340 >> 2] & -8193, HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2]);
          jsvUnLock(HEAP32[$6 + 164 >> 2]);
          break label$64;
         }
         jsvObjectIteratorNew($6 + 160 | 0, HEAP32[$6 + 348 >> 2]);
         cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 4 ? 146076 : 116071, 0);
         HEAP8[$6 + 159 | 0] = jsfGetJSONForObjectItWithCallback($6 + 160 | 0, HEAP32[$6 + 340 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 324 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], 1) & 1;
         jsvObjectIteratorFree_8($6 + 160 | 0);
         if (HEAP8[$6 + 159 | 0] & 1) {
          jsonNewLine(HEAP32[$6 + 340 >> 2], HEAP32[$6 + 336 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2]);
         }
         cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], HEAP32[$6 + 340 >> 2] & 4 ? 116060 : 116064, 0);
        }
        jsvUnLock(HEAP32[$6 + 172 >> 2]);
       }
      }
      break label$51;
     }
     label$70: {
      if (jsvIsFunction(HEAP32[$6 + 348 >> 2]) & 1) {
       if (HEAP32[$6 + 340 >> 2] & 16) {
        cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], 133948, 0);
        break label$70;
       }
       cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], 146102, 0);
       jsfGetJSONForFunctionWithCallback(HEAP32[$6 + 348 >> 2], HEAP32[$6 + 324 >> 2], HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2]);
       break label$70;
      }
      label$73: {
       label$74: {
        label$75: {
         if (jsvIsString(HEAP32[$6 + 348 >> 2]) & 1) {
          if (!(jsvIsName(HEAP32[$6 + 348 >> 2]) & 1)) {
           break label$75;
          }
         }
         if (!(HEAP32[$6 + 340 >> 2] & 1024)) {
          break label$74;
         }
         if (!(jsvIsPin(HEAP32[$6 + 348 >> 2]) & 1)) {
          break label$74;
         }
        }
        label$77: {
         label$78: {
          if (!(HEAP32[$6 + 340 >> 2] & 8)) {
           break label$78;
          }
          if (jsvGetStringLength(HEAP32[$6 + 348 >> 2]) >>> 0 <= 40) {
           break label$78;
          }
          HEAP32[$6 + 152 >> 2] = jsvNewFromStringVar(HEAP32[$6 + 348 >> 2], 0, 17);
          HEAP32[$6 + 148 >> 2] = jsvNewFromStringVar(HEAP32[$6 + 348 >> 2], jsvGetStringLength(HEAP32[$6 + 348 >> 2]) - 17 | 0, 17);
          $0 = HEAP32[$6 + 332 >> 2];
          $1 = HEAP32[$6 + 328 >> 2];
          $2 = HEAP32[$6 + 152 >> 2];
          $3 = HEAP32[48929];
          HEAP32[$6 + 88 >> 2] = HEAP32[$6 + 148 >> 2];
          HEAP32[$6 + 84 >> 2] = $3;
          HEAP32[$6 + 80 >> 2] = $2;
          cbprintf($0, $1, 121480, $6 + 80 | 0);
          jsvUnLock2(HEAP32[$6 + 152 >> 2], HEAP32[$6 + 148 >> 2]);
          break label$77;
         }
         $0 = HEAP32[$6 + 332 >> 2];
         $1 = HEAP32[$6 + 328 >> 2];
         $2 = HEAP32[$6 + 340 >> 2] & 2048;
         HEAP32[$6 + 96 >> 2] = HEAP32[$6 + 348 >> 2];
         cbprintf($0, $1, $2 ? 136909 : 121674, $6 + 96 | 0);
        }
        break label$73;
       }
       label$79: {
        label$80: {
         if (!(HEAP32[$6 + 340 >> 2] & 4096)) {
          break label$80;
         }
         if (!(jsvIsFloat(HEAP32[$6 + 348 >> 2]) & 1)) {
          break label$80;
         }
         __DOUBLE_BITS_5(jsvGetFloat(HEAP32[$6 + 348 >> 2]));
         if ((i64toi32_i32$HIGH_BITS & 2147483647) >>> 0 < 2146435072) {
          break label$80;
         }
         cbprintf(HEAP32[$6 + 332 >> 2], HEAP32[$6 + 328 >> 2], 128729, 0);
         break label$79;
        }
        $0 = HEAP32[$6 + 332 >> 2];
        $1 = HEAP32[$6 + 328 >> 2];
        HEAP32[$6 + 112 >> 2] = HEAP32[$6 + 348 >> 2];
        cbprintf($0, $1, 116903, $6 + 112 | 0);
       }
      }
     }
    }
   }
  }
  $0 = HEAP32[$6 + 348 >> 2];
  $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & -513;
  HEAP8[$0 + 12 | 0] = $1;
  HEAP8[$0 + 13 | 0] = $1 >>> 8;
 }
 __stack_pointer = $6 + 352 | 0;
}

function jspeFunctionCall($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0, $7 = 0;
 $7 = __stack_pointer - 384 | 0;
 $6 = $7;
 __stack_pointer = $6;
 HEAP32[$6 + 376 >> 2] = $0;
 HEAP32[$6 + 372 >> 2] = $1;
 HEAP32[$6 + 368 >> 2] = $2;
 HEAP8[$6 + 367 | 0] = $3;
 HEAP32[$6 + 360 >> 2] = $4;
 HEAP32[$6 + 356 >> 2] = $5;
 label$1: {
  if (!(HEAP32[$6 + 376 >> 2] | (HEAP32[91094] & 63) != 1)) {
   label$3: {
    if (HEAP32[$6 + 372 >> 2]) {
     HEAP32[$6 + 32 >> 2] = HEAP32[$6 + 372 >> 2];
     jsExceptionHere(1, 145764, $6 + 32 | 0);
     break label$3;
    }
    HEAP32[$6 + 48 >> 2] = HEAP32[$6 + 372 >> 2];
    jsExceptionHere(1, 145787, $6 + 48 | 0);
   }
   HEAP32[$6 + 380 >> 2] = 0;
   break label$1;
  }
  if ((HEAP32[91094] & 63) == 1) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$6 + 380 >> 2] = 0;
    break label$1;
   }
  }
  if (!(!HEAP32[$6 + 376 >> 2] | (HEAP32[91094] & 63) != 1)) {
   HEAP32[$6 + 352 >> 2] = 0;
   if (!(jsvIsFunction(HEAP32[$6 + 376 >> 2]) & 1)) {
    HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 376 >> 2];
    jsExceptionHere(1, 118765, $6 + 16 | 0);
    HEAP32[$6 + 380 >> 2] = 0;
    break label$1;
   }
   HEAP32[$6 + 348 >> 2] = jsvLockAgainSafe(HEAP32[$6 + 368 >> 2]);
   if (HEAP8[$6 + 367 | 0] & 1) {
    if (!(jslMatch(40) & 1)) {
     HEAP32[$6 + 380 >> 2] = 0;
     break label$1;
    }
   }
   label$11: {
    if (jsvIsNativeFunction(HEAP32[$6 + 376 >> 2]) & 1) {
     HEAP32[$6 + 344 >> 2] = 0;
     HEAP32[$6 + 340 >> 2] = 0;
     jsvObjectIteratorNew($6 + 336 | 0, HEAP32[$6 + 376 >> 2]);
     HEAP32[$6 + 332 >> 2] = jsvObjectIteratorGetKey_2($6 + 336 | 0);
     while (1) {
      if (jsvIsFunctionParameter(HEAP32[$6 + 332 >> 2]) & 1) {
       if (HEAPU32[$6 + 360 >> 2] >= HEAPU32[$6 + 344 >> 2]) {
        if (HEAP32[$6 + 344 >> 2]) {
         $0 = HEAP32[$6 + 344 >> 2];
        } else {
         $0 = HEAP32[$6 + 360 >> 2];
        }
        HEAP32[$6 + 328 >> 2] = $0 << 2;
        HEAP32[$6 + 324 >> 2] = HEAP32[$6 + 328 >> 2] << 2;
        if (jsuGetFreeStack() >>> 0 < HEAP32[$6 + 324 >> 2] + 256 >>> 0) {
         jsExceptionHere(1, 119644, 0);
         jsvUnLock(HEAP32[$6 + 348 >> 2]);
         HEAP32[$6 + 380 >> 2] = 0;
         break label$1;
        }
        $7 = $7 - (HEAP32[$6 + 324 >> 2] + 15 & -16) | 0;
        __stack_pointer = $7;
        HEAP32[$6 + 320 >> 2] = $7;
        __memcpy(HEAP32[$6 + 320 >> 2], HEAP32[$6 + 356 >> 2], HEAP32[$6 + 360 >> 2] << 2);
        HEAP32[$6 + 356 >> 2] = HEAP32[$6 + 320 >> 2];
        HEAP32[$6 + 344 >> 2] = HEAP32[$6 + 328 >> 2];
       }
       HEAP32[$6 + 316 >> 2] = HEAP32[$6 + 360 >> 2] - 1;
       while (1) {
        if (HEAP32[$6 + 316 >> 2] >= HEAP32[$6 + 340 >> 2]) {
         HEAP32[HEAP32[$6 + 356 >> 2] + (HEAP32[$6 + 316 >> 2] + 1 << 2) >> 2] = HEAP32[HEAP32[$6 + 356 >> 2] + (HEAP32[$6 + 316 >> 2] << 2) >> 2];
         HEAP32[$6 + 316 >> 2] = HEAP32[$6 + 316 >> 2] - 1;
         continue;
        }
        break;
       }
       $0 = jsvSkipName(HEAP32[$6 + 332 >> 2]);
       HEAP32[HEAP32[$6 + 356 >> 2] + (HEAP32[$6 + 340 >> 2] << 2) >> 2] = $0;
       HEAP32[$6 + 360 >> 2] = HEAP32[$6 + 360 >> 2] + 1;
       HEAP32[$6 + 340 >> 2] = HEAP32[$6 + 340 >> 2] + 1;
       jsvUnLock(HEAP32[$6 + 332 >> 2]);
       jsvObjectIteratorNext($6 + 336 | 0);
       HEAP32[$6 + 332 >> 2] = jsvObjectIteratorGetKey_2($6 + 336 | 0);
       continue;
      }
      break;
     }
     while (1) {
      if (HEAP32[$6 + 332 >> 2]) {
       if (jsvIsStringEqual(HEAP32[$6 + 332 >> 2], 120157) & 1) {
        jsvUnLock(HEAP32[$6 + 348 >> 2]);
        HEAP32[$6 + 348 >> 2] = jsvSkipName(HEAP32[$6 + 332 >> 2]);
       } else {
        jsvUnLock(HEAP32[$6 + 332 >> 2]);
        jsvObjectIteratorNext($6 + 336 | 0);
        HEAP32[$6 + 332 >> 2] = jsvObjectIteratorGetKey_2($6 + 336 | 0);
        continue;
       }
      }
      break;
     }
     jsvUnLock(HEAP32[$6 + 332 >> 2]);
     jsvObjectIteratorFree_2($6 + 336 | 0);
     HEAP32[$6 + 312 >> 2] = HEAP32[$6 + 340 >> 2];
     if (HEAP8[$6 + 367 | 0] & 1) {
      while (1) {
       $0 = 0;
       label$27: {
        if (HEAP32[91094] & 112) {
         break label$27;
        }
        $0 = 0;
        if (HEAP16[HEAP32[49079] + 2 >> 1] == 41) {
         break label$27;
        }
        $0 = HEAP16[HEAP32[49079] + 2 >> 1];
       }
       if ($0) {
        if (HEAPU32[$6 + 360 >> 2] >= HEAPU32[$6 + 344 >> 2]) {
         if (HEAP32[$6 + 344 >> 2]) {
          $0 = HEAP32[$6 + 344 >> 2] << 2;
         } else {
          $0 = 16;
         }
         HEAP32[$6 + 308 >> 2] = $0;
         $7 = $7 - ((HEAP32[$6 + 308 >> 2] << 2) + 15 & -16) | 0;
         __stack_pointer = $7;
         HEAP32[$6 + 304 >> 2] = $7;
         __memcpy(HEAP32[$6 + 304 >> 2], HEAP32[$6 + 356 >> 2], HEAP32[$6 + 360 >> 2] << 2);
         HEAP32[$6 + 356 >> 2] = HEAP32[$6 + 304 >> 2];
         HEAP32[$6 + 344 >> 2] = HEAP32[$6 + 308 >> 2];
        }
        $1 = jsvSkipNameAndUnLock(jspeAssignmentExpression());
        $2 = HEAP32[$6 + 356 >> 2];
        $0 = HEAP32[$6 + 360 >> 2];
        HEAP32[$6 + 360 >> 2] = $0 + 1;
        HEAP32[($0 << 2) + $2 >> 2] = $1;
        if (HEAP16[HEAP32[49079] + 2 >> 1] != 41) {
         if (!(jslMatch(44) & 1)) {
          jsvUnLockMany(HEAP32[$6 + 360 >> 2], HEAP32[$6 + 356 >> 2]);
          jsvUnLock(HEAP32[$6 + 348 >> 2]);
          HEAP32[$6 + 380 >> 2] = 0;
          break label$1;
         }
        }
        continue;
       }
       break;
      }
      if (!(jslMatch(41) & 1)) {
       jsvUnLockMany(HEAP32[$6 + 360 >> 2], HEAP32[$6 + 356 >> 2]);
       jsvUnLock(HEAP32[$6 + 348 >> 2]);
       HEAP32[$6 + 380 >> 2] = 0;
       break label$1;
      }
      HEAP32[$6 + 312 >> 2] = HEAP32[$6 + 360 >> 2];
     }
     HEAP32[$6 + 300 >> 2] = jsvGetNativeFunctionPtr(HEAP32[$6 + 376 >> 2]);
     HEAP32[$6 + 296 >> 2] = HEAP32[91092];
     label$35: {
      if (HEAP32[$6 + 348 >> 2]) {
       HEAP32[91092] = jsvRef(HEAP32[$6 + 348 >> 2]);
       break label$35;
      }
      label$37: {
       if (HEAP32[$6 + 300 >> 2] == 9) {
        if (HEAP32[91092]) {
         HEAP32[91092] = jsvRef(HEAP32[91092]);
        }
        break label$37;
       }
       HEAP32[91092] = jsvRef(HEAP32[91086]);
      }
     }
     label$40: {
      if (!(!HEAP32[$6 + 300 >> 2] | HEAP32[91094] & 112)) {
       $0 = HEAP32[$6 + 376 >> 2];
       HEAP32[$6 + 352 >> 2] = jsnCallFunction(HEAP32[$6 + 300 >> 2], HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8, HEAP32[$6 + 348 >> 2], HEAP32[$6 + 356 >> 2], HEAP32[$6 + 360 >> 2]);
       break label$40;
      }
      HEAP32[$6 + 352 >> 2] = 0;
     }
     jsvUnLockMany(HEAP32[$6 + 312 >> 2], HEAP32[$6 + 356 >> 2]);
     if (HEAP32[91092]) {
      jsvUnRef(HEAP32[91092]);
     }
     HEAP32[91092] = HEAP32[$6 + 296 >> 2];
     break label$11;
    }
    HEAP32[$6 + 292 >> 2] = jsvNewWithFlags(7);
    if (!HEAP32[$6 + 292 >> 2]) {
     jspSetError(0);
     jsvUnLock(HEAP32[$6 + 348 >> 2]);
     HEAP32[$6 + 380 >> 2] = 0;
     break label$1;
    }
    HEAP32[$6 + 288 >> 2] = 0;
    HEAP32[$6 + 284 >> 2] = 0;
    HEAP32[$6 + 280 >> 2] = 0;
    jsvObjectIteratorNew($6 + 272 | 0, HEAP32[$6 + 376 >> 2]);
    HEAP32[$6 + 268 >> 2] = jsvObjectIteratorGetKey_2($6 + 272 | 0);
    HEAP32[$6 + 264 >> 2] = jsvObjectIteratorGetValue_2($6 + 272 | 0);
    while (1) {
     $0 = 0;
     if (jsvIsFunctionParameter(HEAP32[$6 + 268 >> 2]) & 1) {
      $0 = HEAP32[$6 + 264 >> 2] != 0;
     }
     if ($0) {
      jsvAddFunctionParameter(HEAP32[$6 + 292 >> 2], jsvNewFromStringVar(HEAP32[$6 + 268 >> 2], 1, 2147483647), HEAP32[$6 + 264 >> 2]);
      jsvUnLock2(HEAP32[$6 + 264 >> 2], HEAP32[$6 + 268 >> 2]);
      jsvObjectIteratorNext($6 + 272 | 0);
      HEAP32[$6 + 268 >> 2] = jsvObjectIteratorGetKey_2($6 + 272 | 0);
      HEAP32[$6 + 264 >> 2] = jsvObjectIteratorGetValue_2($6 + 272 | 0);
      continue;
     }
     break;
    }
    jsvUnLock2(HEAP32[$6 + 264 >> 2], HEAP32[$6 + 268 >> 2]);
    label$47: {
     if (HEAP8[$6 + 367 | 0] & 1) {
      HEAP32[$6 + 260 >> 2] = 0;
      while (1) {
       $0 = 0;
       $0 = HEAP32[91094] & 80 ? $0 : HEAP16[HEAP32[49079] + 2 >> 1] != 41;
       if ($0) {
        HEAP32[$6 + 256 >> 2] = jsvObjectIteratorGetKey_2($6 + 272 | 0);
        HEAP8[$6 + 255 | 0] = jsvIsFunctionParameter(HEAP32[$6 + 256 >> 2]) & 1;
        if (!(HEAP8[$6 + 255 | 0] & 1 ? 0 : HEAP16[HEAP32[49079] + 2 >> 1] == 41)) {
         HEAP32[$6 + 260 >> 2] = HEAP32[$6 + 260 >> 2] + 1;
         HEAP32[$6 + 248 >> 2] = 0;
         if (HEAP16[HEAP32[49079] + 2 >> 1] != 41) {
          HEAP32[$6 + 248 >> 2] = jspeAssignmentExpression();
         }
         HEAP32[$6 + 248 >> 2] = jsvSkipNameAndUnLock(HEAP32[$6 + 248 >> 2]);
         $1 = HEAP32[$6 + 292 >> 2];
         label$55: {
          if (HEAP8[$6 + 255 | 0] & 1) {
           $0 = jsvNewFromStringVar(HEAP32[$6 + 256 >> 2], 1, 2147483647);
           break label$55;
          }
          $0 = 0;
         }
         jsvAddFunctionParameter($1, $0, HEAP32[$6 + 248 >> 2]);
         jsvUnLock(HEAP32[$6 + 248 >> 2]);
         if (HEAP16[HEAP32[49079] + 2 >> 1] != 41) {
          if (!(jslMatch(44) & 1)) {
           HEAP32[$6 + 380 >> 2] = 0;
           break label$1;
          }
         }
        }
        jsvUnLock(HEAP32[$6 + 256 >> 2]);
        if (HEAP8[$6 + 255 | 0] & 1) {
         jsvObjectIteratorNext($6 + 272 | 0);
        }
        continue;
       }
       break;
      }
      if (!(jslMatch(41) & 1)) {
       HEAP32[$6 + 380 >> 2] = 0;
       break label$1;
      }
      break label$47;
     }
     HEAP32[$6 + 244 >> 2] = 0;
     while (1) {
      if (HEAP32[$6 + 244 >> 2] < HEAP32[$6 + 360 >> 2]) {
       HEAP32[$6 + 240 >> 2] = jsvObjectIteratorGetKey_2($6 + 272 | 0);
       HEAP8[$6 + 239 | 0] = jsvIsFunctionParameter(HEAP32[$6 + 240 >> 2]) & 1;
       $1 = HEAP32[$6 + 292 >> 2];
       label$63: {
        if (HEAP8[$6 + 239 | 0] & 1) {
         $0 = jsvNewFromStringVar(HEAP32[$6 + 240 >> 2], 1, 2147483647);
         break label$63;
        }
        $0 = 0;
       }
       jsvAddFunctionParameter($1, $0, HEAP32[HEAP32[$6 + 356 >> 2] + (HEAP32[$6 + 244 >> 2] << 2) >> 2]);
       HEAP32[$6 + 244 >> 2] = HEAP32[$6 + 244 >> 2] + 1;
       jsvUnLock(HEAP32[$6 + 240 >> 2]);
       if (HEAP8[$6 + 239 | 0] & 1) {
        jsvObjectIteratorNext($6 + 272 | 0);
       }
       continue;
      }
      break;
     }
    }
    while (1) {
     if (jsvObjectIteratorHasValue_2($6 + 272 | 0) & 1) {
      HEAP32[$6 + 232 >> 2] = jsvObjectIteratorGetKey_2($6 + 272 | 0);
      if (jsvIsString(HEAP32[$6 + 232 >> 2]) & 1) {
       label$69: {
        if (jsvIsStringEqual(HEAP32[$6 + 232 >> 2], 128047) & 1) {
         HEAP32[$6 + 288 >> 2] = jsvSkipName(HEAP32[$6 + 232 >> 2]);
         break label$69;
        }
        label$71: {
         if (jsvIsStringEqual(HEAP32[$6 + 232 >> 2], 133204) & 1) {
          HEAP32[$6 + 284 >> 2] = jsvSkipName(HEAP32[$6 + 232 >> 2]);
          break label$71;
         }
         label$73: {
          if (jsvIsStringEqual(HEAP32[$6 + 232 >> 2], 128707) & 1) {
           HEAP32[$6 + 280 >> 2] = jsvSkipName(HEAP32[$6 + 232 >> 2]);
           break label$73;
          }
          label$75: {
           if (jsvIsStringEqual(HEAP32[$6 + 232 >> 2], 120157) & 1) {
            jsvUnLock(HEAP32[$6 + 348 >> 2]);
            HEAP32[$6 + 348 >> 2] = jsvSkipName(HEAP32[$6 + 232 >> 2]);
            break label$75;
           }
           if (jsvIsFunctionParameter(HEAP32[$6 + 232 >> 2]) & 1) {
            HEAP32[$6 + 228 >> 2] = jsvSkipName(HEAP32[$6 + 232 >> 2]);
            jsvAddFunctionParameter(HEAP32[$6 + 292 >> 2], jsvNewFromStringVar(HEAP32[$6 + 232 >> 2], 1, 2147483647), HEAP32[$6 + 228 >> 2]);
            jsvUnLock(HEAP32[$6 + 228 >> 2]);
           }
          }
         }
        }
       }
      }
      jsvUnLock(HEAP32[$6 + 232 >> 2]);
      jsvObjectIteratorNext($6 + 272 | 0);
      continue;
     }
     break;
    }
    jsvObjectIteratorFree_2($6 + 272 | 0);
    if (HEAP32[$6 + 280 >> 2]) {
     HEAP32[$6 + 224 >> 2] = jsvMakeIntoVariableName(jsvNewFromStringVarComplete(HEAP32[$6 + 280 >> 2]), HEAP32[$6 + 376 >> 2]);
     jsvAddName(HEAP32[$6 + 292 >> 2], HEAP32[$6 + 224 >> 2]);
     jsvUnLock2(HEAP32[$6 + 224 >> 2], HEAP32[$6 + 280 >> 2]);
    }
    if (!(HEAP32[91094] & 112)) {
     HEAP32[$6 + 220 >> 2] = HEAP32[91088];
     HEAP32[91088] = 0;
     if (HEAP32[$6 + 288 >> 2]) {
      jspeiLoadScopesFromVar(HEAP32[$6 + 288 >> 2]);
      jsvUnLock(HEAP32[$6 + 288 >> 2]);
     }
     if (jspeiAddScope(HEAP32[$6 + 292 >> 2]) & 1) {
      HEAP32[$6 + 216 >> 2] = HEAP32[91089];
      HEAP8[$6 + 215 | 0] = HEAPU8[364364];
      HEAP32[91089] = HEAP32[$6 + 292 >> 2];
      HEAP8[364364] = 0;
      HEAP32[$6 + 208 >> 2] = HEAP32[91092];
      label$82: {
       if (HEAP32[$6 + 348 >> 2]) {
        HEAP32[91092] = jsvRef(HEAP32[$6 + 348 >> 2]);
        break label$82;
       }
       HEAP32[91092] = jsvRef(HEAP32[91086]);
      }
      if (HEAP32[$6 + 284 >> 2]) {
       HEAP32[$6 + 76 >> 2] = jslSetLex($6 + 80 | 0);
       jslInit(HEAP32[$6 + 284 >> 2]);
       HEAP32[$6 + 72 >> 2] = HEAP32[91094];
       HEAP32[91094] = HEAP32[91094] & 6256 | 1;
       label$85: {
        if (jsvIsFunctionReturn(HEAP32[$6 + 376 >> 2]) & 1) {
         if (HEAP16[HEAP32[49079] + 2 >> 1] == 59 | HEAP16[HEAP32[49079] + 2 >> 1] == 125) {
          break label$85;
         }
         HEAP32[$6 + 352 >> 2] = jsvSkipNameAndUnLock(jspeExpression());
         break label$85;
        }
        HEAP32[$6 + 68 >> 2] = jsvAddNamedChild(HEAP32[$6 + 292 >> 2], 0, 128076);
        HEAP8[364364] = HEAPU8[364364] - 1;
        jspeBlockNoBrackets();
        HEAP8[364364] = HEAPU8[364364] + 1;
        HEAP32[$6 + 352 >> 2] = jsvSkipName(HEAP32[$6 + 68 >> 2]);
        if (HEAP32[$6 + 68 >> 2]) {
         jsvRemoveChildAndUnLock(HEAP32[$6 + 292 >> 2], HEAP32[$6 + 68 >> 2]);
        }
       }
       HEAP32[$6 + 64 >> 2] = HEAP32[91094] & 112;
       HEAP32[91094] = HEAP32[91094] & -1664 | HEAP32[$6 + 72 >> 2] & 1663;
       jslKill();
       jslSetLex(HEAP32[$6 + 76 >> 2]);
       if (HEAP32[$6 + 64 >> 2]) {
        HEAP32[91094] = HEAP32[$6 + 64 >> 2] | HEAP32[91094];
        HEAP32[$6 + 60 >> 2] = jsvObjectGetChild(HEAP32[91087], 132883, 28);
        if (HEAP32[$6 + 60 >> 2]) {
         $0 = HEAP32[$6 + 60 >> 2];
         $1 = jsvIsString(HEAP32[$6 + 372 >> 2]) & 1;
         HEAP32[$6 >> 2] = HEAP32[$6 + 372 >> 2];
         jsvAppendPrintf($0, $1 ? 146112 : 146140, $6);
         label$90: {
          if (HEAP32[49079]) {
           jspAppendStackTrace(HEAP32[$6 + 60 >> 2]);
           break label$90;
          }
          jsvAppendPrintf(HEAP32[$6 + 60 >> 2], 146685, 0);
         }
         jsvUnLock(HEAP32[$6 + 60 >> 2]);
        }
       }
      }
      if (HEAP32[91092]) {
       jsvUnRef(HEAP32[91092]);
      }
      HEAP32[91092] = HEAP32[$6 + 208 >> 2];
      jspeiRemoveScope();
      HEAP32[91089] = HEAP32[$6 + 216 >> 2];
      HEAP8[364364] = HEAPU8[$6 + 215 | 0];
     }
     jsvUnLock(HEAP32[91088]);
     HEAP32[91088] = HEAP32[$6 + 220 >> 2];
    }
    jsvUnLock2(HEAP32[$6 + 284 >> 2], HEAP32[$6 + 292 >> 2]);
   }
   jsvUnLock(HEAP32[$6 + 348 >> 2]);
   if (HEAP32[49079]) {
    jsvStringIteratorUpdatePtr(HEAP32[49079] + 88 | 0);
   }
   HEAP32[$6 + 380 >> 2] = HEAP32[$6 + 352 >> 2];
   break label$1;
  }
  if (HEAP8[$6 + 367 | 0] & 1) {
   if (jspCheckStackPosition() & 1) {
    jspeParseFunctionCallBrackets();
   }
   HEAP32[$6 + 380 >> 2] = 0;
   break label$1;
  }
  HEAP32[$6 + 380 >> 2] = 0;
 }
 __stack_pointer = $6 + 384 | 0;
 return HEAP32[$6 + 380 >> 2];
}

function jsvMathsOp($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = __stack_pointer - 80 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 72 >> 2] = $0;
 HEAP32[$3 + 68 >> 2] = $1;
 HEAP32[$3 + 64 >> 2] = $2;
 label$1: {
  if (!(HEAP32[$3 + 64 >> 2] != 139 & HEAP32[$3 + 64 >> 2] != 141)) {
   HEAP8[$3 + 63 | 0] = jsvMathsOpTypeEqual(HEAP32[$3 + 72 >> 2], HEAP32[$3 + 68 >> 2]) & 1;
   if (HEAP32[$3 + 64 >> 2] == 139) {
    HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP8[$3 + 63 | 0] & 1);
    break label$1;
   }
   HEAP32[$3 + 76 >> 2] = jsvNewFromBool((HEAPU8[$3 + 63 | 0] ^ -1) & 1);
   break label$1;
  }
  $0 = 1;
  label$5: {
   if (HEAP32[$3 + 64 >> 2] == 38) {
    break label$5;
   }
   $0 = 1;
   if (HEAP32[$3 + 64 >> 2] == 124) {
    break label$5;
   }
   $0 = 1;
   if (HEAP32[$3 + 64 >> 2] == 94) {
    break label$5;
   }
   $0 = 1;
   if (HEAP32[$3 + 64 >> 2] == 143) {
    break label$5;
   }
   $0 = 1;
   if (HEAP32[$3 + 64 >> 2] == 146) {
    break label$5;
   }
   $0 = HEAP32[$3 + 64 >> 2] == 147;
  }
  HEAP8[$3 + 62 | 0] = $0;
  $0 = 1;
  label$6: {
   if (HEAP8[$3 + 62 | 0] & 1) {
    break label$6;
   }
   $0 = 1;
   if (HEAP32[$3 + 64 >> 2] == 42) {
    break label$6;
   }
   $0 = 1;
   if (HEAP32[$3 + 64 >> 2] == 47) {
    break label$6;
   }
   $0 = 1;
   if (HEAP32[$3 + 64 >> 2] == 37) {
    break label$6;
   }
   $0 = HEAP32[$3 + 64 >> 2] == 45;
  }
  HEAP8[$3 + 61 | 0] = $0;
  $0 = 1;
  label$7: {
   if (HEAP32[$3 + 64 >> 2] == 138) {
    break label$7;
   }
   $0 = 1;
   if (HEAP32[$3 + 64 >> 2] == 140) {
    break label$7;
   }
   $0 = 1;
   if (HEAP32[$3 + 64 >> 2] == 60) {
    break label$7;
   }
   $0 = 1;
   if (HEAP32[$3 + 64 >> 2] == 142) {
    break label$7;
   }
   $0 = 1;
   if (HEAP32[$3 + 64 >> 2] == 62) {
    break label$7;
   }
   $0 = HEAP32[$3 + 64 >> 2] == 145;
  }
  HEAP8[$3 + 60 | 0] = $0;
  if (HEAP8[$3 + 60 | 0] & 1) {
   label$9: {
    label$10: {
     if (!(jsvIsNumeric(HEAP32[$3 + 72 >> 2]) & 1)) {
      break label$10;
     }
     if (!(jsvIsString(HEAP32[$3 + 68 >> 2]) & 1)) {
      break label$10;
     }
     HEAP8[$3 + 61 | 0] = 1;
     if (jsvIsIntegerish(HEAP32[$3 + 72 >> 2]) & 1) {
      $4 = jsvIsStringNumericInt(HEAP32[$3 + 68 >> 2], 0);
     }
     HEAP8[$3 + 62 | 0] = $4 & 1;
     break label$9;
    }
    label$12: {
     if (!(jsvIsNumeric(HEAP32[$3 + 68 >> 2]) & 1)) {
      break label$12;
     }
     if (!(jsvIsString(HEAP32[$3 + 72 >> 2]) & 1)) {
      break label$12;
     }
     HEAP8[$3 + 61 | 0] = 1;
     if (jsvIsIntegerish(HEAP32[$3 + 68 >> 2]) & 1) {
      $4 = jsvIsStringNumericInt(HEAP32[$3 + 72 >> 2], 0);
     }
     HEAP8[$3 + 62 | 0] = $4 & 1;
    }
   }
  }
  label$14: {
   if (!(jsvIsUndefined(HEAP32[$3 + 72 >> 2]) & 1)) {
    break label$14;
   }
   if (!(jsvIsUndefined(HEAP32[$3 + 68 >> 2]) & 1)) {
    break label$14;
   }
   if (HEAP32[$3 + 64 >> 2] == 138) {
    HEAP32[$3 + 76 >> 2] = jsvNewFromBool(1);
    break label$1;
   }
   if (HEAP32[$3 + 64 >> 2] == 140) {
    HEAP32[$3 + 76 >> 2] = jsvNewFromBool(0);
    break label$1;
   }
   HEAP32[$3 + 76 >> 2] = 0;
   break label$1;
  }
  label$17: {
   label$18: {
    if (HEAP8[$3 + 61 | 0] & 1) {
     break label$18;
    }
    label$19: {
     if (jsvIsNumeric(HEAP32[$3 + 72 >> 2]) & 1) {
      break label$19;
     }
     if (jsvIsUndefined(HEAP32[$3 + 72 >> 2]) & 1) {
      break label$19;
     }
     if (!(jsvIsNull(HEAP32[$3 + 72 >> 2]) & 1)) {
      break label$17;
     }
    }
    if (jsvIsNumeric(HEAP32[$3 + 68 >> 2]) & 1) {
     break label$18;
    }
    if (jsvIsUndefined(HEAP32[$3 + 68 >> 2]) & 1) {
     break label$18;
    }
    if (!(jsvIsNull(HEAP32[$3 + 68 >> 2]) & 1)) {
     break label$17;
    }
   }
   label$20: {
    if (!(HEAP8[$3 + 62 | 0] & 1)) {
     if (!(jsvIsIntegerish(HEAP32[$3 + 72 >> 2]) & 1)) {
      break label$20;
     }
     if (!(jsvIsIntegerish(HEAP32[$3 + 68 >> 2]) & 1)) {
      break label$20;
     }
    }
    HEAP32[$3 + 56 >> 2] = jsvGetInteger(HEAP32[$3 + 72 >> 2]);
    HEAP32[$3 + 52 >> 2] = jsvGetInteger(HEAP32[$3 + 68 >> 2]);
    label$22: {
     switch (HEAP32[$3 + 64 >> 2] - 37 | 0) {
     case 6:
      $0 = HEAP32[$3 + 56 >> 2];
      $4 = $0 >> 31;
      $2 = $0;
      $1 = $4;
      $4 = HEAP32[$3 + 52 >> 2];
      $0 = $4 >> 31;
      $5 = $4;
      $4 = $0;
      $0 = $1;
      $1 = $0 + $4 | 0;
      $2 = $2 + $5 | 0;
      $1 = $2 >>> 0 < $5 >>> 0 ? $1 + 1 | 0 : $1;
      HEAP32[$3 + 76 >> 2] = jsvNewFromLongInteger($2, $1);
      break label$1;

     case 8:
      $1 = HEAP32[$3 + 56 >> 2];
      $2 = $1 >> 31;
      $0 = $1;
      $6 = $2;
      $2 = HEAP32[$3 + 52 >> 2];
      $1 = $2 >> 31;
      $7 = $1;
      $5 = $2;
      $4 = $0 - $2 | 0;
      $1 = $6;
      $2 = $7;
      $2 = $2 + ($0 >>> 0 < $5 >>> 0) | 0;
      $2 = $1 - $2 | 0;
      HEAP32[$3 + 76 >> 2] = jsvNewFromLongInteger($4, $2);
      break label$1;

     case 5:
      $2 = HEAP32[$3 + 56 >> 2];
      $0 = $2 >> 31;
      $5 = $2;
      $1 = $0;
      $0 = HEAP32[$3 + 52 >> 2];
      $2 = $0 >> 31;
      $4 = $2;
      $2 = $1;
      $1 = $0;
      $0 = $4;
      $0 = __wasm_i64_mul($5, $2, $1, $0);
      $2 = i64toi32_i32$HIGH_BITS;
      HEAP32[$3 + 76 >> 2] = jsvNewFromLongInteger($0, $2);
      break label$1;

     case 10:
      HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(+HEAP32[$3 + 56 >> 2] / +HEAP32[$3 + 52 >> 2]);
      break label$1;

     case 1:
      HEAP32[$3 + 76 >> 2] = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] & HEAP32[$3 + 52 >> 2]);
      break label$1;

     case 87:
      HEAP32[$3 + 76 >> 2] = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] | HEAP32[$3 + 52 >> 2]);
      break label$1;

     case 57:
      HEAP32[$3 + 76 >> 2] = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] ^ HEAP32[$3 + 52 >> 2]);
      break label$1;

     case 0:
      if (HEAP32[$3 + 52 >> 2] < 0) {
       HEAP32[$3 + 52 >> 2] = 0 - HEAP32[$3 + 52 >> 2];
      }
      label$41: {
       if (HEAP32[$3 + 52 >> 2]) {
        $0 = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] % HEAP32[$3 + 52 >> 2] | 0);
        break label$41;
       }
       $0 = jsvNewFromFloat(nan);
      }
      HEAP32[$3 + 76 >> 2] = $0;
      break label$1;

     case 106:
      HEAP32[$3 + 76 >> 2] = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] << HEAP32[$3 + 52 >> 2]);
      break label$1;

     case 109:
      HEAP32[$3 + 76 >> 2] = jsvNewFromInteger(HEAP32[$3 + 56 >> 2] >> HEAP32[$3 + 52 >> 2]);
      break label$1;

     case 110:
      HEAP32[$3 + 76 >> 2] = jsvNewFromLongInteger(HEAP32[$3 + 56 >> 2] >>> HEAP32[$3 + 52 >> 2] | 0, 0);
      break label$1;

     case 101:
      if (HEAP32[$3 + 56 >> 2] == HEAP32[$3 + 52 >> 2]) {
       $5 = (jsvIsNull(HEAP32[$3 + 72 >> 2]) & 1) == (jsvIsNull(HEAP32[$3 + 68 >> 2]) & 1);
      }
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool($5);
      break label$1;

     case 103:
      $0 = 1;
      if (HEAP32[$3 + 56 >> 2] == HEAP32[$3 + 52 >> 2]) {
       $0 = (jsvIsNull(HEAP32[$3 + 72 >> 2]) & 1) != (jsvIsNull(HEAP32[$3 + 68 >> 2]) & 1);
      }
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool($0);
      break label$1;

     case 23:
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 56 >> 2] < HEAP32[$3 + 52 >> 2]);
      break label$1;

     case 105:
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 56 >> 2] <= HEAP32[$3 + 52 >> 2]);
      break label$1;

     case 25:
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 56 >> 2] > HEAP32[$3 + 52 >> 2]);
      break label$1;

     case 108:
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 56 >> 2] >= HEAP32[$3 + 52 >> 2]);
      break label$1;

     default:
      break label$22;
     }
    }
    HEAP32[$3 + 76 >> 2] = jsvMathsOpError(HEAP32[$3 + 64 >> 2], 121168);
    break label$1;
   }
   HEAPF64[$3 + 40 >> 3] = jsvGetFloat(HEAP32[$3 + 72 >> 2]);
   HEAPF64[$3 + 32 >> 3] = jsvGetFloat(HEAP32[$3 + 68 >> 2]);
   label$45: {
    switch (HEAP32[$3 + 64 >> 2] - 37 | 0) {
    case 6:
     HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(HEAPF64[$3 + 40 >> 3] + HEAPF64[$3 + 32 >> 3]);
     break label$1;

    case 8:
     HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(HEAPF64[$3 + 40 >> 3] - HEAPF64[$3 + 32 >> 3]);
     break label$1;

    case 5:
     HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(HEAPF64[$3 + 40 >> 3] * HEAPF64[$3 + 32 >> 3]);
     break label$1;

    case 10:
     HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(HEAPF64[$3 + 40 >> 3] / HEAPF64[$3 + 32 >> 3]);
     break label$1;

    case 0:
     HEAP32[$3 + 76 >> 2] = jsvNewFromFloat(jswrap_math_mod(HEAPF64[$3 + 40 >> 3], HEAPF64[$3 + 32 >> 3]));
     break label$1;

    case 101:
    case 103:
     if (HEAPF64[$3 + 40 >> 3] == HEAPF64[$3 + 32 >> 3]) {
      $5 = (jsvIsNull(HEAP32[$3 + 72 >> 2]) & 1) == (jsvIsNull(HEAP32[$3 + 68 >> 2]) & 1);
     }
     HEAP8[$3 + 31 | 0] = $5;
     label$57: {
      label$58: {
       if (jsvIsNull(HEAP32[$3 + 72 >> 2]) & 1) {
        if (jsvIsUndefined(HEAP32[$3 + 68 >> 2]) & 1) {
         break label$58;
        }
       }
       if (!(jsvIsNull(HEAP32[$3 + 68 >> 2]) & 1)) {
        break label$57;
       }
       if (!(jsvIsUndefined(HEAP32[$3 + 72 >> 2]) & 1)) {
        break label$57;
       }
      }
      HEAP8[$3 + 31 | 0] = 1;
     }
     if (HEAP32[$3 + 64 >> 2] == 138) {
      $0 = HEAP8[$3 + 31 | 0] & 1;
     } else {
      $0 = (HEAPU8[$3 + 31 | 0] ^ -1) & 1;
     }
     HEAP32[$3 + 76 >> 2] = jsvNewFromBool($0);
     break label$1;

    case 23:
     HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAPF64[$3 + 40 >> 3] < HEAPF64[$3 + 32 >> 3]);
     break label$1;

    case 105:
     HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAPF64[$3 + 40 >> 3] <= HEAPF64[$3 + 32 >> 3]);
     break label$1;

    case 25:
     HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAPF64[$3 + 40 >> 3] > HEAPF64[$3 + 32 >> 3]);
     break label$1;

    case 108:
     HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAPF64[$3 + 40 >> 3] >= HEAPF64[$3 + 32 >> 3]);
     break label$1;

    default:
     break label$45;
    }
   }
   HEAP32[$3 + 76 >> 2] = jsvMathsOpError(HEAP32[$3 + 64 >> 2], 132501);
   break label$1;
  }
  label$62: {
   label$63: {
    if (jsvIsArray(HEAP32[$3 + 72 >> 2]) & 1) {
     break label$63;
    }
    if (jsvIsObject(HEAP32[$3 + 72 >> 2]) & 1) {
     break label$63;
    }
    if (jsvIsFunction(HEAP32[$3 + 72 >> 2]) & 1) {
     break label$63;
    }
    if (jsvIsArray(HEAP32[$3 + 68 >> 2]) & 1) {
     break label$63;
    }
    if (jsvIsObject(HEAP32[$3 + 68 >> 2]) & 1) {
     break label$63;
    }
    if (!(jsvIsFunction(HEAP32[$3 + 68 >> 2]) & 1)) {
     break label$62;
    }
   }
   if ((jsvIsArray(HEAP32[$3 + 72 >> 2]) & 1) != (jsvIsArray(HEAP32[$3 + 68 >> 2]) & 1) | HEAP32[$3 + 64 >> 2] != 138 & HEAP32[$3 + 64 >> 2] != 140) {
    break label$62;
   }
   HEAP8[$3 + 30 | 0] = HEAP32[$3 + 72 >> 2] == HEAP32[$3 + 68 >> 2];
   label$65: {
    if (!(jsvIsNativeFunction(HEAP32[$3 + 72 >> 2]) & 1)) {
     if (!(jsvIsNativeFunction(HEAP32[$3 + 68 >> 2]) & 1)) {
      break label$65;
     }
    }
    $0 = 0;
    label$67: {
     if (!HEAP32[$3 + 72 >> 2]) {
      break label$67;
     }
     $0 = 0;
     if (!HEAP32[$3 + 68 >> 2]) {
      break label$67;
     }
     $1 = HEAP32[$3 + 72 >> 2];
     $2 = HEAP32[$3 + 68 >> 2];
     $0 = 0;
     if ((HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24)) != (HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24))) {
      break label$67;
     }
     $1 = HEAP32[$3 + 72 >> 2];
     $2 = HEAP32[$3 + 68 >> 2];
     $0 = 0;
     if ((HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8) != (HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8)) {
      break label$67;
     }
     $0 = (jsvGetFirstChild(HEAP32[$3 + 72 >> 2]) & 65535) == (jsvGetFirstChild(HEAP32[$3 + 68 >> 2]) & 65535);
    }
    HEAP8[$3 + 30 | 0] = $0;
   }
   label$68: {
    switch (HEAP32[$3 + 64 >> 2] - 138 | 0) {
    case 0:
     HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP8[$3 + 30 | 0] & 1);
     break label$1;

    case 2:
     HEAP32[$3 + 76 >> 2] = jsvNewFromBool((HEAPU8[$3 + 30 | 0] ^ -1) & 1);
     break label$1;

    default:
     break label$68;
    }
   }
   HEAP32[$3 + 76 >> 2] = jsvMathsOpError(HEAP32[$3 + 64 >> 2], jsvIsArray(HEAP32[$3 + 72 >> 2]) & 1 ? 116389 : 117903);
   break label$1;
  }
  HEAP32[$3 + 24 >> 2] = jsvAsString(HEAP32[$3 + 72 >> 2]);
  HEAP32[$3 + 20 >> 2] = jsvAsString(HEAP32[$3 + 68 >> 2]);
  if (!(HEAP32[$3 + 20 >> 2] ? HEAP32[$3 + 24 >> 2] : 0)) {
   jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
   HEAP32[$3 + 76 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$3 + 64 >> 2] == 43) {
   $0 = HEAP32[$3 + 24 >> 2];
   HEAP16[$3 + 14 >> 1] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   label$74: {
    label$75: {
     if (HEAPU16[$3 + 14 >> 1] < 28 | HEAPU16[$3 + 14 >> 1] > 37) {
      break label$75;
     }
     if ((jsvGetLocks(HEAP32[$3 + 24 >> 2]) & 255) != 1) {
      break label$75;
     }
     if (jsvGetRefs(HEAP32[$3 + 24 >> 2]) & 65535) {
      break label$75;
     }
     HEAP32[$3 + 16 >> 2] = jsvLockAgain(HEAP32[$3 + 24 >> 2]);
     break label$74;
    }
    label$76: {
     if (!(!(HEAPU16[$3 + 14 >> 1] == 38 | HEAPU16[$3 + 14 >> 1] == 39) & HEAPU16[$3 + 14 >> 1] != 40)) {
      HEAP32[$3 + 16 >> 2] = jsvNewFromStringVarComplete(HEAP32[$3 + 24 >> 2]);
      break label$76;
     }
     HEAP32[$3 + 16 >> 2] = jsvCopy(HEAP32[$3 + 24 >> 2], 0);
    }
   }
   if (HEAP32[$3 + 16 >> 2]) {
    jsvAppendStringVarComplete(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 20 >> 2]);
   }
   jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 16 >> 2];
   break label$1;
  }
  HEAP32[$3 + 8 >> 2] = jsvCompareString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], 0, 0, 0);
  jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
  label$80: {
   label$81: {
    label$82: {
     label$83: {
      $0 = HEAP32[$3 + 64 >> 2];
      if (($0 | 0) != 60) {
       if (($0 | 0) == 62) {
        break label$82;
       }
       label$85: {
        if (($0 | 0) != 138) {
         switch ($0 - 140 | 0) {
         case 5:
          break label$81;

         case 2:
          break label$83;

         case 0:
          break label$85;

         default:
          break label$80;
         }
        }
        HEAP32[$3 + 76 >> 2] = jsvNewFromBool(!HEAP32[$3 + 8 >> 2]);
        break label$1;
       }
       HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 8 >> 2] != 0);
       break label$1;
      }
      HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 8 >> 2] < 0);
      break label$1;
     }
     HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 8 >> 2] <= 0);
     break label$1;
    }
    HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 8 >> 2] > 0);
    break label$1;
   }
   HEAP32[$3 + 76 >> 2] = jsvNewFromBool(HEAP32[$3 + 8 >> 2] >= 0);
   break label$1;
  }
  HEAP32[$3 + 76 >> 2] = jsvMathsOpError(HEAP32[$3 + 64 >> 2], 129941);
 }
 __stack_pointer = $3 + 80 | 0;
 return HEAP32[$3 + 76 >> 2];
}

function jswrap_graphics_drawImage($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0;
 $5 = __stack_pointer - 784 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 776 >> 2] = $0;
 HEAP32[$5 + 772 >> 2] = $1;
 HEAP32[$5 + 768 >> 2] = $2;
 HEAP32[$5 + 764 >> 2] = $3;
 HEAP32[$5 + 760 >> 2] = $4;
 label$1: {
  if (!(graphicsGetFromVar($5 + 688 | 0, HEAP32[$5 + 776 >> 2]) & 1)) {
   HEAP32[$5 + 780 >> 2] = 0;
   break label$1;
  }
  if (!(_jswrap_graphics_parseImage($5 + 688 | 0, HEAP32[$5 + 772 >> 2], 0, $5 + 600 | 0) & 1)) {
   HEAP32[$5 + 780 >> 2] = 0;
   break label$1;
  }
  HEAPF64[$5 + 592 >> 3] = 1;
  HEAPF64[$5 + 584 >> 3] = 0;
  HEAP8[$5 + 583 | 0] = 0;
  HEAP8[$5 + 582 | 0] = 0;
  if (jsvIsObject(HEAP32[$5 + 760 >> 2]) & 1) {
   HEAP32[$5 + 576 >> 2] = jsvObjectGetIntegerChild(HEAP32[$5 + 760 >> 2], 132392);
   if (HEAP32[$5 + 576 >> 2] > 0) {
    HEAP32[$5 + 624 >> 2] = HEAP32[$5 + 624 >> 2] + Math_imul(HEAPU16[$5 + 650 >> 1], HEAP32[$5 + 576 >> 2]);
   }
   HEAPF64[$5 + 592 >> 3] = jsvObjectGetFloatChild(HEAP32[$5 + 760 >> 2], 132619);
   $1 = __DOUBLE_BITS_11(HEAPF64[$5 + 592 >> 3]);
   $2 = $1;
   $0 = i64toi32_i32$HIGH_BITS;
   $1 = $0 & 2147483647;
   if (HEAPF64[$5 + 592 >> 3] <= 0 ? 1 : ($1 | 0) == 2146435072 | $1 >>> 0 > 2146435072) {
    HEAPF64[$5 + 592 >> 3] = 1;
   }
   HEAPF64[$5 + 584 >> 3] = jsvObjectGetFloatChild(HEAP32[$5 + 760 >> 2], 131999);
   $0 = __DOUBLE_BITS_11(HEAPF64[$5 + 584 >> 3]);
   $2 = $0;
   $1 = i64toi32_i32$HIGH_BITS;
   $0 = $1 & 2147483647;
   HEAP8[$5 + 583 | 0] = $0 >>> 0 < 2146435072;
   if (!(HEAP8[$5 + 583 | 0] & 1)) {
    HEAPF64[$5 + 584 >> 3] = 0;
   }
   HEAP8[$5 + 582 | 0] = jsvObjectGetBoolChild(HEAP32[$5 + 760 >> 2], 121006) & 1;
  }
  HEAP32[$5 + 572 >> 2] = 0;
  HEAP32[$5 + 568 >> 2] = 0;
  HEAP32[$5 + 564 >> 2] = 0;
  jsvStringIteratorNew($5 + 528 | 0, HEAP32[$5 + 620 >> 2], HEAP32[$5 + 624 >> 2]);
  label$10: {
   if (!(HEAP8[$5 + 583 | 0] & 1 | (HEAPF64[$5 + 592 >> 3] != 1 | HEAPF64[$5 + 584 >> 3] != 0))) {
    _jswrap_drawImageSimple($5 + 688 | 0, HEAP32[$5 + 768 >> 2], HEAP32[$5 + 764 >> 2], $5 + 600 | 0, $5 + 528 | 0, 0);
    break label$10;
   }
   $0 = 0;
   label$12: {
    if (HEAP8[$5 + 583 | 0] & 1) {
     break label$12;
    }
    $0 = 0;
    if (HEAPF64[$5 + 592 >> 3] - Math_floor(HEAPF64[$5 + 592 >> 3]) != 0) {
     break label$12;
    }
    $0 = !((HEAPU8[$5 + 696 | 0] | HEAPU8[$5 + 697 | 0] << 8 | (HEAPU8[$5 + 698 | 0] << 16 | HEAPU8[$5 + 699 | 0] << 24)) & 112);
   }
   HEAP8[$5 + 527 | 0] = $0;
   label$13: {
    if (HEAP8[$5 + 527 | 0] & 1) {
     $6 = HEAPF64[$5 + 592 >> 3];
     label$15: {
      if (Math_abs($6) < 2147483648) {
       $0 = ~~$6;
       break label$15;
      }
      $0 = -2147483648;
     }
     HEAP32[$5 + 520 >> 2] = $0;
     HEAP32[$5 + 516 >> 2] = 0;
     HEAP32[$5 + 512 >> 2] = HEAP32[$5 + 764 >> 2];
     HEAP32[$5 + 568 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 568 >> 2] < HEAP32[$5 + 604 >> 2]) {
       HEAP32[$5 + 508 >> 2] = jsvStringIteratorGetIndex_6($5 + 528 | 0);
       HEAP32[$5 + 504 >> 2] = HEAP32[$5 + 516 >> 2];
       HEAP32[$5 + 500 >> 2] = HEAP32[$5 + 564 >> 2];
       HEAP32[$5 + 496 >> 2] = 0;
       while (1) {
        if (HEAP32[$5 + 496 >> 2] < HEAP32[$5 + 520 >> 2]) {
         if (HEAP32[$5 + 496 >> 2]) {
          jsvStringIteratorGoto($5 + 528 | 0, HEAP32[$5 + 620 >> 2], HEAP32[$5 + 508 >> 2]);
          HEAP32[$5 + 516 >> 2] = HEAP32[$5 + 504 >> 2];
          HEAP32[$5 + 564 >> 2] = HEAP32[$5 + 500 >> 2];
         }
         HEAP32[$5 + 492 >> 2] = HEAP32[$5 + 768 >> 2];
         HEAP32[$5 + 572 >> 2] = 0;
         while (1) {
          if (HEAP32[$5 + 572 >> 2] < HEAP32[$5 + 600 >> 2]) {
           while (1) {
            if (HEAP32[$5 + 516 >> 2] < HEAP32[$5 + 608 >> 2]) {
             HEAP32[$5 + 564 >> 2] = HEAP32[$5 + 564 >> 2] << 8 | jsvStringIteratorGetCharAndNext($5 + 528 | 0) & 255;
             HEAP32[$5 + 516 >> 2] = HEAP32[$5 + 516 >> 2] + 8;
             continue;
            }
            break;
           }
           HEAP32[$5 + 488 >> 2] = HEAP32[$5 + 636 >> 2] & HEAP32[$5 + 564 >> 2] >>> HEAP32[$5 + 516 >> 2] - HEAP32[$5 + 608 >> 2];
           HEAP32[$5 + 516 >> 2] = HEAP32[$5 + 516 >> 2] - HEAP32[$5 + 608 >> 2];
           label$26: {
            if (!(HEAP32[$5 + 616 >> 2] == HEAP32[$5 + 488 >> 2] | HEAP32[$5 + 512 >> 2] < (HEAPU8[$5 + 722 | 0] | HEAPU8[$5 + 723 | 0] << 8) | HEAP32[$5 + 512 >> 2] > (HEAPU8[$5 + 726 | 0] | HEAPU8[$5 + 727 | 0] << 8))) {
             if (HEAP32[$5 + 628 >> 2]) {
              HEAP32[$5 + 488 >> 2] = HEAPU16[HEAP32[$5 + 628 >> 2] + ((HEAP32[$5 + 488 >> 2] & HEAP32[$5 + 632 >> 2]) << 1) >> 1];
             }
             HEAP32[$5 + 484 >> 2] = 0;
             while (1) {
              if (HEAP32[$5 + 484 >> 2] < HEAP32[$5 + 520 >> 2]) {
               if (!(HEAP32[$5 + 492 >> 2] < (HEAPU8[$5 + 720 | 0] | HEAPU8[$5 + 721 | 0] << 8) | HEAP32[$5 + 492 >> 2] > (HEAPU8[$5 + 724 | 0] | HEAPU8[$5 + 725 | 0] << 8))) {
                FUNCTION_TABLE[HEAPU8[$5 + 740 | 0] | HEAPU8[$5 + 741 | 0] << 8 | (HEAPU8[$5 + 742 | 0] << 16 | HEAPU8[$5 + 743 | 0] << 24)]($5 + 688 | 0, HEAP32[$5 + 492 >> 2], HEAP32[$5 + 512 >> 2], HEAP32[$5 + 488 >> 2]);
               }
               HEAP32[$5 + 492 >> 2] = HEAP32[$5 + 492 >> 2] + 1;
               HEAP32[$5 + 484 >> 2] = HEAP32[$5 + 484 >> 2] + 1;
               continue;
              }
              break;
             }
             break label$26;
            }
            HEAP32[$5 + 492 >> 2] = HEAP32[$5 + 520 >> 2] + HEAP32[$5 + 492 >> 2];
           }
           HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 572 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAP32[$5 + 512 >> 2] = HEAP32[$5 + 512 >> 2] + 1;
         HEAP32[$5 + 496 >> 2] = HEAP32[$5 + 496 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$5 + 568 >> 2] = HEAP32[$5 + 568 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$5 + 480 >> 2] = HEAP32[$5 + 768 >> 2];
     HEAP32[$5 + 476 >> 2] = HEAP32[$5 + 764 >> 2];
     HEAP32[$5 + 472 >> 2] = HEAP32[$5 + 768 >> 2] + Math_imul(HEAP32[$5 + 520 >> 2], HEAP32[$5 + 600 >> 2]);
     HEAP32[$5 + 468 >> 2] = HEAP32[$5 + 764 >> 2] + Math_imul(HEAP32[$5 + 520 >> 2], HEAP32[$5 + 604 >> 2]);
     graphicsSetModifiedAndClip($5 + 688 | 0, $5 + 480 | 0, $5 + 476 | 0, $5 + 472 | 0, $5 + 468 | 0, 0);
     break label$13;
    }
    HEAP32[$5 + 272 >> 2] = HEAP32[$5 + 768 >> 2] << 8;
    HEAP32[$5 + 276 >> 2] = HEAP32[$5 + 764 >> 2] << 8;
    __memcpy($5 + 308 | 0, $5 + 600 | 0, 84);
    $0 = HEAP32[$5 + 532 >> 2];
    $1 = HEAP32[$5 + 528 >> 2];
    $3 = $1;
    $2 = $5 + 272 | 0;
    $1 = $2;
    HEAP32[$1 + 120 >> 2] = $3;
    HEAP32[$1 + 124 >> 2] = $0;
    HEAP32[$1 + 152 >> 2] = HEAP32[$5 + 560 >> 2];
    $1 = HEAP32[$5 + 556 >> 2];
    $0 = HEAP32[$5 + 552 >> 2];
    $3 = $0;
    $0 = $2;
    HEAP32[$0 + 144 >> 2] = $3;
    HEAP32[$0 + 148 >> 2] = $1;
    $0 = HEAP32[$5 + 548 >> 2];
    $1 = HEAP32[$5 + 544 >> 2];
    $3 = $1;
    $1 = $2;
    HEAP32[$1 + 136 >> 2] = $3;
    HEAP32[$1 + 140 >> 2] = $0;
    $1 = HEAP32[$5 + 540 >> 2];
    $0 = HEAP32[$5 + 536 >> 2];
    $3 = $0;
    $0 = $2;
    HEAP32[$0 + 128 >> 2] = $3;
    HEAP32[$0 + 132 >> 2] = $1;
    HEAPF64[$5 + 288 >> 3] = HEAPF64[$5 + 584 >> 3];
    HEAPF64[$5 + 296 >> 3] = HEAPF64[$5 + 592 >> 3];
    HEAP8[$5 + 304 | 0] = HEAP8[$5 + 583 | 0] & 1;
    HEAP8[$5 + 305 | 0] = 0;
    _jswrap_drawImageLayerInit($5 + 272 | 0);
    HEAP32[$5 + 268 >> 2] = HEAP32[$5 + 272 >> 2] >> 8;
    HEAP32[$5 + 264 >> 2] = HEAP32[$5 + 276 >> 2] >> 8;
    HEAP32[$5 + 260 >> 2] = (HEAP32[$5 + 280 >> 2] >> 8) - 1;
    HEAP32[$5 + 256 >> 2] = (HEAP32[$5 + 284 >> 2] >> 8) - 1;
    graphicsSetModifiedAndClip($5 + 688 | 0, $5 + 268 | 0, $5 + 264 | 0, $5 + 260 | 0, $5 + 256 | 0, 0);
    _jswrap_drawImageLayerSetStart($5 + 272 | 0, HEAP32[$5 + 268 >> 2], HEAP32[$5 + 264 >> 2]);
    HEAP32[$5 + 252 >> 2] = graphicsGetSetPixelFn($5 + 688 | 0);
    label$32: {
     if (!(!(HEAP8[$5 + 582 | 0] & 1) | !(HEAPF64[$5 + 592 >> 3] < .75))) {
      $6 = +HEAP32[$5 + 436 >> 2] * HEAPF64[$5 + 592 >> 3];
      label$34: {
       if (Math_abs($6) < 2147483648) {
        $0 = ~~$6;
        break label$34;
       }
       $0 = -2147483648;
      }
      HEAP32[$5 + 248 >> 2] = $0;
      $6 = +HEAP32[$5 + 440 >> 2] * HEAPF64[$5 + 592 >> 3];
      label$36: {
       if (Math_abs($6) < 2147483648) {
        $0 = ~~$6;
        break label$36;
       }
       $0 = -2147483648;
      }
      HEAP32[$5 + 244 >> 2] = $0;
      HEAP32[$5 + 240 >> 2] = HEAP32[$5 + 436 >> 2] - HEAP32[$5 + 248 >> 2];
      HEAP32[$5 + 236 >> 2] = HEAP32[$5 + 440 >> 2] - HEAP32[$5 + 244 >> 2];
      __memcpy($5 + 40 | 0, $5 + 272 | 0, 192);
      jsvStringIteratorNew($5 + 160 | 0, HEAP32[$5 + 96 >> 2], 0);
      HEAP32[$5 + 212 >> 2] = HEAP32[$5 + 244 >> 2] + HEAP32[$5 + 212 >> 2];
      HEAP32[$5 + 216 >> 2] = HEAP32[$5 + 248 >> 2] + HEAP32[$5 + 216 >> 2];
      _jswrap_drawImageLayerNextY($5 + 40 | 0);
      HEAP32[$5 + 568 >> 2] = HEAP32[$5 + 264 >> 2];
      while (1) {
       if (HEAP32[$5 + 568 >> 2] <= HEAP32[$5 + 256 >> 2]) {
        _jswrap_drawImageLayerStartX($5 + 272 | 0);
        _jswrap_drawImageLayerStartX($5 + 40 | 0);
        HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 268 >> 2];
        while (1) {
         if (HEAP32[$5 + 572 >> 2] <= HEAP32[$5 + 260 >> 2]) {
          HEAP8[$5 + 23 | 0] = 1;
          HEAP8[$5 + 23 | 0] = _jswrap_drawImageLayerGetPixel($5 + 272 | 0, $5 + 36 | 0) & 1 & (HEAP8[$5 + 23 | 0] & 1);
          HEAP32[$5 + 452 >> 2] = HEAP32[$5 + 248 >> 2] + HEAP32[$5 + 452 >> 2];
          HEAP32[$5 + 456 >> 2] = HEAP32[$5 + 456 >> 2] - HEAP32[$5 + 244 >> 2];
          HEAP8[$5 + 23 | 0] = _jswrap_drawImageLayerGetPixel($5 + 272 | 0, $5 + 32 | 0) & 1 & (HEAP8[$5 + 23 | 0] & 1);
          HEAP32[$5 + 452 >> 2] = HEAP32[$5 + 240 >> 2] + HEAP32[$5 + 452 >> 2];
          HEAP32[$5 + 456 >> 2] = HEAP32[$5 + 456 >> 2] - HEAP32[$5 + 236 >> 2];
          HEAP8[$5 + 23 | 0] = _jswrap_drawImageLayerGetPixel($5 + 40 | 0, $5 + 28 | 0) & 1 & (HEAP8[$5 + 23 | 0] & 1);
          HEAP32[$5 + 220 >> 2] = HEAP32[$5 + 248 >> 2] + HEAP32[$5 + 220 >> 2];
          HEAP32[$5 + 224 >> 2] = HEAP32[$5 + 224 >> 2] - HEAP32[$5 + 244 >> 2];
          HEAP8[$5 + 23 | 0] = _jswrap_drawImageLayerGetPixel($5 + 40 | 0, $5 + 24 | 0) & 1 & (HEAP8[$5 + 23 | 0] & 1);
          HEAP32[$5 + 220 >> 2] = HEAP32[$5 + 240 >> 2] + HEAP32[$5 + 220 >> 2];
          HEAP32[$5 + 224 >> 2] = HEAP32[$5 + 224 >> 2] - HEAP32[$5 + 236 >> 2];
          HEAP32[$5 + 36 >> 2] = graphicsBlendColor($5 + 688 | 0, HEAP32[$5 + 36 >> 2], HEAP32[$5 + 32 >> 2], 128);
          HEAP32[$5 + 28 >> 2] = graphicsBlendColor($5 + 688 | 0, HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], 128);
          HEAP32[$5 + 564 >> 2] = graphicsBlendColor($5 + 688 | 0, HEAP32[$5 + 36 >> 2], HEAP32[$5 + 28 >> 2], 128);
          FUNCTION_TABLE[HEAP32[$5 + 252 >> 2]]($5 + 688 | 0, HEAP32[$5 + 572 >> 2], HEAP32[$5 + 568 >> 2], HEAP32[$5 + 564 >> 2]);
          HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 572 >> 2] + 1;
          continue;
         }
         break;
        }
        _jswrap_drawImageLayerNextY($5 + 272 | 0);
        _jswrap_drawImageLayerNextY($5 + 40 | 0);
        HEAP32[$5 + 568 >> 2] = HEAP32[$5 + 568 >> 2] + 1;
        continue;
       }
       break;
      }
      jsvStringIteratorFree_16($5 + 160 | 0);
      break label$32;
     }
     HEAP32[$5 + 568 >> 2] = HEAP32[$5 + 264 >> 2];
     while (1) {
      if (HEAP32[$5 + 568 >> 2] <= HEAP32[$5 + 256 >> 2]) {
       _jswrap_drawImageLayerStartX($5 + 272 | 0);
       HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 268 >> 2];
       while (1) {
        if (HEAP32[$5 + 572 >> 2] <= HEAP32[$5 + 260 >> 2]) {
         if (_jswrap_drawImageLayerGetPixel($5 + 272 | 0, $5 + 564 | 0) & 1) {
          FUNCTION_TABLE[HEAP32[$5 + 252 >> 2]]($5 + 688 | 0, HEAP32[$5 + 572 >> 2], HEAP32[$5 + 568 >> 2], HEAP32[$5 + 564 >> 2]);
         }
         _jswrap_drawImageLayerNextX($5 + 272 | 0);
         HEAP32[$5 + 572 >> 2] = HEAP32[$5 + 572 >> 2] + 1;
         continue;
        }
        break;
       }
       _jswrap_drawImageLayerNextY($5 + 272 | 0);
       HEAP32[$5 + 568 >> 2] = HEAP32[$5 + 568 >> 2] + 1;
       continue;
      }
      break;
     }
    }
    $2 = $5 + 272 | 0;
    HEAP32[$5 + 560 >> 2] = HEAP32[$2 + 152 >> 2];
    $1 = HEAP32[$2 + 144 >> 2];
    $0 = HEAP32[$2 + 148 >> 2];
    HEAP32[$5 + 552 >> 2] = $1;
    HEAP32[$5 + 556 >> 2] = $0;
    $1 = HEAP32[$2 + 140 >> 2];
    $0 = HEAP32[$2 + 136 >> 2];
    HEAP32[$5 + 544 >> 2] = $0;
    HEAP32[$5 + 548 >> 2] = $1;
    $0 = HEAP32[$2 + 132 >> 2];
    $1 = HEAP32[$2 + 128 >> 2];
    HEAP32[$5 + 536 >> 2] = $1;
    HEAP32[$5 + 540 >> 2] = $0;
    $1 = HEAP32[$2 + 124 >> 2];
    $0 = HEAP32[$2 + 120 >> 2];
    HEAP32[$5 + 528 >> 2] = $0;
    HEAP32[$5 + 532 >> 2] = $1;
   }
  }
  jsvStringIteratorFree_16($5 + 528 | 0);
  _jswrap_graphics_freeImageInfo($5 + 600 | 0);
  graphicsSetVar($5 + 688 | 0);
  HEAP32[$5 + 780 >> 2] = jsvLockAgain(HEAP32[$5 + 776 >> 2]);
 }
 __stack_pointer = $5 + 784 | 0;
 return HEAP32[$5 + 780 >> 2];
}

function jswrap_graphics_drawString($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = __stack_pointer - 432 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 424 >> 2] = $0;
 HEAP32[$5 + 420 >> 2] = $1;
 HEAP32[$5 + 416 >> 2] = $2;
 HEAP32[$5 + 412 >> 2] = $3;
 HEAP8[$5 + 411 | 0] = $4;
 label$1: {
  if (!(graphicsGetFromVar($5 + 336 | 0, HEAP32[$5 + 424 >> 2]) & 1)) {
   HEAP32[$5 + 428 >> 2] = 0;
   break label$1;
  }
  _jswrap_graphics_getFontInfo($5 + 336 | 0, $5 + 312 | 0);
  HEAP32[$5 + 308 >> 2] = _jswrap_graphics_getFontHeightInternal($5 + 336 | 0, $5 + 312 | 0);
  HEAP32[$5 + 304 >> 2] = 1;
  if (HEAP32[$5 + 312 >> 2] & 32768) {
   if ((HEAP32[$5 + 312 >> 2] & 57344) == 40960) {
    HEAP32[$5 + 304 >> 2] = 2;
   }
   if ((HEAP32[$5 + 312 >> 2] & 57344) == 49152) {
    HEAP32[$5 + 304 >> 2] = 4;
   }
  }
  HEAP32[$5 + 300 >> 2] = HEAPU8[$5 + 344 | 0] | HEAPU8[$5 + 345 | 0] << 8 | (HEAPU8[$5 + 346 | 0] << 16 | HEAPU8[$5 + 347 | 0] << 24);
  label$6: {
   if ((HEAPU8[$5 + 367 | 0] >>> 4 & 3) == 1) {
    $0 = (HEAPU8[$5 + 344 | 0] | HEAPU8[$5 + 345 | 0] << 8 | (HEAPU8[$5 + 346 | 0] << 16 | HEAPU8[$5 + 347 | 0] << 24)) ^ 48;
    HEAP8[$5 + 344 | 0] = $0;
    HEAP8[$5 + 345 | 0] = $0 >>> 8;
    HEAP8[$5 + 346 | 0] = $0 >>> 16;
    HEAP8[$5 + 347 | 0] = $0 >>> 24;
    HEAP32[$5 + 296 >> 2] = (HEAPU8[$5 + 348 | 0] | HEAPU8[$5 + 349 | 0] << 8) - (HEAP32[$5 + 416 >> 2] + 1 | 0);
    HEAP32[$5 + 416 >> 2] = HEAP32[$5 + 412 >> 2];
    HEAP32[$5 + 412 >> 2] = HEAP32[$5 + 296 >> 2];
    break label$6;
   }
   label$8: {
    if ((HEAPU8[$5 + 367 | 0] >>> 4 & 3) == 2) {
     $0 = (HEAPU8[$5 + 344 | 0] | HEAPU8[$5 + 345 | 0] << 8 | (HEAPU8[$5 + 346 | 0] << 16 | HEAPU8[$5 + 347 | 0] << 24)) ^ 96;
     HEAP8[$5 + 344 | 0] = $0;
     HEAP8[$5 + 345 | 0] = $0 >>> 8;
     HEAP8[$5 + 346 | 0] = $0 >>> 16;
     HEAP8[$5 + 347 | 0] = $0 >>> 24;
     HEAP32[$5 + 416 >> 2] = (HEAPU8[$5 + 348 | 0] | HEAPU8[$5 + 349 | 0] << 8) - (HEAP32[$5 + 416 >> 2] + 1 | 0);
     HEAP32[$5 + 412 >> 2] = (HEAPU8[$5 + 350 | 0] | HEAPU8[$5 + 351 | 0] << 8) - (HEAP32[$5 + 412 >> 2] + 1 | 0);
     break label$8;
    }
    if ((HEAPU8[$5 + 367 | 0] >>> 4 & 3) == 3) {
     $0 = (HEAPU8[$5 + 344 | 0] | HEAPU8[$5 + 345 | 0] << 8 | (HEAPU8[$5 + 346 | 0] << 16 | HEAPU8[$5 + 347 | 0] << 24)) ^ 80;
     HEAP8[$5 + 344 | 0] = $0;
     HEAP8[$5 + 345 | 0] = $0 >>> 8;
     HEAP8[$5 + 346 | 0] = $0 >>> 16;
     HEAP8[$5 + 347 | 0] = $0 >>> 24;
     HEAP32[$5 + 292 >> 2] = (HEAPU8[$5 + 350 | 0] | HEAPU8[$5 + 351 | 0] << 8) - (HEAP32[$5 + 412 >> 2] + 1 | 0);
     HEAP32[$5 + 412 >> 2] = HEAP32[$5 + 416 >> 2];
     HEAP32[$5 + 416 >> 2] = HEAP32[$5 + 292 >> 2];
    }
   }
  }
  HEAP32[$5 + 288 >> 2] = jsvAsString(HEAP32[$5 + 420 >> 2]);
  HEAP32[$5 + 284 >> 2] = HEAP32[$5 + 416 >> 2];
  if ((HEAPU8[$5 + 367 | 0] & 3) >>> 0 < 2) {
   HEAP32[$5 + 416 >> 2] = HEAP32[$5 + 284 >> 2] - ((Math_imul(_jswrap_graphics_stringWidth($5 + 336 | 0, HEAP32[$5 + 288 >> 2], 0), (HEAPU8[$5 + 367 | 0] & 3) + 1 | 0) | 0) / 2 | 0);
  }
  if ((HEAPU8[$5 + 367 | 0] >>> 2 & 3) >>> 0 < 2) {
   _jswrap_graphics_stringMetrics($5 + 336 | 0, HEAP32[$5 + 288 >> 2], -1, $5 + 264 | 0);
   HEAP32[$5 + 412 >> 2] = HEAP32[$5 + 412 >> 2] - ((Math_imul(HEAP32[$5 + 268 >> 2], (HEAPU8[$5 + 367 | 0] >>> 2 & 3) + 1 | 0) | 0) / 2 | 0);
  }
  HEAP32[$5 + 260 >> 2] = HEAPU8[$5 + 368 | 0] | HEAPU8[$5 + 369 | 0] << 8;
  HEAP32[$5 + 256 >> 2] = HEAPU8[$5 + 370 | 0] | HEAPU8[$5 + 371 | 0] << 8;
  HEAP32[$5 + 252 >> 2] = HEAPU8[$5 + 372 | 0] | HEAPU8[$5 + 373 | 0] << 8;
  HEAP32[$5 + 248 >> 2] = HEAPU8[$5 + 374 | 0] | HEAPU8[$5 + 375 | 0] << 8;
  deviceToGraphicsCoordinates($5 + 336 | 0, $5 + 260 | 0, $5 + 256 | 0);
  deviceToGraphicsCoordinates($5 + 336 | 0, $5 + 252 | 0, $5 + 248 | 0);
  if (HEAP32[$5 + 252 >> 2] < HEAP32[$5 + 260 >> 2]) {
   HEAP32[$5 + 244 >> 2] = HEAP32[$5 + 260 >> 2];
   HEAP32[$5 + 260 >> 2] = HEAP32[$5 + 252 >> 2];
   HEAP32[$5 + 252 >> 2] = HEAP32[$5 + 244 >> 2];
  }
  if (HEAP32[$5 + 248 >> 2] < HEAP32[$5 + 256 >> 2]) {
   HEAP32[$5 + 240 >> 2] = HEAP32[$5 + 256 >> 2];
   HEAP32[$5 + 256 >> 2] = HEAP32[$5 + 248 >> 2];
   HEAP32[$5 + 248 >> 2] = HEAP32[$5 + 240 >> 2];
  }
  jsvStringIteratorNewUTF8($5 + 200 | 0, HEAP32[$5 + 288 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar_12($5 + 200 | 0) & 1) {
    HEAP32[$5 + 196 >> 2] = jsvStringIteratorGetUTF8CharAndNext($5 + 200 | 0);
    if (HEAP32[$5 + 196 >> 2] == 10) {
     HEAP32[$5 + 416 >> 2] = HEAP32[$5 + 284 >> 2];
     if ((HEAPU8[$5 + 367 | 0] & 3) >>> 0 < 2) {
      $0 = HEAP32[$5 + 288 >> 2];
      HEAP32[$5 + 416 >> 2] = HEAP32[$5 + 284 >> 2] - ((Math_imul(_jswrap_graphics_stringWidth($5 + 336 | 0, $0, jsvConvertToUTF8Index($0, jsvStringIteratorGetIndex_6($5 + 200 | 0))), (HEAPU8[$5 + 367 | 0] & 3) + 1 | 0) | 0) / 2 | 0);
     }
     HEAP32[$5 + 412 >> 2] = HEAP32[$5 + 308 >> 2] + HEAP32[$5 + 412 >> 2];
     continue;
    }
    if (!HEAP32[$5 + 196 >> 2]) {
     HEAP32[$5 + 108 >> 2] = jsvConvertToUTF8Index(HEAP32[$5 + 288 >> 2], jsvStringIteratorGetIndex_6($5 + 200 | 0));
     if (_jswrap_graphics_parseImage($5 + 336 | 0, HEAP32[$5 + 288 >> 2], HEAP32[$5 + 108 >> 2], $5 + 112 | 0) & 1) {
      jsvStringIteratorGotoUTF8($5 + 200 | 0, HEAP32[$5 + 288 >> 2], HEAP32[$5 + 108 >> 2] + HEAPU16[$5 + 160 >> 1] | 0);
      _jswrap_drawImageSimple($5 + 336 | 0, HEAP32[$5 + 416 >> 2], HEAP32[$5 + 412 >> 2] + ((HEAP32[$5 + 308 >> 2] - HEAP32[$5 + 116 >> 2] | 0) / 2 | 0) | 0, $5 + 112 | 0, $5 + 200 | 0, 1);
      _jswrap_graphics_freeImageInfo($5 + 112 | 0);
      HEAP32[$5 + 416 >> 2] = HEAP32[$5 + 112 >> 2] + HEAP32[$5 + 416 >> 2];
     }
     continue;
    }
    label$21: {
     if (!(HEAP32[$5 + 312 >> 2] | HEAP32[$5 + 196 >> 2] >= 256)) {
      HEAP32[$5 + 104 >> 2] = graphicsVectorCharWidth(HEAPU16[$5 + 318 >> 1], HEAP32[$5 + 196 >> 2] << 24 >> 24);
      if (!(HEAP32[$5 + 416 >> 2] <= (HEAP32[$5 + 260 >> 2] - HEAP32[$5 + 104 >> 2] | 0) | HEAP32[$5 + 416 >> 2] >= HEAP32[$5 + 252 >> 2] | (HEAP32[$5 + 412 >> 2] <= (HEAP32[$5 + 256 >> 2] - HEAP32[$5 + 308 >> 2] | 0) | HEAP32[$5 + 412 >> 2] > HEAP32[$5 + 248 >> 2]))) {
       if (HEAP8[$5 + 411 | 0] & 1) {
        graphicsFillRect($5 + 336 | 0, HEAP32[$5 + 416 >> 2], HEAP32[$5 + 412 >> 2], (HEAP32[$5 + 416 >> 2] + HEAP32[$5 + 104 >> 2] | 0) - 1 | 0, (HEAP32[$5 + 412 >> 2] + HEAP32[$5 + 308 >> 2] | 0) - 1 | 0, HEAPU8[$5 + 357 | 0] | HEAPU8[$5 + 358 | 0] << 8 | (HEAPU8[$5 + 359 | 0] << 16 | HEAPU8[$5 + 360 | 0] << 24));
       }
       graphicsGetVectorChar(663, $5 + 336 | 0, HEAP32[$5 + 416 >> 2], HEAP32[$5 + 412 >> 2], HEAPU16[$5 + 318 >> 1], HEAPU16[$5 + 320 >> 1], HEAP32[$5 + 196 >> 2] << 24 >> 24);
      }
      HEAP32[$5 + 416 >> 2] = HEAP32[$5 + 104 >> 2] + HEAP32[$5 + 416 >> 2];
      break label$21;
     }
     label$25: {
      if (!(HEAP32[$5 + 312 >> 2] != 8192 | HEAP32[$5 + 196 >> 2] >= 256)) {
       if (!(HEAP32[$5 + 416 >> 2] <= (HEAP32[$5 + 260 >> 2] - (HEAPU16[$5 + 318 >> 1] << 2) | 0) | HEAP32[$5 + 416 >> 2] >= HEAP32[$5 + 252 >> 2] | (HEAP32[$5 + 412 >> 2] <= (HEAP32[$5 + 256 >> 2] - HEAP32[$5 + 308 >> 2] | 0) | HEAP32[$5 + 412 >> 2] > HEAP32[$5 + 248 >> 2]))) {
        graphicsDrawChar4x6($5 + 336 | 0, HEAP32[$5 + 416 >> 2], HEAP32[$5 + 412 >> 2], HEAP32[$5 + 196 >> 2] << 24 >> 24, HEAPU16[$5 + 318 >> 1], HEAPU16[$5 + 320 >> 1], HEAP8[$5 + 411 | 0] & 1);
       }
       HEAP32[$5 + 416 >> 2] = HEAP32[$5 + 416 >> 2] + (HEAPU16[$5 + 318 >> 1] << 2);
       break label$25;
      }
      label$28: {
       if (HEAP32[$5 + 312 >> 2] == 16384) {
        if (!(HEAP32[$5 + 416 >> 2] <= (HEAP32[$5 + 260 >> 2] - Math_imul(HEAPU16[$5 + 318 >> 1], 6) | 0) | HEAP32[$5 + 416 >> 2] >= HEAP32[$5 + 252 >> 2] | (HEAP32[$5 + 412 >> 2] <= (HEAP32[$5 + 256 >> 2] - HEAP32[$5 + 308 >> 2] | 0) | HEAP32[$5 + 412 >> 2] > HEAP32[$5 + 248 >> 2]))) {
         graphicsDrawChar6x8($5 + 336 | 0, HEAP32[$5 + 416 >> 2], HEAP32[$5 + 412 >> 2], HEAP32[$5 + 196 >> 2] << 24 >> 24, HEAPU16[$5 + 318 >> 1], HEAPU16[$5 + 320 >> 1], HEAP8[$5 + 411 | 0] & 1);
        }
        HEAP32[$5 + 416 >> 2] = HEAP32[$5 + 416 >> 2] + Math_imul(HEAPU16[$5 + 318 >> 1], 6);
        break label$28;
       }
       if (!(!(HEAP32[$5 + 312 >> 2] & 32768) | HEAP32[$5 + 196 >> 2] >= 256)) {
        HEAP32[$5 + 100 >> 2] = (1 << HEAP32[$5 + 304 >> 2]) - 1;
        HEAP32[$5 + 96 >> 2] = 0;
        HEAP32[$5 + 92 >> 2] = 0;
        label$32: {
         if (jsvIsString(HEAP32[$5 + 324 >> 2]) & 1) {
          if (HEAP32[$5 + 196 >> 2] >= HEAPU8[$5 + 322 | 0]) {
           jsvStringIteratorNew($5 + 56 | 0, HEAP32[$5 + 324 >> 2], 0);
           while (1) {
            $0 = 0;
            if (jsvStringIteratorHasChar_12($5 + 56 | 0) & 1) {
             $0 = (jsvStringIteratorGetIndex_6($5 + 56 | 0) | 0) < (HEAP32[$5 + 196 >> 2] - HEAPU8[$5 + 322 | 0] | 0);
            }
            if ($0) {
             HEAP32[$5 + 92 >> 2] = (jsvStringIteratorGetCharAndNext($5 + 56 | 0) & 255) + HEAP32[$5 + 92 >> 2];
             continue;
            }
            break;
           }
           HEAP32[$5 + 96 >> 2] = jsvStringIteratorGetChar_6($5 + 56 | 0) & 255;
           jsvStringIteratorFree_16($5 + 56 | 0);
          }
          break label$32;
         }
         HEAP32[$5 + 96 >> 2] = jsvGetInteger(HEAP32[$5 + 324 >> 2]);
         HEAP32[$5 + 92 >> 2] = Math_imul(HEAP32[$5 + 96 >> 2], HEAP32[$5 + 196 >> 2] - HEAPU8[$5 + 322 | 0] | 0);
        }
        label$38: {
         if (HEAP32[$5 + 196 >> 2] < HEAPU8[$5 + 322 | 0] | HEAP32[$5 + 416 >> 2] <= (HEAP32[$5 + 260 >> 2] - Math_imul(HEAP32[$5 + 96 >> 2], HEAPU16[$5 + 318 >> 1]) | 0) | (HEAP32[$5 + 412 >> 2] <= (HEAP32[$5 + 256 >> 2] - HEAP32[$5 + 308 >> 2] | 0) | HEAP32[$5 + 416 >> 2] >= HEAP32[$5 + 252 >> 2])) {
          break label$38;
         }
         if (HEAP32[$5 + 412 >> 2] > HEAP32[$5 + 248 >> 2]) {
          break label$38;
         }
         HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 308 >> 2] / HEAPU16[$5 + 320 >> 1];
         HEAP32[$5 + 92 >> 2] = Math_imul(HEAP32[$5 + 92 >> 2], Math_imul(HEAP32[$5 + 52 >> 2], HEAP32[$5 + 304 >> 2]));
         jsvStringIteratorNew($5 + 16 | 0, HEAP32[$5 + 328 >> 2], HEAP32[$5 + 92 >> 2] >> 3);
         HEAP32[$5 + 92 >> 2] = HEAP32[$5 + 92 >> 2] & 7;
         HEAP32[$5 + 4 >> 2] = jsvStringIteratorGetChar_6($5 + 16 | 0) << 24 >> 24;
         HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] << Math_imul(HEAP32[$5 + 304 >> 2], HEAP32[$5 + 92 >> 2]);
         HEAP32[$5 + 12 >> 2] = 0;
         while (1) {
          if (HEAP32[$5 + 12 >> 2] < HEAP32[$5 + 96 >> 2]) {
           HEAP32[$5 + 8 >> 2] = 0;
           while (1) {
            if (HEAP32[$5 + 8 >> 2] < HEAP32[$5 + 52 >> 2]) {
             HEAP32[$5 >> 2] = (HEAP32[$5 + 4 >> 2] & 255) >> 8 - HEAP32[$5 + 304 >> 2];
             if (HEAP32[$5 >> 2] ? 1 : HEAP8[$5 + 411 | 0] & 1) {
              graphicsFillRect($5 + 336 | 0, HEAP32[$5 + 416 >> 2] + Math_imul(HEAP32[$5 + 12 >> 2], HEAPU16[$5 + 318 >> 1]) | 0, HEAP32[$5 + 412 >> 2] + Math_imul(HEAP32[$5 + 8 >> 2], HEAPU16[$5 + 320 >> 1]) | 0, (HEAPU16[$5 + 318 >> 1] + (HEAP32[$5 + 416 >> 2] + Math_imul(HEAP32[$5 + 12 >> 2], HEAPU16[$5 + 318 >> 1]) | 0) | 0) - 1 | 0, (HEAPU16[$5 + 320 >> 1] + (HEAP32[$5 + 412 >> 2] + Math_imul(HEAP32[$5 + 8 >> 2], HEAPU16[$5 + 320 >> 1]) | 0) | 0) - 1 | 0, graphicsBlendGfxColor($5 + 336 | 0, (HEAP32[$5 >> 2] << 8) / HEAP32[$5 + 100 >> 2] | 0));
             }
             HEAP32[$5 + 92 >> 2] = HEAP32[$5 + 304 >> 2] + HEAP32[$5 + 92 >> 2];
             HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] << HEAP32[$5 + 304 >> 2];
             if (HEAP32[$5 + 92 >> 2] >= 8) {
              HEAP32[$5 + 92 >> 2] = 0;
              jsvStringIteratorNext($5 + 16 | 0);
              HEAP32[$5 + 4 >> 2] = jsvStringIteratorGetChar_6($5 + 16 | 0) << 24 >> 24;
             }
             HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
           continue;
          }
          break;
         }
         jsvStringIteratorFree_16($5 + 16 | 0);
        }
        HEAP32[$5 + 416 >> 2] = HEAP32[$5 + 416 >> 2] + Math_imul(HEAP32[$5 + 96 >> 2], HEAPU16[$5 + 318 >> 1]);
       }
      }
     }
    }
    if (!(jspIsInterrupted() & 1)) {
     continue;
    }
   }
   break;
  }
  jsvStringIteratorFree_16($5 + 200 | 0);
  jsvUnLock(HEAP32[$5 + 288 >> 2]);
  $0 = HEAP32[$5 + 300 >> 2];
  HEAP8[$5 + 344 | 0] = $0;
  HEAP8[$5 + 345 | 0] = $0 >>> 8;
  HEAP8[$5 + 346 | 0] = $0 >>> 16;
  HEAP8[$5 + 347 | 0] = $0 >>> 24;
  graphicsSetVar($5 + 336 | 0);
  _jswrap_graphics_freeFontInfo($5 + 312 | 0);
  HEAP32[$5 + 428 >> 2] = jsvLockAgain(HEAP32[$5 + 424 >> 2]);
 }
 __stack_pointer = $5 + 432 | 0;
 return HEAP32[$5 + 428 >> 2];
}

function jswrap_graphics_drawImages($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 304 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 296 >> 2] = $0;
 HEAP32[$3 + 292 >> 2] = $1;
 HEAP32[$3 + 288 >> 2] = $2;
 HEAP32[$3 + 284 >> 2] = 4;
 label$1: {
  if (!(graphicsGetFromVar($3 + 208 | 0, HEAP32[$3 + 296 >> 2]) & 1)) {
   HEAP32[$3 + 300 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 204 >> 2] = $3;
  $2 = $3 - 768 | 0;
  __stack_pointer = $2;
  label$3: {
   label$4: {
    if (jsvIsArray(HEAP32[$3 + 292 >> 2]) & 1) {
     $0 = jsvGetArrayLength(HEAP32[$3 + 292 >> 2]);
     HEAP32[$3 + 196 >> 2] = $0;
     if (($0 | 0) <= 4) {
      break label$4;
     }
    }
    HEAP32[$3 + 48 >> 2] = 4;
    jsExceptionHere(3, 120246, $3 + 48 | 0);
    HEAP32[$3 + 300 >> 2] = 0;
    break label$3;
   }
   HEAP32[$3 + 188 >> 2] = 1e4;
   HEAP32[$3 + 184 >> 2] = 1e4;
   HEAP32[$3 + 180 >> 2] = 1e4;
   HEAP32[$3 + 176 >> 2] = 1e4;
   HEAP8[$3 + 175 | 0] = 1;
   HEAP32[$3 + 200 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 200 >> 2] < HEAP32[$3 + 196 >> 2]) {
     HEAP32[$3 + 168 >> 2] = jsvGetArrayItem(HEAP32[$3 + 292 >> 2], HEAP32[$3 + 200 >> 2]);
     label$8: {
      if (jsvIsObject(HEAP32[$3 + 168 >> 2]) & 1) {
       HEAP32[$3 + 164 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 168 >> 2], 132688);
       label$10: {
        if (_jswrap_graphics_parseImage($3 + 208 | 0, HEAP32[$3 + 164 >> 2], 0, (Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 36 | 0) & 1) {
         $4 = jsvObjectGetFloatChild(HEAP32[$3 + 168 >> 2], 116522) * 256;
         label$12: {
          if (Math_abs($4) < 2147483648) {
           $0 = ~~$4;
           break label$12;
          }
          $0 = -2147483648;
         }
         HEAP32[Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 >> 2] = $0;
         $4 = jsvObjectGetFloatChild(HEAP32[$3 + 168 >> 2], 116397) * 256;
         label$14: {
          if (Math_abs($4) < 2147483648) {
           $0 = ~~$4;
           break label$14;
          }
          $0 = -2147483648;
         }
         HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 4 >> 2] = $0;
         $4 = jsvObjectGetFloatChild(HEAP32[$3 + 168 >> 2], 132619);
         HEAPF64[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 24 >> 3] = $4;
         $0 = __DOUBLE_BITS_11(HEAPF64[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 24 >> 3]);
         $1 = $0;
         $0 = i64toi32_i32$HIGH_BITS;
         $0 = $0 & 2147483647;
         if (HEAPF64[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 24 >> 3] <= 0 ? 1 : ($0 | 0) == 2146435072 | $0 >>> 0 > 2146435072) {
          HEAPF64[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 24 >> 3] = 1;
         }
         $4 = jsvObjectGetFloatChild(HEAP32[$3 + 168 >> 2], 131999);
         HEAPF64[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 16 >> 3] = $4;
         $0 = __DOUBLE_BITS_11(HEAPF64[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 16 >> 3]);
         $1 = $0;
         $0 = i64toi32_i32$HIGH_BITS;
         $0 = $0 & 2147483647;
         if (($0 | 0) == 2146435072 | $0 >>> 0 > 2146435072) {
          HEAPF64[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 16 >> 3] = 0;
         }
         $0 = jsvObjectGetBoolChild(HEAP32[$3 + 168 >> 2], 120999);
         HEAP8[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 32 | 0] = $0 & 1;
         $0 = jsvObjectGetBoolChild(HEAP32[$3 + 168 >> 2], 117940);
         HEAP8[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 33 | 0] = $0 & 1;
         _jswrap_drawImageLayerInit(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0);
         if (!(jsvObjectGetBoolChild(HEAP32[$3 + 168 >> 2], 120442) & 1)) {
          if (HEAP32[$3 + 188 >> 2] > HEAP32[Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 >> 2] >> 8) {
           HEAP32[$3 + 188 >> 2] = HEAP32[Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 >> 2] >> 8;
          }
          if (HEAP32[$3 + 184 >> 2] > HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 4 >> 2] >> 8) {
           HEAP32[$3 + 184 >> 2] = HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 4 >> 2] >> 8;
          }
          if ((HEAP32[$3 + 188 >> 2] + HEAP32[$3 + 180 >> 2] | 0) < HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 8 >> 2] + 255 >> 8) {
           HEAP32[$3 + 180 >> 2] = (HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 8 >> 2] + 255 >> 8) - HEAP32[$3 + 188 >> 2];
          }
          if ((HEAP32[$3 + 184 >> 2] + HEAP32[$3 + 176 >> 2] | 0) < HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 12 >> 2] + 255 >> 8) {
           HEAP32[$3 + 176 >> 2] = (HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 12 >> 2] + 255 >> 8) - HEAP32[$3 + 184 >> 2];
          }
         }
         HEAP32[$3 + 160 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 168 >> 2], 131932);
         if (HEAP32[$3 + 160 >> 2]) {
          jsvUnLock(_jswrap_graphics_parseImage_palette((Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 36 | 0, HEAP32[$3 + 160 >> 2]));
          if (!HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 64 >> 2]) {
           HEAP8[$3 + 175 | 0] = 0;
          }
         }
         HEAP32[$3 + 156 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 168 >> 2], 132071);
         HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 188 >> 2] = 0;
         label$27: {
          label$28: {
           if (HEAP32[$3 + 156 >> 2]) {
            if (jsvGetStringLength(HEAP32[$3 + 156 >> 2])) {
             break label$28;
            }
           }
           HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 188 >> 2] = 0;
           break label$27;
          }
          label$30: {
           if (jsvIsStringEqual(HEAP32[$3 + 156 >> 2], 134141) & 1) {
            HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 188 >> 2] = 1;
            break label$30;
           }
           label$32: {
            if (jsvIsStringEqual(HEAP32[$3 + 156 >> 2], 120976) & 1) {
             HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 188 >> 2] = 2;
             break label$32;
            }
            label$34: {
             if (jsvIsStringEqual(HEAP32[$3 + 156 >> 2], 120763) & 1) {
              HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 188 >> 2] = 3;
              break label$34;
             }
             HEAP32[$3 >> 2] = HEAP32[$3 + 156 >> 2];
             jsExceptionHere(1, 121539, $3);
             HEAP8[$3 + 175 | 0] = 0;
            }
           }
          }
         }
         jsvUnLock(HEAP32[$3 + 156 >> 2]);
         break label$10;
        }
        HEAP8[$3 + 175 | 0] = 0;
       }
       jsvUnLock(HEAP32[$3 + 164 >> 2]);
       break label$8;
      }
      HEAP8[$3 + 175 | 0] = 0;
     }
     jsvUnLock(HEAP32[$3 + 168 >> 2]);
     HEAP32[$3 + 200 >> 2] = HEAP32[$3 + 200 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$3 + 96 >> 2] = 116522;
   HEAP16[$3 + 100 >> 1] = 10;
   HEAP32[$3 + 104 >> 2] = $3 + 188;
   HEAP32[$3 + 108 >> 2] = 116397;
   HEAP16[$3 + 112 >> 1] = 10;
   HEAP32[$3 + 116 >> 2] = $3 + 184;
   HEAP32[$3 + 120 >> 2] = 129398;
   HEAP16[$3 + 124 >> 1] = 10;
   HEAP32[$3 + 128 >> 2] = $3 + 180;
   HEAP32[$3 + 132 >> 2] = 117745;
   HEAP16[$3 + 136 >> 1] = 10;
   HEAP32[$3 + 140 >> 2] = $3 + 176;
   if (!(jsvReadConfigObject(HEAP32[$3 + 288 >> 2], $3 + 96 | 0, 4) & 1)) {
    HEAP8[$3 + 175 | 0] = 0;
   }
   HEAP32[$3 + 92 >> 2] = (HEAP32[$3 + 188 >> 2] + HEAP32[$3 + 180 >> 2] | 0) - 1;
   HEAP32[$3 + 88 >> 2] = (HEAP32[$3 + 184 >> 2] + HEAP32[$3 + 176 >> 2] | 0) - 1;
   graphicsSetModifiedAndClip($3 + 208 | 0, $3 + 188 | 0, $3 + 184 | 0, $3 + 92 | 0, $3 + 88 | 0, 0);
   HEAP32[$3 + 84 >> 2] = graphicsGetSetPixelFn($3 + 208 | 0);
   if (HEAP8[$3 + 175 | 0] & 1) {
    HEAP32[$3 + 80 >> 2] = (1 << HEAPU8[$3 + 224 | 0]) - 1;
    HEAP32[$3 + 200 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 200 >> 2] < HEAP32[$3 + 196 >> 2]) {
      jsvStringIteratorNew((Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 120 | 0, HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 56 >> 2], HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 60 >> 2]);
      _jswrap_drawImageLayerSetStart(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0, HEAP32[$3 + 188 >> 2], HEAP32[$3 + 184 >> 2]);
      HEAP32[$3 + 200 >> 2] = HEAP32[$3 + 200 >> 2] + 1;
      continue;
     }
     break;
    }
    HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 184 >> 2];
    while (1) {
     if (HEAP32[$3 + 76 >> 2] <= HEAP32[$3 + 88 >> 2]) {
      HEAP32[$3 + 200 >> 2] = 0;
      while (1) {
       if (HEAP32[$3 + 200 >> 2] < HEAP32[$3 + 196 >> 2]) {
        _jswrap_drawImageLayerStartX(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0);
        HEAP32[$3 + 200 >> 2] = HEAP32[$3 + 200 >> 2] + 1;
        continue;
       }
       break;
      }
      HEAP32[$3 + 72 >> 2] = HEAP32[$3 + 188 >> 2];
      while (1) {
       if (HEAP32[$3 + 72 >> 2] <= HEAP32[$3 + 92 >> 2]) {
        HEAP8[$3 + 71 | 0] = 0;
        HEAP32[$3 + 64 >> 2] = 0;
        HEAP32[$3 + 200 >> 2] = 0;
        while (1) {
         if (HEAP32[$3 + 200 >> 2] < HEAP32[$3 + 196 >> 2]) {
          if (_jswrap_drawImageLayerGetPixel(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0, $3 + 60 | 0) & 1) {
           HEAP8[$3 + 71 | 0] = 1;
           if (!(HEAP32[$3 + 200 >> 2] | !HEAP32[$2 + 188 >> 2])) {
            HEAP32[$3 + 64 >> 2] = graphicsGetPixel($3 + 208 | 0, HEAP32[$3 + 72 >> 2], HEAP32[$3 + 76 >> 2]);
           }
           label$50: {
            label$51: {
             switch (HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 188 >> 2]) {
             case 0:
              HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 60 >> 2];
              break label$50;

             case 1:
              HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 60 >> 2] + HEAP32[$3 + 64 >> 2];
              if (HEAPU32[$3 + 64 >> 2] > HEAPU32[$3 + 80 >> 2]) {
               HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 80 >> 2];
              }
              break label$50;

             case 2:
              HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 60 >> 2] | HEAP32[$3 + 64 >> 2];
              break label$50;

             case 3:
              break label$51;

             default:
              break label$50;
             }
            }
            HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 60 >> 2] ^ HEAP32[$3 + 64 >> 2];
           }
          }
          _jswrap_drawImageLayerNextX(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0);
          _jswrap_drawImageLayerNextXRepeat(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0);
          HEAP32[$3 + 200 >> 2] = HEAP32[$3 + 200 >> 2] + 1;
          continue;
         }
         break;
        }
        if (HEAP8[$3 + 71 | 0] & 1) {
         FUNCTION_TABLE[HEAP32[$3 + 84 >> 2]]($3 + 208 | 0, HEAP32[$3 + 72 >> 2], HEAP32[$3 + 76 >> 2], HEAP32[$3 + 64 >> 2]);
        }
        HEAP32[$3 + 72 >> 2] = HEAP32[$3 + 72 >> 2] + 1;
        continue;
       }
       break;
      }
      HEAP32[$3 + 200 >> 2] = 0;
      while (1) {
       if (HEAP32[$3 + 200 >> 2] < HEAP32[$3 + 196 >> 2]) {
        _jswrap_drawImageLayerNextY(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0);
        HEAP32[$3 + 200 >> 2] = HEAP32[$3 + 200 >> 2] + 1;
        continue;
       }
       break;
      }
      HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
      continue;
     }
     break;
    }
    HEAP32[$3 + 200 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 200 >> 2] < HEAP32[$3 + 196 >> 2]) {
      jsvStringIteratorFree_16((Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 120 | 0);
      HEAP32[$3 + 200 >> 2] = HEAP32[$3 + 200 >> 2] + 1;
      continue;
     }
     break;
    }
   }
   HEAP32[$3 + 200 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 200 >> 2] < HEAP32[$3 + 196 >> 2]) {
     jsvUnLock(HEAP32[(Math_imul(HEAP32[$3 + 200 >> 2], 192) + $2 | 0) + 56 >> 2]);
     HEAP32[$3 + 200 >> 2] = HEAP32[$3 + 200 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$3 + 300 >> 2] = jsvLockAgain(HEAP32[$3 + 296 >> 2]);
  }
  HEAP32[$3 + 192 >> 2] = 1;
 }
 __stack_pointer = $3 + 304 | 0;
 return HEAP32[$3 + 300 >> 2];
}

function jswrap_banglejs_idle() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0;
 $2 = __stack_pointer - 352 | 0;
 $0 = $2;
 __stack_pointer = $0;
 HEAP32[$0 + 348 >> 2] = jsvObjectGetChildIfExists(HEAP32[91086], 132487);
 label$1: {
  if (jsiObjectHasCallbacks(HEAP32[$0 + 348 >> 2], 128987) & 1) {
   HEAP32[97749] = HEAP32[97749] | 1024;
   break label$1;
  }
  HEAP32[97749] = HEAP32[97749] & -1025;
 }
 if (!HEAP32[$0 + 348 >> 2]) {
  HEAP32[97752] = 0;
 }
 if (HEAP32[97752]) {
  if (HEAP32[97752] & 4) {
   jswrap_banglejs_setLCDPower(0);
  }
  if (HEAP32[97752] & 2) {
   jswrap_banglejs_setLCDPower(1);
  }
  if (HEAP32[97752] & 16) {
   jswrap_banglejs_setLCDPowerBacklight(0);
  }
  if (HEAP32[97752] & 8) {
   jswrap_banglejs_setLCDPowerBacklight(1);
  }
  if (HEAP32[97752] & 32) {
   _jswrap_banglejs_setLocked(1, HEAP32[97750]);
   HEAP32[97750] = 0;
  }
  if (HEAP32[97752] & 64) {
   _jswrap_banglejs_setLocked(0, HEAP32[97750]);
   HEAP32[97750] = 0;
  }
  if (HEAP32[97752] & 1) {
   HEAP16[182206] = HEAPU16[182206] | 64;
  }
  if (HEAP32[97752] & 67108864) {
   jswrap_banglejs_setPollInterval_internal(80);
  }
  if (HEAP32[97752] & 134217728) {
   jswrap_banglejs_setPollInterval_internal(800);
  }
  if (HEAP32[97752] & 128) {
   HEAP32[$0 + 344 >> 2] = jswrap_banglejs_getAccel();
   if (HEAP32[$0 + 344 >> 2]) {
    jsiQueueObjectCallbacks(HEAP32[$0 + 348 >> 2], 128987, $0 + 344 | 0, 1);
    jsvUnLock(HEAP32[$0 + 344 >> 2]);
   }
  }
  if (HEAP32[97752] & 256) {
   HEAP32[$0 + 340 >> 2] = jsvNewObject();
   if (HEAP32[$0 + 340 >> 2]) {
    HEAP32[$0 + 336 >> 2] = 148267;
    if (HEAPU8[391164] & 2) {
     HEAP32[$0 + 336 >> 2] = 117448;
    }
    if (HEAP8[391164] & 1) {
     HEAP32[$0 + 336 >> 2] = 129131;
    }
    if (HEAPU8[391164] & 8) {
     HEAP32[$0 + 336 >> 2] = 128665;
    }
    if (HEAPU8[391164] & 4) {
     HEAP32[$0 + 336 >> 2] = 121719;
    }
    if (HEAPU8[391164] & 16) {
     HEAP32[$0 + 336 >> 2] = 117700;
    }
    if (HEAPU8[391164] & 32) {
     HEAP32[$0 + 336 >> 2] = 117782;
    }
    HEAP32[$0 + 332 >> 2] = HEAPU8[391164] & 128 ? 2 : 1;
    jsvObjectSetChildAndUnLock(HEAP32[$0 + 340 >> 2], 120979, jsvNewFromString(HEAP32[$0 + 336 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$0 + 340 >> 2], 132494, jsvNewFromBool((HEAPU8[391164] & 128) != 0));
    $3 = HEAP32[$0 + 340 >> 2];
    if (HEAPU8[391164] & 16) {
     $1 = 0 - HEAP32[$0 + 332 >> 2] | 0;
    } else {
     if (HEAPU8[391164] & 32) {
      $1 = HEAP32[$0 + 332 >> 2];
     } else {
      $1 = 0;
     }
    }
    jsvObjectSetChildAndUnLock($3, 116522, jsvNewFromInteger($1));
    $3 = HEAP32[$0 + 340 >> 2];
    if (HEAPU8[391164] & 4) {
     $1 = 0 - HEAP32[$0 + 332 >> 2] | 0;
    } else {
     if (HEAPU8[391164] & 8) {
      $1 = HEAP32[$0 + 332 >> 2];
     } else {
      $1 = 0;
     }
    }
    jsvObjectSetChildAndUnLock($3, 116397, jsvNewFromInteger($1));
    $3 = HEAP32[$0 + 340 >> 2];
    if (HEAP8[391164] & 1) {
     $1 = 0 - HEAP32[$0 + 332 >> 2] | 0;
    } else {
     if (HEAPU8[391164] & 2) {
      $1 = HEAP32[$0 + 332 >> 2];
     } else {
      $1 = 0;
     }
    }
    jsvObjectSetChildAndUnLock($3, 116106, jsvNewFromInteger($1));
    jsiQueueObjectCallbacks(HEAP32[$0 + 348 >> 2], 121842, $0 + 340 | 0, 1);
    jsvUnLock(HEAP32[$0 + 340 >> 2]);
   }
  }
  if (HEAP32[97752] & 16384) {
   label$37: {
    if (!HEAP32[$0 + 348 >> 2]) {
     break label$37;
    }
    if (!(jsiObjectHasCallbacks(HEAP32[$0 + 348 >> 2], 130066) & 1)) {
     break label$37;
    }
    HEAP32[$0 + 328 >> 2] = jswrap_banglejs_getCompass();
    if (HEAP32[$0 + 328 >> 2]) {
     jsiQueueObjectCallbacks(HEAP32[$0 + 348 >> 2], 130066, $0 + 328 | 0, 1);
     jsvUnLock(HEAP32[$0 + 328 >> 2]);
    }
   }
  }
  if (HEAP32[97752] & 536870912) {
   HEAP32[$0 + 324 >> 2] = _jswrap_banglejs_getHealthStatusObject(391104);
   if (HEAP32[$0 + 324 >> 2]) {
    jsiQueueObjectCallbacks(HEAP32[$0 + 348 >> 2], 129330, $0 + 324 | 0, 1);
    jsvUnLock(HEAP32[$0 + 324 >> 2]);
   }
  }
  if (HEAP32[97752] & 1073741824) {
   jsiQueueObjectCallbacks(HEAP32[$0 + 348 >> 2], 117706, 0, 0);
  }
  if (HEAP32[97752] & 32768) {
   if (jsiObjectHasCallbacks(HEAP32[$0 + 348 >> 2], 132103) & 1) {
    HEAP32[$0 + 320 >> 2] = jsvNewTypedArray(17, Math_imul(HEAPU8[391165], 3));
    if (HEAP32[$0 + 320 >> 2]) {
     HEAP32[$0 + 316 >> 2] = HEAPU8[391166] - Math_imul(HEAPU8[391165], 3);
     while (1) {
      if (HEAP32[$0 + 316 >> 2] < 0) {
       HEAP32[$0 + 316 >> 2] = HEAP32[$0 + 316 >> 2] + 150;
       continue;
      }
      break;
     }
     jsvArrayBufferIteratorNew($0 + 256 | 0, HEAP32[$0 + 320 >> 2], 0);
     HEAP32[$0 + 252 >> 2] = 0;
     while (1) {
      if (HEAP32[$0 + 252 >> 2] < (Math_imul(HEAPU8[391165], 3) | 0)) {
       $1 = HEAP32[$0 + 316 >> 2];
       HEAP32[$0 + 316 >> 2] = $1 + 1;
       jsvArrayBufferIteratorSetByteValue($0 + 256 | 0, HEAP8[$1 + 391168 | 0]);
       jsvArrayBufferIteratorNext($0 + 256 | 0);
       if (HEAP32[$0 + 316 >> 2] >= 150) {
        HEAP32[$0 + 316 >> 2] = HEAP32[$0 + 316 >> 2] - 150;
       }
       HEAP32[$0 + 252 >> 2] = HEAP32[$0 + 252 >> 2] + 1;
       continue;
      }
      break;
     }
     jsvArrayBufferIteratorFree($0 + 256 | 0);
     jsiQueueObjectCallbacks(HEAP32[$0 + 348 >> 2], 132103, $0 + 320 | 0, 1);
     jsvUnLock(HEAP32[$0 + 320 >> 2]);
    }
   }
   if (jsiObjectHasCallbacks(HEAP32[$0 + 348 >> 2], 132114) & 1) {
    jsfNameFromString($0 + 184 | 0, 128818);
    HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 208 >> 2];
    $3 = HEAP32[$0 + 204 >> 2];
    $1 = HEAP32[$0 + 200 >> 2];
    HEAP32[$0 + 24 >> 2] = $1;
    HEAP32[$0 + 28 >> 2] = $3;
    $1 = HEAP32[$0 + 196 >> 2];
    $3 = HEAP32[$0 + 192 >> 2];
    HEAP32[$0 + 16 >> 2] = $3;
    HEAP32[$0 + 20 >> 2] = $1;
    $3 = HEAP32[$0 + 188 >> 2];
    $1 = HEAP32[$0 + 184 >> 2];
    HEAP32[$0 + 8 >> 2] = $1;
    HEAP32[$0 + 12 >> 2] = $3;
    HEAP32[$0 + 212 >> 2] = jsfFindFile($0 + 8 | 0, $0 + 216 | 0);
    label$51: {
     if (!HEAP32[$0 + 212 >> 2]) {
      jsiConsolePrintf(146693, 0);
      break label$51;
     }
     HEAP32[$0 + 180 >> 2] = jsfGetFileSize($0 + 216 | 0);
     $2 = $2 - (HEAP32[$0 + 180 >> 2] + 15 & -16) | 0;
     __stack_pointer = $2;
     HEAP32[$0 + 176 >> 2] = $2;
     jshFlashRead(HEAP32[$0 + 176 >> 2], HEAP32[$0 + 212 >> 2], HEAP32[$0 + 180 >> 2]);
     HEAP32[$0 + 172 >> 2] = jsvNewNativeString(HEAP32[$0 + 176 >> 2], HEAP32[$0 + 180 >> 2]);
     while (1) {
      if (jsiFreeMoreMemory() & 1) {
       continue;
      }
      break;
     }
     jsvGarbageCollect();
     HEAP32[$0 + 168 >> 2] = jswrap_tensorflow_create(4e3, HEAP32[$0 + 172 >> 2]);
     jsvUnLock(HEAP32[$0 + 172 >> 2]);
     if (HEAP32[$0 + 168 >> 2]) {
      HEAP32[$0 + 164 >> 2] = jswrap_tfmicrointerpreter_getInput(HEAP32[$0 + 168 >> 2]);
      jsvArrayBufferIteratorNew($0 + 104 | 0, HEAP32[$0 + 164 >> 2], 0);
      HEAP32[$0 + 100 >> 2] = HEAPU8[391166] - Math_imul(HEAPU8[391165], 3);
      while (1) {
       if (HEAP32[$0 + 100 >> 2] < 0) {
        HEAP32[$0 + 100 >> 2] = HEAP32[$0 + 100 >> 2] + 150;
        continue;
       }
       break;
      }
      HEAP32[$0 + 96 >> 2] = 0;
      while (1) {
       if (HEAP32[$0 + 96 >> 2] < (Math_imul(HEAPU8[391165], 3) | 0)) {
        $1 = HEAP32[$0 + 100 >> 2];
        HEAP32[$0 + 100 >> 2] = $1 + 1;
        jsvArrayBufferIteratorSetIntegerValue($0 + 104 | 0, HEAP8[$1 + 391168 | 0]);
        jsvArrayBufferIteratorNext($0 + 104 | 0);
        if (HEAP32[$0 + 100 >> 2] >= 150) {
         HEAP32[$0 + 100 >> 2] = HEAP32[$0 + 100 >> 2] - 150;
        }
        HEAP32[$0 + 96 >> 2] = HEAP32[$0 + 96 >> 2] + 1;
        continue;
       }
       break;
      }
      jsvArrayBufferIteratorFree($0 + 104 | 0);
      jsvUnLock(HEAP32[$0 + 164 >> 2]);
      jswrap_tfmicrointerpreter_invoke(HEAP32[$0 + 168 >> 2]);
      HEAP32[$0 + 164 >> 2] = jswrap_tfmicrointerpreter_getOutput(HEAP32[$0 + 168 >> 2]);
      HEAP32[$0 + 92 >> 2] = jswrap_array_slice(HEAP32[$0 + 164 >> 2], 0, 0);
      jsvUnLock2(HEAP32[$0 + 164 >> 2], HEAP32[$0 + 168 >> 2]);
      HEAP32[$0 + 88 >> 2] = jspExecuteJSFunctionCode(135863, 138542, 0, 0, 1, $0 + 92 | 0);
      HEAP32[$0 + 80 >> 2] = HEAP32[$0 + 88 >> 2];
      HEAP32[$0 + 84 >> 2] = HEAP32[$0 + 92 >> 2];
      jsiQueueObjectCallbacks(HEAP32[$0 + 348 >> 2], 132114, $0 + 80 | 0, 2);
      jsvUnLock2(HEAP32[$0 + 88 >> 2], HEAP32[$0 + 92 >> 2]);
     }
    }
   }
  }
  if (HEAP32[97752] & 131072) {
   HEAP32[$0 + 76 >> 2] = jsvNewFromBool(HEAP8[391318] & 1);
   jsiQueueObjectCallbacks(HEAP32[$0 + 348 >> 2], 130019, $0 + 76 | 0, 1);
   jsvUnLock(HEAP32[$0 + 76 >> 2]);
  }
  if (HEAP32[97752] & 262144) {
   HEAP32[$0 + 72 >> 2] = jsvNewFromInteger(HEAP32[97767]);
   jsiQueueObjectCallbacks(HEAP32[$0 + 348 >> 2], 121829, $0 + 72 | 0, 1);
   jsvUnLock(HEAP32[$0 + 72 >> 2]);
  }
  if (HEAP32[97752] & 16777216) {
   jsiQueueObjectCallbacks(HEAP32[$0 + 348 >> 2], 117318, 0, 0);
  }
  if (HEAP32[97752] & 33554432) {
   HEAP32[$0 + 68 >> 2] = jsvNewFromBool(HEAP8[391319] & 1);
   jsiQueueObjectCallbacks(HEAP32[$0 + 348 >> 2], 121879, $0 + 68 | 0, 1);
   jsvUnLock(HEAP32[$0 + 68 >> 2]);
  }
  if (HEAP32[97752] & 524288) {
   $1 = $0 + 60 | 0;
   HEAP32[$1 >> 2] = jsvNewFromInteger(HEAP32[97763] == 1 ? -1 : HEAP32[97763] == 2);
   HEAP32[$1 + 4 >> 2] = jsvNewFromInteger(HEAP32[97763] == 3 ? -1 : HEAP32[97763] == 4);
   HEAP32[97763] = 0;
   jsiQueueObjectCallbacks(HEAP32[$0 + 348 >> 2], 132343, $0 + 60 | 0, 2);
   jsvUnLockMany(2, $0 + 60 | 0);
  }
  if (HEAP32[97752] & 3145728) {
   HEAP32[$0 + 52 >> 2] = jsvNewFromInteger(!!(HEAP32[97752] & 1048576) | (HEAP32[97752] & 2097152 ? 2 : 0));
   HEAP32[$0 + 56 >> 2] = jsvNewObject();
   HEAP32[$0 + 48 >> 2] = HEAP16[195521];
   HEAP32[$0 + 44 >> 2] = HEAP16[195522];
   if (HEAP32[$0 + 48 >> 2] < 0) {
    HEAP32[$0 + 48 >> 2] = 0;
   }
   if (HEAP32[$0 + 44 >> 2] < 0) {
    HEAP32[$0 + 44 >> 2] = 0;
   }
   if (HEAP32[$0 + 48 >> 2] >= 176) {
    HEAP32[$0 + 48 >> 2] = 175;
   }
   if (HEAP32[$0 + 44 >> 2] >= 176) {
    HEAP32[$0 + 44 >> 2] = 175;
   }
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 56 >> 2], 116522, jsvNewFromInteger(HEAP32[$0 + 48 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 56 >> 2], 116397, jsvNewFromInteger(HEAP32[$0 + 44 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 56 >> 2], 132338, jsvNewFromInteger(HEAPU8[391056]));
   jsiQueueObjectCallbacks(HEAP32[$0 + 348 >> 2], 129506, $0 + 52 | 0, 2);
   jsvUnLockMany(2, $0 + 52 | 0);
  }
 }
 if (HEAP32[97752] & 4194304) {
  HEAP32[$0 + 40 >> 2] = jsvNewObject();
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 40 >> 2], 116522, jsvNewFromInteger(HEAP16[195521]));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 40 >> 2], 116397, jsvNewFromInteger(HEAP16[195522]));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 40 >> 2], 135741, jsvNewFromInteger(HEAP8[391046] & 1));
  $1 = HEAP32[$0 + 40 >> 2];
  if (HEAP8[391057] & 1) {
   $2 = HEAP16[195521] - HEAP16[195529] | 0;
  } else {
   $2 = 0;
  }
  jsvObjectSetChildAndUnLock($1, 116466, jsvNewFromInteger($2));
  $1 = HEAP32[$0 + 40 >> 2];
  if (HEAP8[391057] & 1) {
   $2 = HEAP16[195522] - HEAP16[195530] | 0;
  } else {
   $2 = 0;
  }
  jsvObjectSetChildAndUnLock($1, 116224, jsvNewFromInteger($2));
  jsiQueueObjectCallbacks(HEAP32[$0 + 348 >> 2], 130058, $0 + 40 | 0, 1);
  jsvUnLock(HEAP32[$0 + 40 >> 2]);
  HEAP16[195529] = HEAPU16[195521];
  HEAP16[195530] = HEAPU16[195522];
  HEAP8[391057] = HEAP8[391046] & 1;
 }
 jsvUnLock(HEAP32[$0 + 348 >> 2]);
 HEAP32[97752] = 0;
 if ((HEAPU8[366844] | HEAPU8[366845] << 8) << 16 >> 16 >= (HEAPU8[366840] | HEAPU8[366841] << 8) << 16 >> 16) {
  graphicsInternalFlip();
 }
 if (!(HEAPU8[391136] | !HEAP32[97790])) {
  jspromise_resolve(HEAP32[97790], 0);
  jsvUnLock(HEAP32[97790]);
  HEAP32[97790] = 0;
 }
 if (!(HEAPU16[195569] | !HEAP32[97789])) {
  jspromise_resolve(HEAP32[97789], 0);
  jsvUnLock(HEAP32[97789]);
  HEAP32[97789] = 0;
 }
 __stack_pointer = $0 + 352 | 0;
 return 0;
}

function mbedtls_sha512_finish($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 $1 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$1 + 8 >> 2];
 $2 = HEAP32[$1 + 12 >> 2];
 $4 = $0 << 3;
 $0 = $2 << 3 | $0 >>> 29;
 $5 = $0;
 $2 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$2 >> 2];
 $1 = HEAP32[$2 + 4 >> 2];
 $0 = 0;
 $2 = $0;
 $0 = $1 >>> 29 | 0;
 $1 = $4;
 $0 = $0 | $1;
 HEAP32[$3 + 24 >> 2] = $0;
 $0 = $5;
 $2 = $0 | $2;
 HEAP32[$3 + 28 >> 2] = $2;
 $0 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$0 >> 2];
 $1 = HEAP32[$0 + 4 >> 2];
 $0 = $2;
 $2 = $1 << 3 | $2 >>> 29;
 $0 = $0 << 3;
 HEAP32[$3 + 16 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $2;
 $2 = HEAP32[$3 + 24 >> 2];
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP8[$3 | 0] = $0 >>> 24;
 $2 = HEAP32[$3 + 24 >> 2];
 $1 = HEAP32[$3 + 28 >> 2];
 HEAP8[$3 + 1 | 0] = $1 >>> 16;
 $2 = HEAP32[$3 + 24 >> 2];
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP8[$3 + 2 | 0] = $0 >>> 8;
 $2 = HEAP32[$3 + 24 >> 2];
 $1 = HEAP32[$3 + 28 >> 2];
 HEAP8[$3 + 3 | 0] = $1;
 $2 = HEAP32[$3 + 24 >> 2];
 $1 = $2;
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP8[$3 + 4 | 0] = ($0 & 16777215) << 8 | $1 >>> 24;
 $2 = HEAP32[$3 + 24 >> 2];
 $0 = $2;
 $1 = HEAP32[$3 + 28 >> 2];
 HEAP8[$3 + 5 | 0] = ($1 & 65535) << 16 | $0 >>> 16;
 $2 = HEAP32[$3 + 24 >> 2];
 $1 = $2;
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP8[$3 + 6 | 0] = ($0 & 255) << 24 | $1 >>> 8;
 $2 = HEAP32[$3 + 24 >> 2];
 HEAP8[$3 + 7 | 0] = $2;
 $1 = HEAP32[$3 + 16 >> 2];
 $2 = HEAP32[$3 + 20 >> 2];
 HEAP8[$3 + 8 | 0] = $2 >>> 24;
 $1 = HEAP32[$3 + 16 >> 2];
 $0 = HEAP32[$3 + 20 >> 2];
 HEAP8[$3 + 9 | 0] = $0 >>> 16;
 $1 = HEAP32[$3 + 16 >> 2];
 $2 = HEAP32[$3 + 20 >> 2];
 HEAP8[$3 + 10 | 0] = $2 >>> 8;
 $1 = HEAP32[$3 + 16 >> 2];
 $0 = HEAP32[$3 + 20 >> 2];
 HEAP8[$3 + 11 | 0] = $0;
 $1 = HEAP32[$3 + 16 >> 2];
 $0 = $1;
 $2 = HEAP32[$3 + 20 >> 2];
 HEAP8[$3 + 12 | 0] = ($2 & 16777215) << 8 | $0 >>> 24;
 $1 = HEAP32[$3 + 16 >> 2];
 $2 = $1;
 $0 = HEAP32[$3 + 20 >> 2];
 HEAP8[$3 + 13 | 0] = ($0 & 65535) << 16 | $2 >>> 16;
 $1 = HEAP32[$3 + 16 >> 2];
 $0 = $1;
 $2 = HEAP32[$3 + 20 >> 2];
 HEAP8[$3 + 14 | 0] = ($2 & 255) << 24 | $0 >>> 8;
 $1 = HEAP32[$3 + 16 >> 2];
 HEAP8[$3 + 15 | 0] = $1;
 $2 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$2 >> 2];
 $2 = $0;
 HEAP32[$3 + 36 >> 2] = $2 & 127;
 if (HEAPU32[$3 + 36 >> 2] < 112) {
  $0 = 112 - HEAP32[$3 + 36 >> 2] | 0;
 } else {
  $0 = 240 - HEAP32[$3 + 36 >> 2] | 0;
 }
 HEAP32[$3 + 32 >> 2] = $0;
 mbedtls_sha512_update(HEAP32[$3 + 44 >> 2], 171568, HEAP32[$3 + 32 >> 2]);
 mbedtls_sha512_update(HEAP32[$3 + 44 >> 2], $3, 16);
 $1 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$1 + 16 >> 2];
 $2 = HEAP32[$1 + 20 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2]] = $2 >>> 24;
 $2 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$2 + 16 >> 2];
 $1 = HEAP32[$2 + 20 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 1 | 0] = $1 >>> 16;
 $1 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$1 + 16 >> 2];
 $2 = HEAP32[$1 + 20 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 2 | 0] = $2 >>> 8;
 $2 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$2 + 16 >> 2];
 $1 = HEAP32[$2 + 20 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 3 | 0] = $1;
 $1 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$1 + 16 >> 2];
 $2 = HEAP32[$1 + 20 >> 2];
 $1 = $0;
 HEAP8[HEAP32[$3 + 40 >> 2] + 4 | 0] = ($2 & 16777215) << 8 | $1 >>> 24;
 $2 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$2 + 16 >> 2];
 $1 = HEAP32[$2 + 20 >> 2];
 $2 = $0;
 HEAP8[HEAP32[$3 + 40 >> 2] + 5 | 0] = ($1 & 65535) << 16 | $2 >>> 16;
 $1 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$1 + 16 >> 2];
 $2 = HEAP32[$1 + 20 >> 2];
 $1 = $0;
 HEAP8[HEAP32[$3 + 40 >> 2] + 6 | 0] = ($2 & 255) << 24 | $1 >>> 8;
 $2 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$2 + 16 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 7 | 0] = $0;
 $2 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$2 + 24 >> 2];
 $0 = HEAP32[$2 + 28 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 8 | 0] = $0 >>> 24;
 $0 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$0 + 24 >> 2];
 $2 = HEAP32[$0 + 28 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 9 | 0] = $2 >>> 16;
 $2 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$2 + 24 >> 2];
 $0 = HEAP32[$2 + 28 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 10 | 0] = $0 >>> 8;
 $0 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$0 + 24 >> 2];
 $2 = HEAP32[$0 + 28 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 11 | 0] = $2;
 $2 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$2 + 24 >> 2];
 $0 = HEAP32[$2 + 28 >> 2];
 $2 = $1;
 HEAP8[HEAP32[$3 + 40 >> 2] + 12 | 0] = ($0 & 16777215) << 8 | $2 >>> 24;
 $0 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$0 + 24 >> 2];
 $2 = HEAP32[$0 + 28 >> 2];
 $0 = $1;
 HEAP8[HEAP32[$3 + 40 >> 2] + 13 | 0] = ($2 & 65535) << 16 | $0 >>> 16;
 $2 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$2 + 24 >> 2];
 $0 = HEAP32[$2 + 28 >> 2];
 $2 = $1;
 HEAP8[HEAP32[$3 + 40 >> 2] + 14 | 0] = ($0 & 255) << 24 | $2 >>> 8;
 $0 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$0 + 24 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 15 | 0] = $1;
 $0 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$0 + 32 >> 2];
 $1 = HEAP32[$0 + 36 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 16 | 0] = $1 >>> 24;
 $1 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$1 + 32 >> 2];
 $0 = HEAP32[$1 + 36 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 17 | 0] = $0 >>> 16;
 $0 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$0 + 32 >> 2];
 $1 = HEAP32[$0 + 36 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 18 | 0] = $1 >>> 8;
 $1 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$1 + 32 >> 2];
 $0 = HEAP32[$1 + 36 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 19 | 0] = $0;
 $0 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$0 + 32 >> 2];
 $1 = HEAP32[$0 + 36 >> 2];
 $0 = $2;
 HEAP8[HEAP32[$3 + 40 >> 2] + 20 | 0] = ($1 & 16777215) << 8 | $0 >>> 24;
 $1 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$1 + 32 >> 2];
 $0 = HEAP32[$1 + 36 >> 2];
 $1 = $2;
 HEAP8[HEAP32[$3 + 40 >> 2] + 21 | 0] = ($0 & 65535) << 16 | $1 >>> 16;
 $0 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$0 + 32 >> 2];
 $1 = HEAP32[$0 + 36 >> 2];
 $0 = $2;
 HEAP8[HEAP32[$3 + 40 >> 2] + 22 | 0] = ($1 & 255) << 24 | $0 >>> 8;
 $1 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$1 + 32 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 23 | 0] = $2;
 $1 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$1 + 40 >> 2];
 $2 = HEAP32[$1 + 44 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 24 | 0] = $2 >>> 24;
 $2 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$2 + 40 >> 2];
 $1 = HEAP32[$2 + 44 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 25 | 0] = $1 >>> 16;
 $1 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$1 + 40 >> 2];
 $2 = HEAP32[$1 + 44 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 26 | 0] = $2 >>> 8;
 $2 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$2 + 40 >> 2];
 $1 = HEAP32[$2 + 44 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 27 | 0] = $1;
 $1 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$1 + 40 >> 2];
 $2 = HEAP32[$1 + 44 >> 2];
 $1 = $0;
 HEAP8[HEAP32[$3 + 40 >> 2] + 28 | 0] = ($2 & 16777215) << 8 | $1 >>> 24;
 $2 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$2 + 40 >> 2];
 $1 = HEAP32[$2 + 44 >> 2];
 $2 = $0;
 HEAP8[HEAP32[$3 + 40 >> 2] + 29 | 0] = ($1 & 65535) << 16 | $2 >>> 16;
 $1 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$1 + 40 >> 2];
 $2 = HEAP32[$1 + 44 >> 2];
 $1 = $0;
 HEAP8[HEAP32[$3 + 40 >> 2] + 30 | 0] = ($2 & 255) << 24 | $1 >>> 8;
 $2 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$2 + 40 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 31 | 0] = $0;
 $2 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$2 + 48 >> 2];
 $0 = HEAP32[$2 + 52 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 32 | 0] = $0 >>> 24;
 $0 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$0 + 48 >> 2];
 $2 = HEAP32[$0 + 52 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 33 | 0] = $2 >>> 16;
 $2 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$2 + 48 >> 2];
 $0 = HEAP32[$2 + 52 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 34 | 0] = $0 >>> 8;
 $0 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$0 + 48 >> 2];
 $2 = HEAP32[$0 + 52 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 35 | 0] = $2;
 $2 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$2 + 48 >> 2];
 $0 = HEAP32[$2 + 52 >> 2];
 $2 = $1;
 HEAP8[HEAP32[$3 + 40 >> 2] + 36 | 0] = ($0 & 16777215) << 8 | $2 >>> 24;
 $0 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$0 + 48 >> 2];
 $2 = HEAP32[$0 + 52 >> 2];
 $0 = $1;
 HEAP8[HEAP32[$3 + 40 >> 2] + 37 | 0] = ($2 & 65535) << 16 | $0 >>> 16;
 $2 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$2 + 48 >> 2];
 $0 = HEAP32[$2 + 52 >> 2];
 $2 = $1;
 HEAP8[HEAP32[$3 + 40 >> 2] + 38 | 0] = ($0 & 255) << 24 | $2 >>> 8;
 $0 = HEAP32[$3 + 44 >> 2];
 $1 = HEAP32[$0 + 48 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 39 | 0] = $1;
 $0 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$0 + 56 >> 2];
 $1 = HEAP32[$0 + 60 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 40 | 0] = $1 >>> 24;
 $1 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$1 + 56 >> 2];
 $0 = HEAP32[$1 + 60 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 41 | 0] = $0 >>> 16;
 $0 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$0 + 56 >> 2];
 $1 = HEAP32[$0 + 60 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 42 | 0] = $1 >>> 8;
 $1 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$1 + 56 >> 2];
 $0 = HEAP32[$1 + 60 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 43 | 0] = $0;
 $0 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$0 + 56 >> 2];
 $1 = HEAP32[$0 + 60 >> 2];
 $0 = $2;
 HEAP8[HEAP32[$3 + 40 >> 2] + 44 | 0] = ($1 & 16777215) << 8 | $0 >>> 24;
 $1 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$1 + 56 >> 2];
 $0 = HEAP32[$1 + 60 >> 2];
 $1 = $2;
 HEAP8[HEAP32[$3 + 40 >> 2] + 45 | 0] = ($0 & 65535) << 16 | $1 >>> 16;
 $0 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$0 + 56 >> 2];
 $1 = HEAP32[$0 + 60 >> 2];
 $0 = $2;
 HEAP8[HEAP32[$3 + 40 >> 2] + 46 | 0] = ($1 & 255) << 24 | $0 >>> 8;
 $1 = HEAP32[$3 + 44 >> 2];
 $2 = HEAP32[$1 + 56 >> 2];
 HEAP8[HEAP32[$3 + 40 >> 2] + 47 | 0] = $2;
 if (!HEAP32[HEAP32[$3 + 44 >> 2] + 208 >> 2]) {
  $1 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$1 + 64 >> 2];
  $2 = HEAP32[$1 + 68 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 48 | 0] = $2 >>> 24;
  $2 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$2 + 64 >> 2];
  $1 = HEAP32[$2 + 68 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 49 | 0] = $1 >>> 16;
  $1 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$1 + 64 >> 2];
  $2 = HEAP32[$1 + 68 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 50 | 0] = $2 >>> 8;
  $2 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$2 + 64 >> 2];
  $1 = HEAP32[$2 + 68 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 51 | 0] = $1;
  $1 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$1 + 64 >> 2];
  $2 = HEAP32[$1 + 68 >> 2];
  $1 = $0;
  HEAP8[HEAP32[$3 + 40 >> 2] + 52 | 0] = ($2 & 16777215) << 8 | $1 >>> 24;
  $2 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$2 + 64 >> 2];
  $1 = HEAP32[$2 + 68 >> 2];
  $2 = $0;
  HEAP8[HEAP32[$3 + 40 >> 2] + 53 | 0] = ($1 & 65535) << 16 | $2 >>> 16;
  $1 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$1 + 64 >> 2];
  $2 = HEAP32[$1 + 68 >> 2];
  $1 = $0;
  HEAP8[HEAP32[$3 + 40 >> 2] + 54 | 0] = ($2 & 255) << 24 | $1 >>> 8;
  $2 = HEAP32[$3 + 44 >> 2];
  $0 = HEAP32[$2 + 64 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 55 | 0] = $0;
  $2 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$2 + 72 >> 2];
  $0 = HEAP32[$2 + 76 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 56 | 0] = $0 >>> 24;
  $0 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$0 + 72 >> 2];
  $2 = HEAP32[$0 + 76 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 57 | 0] = $2 >>> 16;
  $2 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$2 + 72 >> 2];
  $0 = HEAP32[$2 + 76 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 58 | 0] = $0 >>> 8;
  $0 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$0 + 72 >> 2];
  $2 = HEAP32[$0 + 76 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 59 | 0] = $2;
  $2 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$2 + 72 >> 2];
  $0 = HEAP32[$2 + 76 >> 2];
  $2 = $1;
  HEAP8[HEAP32[$3 + 40 >> 2] + 60 | 0] = ($0 & 16777215) << 8 | $2 >>> 24;
  $0 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$0 + 72 >> 2];
  $2 = HEAP32[$0 + 76 >> 2];
  $0 = $1;
  HEAP8[HEAP32[$3 + 40 >> 2] + 61 | 0] = ($2 & 65535) << 16 | $0 >>> 16;
  $2 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$2 + 72 >> 2];
  $0 = HEAP32[$2 + 76 >> 2];
  $2 = $1;
  HEAP8[HEAP32[$3 + 40 >> 2] + 62 | 0] = ($0 & 255) << 24 | $2 >>> 8;
  $0 = HEAP32[$3 + 44 >> 2];
  $1 = HEAP32[$0 + 72 >> 2];
  HEAP8[HEAP32[$3 + 40 >> 2] + 63 | 0] = $1;
 }
 __stack_pointer = $3 + 48 | 0;
}

function jsiHandleChar($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 31 | 0] = $0;
 label$1: {
  if (jsiPasswordProtected() & 1) {
   if (!(HEAP8[$1 + 31 | 0] != 13 & HEAP8[$1 + 31 | 0] != 10)) {
    HEAP32[$1 + 24 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 132894);
    label$5: {
     if (!HEAP32[$1 + 24 >> 2]) {
      break label$5;
     }
     if (jsvCompareString(HEAP32[91104], HEAP32[$1 + 24 >> 2], 0, 0, 0)) {
      break label$5;
     }
     HEAP16[182206] = HEAPU16[182206] & -1025;
    }
    jsvUnLock(HEAP32[$1 + 24 >> 2]);
    jsiClearInputLine(0);
    label$6: {
     if (jsiPasswordProtected() & 1) {
      jsiConsolePrintString(138353);
      break label$6;
     }
     jsiConsolePrintString(147657);
     HEAP8[364420] = 1;
     jsiConsoleReturnInputLine();
    }
    break label$1;
   }
   if (jsvGetStringLength(HEAP32[91104]) >>> 0 < 20) {
    jsiAppendToInputLine(HEAP8[$1 + 31 | 0]);
   }
   break label$1;
  }
  if (!(HEAP8[$1 + 31 | 0] != 3 | HEAPU8[364428] < 2 | HEAPU8[364428] > 4)) {
   HEAP32[91094] = HEAP32[91094] & -6145;
  }
  if (HEAPU8[364428] == 2) {
   if (!jsvGetStringLength(HEAP32[91104])) {
    HEAP16[182206] = HEAPU16[182206] & -3;
   }
   HEAP16[182240] = HEAPU8[$1 + 31 | 0] << 8;
   HEAP8[364428] = 3;
   break label$1;
  }
  label$12: {
   if (HEAPU8[364428] == 3) {
    HEAP16[182240] = HEAPU8[$1 + 31 | 0] | HEAPU16[182240];
    label$14: {
     if (!(HEAPU16[182240] & 8191)) {
      jsiPacketProcess();
      break label$14;
     }
     HEAP8[364428] = 4;
    }
    break label$12;
   }
   label$16: {
    if (HEAPU8[364428] == 4) {
     jsiAppendToInputLine(HEAP8[$1 + 31 | 0]);
     if (HEAP32[48917] >= (HEAPU16[182240] & 8191)) {
      jsiPacketProcess();
     }
     break label$16;
    }
    label$19: {
     if (!HEAP8[$1 + 31 | 0]) {
      HEAP8[364428] = 0;
      break label$19;
     }
     label$21: {
      if (HEAP8[$1 + 31 | 0] == 1) {
       if (HEAPU8[364428] == 5) {
        jsiPacketStart();
       }
       break label$21;
      }
      if (HEAP8[$1 + 31 | 0] != 3) {
       label$25: {
        if (HEAP8[$1 + 31 | 0] == 5) {
         if (!jsvGetStringLength(HEAP32[91104])) {
          HEAP32[$1 + 4 >> 2] = 139631;
          HEAP32[$1 >> 2] = 139436;
          jsiConsolePrintf(146592, $1);
         }
         break label$25;
        }
        label$28: {
         if (HEAP8[$1 + 31 | 0] == 16) {
          if (!jsvGetStringLength(HEAP32[91104])) {
           HEAP16[182206] = HEAPU16[182206] | 2;
          }
          HEAP8[364428] = 5;
          break label$28;
         }
         label$31: {
          if (HEAP8[$1 + 31 | 0] == 27) {
           HEAP8[364428] = 6;
           break label$31;
          }
          label$33: {
           if (HEAPU8[364428] == 6) {
            HEAP8[364428] = 0;
            label$35: {
             if (HEAP8[$1 + 31 | 0] == 79) {
              HEAP8[364428] = 7;
              break label$35;
             }
             label$37: {
              if (HEAP8[$1 + 31 | 0] == 91) {
               HEAP8[364428] = 8;
               break label$37;
              }
              if (HEAP8[$1 + 31 | 0] == 10) {
               jsiHandleNewLine(0);
              }
             }
            }
            break label$33;
           }
           label$40: {
            if (HEAPU8[364428] == 7) {
             HEAP8[364428] = 0;
             label$42: {
              if (HEAP8[$1 + 31 | 0] == 70) {
               jsiHandleEnd();
               break label$42;
              }
              label$44: {
               if (HEAP8[$1 + 31 | 0] == 72) {
                jsiHandleHome();
                break label$44;
               }
               label$46: {
                if (HEAP8[$1 + 31 | 0] == 111) {
                 jsiHandleChar(47);
                 break label$46;
                }
                label$48: {
                 if (HEAP8[$1 + 31 | 0] == 106) {
                  jsiHandleChar(42);
                  break label$48;
                 }
                 label$50: {
                  if (HEAP8[$1 + 31 | 0] == 109) {
                   jsiHandleChar(45);
                   break label$50;
                  }
                  label$52: {
                   if (HEAP8[$1 + 31 | 0] == 107) {
                    jsiHandleChar(43);
                    break label$52;
                   }
                   if (HEAP8[$1 + 31 | 0] == 77) {
                    jsiHandleChar(13);
                   }
                  }
                 }
                }
               }
              }
             }
             break label$40;
            }
            label$55: {
             if (HEAPU8[364428] == 8) {
              HEAP8[364428] = 0;
              label$57: {
               if (!(HEAP8[$1 + 31 | 0] < 48 | HEAP8[$1 + 31 | 0] > 57)) {
                HEAP16[182241] = HEAP8[$1 + 31 | 0] - 48;
                HEAP8[364428] = 9;
                break label$57;
               }
               label$59: {
                if (HEAP8[$1 + 31 | 0] == 68) {
                 if (!HEAP32[91106]) {
                  break label$59;
                 }
                 if ((jsvGetCharInString(HEAP32[91104], HEAP32[91106] - 1 | 0) | 0) == 10) {
                  break label$59;
                 }
                 HEAP32[91106] = HEAP32[91106] - 1;
                 if (jsiShowInputLine() & 1) {
                  jsiConsolePrintString(137919);
                 }
                 break label$59;
                }
                label$62: {
                 if (HEAP8[$1 + 31 | 0] == 67) {
                  if (HEAPU32[91106] >= jsvGetStringLength(HEAP32[91104]) >>> 0) {
                   break label$62;
                  }
                  if ((jsvGetCharInString(HEAP32[91104], HEAP32[91106]) | 0) == 10) {
                   break label$62;
                  }
                  HEAP32[91106] = HEAP32[91106] + 1;
                  if (jsiShowInputLine() & 1) {
                   jsiConsolePrintString(138117);
                  }
                  break label$62;
                 }
                 label$65: {
                  if (HEAP8[$1 + 31 | 0] == 65) {
                   HEAP32[$1 + 20 >> 2] = jsvGetStringLength(HEAP32[91104]);
                   label$67: {
                    label$68: {
                     if (HEAP32[$1 + 20 >> 2]) {
                      if (!(jsiIsInHistory(HEAP32[91104]) & 1)) {
                       break label$68;
                      }
                     }
                     if (HEAP32[91106] != HEAP32[$1 + 20 >> 2]) {
                      break label$68;
                     }
                     jsiChangeToHistory(1);
                     break label$67;
                    }
                    jsiHandleMoveUpDown(-1);
                   }
                   break label$65;
                  }
                  label$70: {
                   if (HEAP8[$1 + 31 | 0] == 66) {
                    HEAP32[$1 + 16 >> 2] = jsvGetStringLength(HEAP32[91104]);
                    label$72: {
                     label$73: {
                      if (HEAP32[$1 + 16 >> 2]) {
                       if (!(jsiIsInHistory(HEAP32[91104]) & 1)) {
                        break label$73;
                       }
                      }
                      if (HEAP32[91106] != HEAP32[$1 + 16 >> 2]) {
                       break label$73;
                      }
                      jsiChangeToHistory(0);
                      break label$72;
                     }
                     jsiHandleMoveUpDown(1);
                    }
                    break label$70;
                   }
                   label$75: {
                    if (HEAP8[$1 + 31 | 0] == 70) {
                     jsiHandleEnd();
                     break label$75;
                    }
                    if (HEAP8[$1 + 31 | 0] == 72) {
                     jsiHandleHome();
                    }
                   }
                  }
                 }
                }
               }
              }
              break label$55;
             }
             label$78: {
              if (HEAPU8[364428] == 9) {
               if (!(HEAP8[$1 + 31 | 0] < 48 | HEAP8[$1 + 31 | 0] > 57)) {
                HEAP16[182241] = (HEAP8[$1 + 31 | 0] + Math_imul(HEAPU16[182241], 10) | 0) - 48;
                break label$78;
               }
               label$81: {
                if (HEAP8[$1 + 31 | 0] == 100) {
                 HEAP16[182217] = HEAPU16[182241];
                 break label$81;
                }
                label$83: {
                 if (HEAP8[$1 + 31 | 0] == 72) {
                  if (HEAPU16[182241] == 2) {
                   jsiClearInputLine(1);
                  }
                  break label$83;
                 }
                 if (HEAP8[$1 + 31 | 0] == 126) {
                  label$87: {
                   if (HEAPU16[182241] == 1) {
                    jsiHandleHome();
                    break label$87;
                   }
                   label$89: {
                    if (HEAPU16[182241] == 3) {
                     jsiHandleDelete(0);
                     break label$89;
                    }
                    label$91: {
                     if (HEAPU16[182241] == 4) {
                      jsiHandleEnd();
                      break label$91;
                     }
                     label$93: {
                      if (HEAPU16[182241] == 5) {
                       jsiHandlePageUpDown(0);
                       break label$93;
                      }
                      if (HEAPU16[182241] == 6) {
                       jsiHandlePageUpDown(1);
                      }
                     }
                    }
                   }
                  }
                 }
                }
               }
               HEAP8[364428] = 0;
               break label$78;
              }
              HEAP8[364428] = 0;
              label$96: {
               if (!(HEAP8[$1 + 31 | 0] != 8 & HEAP8[$1 + 31 | 0] != 127)) {
                jsiHandleDelete(1);
                break label$96;
               }
               label$99: {
                if (!(HEAP8[$1 + 31 | 0] != 10 | HEAPU8[364428] != 1)) {
                 HEAP8[364428] = 0;
                 break label$99;
                }
                label$101: {
                 if (!(HEAP8[$1 + 31 | 0] != 13 & HEAP8[$1 + 31 | 0] != 10)) {
                  if (HEAP8[$1 + 31 | 0] == 13) {
                   HEAP8[364428] = 1;
                  }
                  jsiHandleNewLine(1);
                  break label$101;
                 }
                 label$105: {
                  label$106: {
                   if (HEAP8[$1 + 31 | 0] != 9) {
                    break label$106;
                   }
                   if (!(jsiEcho() & 1)) {
                    break label$106;
                   }
                   jsiTabComplete();
                   break label$105;
                  }
                  if (!(HEAP8[$1 + 31 | 0] != 9 & HEAPU8[$1 + 31 | 0] < 32)) {
                   HEAP8[$1 + 14 | 0] = HEAPU8[$1 + 31 | 0];
                   HEAP8[$1 + 15 | 0] = 0;
                   HEAP32[$1 + 8 >> 2] = HEAP8[$1 + 31 | 0] == 9 ? 146381 : $1 + 14 | 0;
                   jsiAppendStringToInputLine(HEAP32[$1 + 8 >> 2]);
                  }
                 }
                }
               }
              }
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
 }
 __stack_pointer = $1 + 32 | 0;
}

function _jswrap_graphics_parseImage($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 176 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 168 >> 2] = $0;
 HEAP32[$4 + 164 >> 2] = $1;
 HEAP32[$4 + 160 >> 2] = $2;
 HEAP32[$4 + 156 >> 2] = $3;
 memset(HEAP32[$4 + 156 >> 2], 0, 84);
 label$1: {
  label$2: {
   if (jsvIsObject(HEAP32[$4 + 164 >> 2]) & 1) {
    label$4: {
     if (jsvIsInstanceOf(HEAP32[$4 + 164 >> 2], 120477) & 1) {
      if (!(graphicsGetFromVar($4 + 80 | 0, HEAP32[$4 + 164 >> 2]) & 1)) {
       HEAP8[$4 + 175 | 0] = 0;
       break label$1;
      }
      if (HEAPU8[$4 + 84 | 0] | HEAPU8[$4 + 85 | 0] << 8 | (HEAPU8[$4 + 86 | 0] << 16 | HEAPU8[$4 + 87 | 0] << 24)) {
       HEAP8[$4 + 175 | 0] = 0;
       break label$1;
      }
      HEAP32[HEAP32[$4 + 156 >> 2] >> 2] = HEAPU8[$4 + 92 | 0] | HEAPU8[$4 + 93 | 0] << 8;
      HEAP32[HEAP32[$4 + 156 >> 2] + 4 >> 2] = HEAPU8[$4 + 94 | 0] | HEAPU8[$4 + 95 | 0] << 8;
      HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] = HEAPU8[$4 + 96 | 0];
      break label$4;
     }
     $0 = jsvObjectGetIntegerChild(HEAP32[$4 + 164 >> 2], 129398);
     HEAP32[HEAP32[$4 + 156 >> 2] >> 2] = $0;
     $0 = jsvObjectGetIntegerChild(HEAP32[$4 + 164 >> 2], 117745);
     HEAP32[HEAP32[$4 + 156 >> 2] + 4 >> 2] = $0;
     $0 = jsvObjectGetIntegerChild(HEAP32[$4 + 164 >> 2], 121714);
     HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] = $0;
     if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] <= 0) {
      HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] = 1;
     }
    }
    HEAP32[$4 + 76 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 164 >> 2], 121187);
    $0 = jsvGetArrayBufferBackingString(HEAP32[$4 + 76 >> 2], HEAP32[$4 + 156 >> 2] + 24 | 0);
    HEAP32[HEAP32[$4 + 156 >> 2] + 20 >> 2] = $0;
    jsvUnLock(HEAP32[$4 + 76 >> 2]);
    $0 = HEAP32[$4 + 156 >> 2];
    HEAP32[$0 + 24 >> 2] = HEAP32[$4 + 160 >> 2] + HEAP32[$0 + 24 >> 2];
    HEAP32[$4 + 72 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 164 >> 2], 117520);
    HEAP8[HEAP32[$4 + 156 >> 2] + 12 | 0] = HEAP32[$4 + 72 >> 2] != 0;
    $0 = jsvGetIntegerAndUnLock(HEAP32[$4 + 72 >> 2]);
    HEAP32[HEAP32[$4 + 156 >> 2] + 16 >> 2] = $0;
    HEAP32[$4 + 72 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 164 >> 2], 131932);
    if (HEAP32[$4 + 72 >> 2]) {
     jsvUnLock(_jswrap_graphics_parseImage_palette(HEAP32[$4 + 156 >> 2], HEAP32[$4 + 72 >> 2]));
     if (!HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2]) {
      HEAP8[$4 + 175 | 0] = 0;
      break label$1;
     }
    }
    break label$2;
   }
   label$11: {
    label$12: {
     if (!(jsvIsString(HEAP32[$4 + 164 >> 2]) & 1)) {
      if (!(jsvIsArrayBuffer(HEAP32[$4 + 164 >> 2]) & 1)) {
       break label$12;
      }
     }
     label$14: {
      if (jsvIsArrayBuffer(HEAP32[$4 + 164 >> 2]) & 1) {
       $0 = jsvGetArrayBufferBackingString(HEAP32[$4 + 164 >> 2], HEAP32[$4 + 156 >> 2] + 24 | 0);
       HEAP32[HEAP32[$4 + 156 >> 2] + 20 >> 2] = $0;
       break label$14;
      }
      $0 = jsvLockAgain(HEAP32[$4 + 164 >> 2]);
      HEAP32[HEAP32[$4 + 156 >> 2] + 20 >> 2] = $0;
     }
     jsvStringIteratorNewUTF8($4 + 32 | 0, HEAP32[HEAP32[$4 + 156 >> 2] + 20 >> 2], HEAP32[$4 + 160 >> 2]);
     $0 = jsvStringIteratorGetUTF8CharAndNext($4 + 32 | 0);
     HEAP32[HEAP32[$4 + 156 >> 2] >> 2] = $0;
     $0 = jsvStringIteratorGetUTF8CharAndNext($4 + 32 | 0);
     HEAP32[HEAP32[$4 + 156 >> 2] + 4 >> 2] = $0;
     $0 = jsvStringIteratorGetUTF8CharAndNext($4 + 32 | 0);
     HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] = $0;
     $0 = HEAP32[$4 + 156 >> 2];
     HEAP32[$0 + 24 >> 2] = HEAP32[$4 + 160 >> 2] + HEAP32[$0 + 24 >> 2];
     label$16: {
      if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] & 128) {
       HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] = HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] & 127;
       HEAP8[HEAP32[$4 + 156 >> 2] + 12 | 0] = 1;
       $0 = jsvStringIteratorGetUTF8CharAndNext($4 + 32 | 0);
       HEAP32[HEAP32[$4 + 156 >> 2] + 16 >> 2] = $0;
       HEAP16[HEAP32[$4 + 156 >> 2] + 48 >> 1] = 4;
       break label$16;
      }
      HEAP16[HEAP32[$4 + 156 >> 2] + 48 >> 1] = 3;
     }
     $0 = HEAP32[$4 + 156 >> 2];
     HEAP32[$0 + 24 >> 2] = HEAPU16[HEAP32[$4 + 156 >> 2] + 48 >> 1] + HEAP32[$0 + 24 >> 2];
     if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] & 64) {
      HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] = HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] & 63;
      if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] > 8) {
       jsExceptionHere(1, 120306, 0);
       _jswrap_graphics_freeImageInfo(HEAP32[$4 + 156 >> 2]);
       jsvStringIteratorFree_16($4 + 32 | 0);
       HEAP8[$4 + 175 | 0] = 0;
       break label$1;
      }
      HEAP32[$4 + 28 >> 2] = 1 << HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2];
      HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = HEAP32[$4 + 28 >> 2] - 1;
      label$20: {
       if (HEAP32[$4 + 28 >> 2] << 1 >>> 0 <= 32) {
        HEAP32[$4 + 24 >> 2] = HEAP32[HEAP32[$4 + 156 >> 2] + 24 >> 2];
        HEAP32[$4 + 20 >> 2] = 0;
        while (1) {
         if (HEAPU32[$4 + 20 >> 2] < HEAPU32[$4 + 28 >> 2]) {
          $0 = jsvStringIteratorGetUTF8CharAndNext($4 + 32 | 0) & 255;
          $1 = (jsvStringIteratorGetUTF8CharAndNext($4 + 32 | 0) & 255) << 8;
          HEAP16[(HEAP32[$4 + 156 >> 2] + 52 | 0) + (HEAP32[$4 + 20 >> 2] << 1) >> 1] = $0 | $1;
          HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] + 2;
          HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + 1;
          continue;
         }
         break;
        }
        HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = HEAP32[$4 + 156 >> 2] + 52;
        break label$20;
       }
       if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] <= 8) {
        HEAP32[$4 + 16 >> 2] = HEAP32[HEAP32[$4 + 156 >> 2] + 24 >> 2] + (HEAP32[$4 + 28 >> 2] << 1);
        HEAP32[$4 + 12 >> 2] = 0;
        HEAP32[$4 + 8 >> 2] = jsvGetDataPointer(HEAP32[HEAP32[$4 + 156 >> 2] + 20 >> 2], $4 + 12 | 0);
        if (!(!HEAP32[$4 + 8 >> 2] | HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] > 8 | HEAPU32[$4 + 16 >> 2] >= HEAPU32[$4 + 12 >> 2])) {
         HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = HEAP32[$4 + 28 >> 2] - 1;
         HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = HEAP32[$4 + 8 >> 2] + (HEAP32[HEAP32[$4 + 156 >> 2] + 24 >> 2] + HEAPU16[HEAP32[$4 + 156 >> 2] + 48 >> 1] | 0);
        }
       }
      }
      if (!HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2]) {
       jsExceptionHere(1, 138303, 0);
       _jswrap_graphics_freeImageInfo(HEAP32[$4 + 156 >> 2]);
       jsvStringIteratorFree_16($4 + 32 | 0);
       HEAP8[$4 + 175 | 0] = 0;
       break label$1;
      }
      $0 = HEAP32[$4 + 156 >> 2];
      HEAP16[$0 + 48 >> 1] = HEAPU16[$0 + 48 >> 1] + (HEAP32[$4 + 28 >> 2] << 1 & 65535);
      $0 = HEAP32[$4 + 156 >> 2];
      HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] + (HEAP32[$4 + 28 >> 2] << 1 & 65535);
     }
     jsvStringIteratorFree_16($4 + 32 | 0);
     break label$11;
    }
    jsExceptionHere(1, 129785, 0);
    HEAP8[$4 + 175 | 0] = 0;
    break label$1;
   }
  }
  if (!(HEAP8[HEAP32[$4 + 156 >> 2] + 12 | 0] & 1)) {
   HEAP32[HEAP32[$4 + 156 >> 2] + 16 >> 2] = -1;
  }
  if (!HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2]) {
   label$29: {
    if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] == 1) {
     $0 = HEAP32[$4 + 168 >> 2];
     HEAP16[HEAP32[$4 + 156 >> 2] + 52 >> 1] = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
     $0 = HEAP32[$4 + 168 >> 2];
     HEAP16[HEAP32[$4 + 156 >> 2] + 54 >> 1] = HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24);
     HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = HEAP32[$4 + 156 >> 2] + 52;
     HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 1;
     break label$29;
    }
    label$31: {
     if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] == 2) {
      $0 = HEAP32[$4 + 168 >> 2];
      HEAP16[HEAP32[$4 + 156 >> 2] + 52 >> 1] = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
      $0 = graphicsBlendGfxColor(HEAP32[$4 + 168 >> 2], 85);
      HEAP16[HEAP32[$4 + 156 >> 2] + 54 >> 1] = $0;
      $0 = graphicsBlendGfxColor(HEAP32[$4 + 168 >> 2], 171);
      HEAP16[HEAP32[$4 + 156 >> 2] + 56 >> 1] = $0;
      $0 = HEAP32[$4 + 168 >> 2];
      HEAP16[HEAP32[$4 + 156 >> 2] + 58 >> 1] = HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24);
      HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = HEAP32[$4 + 156 >> 2] + 52;
      HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 3;
      break label$31;
     }
     label$33: {
      if (!(HEAPU8[HEAP32[$4 + 168 >> 2] + 16 | 0] != 16 | HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] != 3)) {
       HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = 188576;
       HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 7;
       break label$33;
      }
      label$35: {
       if (!(HEAPU8[HEAP32[$4 + 168 >> 2] + 16 | 0] != 16 | HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] != 4)) {
        HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = 188608;
        HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 15;
        break label$35;
       }
       label$37: {
        if (!(HEAPU8[HEAP32[$4 + 168 >> 2] + 16 | 0] != 16 | HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] != 8)) {
         HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = 188640;
         HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 255;
         break label$37;
        }
        label$39: {
         if (!(HEAPU8[HEAP32[$4 + 168 >> 2] + 16 | 0] != 8 | HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] != 4)) {
          HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = 189152;
          HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 15;
          break label$39;
         }
         label$41: {
          if (!(HEAPU8[HEAP32[$4 + 168 >> 2] + 16 | 0] != 8 | HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] != 3)) {
           HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = 189184;
           HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 7;
           break label$41;
          }
          if (!(HEAPU8[HEAP32[$4 + 168 >> 2] + 16 | 0] != 4 | HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] != 3)) {
           HEAP32[HEAP32[$4 + 156 >> 2] + 28 >> 2] = 189200;
           HEAP32[HEAP32[$4 + 156 >> 2] + 32 >> 2] = 7;
          }
         }
        }
       }
      }
     }
    }
   }
  }
  label$44: {
   if (!(!(jsvIsString(HEAP32[HEAP32[$4 + 156 >> 2] + 20 >> 2]) & 1) | HEAP32[HEAP32[$4 + 156 >> 2] >> 2] <= 0 | HEAP32[HEAP32[$4 + 156 >> 2] + 4 >> 2] <= 0)) {
    if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] <= 32) {
     break label$44;
    }
   }
   jsExceptionHere(1, 132694, 0);
   _jswrap_graphics_freeImageInfo(HEAP32[$4 + 156 >> 2]);
   HEAP8[$4 + 175 | 0] = 0;
   break label$1;
  }
  HEAP32[HEAP32[$4 + 156 >> 2] + 36 >> 2] = (1 << HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2]) - 1;
  $1 = HEAP32[$4 + 156 >> 2];
  if (HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] < 8) {
   $0 = (8 / HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2] | 0) - 1 | 0;
  } else {
   $0 = 0;
  }
  HEAP32[$1 + 40 >> 2] = $0;
  HEAP32[HEAP32[$4 + 156 >> 2] + 44 >> 2] = Math_imul(HEAP32[HEAP32[$4 + 156 >> 2] >> 2], HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2]) + 7 >> 3;
  HEAP16[HEAP32[$4 + 156 >> 2] + 50 >> 1] = Math_imul(HEAP32[HEAP32[$4 + 156 >> 2] + 8 >> 2], Math_imul(HEAP32[HEAP32[$4 + 156 >> 2] >> 2], HEAP32[HEAP32[$4 + 156 >> 2] + 4 >> 2])) + 7 >> 3;
  HEAP8[$4 + 175 | 0] = 1;
 }
 __stack_pointer = $4 + 176 | 0;
 return HEAP8[$4 + 175 | 0] & 1;
}

function jswrap_graphics_asBMP_X($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 240 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 232 >> 2] = $0;
 HEAP8[$2 + 231 | 0] = $1;
 label$1: {
  if (!(graphicsGetFromVar($2 + 152 | 0, HEAP32[$2 + 232 >> 2]) & 1)) {
   HEAP32[$2 + 236 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 148 >> 2] = graphicsGetWidth($2 + 152 | 0) & 65535;
  HEAP32[$2 + 144 >> 2] = graphicsGetHeight($2 + 152 | 0) & 65535;
  HEAP32[$2 + 140 >> 2] = HEAPU8[$2 + 168 | 0];
  if ((HEAPU8[$2 + 156 | 0] | HEAPU8[$2 + 157 | 0] << 8 | (HEAPU8[$2 + 158 | 0] << 16 | HEAPU8[$2 + 159 | 0] << 24)) == 6) {
   HEAP32[$2 + 140 >> 2] = 3;
  }
  HEAP32[$2 + 136 >> 2] = HEAP32[$2 + 140 >> 2];
  label$4: {
   if (!(HEAP32[$2 + 136 >> 2] <= 1 | HEAP32[$2 + 136 >> 2] >= 4)) {
    HEAP32[$2 + 136 >> 2] = 4;
    break label$4;
   }
   if (!(HEAP32[$2 + 136 >> 2] <= 4 | HEAP32[$2 + 136 >> 2] >= 8)) {
    HEAP32[$2 + 136 >> 2] = 8;
   }
  }
  HEAP8[$2 + 135 | 0] = HEAP32[$2 + 136 >> 2] <= 8;
  HEAP32[$2 + 128 >> 2] = Math_imul(HEAP32[$2 + 148 >> 2], HEAP32[$2 + 136 >> 2]) + 31 >> 5 << 2;
  if (HEAP8[$2 + 135 | 0] & 1) {
   $0 = 1 << HEAP32[$2 + 136 >> 2];
  } else {
   $0 = 0;
  }
  HEAP32[$2 + 124 >> 2] = $0;
  label$9: {
   if (HEAP32[$2 + 136 >> 2] == 16) {
    HEAP32[$2 + 120 >> 2] = 70;
    break label$9;
   }
   HEAP32[$2 + 120 >> 2] = Math_imul(HEAP32[$2 + 124 >> 2], 3) + 26;
  }
  HEAP32[$2 + 116 >> 2] = HEAP32[$2 + 120 >> 2] + Math_imul(HEAP32[$2 + 144 >> 2], HEAP32[$2 + 128 >> 2]);
  if (HEAP8[$2 + 231 | 0] & 1) {
   $0 = HEAP32[$2 + 120 >> 2] + HEAP32[$2 + 128 >> 2] | 0;
  } else {
   $0 = HEAP32[$2 + 116 >> 2];
  }
  HEAP32[$2 + 112 >> 2] = $0;
  HEAP32[$2 + 108 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 112 >> 2]);
  if (!HEAP32[$2 + 108 >> 2]) {
   HEAP32[$2 + 236 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 104 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 108 >> 2]);
  if (!HEAP32[$2 + 104 >> 2]) {
   HEAP32[$2 + 236 >> 2] = 0;
   break label$1;
  }
  HEAP8[HEAP32[$2 + 104 >> 2]] = 66;
  HEAP8[HEAP32[$2 + 104 >> 2] + 1 | 0] = 77;
  HEAP8[HEAP32[$2 + 104 >> 2] + 2 | 0] = HEAP32[$2 + 116 >> 2];
  HEAP8[HEAP32[$2 + 104 >> 2] + 3 | 0] = HEAP32[$2 + 116 >> 2] >> 8;
  HEAP8[HEAP32[$2 + 104 >> 2] + 4 | 0] = HEAP32[$2 + 116 >> 2] >> 16;
  HEAP8[HEAP32[$2 + 104 >> 2] + 5 | 0] = HEAP32[$2 + 116 >> 2] >> 24;
  HEAP8[HEAP32[$2 + 104 >> 2] + 10 | 0] = HEAP32[$2 + 120 >> 2];
  HEAP8[HEAP32[$2 + 104 >> 2] + 18 | 0] = HEAP32[$2 + 148 >> 2];
  HEAP8[HEAP32[$2 + 104 >> 2] + 19 | 0] = HEAP32[$2 + 148 >> 2] >> 8;
  label$15: {
   if (HEAP32[$2 + 136 >> 2] == 16) {
    HEAP32[$2 + 100 >> 2] = 14;
    HEAP8[HEAP32[$2 + 104 >> 2] + 14 | 0] = 56;
    HEAP8[HEAP32[$2 + 104 >> 2] + 22 | 0] = HEAP32[$2 + 144 >> 2];
    HEAP8[HEAP32[$2 + 104 >> 2] + 23 | 0] = HEAP32[$2 + 144 >> 2] >> 8;
    HEAP8[HEAP32[$2 + 104 >> 2] + 26 | 0] = 1;
    HEAP8[HEAP32[$2 + 104 >> 2] + 28 | 0] = 16;
    HEAP8[HEAP32[$2 + 104 >> 2] + 30 | 0] = 3;
    HEAP32[$2 + 96 >> 2] = Math_imul(HEAP32[$2 + 144 >> 2], HEAP32[$2 + 128 >> 2]);
    HEAP8[HEAP32[$2 + 104 >> 2] + 34 | 0] = HEAP32[$2 + 96 >> 2];
    HEAP8[HEAP32[$2 + 104 >> 2] + 35 | 0] = HEAP32[$2 + 96 >> 2] >>> 8;
    HEAP8[HEAP32[$2 + 104 >> 2] + 36 | 0] = HEAP32[$2 + 96 >> 2] >>> 16;
    HEAP8[HEAP32[$2 + 104 >> 2] + 37 | 0] = HEAP32[$2 + 96 >> 2] >>> 24;
    HEAP8[HEAP32[$2 + 104 >> 2] + 55 | 0] = 248;
    HEAP8[HEAP32[$2 + 104 >> 2] + 58 | 0] = 224;
    HEAP8[HEAP32[$2 + 104 >> 2] + 59 | 0] = 7;
    HEAP8[HEAP32[$2 + 104 >> 2] + 62 | 0] = 31;
    break label$15;
   }
   HEAP8[HEAP32[$2 + 104 >> 2] + 14 | 0] = 12;
   HEAP8[HEAP32[$2 + 104 >> 2] + 20 | 0] = HEAP32[$2 + 144 >> 2];
   HEAP8[HEAP32[$2 + 104 >> 2] + 21 | 0] = HEAP32[$2 + 144 >> 2] >> 8;
   HEAP8[HEAP32[$2 + 104 >> 2] + 22 | 0] = 1;
   HEAP8[HEAP32[$2 + 104 >> 2] + 24 | 0] = HEAP32[$2 + 136 >> 2];
   if (HEAP8[$2 + 135 | 0] & 1) {
    label$18: {
     if (HEAP32[$2 + 136 >> 2] == 1) {
      HEAP8[HEAP32[$2 + 104 >> 2] + 26 | 0] = 255;
      HEAP8[HEAP32[$2 + 104 >> 2] + 27 | 0] = 255;
      HEAP8[HEAP32[$2 + 104 >> 2] + 28 | 0] = 255;
      break label$18;
     }
     label$20: {
      if (HEAP32[$2 + 140 >> 2] == 3) {
       HEAP32[$2 + 92 >> 2] = 0;
       while (1) {
        if (HEAP32[$2 + 92 >> 2] < HEAP32[$2 + 124 >> 2]) {
         HEAP8[HEAP32[$2 + 104 >> 2] + (Math_imul(HEAP32[$2 + 92 >> 2], 3) + 26 | 0) | 0] = HEAP32[$2 + 92 >> 2] & 1 ? 255 : 0;
         HEAP8[HEAP32[$2 + 104 >> 2] + (Math_imul(HEAP32[$2 + 92 >> 2], 3) + 27 | 0) | 0] = HEAP32[$2 + 92 >> 2] & 2 ? 255 : 0;
         HEAP8[HEAP32[$2 + 104 >> 2] + (Math_imul(HEAP32[$2 + 92 >> 2], 3) + 28 | 0) | 0] = HEAP32[$2 + 92 >> 2] & 4 ? 255 : 0;
         HEAP32[$2 + 92 >> 2] = HEAP32[$2 + 92 >> 2] + 1;
         continue;
        }
        break;
       }
       break label$20;
      }
      label$24: {
       if (HEAP32[$2 + 140 >> 2] == 4) {
        HEAP32[$2 + 88 >> 2] = 0;
        while (1) {
         if (HEAP32[$2 + 88 >> 2] < 16) {
          HEAP32[$2 + 84 >> 2] = HEAPU16[(HEAP32[$2 + 88 >> 2] << 1) + 188608 >> 1];
          HEAP8[HEAP32[$2 + 104 >> 2] + (Math_imul(HEAP32[$2 + 88 >> 2], 3) + 26 | 0) | 0] = HEAP32[$2 + 84 >> 2] << 3 & 248;
          HEAP8[HEAP32[$2 + 104 >> 2] + (Math_imul(HEAP32[$2 + 88 >> 2], 3) + 27 | 0) | 0] = HEAP32[$2 + 84 >> 2] >> 3 & 252;
          HEAP8[HEAP32[$2 + 104 >> 2] + (Math_imul(HEAP32[$2 + 88 >> 2], 3) + 28 | 0) | 0] = HEAP32[$2 + 84 >> 2] >> 8 & 248;
          HEAP32[$2 + 88 >> 2] = HEAP32[$2 + 88 >> 2] + 1;
          continue;
         }
         break;
        }
        break label$24;
       }
       label$28: {
        if (HEAP32[$2 + 140 >> 2] == 8) {
         HEAP32[$2 + 80 >> 2] = 0;
         while (1) {
          if (HEAP32[$2 + 80 >> 2] < 255) {
           HEAP32[$2 + 76 >> 2] = HEAPU16[(HEAP32[$2 + 80 >> 2] << 1) + 188640 >> 1];
           HEAP8[HEAP32[$2 + 104 >> 2] + (Math_imul(HEAP32[$2 + 80 >> 2], 3) + 26 | 0) | 0] = HEAP32[$2 + 76 >> 2] << 3 & 248;
           HEAP8[HEAP32[$2 + 104 >> 2] + (Math_imul(HEAP32[$2 + 80 >> 2], 3) + 27 | 0) | 0] = HEAP32[$2 + 76 >> 2] >> 3 & 252;
           HEAP8[HEAP32[$2 + 104 >> 2] + (Math_imul(HEAP32[$2 + 80 >> 2], 3) + 28 | 0) | 0] = HEAP32[$2 + 76 >> 2] >> 8 & 248;
           HEAP32[$2 + 80 >> 2] = HEAP32[$2 + 80 >> 2] + 1;
           continue;
          }
          break;
         }
         break label$28;
        }
        HEAP32[$2 + 72 >> 2] = 0;
        while (1) {
         if (HEAP32[$2 + 72 >> 2] < 1 << HEAP32[$2 + 140 >> 2]) {
          HEAP8[$2 + 71 | 0] = (Math_imul(HEAP32[$2 + 72 >> 2], 255) | 0) / (1 << HEAP32[$2 + 140 >> 2]);
          HEAP8[HEAP32[$2 + 104 >> 2] + (Math_imul(HEAP32[$2 + 72 >> 2], 3) + 26 | 0) | 0] = HEAPU8[$2 + 71 | 0];
          HEAP8[HEAP32[$2 + 104 >> 2] + (Math_imul(HEAP32[$2 + 72 >> 2], 3) + 27 | 0) | 0] = HEAPU8[$2 + 71 | 0];
          HEAP8[HEAP32[$2 + 104 >> 2] + (Math_imul(HEAP32[$2 + 72 >> 2], 3) + 28 | 0) | 0] = HEAPU8[$2 + 71 | 0];
          HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 72 >> 2] + 1;
          continue;
         }
         break;
        }
       }
      }
     }
    }
   }
  }
  HEAP32[$2 + 64 >> 2] = (1 << HEAP32[$2 + 136 >> 2]) - 1;
  HEAP32[$2 + 60 >> 2] = 8 / HEAP32[$2 + 136 >> 2];
  HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 120 >> 2];
  HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 144 >> 2] - 1;
  while (1) {
   if (HEAP32[$2 + 52 >> 2] >= 0) {
    HEAP32[$2 + 48 >> 2] = 0;
    label$36: {
     if (HEAP32[$2 + 136 >> 2] < 8) {
      HEAP32[$2 + 44 >> 2] = 0;
      while (1) {
       if (HEAP32[$2 + 44 >> 2] < HEAP32[$2 + 148 >> 2]) {
        HEAP32[$2 + 40 >> 2] = 0;
        HEAP32[$2 + 36 >> 2] = 0;
        while (1) {
         if (HEAP32[$2 + 36 >> 2] < HEAP32[$2 + 60 >> 2]) {
          $0 = HEAP32[$2 + 44 >> 2];
          HEAP32[$2 + 44 >> 2] = $0 + 1;
          HEAP32[$2 + 32 >> 2] = graphicsGetPixel($2 + 152 | 0, $0, HEAP32[$2 + 52 >> 2]);
          if ((HEAPU8[$2 + 156 | 0] | HEAPU8[$2 + 157 | 0] << 8 | (HEAPU8[$2 + 158 | 0] << 16 | HEAPU8[$2 + 159 | 0] << 24)) == 6) {
           HEAP32[$2 + 32 >> 2] = !!(HEAP32[$2 + 32 >> 2] & 16) | ((HEAP32[$2 + 32 >> 2] & 32768 ? 4 : 0) | (HEAP32[$2 + 32 >> 2] & 1024 ? 2 : 0));
          }
          HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 32 >> 2] & HEAP32[$2 + 64 >> 2] | HEAP32[$2 + 40 >> 2] << HEAP32[$2 + 136 >> 2];
          HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 36 >> 2] + 1;
          continue;
         }
         break;
        }
        $1 = HEAP32[$2 + 40 >> 2];
        $3 = HEAP32[$2 + 104 >> 2];
        $0 = HEAP32[$2 + 56 >> 2];
        HEAP32[$2 + 56 >> 2] = $0 + 1;
        HEAP8[$3 + $0 | 0] = $1;
        HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 48 >> 2] + 1;
        continue;
       }
       break;
      }
      break label$36;
     }
     HEAP32[$2 + 28 >> 2] = 0;
     while (1) {
      if (HEAP32[$2 + 28 >> 2] < HEAP32[$2 + 148 >> 2]) {
       HEAP32[$2 + 24 >> 2] = graphicsGetPixel($2 + 152 | 0, HEAP32[$2 + 28 >> 2], HEAP32[$2 + 52 >> 2]);
       HEAP32[$2 + 20 >> 2] = 0;
       while (1) {
        if (HEAP32[$2 + 20 >> 2] < HEAP32[$2 + 136 >> 2]) {
         $1 = HEAP32[$2 + 24 >> 2];
         $3 = HEAP32[$2 + 104 >> 2];
         $0 = HEAP32[$2 + 56 >> 2];
         HEAP32[$2 + 56 >> 2] = $0 + 1;
         HEAP8[$3 + $0 | 0] = $1;
         HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 48 >> 2] + 1;
         HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 24 >> 2] >>> 8;
         HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] + 8;
         continue;
        }
        break;
       }
       HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 28 >> 2] + 1;
       continue;
      }
      break;
     }
    }
    if (HEAP32[$2 + 48 >> 2] < HEAP32[$2 + 128 >> 2]) {
     HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 56 >> 2] + (HEAP32[$2 + 128 >> 2] - HEAP32[$2 + 48 >> 2] | 0);
    }
    if (!(!(HEAP8[$2 + 231 | 0] & 1) | HEAP32[$2 + 56 >> 2] <= 2)) {
     jshKickWatchDog();
     HEAP8[$2 + 19 | 0] = !HEAP32[$2 + 52 >> 2];
     if (HEAP8[$2 + 19 | 0] & 1) {
      $0 = HEAP32[$2 + 56 >> 2];
     } else {
      $0 = HEAP32[$2 + 56 >> 2] - (HEAP32[$2 + 56 >> 2] % 3 | 0) | 0;
     }
     HEAP32[$2 + 12 >> 2] = $0;
     HEAP32[$2 + 8 >> 2] = jsvNewArrayBufferFromString(HEAP32[$2 + 108 >> 2], HEAP32[$2 + 12 >> 2]);
     HEAP32[$2 + 4 >> 2] = jswrap_btoa(HEAP32[$2 + 8 >> 2]);
     jsvUnLock(HEAP32[$2 + 8 >> 2]);
     if (HEAP32[$2 + 4 >> 2]) {
      HEAP32[$2 >> 2] = HEAP32[$2 + 4 >> 2];
      jsiConsolePrintf(116903, $2);
     }
     jsvUnLock(HEAP32[$2 + 4 >> 2]);
     if (HEAP32[$2 + 12 >> 2] < HEAP32[$2 + 56 >> 2]) {
      memmove(HEAP32[$2 + 104 >> 2], HEAP32[$2 + 104 >> 2] + HEAP32[$2 + 12 >> 2] | 0, HEAP32[$2 + 56 >> 2] - HEAP32[$2 + 12 >> 2] | 0);
     }
     HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 56 >> 2] - HEAP32[$2 + 12 >> 2];
    }
    HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] - 1;
    continue;
   }
   break;
  }
  if (HEAP8[$2 + 231 | 0] & 1) {
   jsiConsolePrintf(148266, 0);
   jsvUnLock(HEAP32[$2 + 108 >> 2]);
   HEAP32[$2 + 236 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 236 >> 2] = HEAP32[$2 + 108 >> 2];
 }
 __stack_pointer = $2 + 240 | 0;
 return HEAP32[$2 + 236 >> 2];
}

function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_negative_values_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 496 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 480 >> 2] = $0;
 HEAP32[$1 + 472 >> 2] = gemmlowp__FixedPoint_int_2c_205__20gemmlowp__FixedPoint_int_2c_205___ConstantPOT__2__28_29();
 HEAP32[$1 + 456 >> 2] = HEAP32[$1 + 472 >> 2];
 HEAP32[$1 + 448 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromScalarRaw_28int_29(1);
 HEAP32[$1 + 464 >> 2] = gemmlowp__FixedPoint_int_2c_205__20gemmlowp__operator__int_2c_205__28gemmlowp__FixedPoint_int_2c_205__2c_20gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$1 + 456 >> 2], HEAP32[$1 + 448 >> 2]);
 HEAP32[$1 + 424 >> 2] = HEAP32[$1 + 480 >> 2];
 HEAP32[$1 + 416 >> 2] = HEAP32[$1 + 464 >> 2];
 HEAP32[$1 + 432 >> 2] = gemmlowp__FixedPoint_int_2c_205__20gemmlowp__operator__int_2c_205__28gemmlowp__FixedPoint_int_2c_205__2c_20gemmlowp__FixedPoint_int_2c_205__29_1(HEAP32[$1 + 424 >> 2], HEAP32[$1 + 416 >> 2]);
 HEAP32[$1 + 408 >> 2] = HEAP32[$1 + 472 >> 2];
 HEAP32[$1 + 440 >> 2] = gemmlowp__FixedPoint_int_2c_205__20gemmlowp__operator__int_2c_205__28gemmlowp__FixedPoint_int_2c_205__2c_20gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$1 + 432 >> 2], HEAP32[$1 + 408 >> 2]);
 HEAP32[$1 + 392 >> 2] = HEAP32[$1 + 440 >> 2];
 HEAP32[$1 + 400 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__Rescale_0_2c_20int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$1 + 392 >> 2]);
 HEAP32[$1 + 488 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_interval_between_negative_one_quarter_and_0_excl_int__28gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 400 >> 2]);
 HEAP32[$1 + 376 >> 2] = HEAP32[$1 + 440 >> 2];
 HEAP32[$1 + 368 >> 2] = HEAP32[$1 + 480 >> 2];
 HEAP32[$1 + 384 >> 2] = gemmlowp__FixedPoint_int_2c_205__20gemmlowp__operator__int_2c_205__28gemmlowp__FixedPoint_int_2c_205__2c_20gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$1 + 376 >> 2], HEAP32[$1 + 368 >> 2]);
 HEAP32[$1 + 388 >> 2] = HEAP32[gemmlowp__FixedPoint_int_2c_205___raw_28_29($1 + 384 | 0) >> 2];
 HEAP32[$1 + 360 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200___28int_29(1672461947));
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$1 + 388 >> 2], int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(16777216)));
 HEAP32[$1 + 336 >> 2] = HEAP32[$1 + 488 >> 2];
 HEAP32[$1 + 328 >> 2] = HEAP32[$1 + 360 >> 2];
 HEAP32[$1 + 344 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 336 >> 2], HEAP32[$1 + 328 >> 2]);
 HEAP32[$1 + 320 >> 2] = HEAP32[$1 + 488 >> 2];
 HEAP32[$1 + 352 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 344 >> 2], HEAP32[$1 + 320 >> 2]);
 HEAP32[$1 + 488 >> 2] = HEAP32[$1 + 352 >> 2];
 HEAP32[$1 + 312 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200___28int_29(1302514674));
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$1 + 388 >> 2], int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(33554432)));
 HEAP32[$1 + 288 >> 2] = HEAP32[$1 + 488 >> 2];
 HEAP32[$1 + 280 >> 2] = HEAP32[$1 + 312 >> 2];
 HEAP32[$1 + 296 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 288 >> 2], HEAP32[$1 + 280 >> 2]);
 HEAP32[$1 + 272 >> 2] = HEAP32[$1 + 488 >> 2];
 HEAP32[$1 + 304 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 296 >> 2], HEAP32[$1 + 272 >> 2]);
 HEAP32[$1 + 488 >> 2] = HEAP32[$1 + 304 >> 2];
 HEAP32[$1 + 264 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200___28int_29(790015084));
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$1 + 388 >> 2], int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(67108864)));
 HEAP32[$1 + 240 >> 2] = HEAP32[$1 + 488 >> 2];
 HEAP32[$1 + 232 >> 2] = HEAP32[$1 + 264 >> 2];
 HEAP32[$1 + 248 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 240 >> 2], HEAP32[$1 + 232 >> 2]);
 HEAP32[$1 + 224 >> 2] = HEAP32[$1 + 488 >> 2];
 HEAP32[$1 + 256 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 248 >> 2], HEAP32[$1 + 224 >> 2]);
 HEAP32[$1 + 488 >> 2] = HEAP32[$1 + 256 >> 2];
 HEAP32[$1 + 216 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200___28int_29(290630308));
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$1 + 388 >> 2], int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(134217728)));
 HEAP32[$1 + 192 >> 2] = HEAP32[$1 + 488 >> 2];
 HEAP32[$1 + 184 >> 2] = HEAP32[$1 + 216 >> 2];
 HEAP32[$1 + 200 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 192 >> 2], HEAP32[$1 + 184 >> 2]);
 HEAP32[$1 + 176 >> 2] = HEAP32[$1 + 488 >> 2];
 HEAP32[$1 + 208 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 200 >> 2], HEAP32[$1 + 176 >> 2]);
 HEAP32[$1 + 488 >> 2] = HEAP32[$1 + 208 >> 2];
 HEAP32[$1 + 168 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200___28int_29(39332535));
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$1 + 388 >> 2], int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(268435456)));
 HEAP32[$1 + 144 >> 2] = HEAP32[$1 + 488 >> 2];
 HEAP32[$1 + 136 >> 2] = HEAP32[$1 + 168 >> 2];
 HEAP32[$1 + 152 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 144 >> 2], HEAP32[$1 + 136 >> 2]);
 HEAP32[$1 + 128 >> 2] = HEAP32[$1 + 488 >> 2];
 HEAP32[$1 + 160 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 152 >> 2], HEAP32[$1 + 128 >> 2]);
 HEAP32[$1 + 488 >> 2] = HEAP32[$1 + 160 >> 2];
 HEAP32[$1 + 120 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200___28int_29(720401));
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$1 + 388 >> 2], int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(536870912)));
 HEAP32[$1 + 96 >> 2] = HEAP32[$1 + 488 >> 2];
 HEAP32[$1 + 88 >> 2] = HEAP32[$1 + 120 >> 2];
 HEAP32[$1 + 104 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 96 >> 2], HEAP32[$1 + 88 >> 2]);
 HEAP32[$1 + 80 >> 2] = HEAP32[$1 + 488 >> 2];
 HEAP32[$1 + 112 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 104 >> 2], HEAP32[$1 + 80 >> 2]);
 HEAP32[$1 + 488 >> 2] = HEAP32[$1 + 112 >> 2];
 HEAP32[$1 + 72 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200___28int_29(242));
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$1 + 388 >> 2], int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(1073741824)));
 HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 488 >> 2];
 HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 72 >> 2];
 HEAP32[$1 + 56 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 48 >> 2], HEAP32[$1 + 40 >> 2]);
 HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 488 >> 2];
 HEAP32[$1 + 64 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 56 >> 2], HEAP32[$1 + 32 >> 2]);
 HEAP32[$1 + 488 >> 2] = HEAP32[$1 + 64 >> 2];
 HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 480 >> 2];
 $0 = int_20gemmlowp__MaskIfZero_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$1 + 16 >> 2]);
 HEAP32[$1 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_200___One_28_29();
 HEAP32[$1 >> 2] = HEAP32[$1 + 488 >> 2];
 HEAP32[$1 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, HEAP32[$1 + 8 >> 2], HEAP32[$1 >> 2]);
 HEAP32[$1 + 488 >> 2] = HEAP32[$1 + 24 >> 2];
 __stack_pointer = $1 + 496 | 0;
 return HEAP32[$1 + 488 >> 2];
}

function __rem_pio2_large($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 $8 = __stack_pointer - 560 | 0;
 __stack_pointer = $8;
 $7 = ($2 - 3 | 0) / 24 | 0;
 $18 = ($7 | 0) > 0 ? $7 : 0;
 $13 = Math_imul($18, -24) + $2 | 0;
 $12 = HEAP32[($4 << 2) + 192800 >> 2];
 $15 = $3 - 1 | 0;
 if (($12 + $15 | 0) >= 0) {
  $6 = $3 + $12 | 0;
  $2 = $18 - $15 | 0;
  $7 = 0;
  while (1) {
   $5 = ($2 | 0) < 0 ? 0 : +HEAP32[($2 << 2) + 192816 >> 2];
   HEAPF64[($8 + 320 | 0) + ($7 << 3) >> 3] = $5;
   $2 = $2 + 1 | 0;
   $7 = $7 + 1 | 0;
   if (($7 | 0) != ($6 | 0)) {
    continue;
   }
   break;
  }
 }
 $17 = $13 - 24 | 0;
 $6 = 0;
 $10 = ($12 | 0) > 0 ? $12 : 0;
 $11 = ($3 | 0) <= 0;
 while (1) {
  label$6: {
   if ($11) {
    $5 = 0;
    break label$6;
   }
   $7 = $6 + $15 | 0;
   $2 = 0;
   $5 = 0;
   while (1) {
    $5 = HEAPF64[($2 << 3) + $0 >> 3] * HEAPF64[($8 + 320 | 0) + ($7 - $2 << 3) >> 3] + $5;
    $2 = $2 + 1 | 0;
    if (($3 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  HEAPF64[($6 << 3) + $8 >> 3] = $5;
  $2 = ($6 | 0) == ($10 | 0);
  $6 = $6 + 1 | 0;
  if (!$2) {
   continue;
  }
  break;
 }
 $23 = 47 - $13 | 0;
 $21 = 48 - $13 | 0;
 $24 = $13 - 25 | 0;
 $6 = $12;
 label$9: {
  while (1) {
   $5 = HEAPF64[($6 << 3) + $8 >> 3];
   $2 = 0;
   $7 = $6;
   $15 = ($6 | 0) <= 0;
   if (!$15) {
    while (1) {
     $10 = $2 << 2;
     $10 = $10 + ($8 + 480 | 0) | 0;
     $9 = $5 * 5.960464477539063e-8;
     label$14: {
      if (Math_abs($9) < 2147483648) {
       $11 = ~~$9;
       break label$14;
      }
      $11 = -2147483648;
     }
     $9 = +($11 | 0);
     $5 = $9 * -16777216 + $5;
     label$13: {
      if (Math_abs($5) < 2147483648) {
       $11 = ~~$5;
       break label$13;
      }
      $11 = -2147483648;
     }
     HEAP32[$10 >> 2] = $11;
     $7 = $7 - 1 | 0;
     $5 = HEAPF64[($7 << 3) + $8 >> 3] + $9;
     $2 = $2 + 1 | 0;
     if (($6 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   $5 = scalbn($5, $17);
   $5 = $5 + floor($5 * .125) * -8;
   label$17: {
    if (Math_abs($5) < 2147483648) {
     $16 = ~~$5;
     break label$17;
    }
    $16 = -2147483648;
   }
   $5 = $5 - +($16 | 0);
   label$19: {
    label$20: {
     label$21: {
      $22 = ($17 | 0) <= 0;
      label$22: {
       if (!$22) {
        $7 = ($6 << 2) + $8 | 0;
        $2 = $7 + 476 | 0;
        $11 = $2;
        $2 = HEAP32[$7 + 476 >> 2];
        $7 = $2;
        $2 = $2 >> $21;
        $7 = $7 - ($2 << $21) | 0;
        HEAP32[$11 >> 2] = $7;
        $16 = $2 + $16 | 0;
        $14 = $7 >> $23;
        break label$22;
       }
       if ($17) {
        break label$21;
       }
       $14 = HEAP32[(($6 << 2) + $8 | 0) + 476 >> 2] >> 23;
      }
      if (($14 | 0) <= 0) {
       break label$19;
      }
      break label$20;
     }
     $14 = 2;
     if ($5 >= .5) {
      break label$20;
     }
     $14 = 0;
     break label$19;
    }
    $2 = 0;
    $11 = 0;
    if (!$15) {
     while (1) {
      $15 = ($8 + 480 | 0) + ($2 << 2) | 0;
      $7 = HEAP32[$15 >> 2];
      $10 = 16777215;
      label$26: {
       label$27: {
        if ($11) {
         break label$27;
        }
        $10 = 16777216;
        if ($7) {
         break label$27;
        }
        $11 = 0;
        break label$26;
       }
       HEAP32[$15 >> 2] = $10 - $7;
       $11 = 1;
      }
      $2 = $2 + 1 | 0;
      if (($6 | 0) != ($2 | 0)) {
       continue;
      }
      break;
     }
    }
    label$28: {
     if ($22) {
      break label$28;
     }
     $2 = 8388607;
     label$29: {
      switch ($24 | 0) {
      case 1:
       $2 = 4194303;
       break;

      case 0:
       break label$29;

      default:
       break label$28;
      }
     }
     $10 = ($6 << 2) + $8 | 0;
     $7 = $10 + 476 | 0;
     HEAP32[$7 >> 2] = HEAP32[$10 + 476 >> 2] & $2;
    }
    $16 = $16 + 1 | 0;
    if (($14 | 0) != 2) {
     break label$19;
    }
    $5 = 1 - $5;
    $14 = 2;
    if (!$11) {
     break label$19;
    }
    $5 = $5 - scalbn(1, $17);
   }
   if ($5 == 0) {
    $7 = 0;
    label$32: {
     $2 = $6;
     if (($12 | 0) >= ($2 | 0)) {
      break label$32;
     }
     while (1) {
      $2 = $2 - 1 | 0;
      $7 = HEAP32[($8 + 480 | 0) + ($2 << 2) >> 2] | $7;
      if (($2 | 0) > ($12 | 0)) {
       continue;
      }
      break;
     }
     if (!$7) {
      break label$32;
     }
     $13 = $17;
     while (1) {
      $13 = $13 - 24 | 0;
      $6 = $6 - 1 | 0;
      if (!HEAP32[($8 + 480 | 0) + ($6 << 2) >> 2]) {
       continue;
      }
      break;
     }
     break label$9;
    }
    $2 = 1;
    while (1) {
     $7 = $2;
     $2 = $2 + 1 | 0;
     if (!HEAP32[($8 + 480 | 0) + ($12 - $7 << 2) >> 2]) {
      continue;
     }
     break;
    }
    $10 = $6 + $7 | 0;
    while (1) {
     $7 = $3 + $6 | 0;
     $6 = $6 + 1 | 0;
     HEAPF64[($8 + 320 | 0) + ($7 << 3) >> 3] = HEAP32[($18 + $6 << 2) + 192816 >> 2];
     $2 = 0;
     $5 = 0;
     if (($3 | 0) > 0) {
      while (1) {
       $5 = HEAPF64[($2 << 3) + $0 >> 3] * HEAPF64[($8 + 320 | 0) + ($7 - $2 << 3) >> 3] + $5;
       $2 = $2 + 1 | 0;
       if (($3 | 0) != ($2 | 0)) {
        continue;
       }
       break;
      }
     }
     HEAPF64[($6 << 3) + $8 >> 3] = $5;
     if (($6 | 0) < ($10 | 0)) {
      continue;
     }
     break;
    }
    $6 = $10;
    continue;
   }
   break;
  }
  $5 = scalbn($5, 24 - $13 | 0);
  label$39: {
   if ($5 >= 16777216) {
    $3 = $6 << 2;
    $3 = $3 + ($8 + 480 | 0) | 0;
    $9 = $5 * 5.960464477539063e-8;
    label$42: {
     if (Math_abs($9) < 2147483648) {
      $2 = ~~$9;
      break label$42;
     }
     $2 = -2147483648;
    }
    $5 = +($2 | 0) * -16777216 + $5;
    label$41: {
     if (Math_abs($5) < 2147483648) {
      $7 = ~~$5;
      break label$41;
     }
     $7 = -2147483648;
    }
    HEAP32[$3 >> 2] = $7;
    $6 = $6 + 1 | 0;
    break label$39;
   }
   if (Math_abs($5) < 2147483648) {
    $2 = ~~$5;
   } else {
    $2 = -2147483648;
   }
   $13 = $17;
  }
  HEAP32[($8 + 480 | 0) + ($6 << 2) >> 2] = $2;
 }
 $5 = scalbn(1, $13);
 label$47: {
  if (($6 | 0) < 0) {
   break label$47;
  }
  $3 = $6;
  while (1) {
   $2 = $3;
   HEAPF64[($2 << 3) + $8 >> 3] = $5 * +HEAP32[($8 + 480 | 0) + ($2 << 2) >> 2];
   $3 = $2 - 1 | 0;
   $5 = $5 * 5.960464477539063e-8;
   if ($2) {
    continue;
   }
   break;
  }
  $10 = 0;
  if (($6 | 0) < 0) {
   break label$47;
  }
  $12 = ($12 | 0) > 0 ? $12 : 0;
  $7 = $6;
  while (1) {
   $0 = $10 >>> 0 > $12 >>> 0 ? $12 : $10;
   $11 = $6 - $7 | 0;
   $2 = 0;
   $5 = 0;
   while (1) {
    $5 = HEAPF64[($2 << 3) + 195584 >> 3] * HEAPF64[($2 + $7 << 3) + $8 >> 3] + $5;
    $3 = ($0 | 0) != ($2 | 0);
    $2 = $2 + 1 | 0;
    if ($3) {
     continue;
    }
    break;
   }
   HEAPF64[($8 + 160 | 0) + ($11 << 3) >> 3] = $5;
   $7 = $7 - 1 | 0;
   $2 = ($6 | 0) != ($10 | 0);
   $10 = $10 + 1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
 label$51: {
  label$52: {
   label$53: {
    switch ($4 | 0) {
    case 3:
     label$56: {
      if (($6 | 0) <= 0) {
       break label$56;
      }
      $5 = HEAPF64[($8 + 160 | 0) + ($6 << 3) >> 3];
      $2 = $6;
      while (1) {
       $3 = $2 - 1 | 0;
       $7 = ($8 + 160 | 0) + ($3 << 3) | 0;
       $9 = HEAPF64[$7 >> 3];
       $19 = $9;
       $9 = $9 + $5;
       HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3] = $5 + ($19 - $9);
       HEAPF64[$7 >> 3] = $9;
       $7 = $2 >>> 0 > 1;
       $5 = $9;
       $2 = $3;
       if ($7) {
        continue;
       }
       break;
      }
      if (($6 | 0) < 2) {
       break label$56;
      }
      $5 = HEAPF64[($8 + 160 | 0) + ($6 << 3) >> 3];
      $2 = $6;
      while (1) {
       $3 = $2 - 1 | 0;
       $7 = ($8 + 160 | 0) + ($3 << 3) | 0;
       $9 = HEAPF64[$7 >> 3];
       $19 = $9;
       $9 = $9 + $5;
       HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3] = $5 + ($19 - $9);
       HEAPF64[$7 >> 3] = $9;
       $7 = $2 >>> 0 > 2;
       $5 = $9;
       $2 = $3;
       if ($7) {
        continue;
       }
       break;
      }
      if (($6 | 0) <= 1) {
       break label$56;
      }
      while (1) {
       $20 = $20 + HEAPF64[($8 + 160 | 0) + ($6 << 3) >> 3];
       $2 = ($6 | 0) > 2;
       $6 = $6 - 1 | 0;
       if ($2) {
        continue;
       }
       break;
      }
     }
     $5 = HEAPF64[$8 + 160 >> 3];
     if ($14) {
      break label$52;
     }
     HEAPF64[$1 >> 3] = $5;
     $5 = HEAPF64[$8 + 168 >> 3];
     HEAPF64[$1 + 16 >> 3] = $20;
     HEAPF64[$1 + 8 >> 3] = $5;
     break label$51;

    case 0:
     $5 = 0;
     if (($6 | 0) >= 0) {
      while (1) {
       $2 = $6;
       $6 = $2 - 1 | 0;
       $5 = $5 + HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3];
       if ($2) {
        continue;
       }
       break;
      }
     }
     HEAPF64[$1 >> 3] = $14 ? -$5 : $5;
     break label$51;

    case 1:
    case 2:
     break label$53;

    default:
     break label$51;
    }
   }
   $5 = 0;
   if (($6 | 0) >= 0) {
    $3 = $6;
    while (1) {
     $2 = $3;
     $3 = $2 - 1 | 0;
     $5 = $5 + HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3];
     if ($2) {
      continue;
     }
     break;
    }
   }
   HEAPF64[$1 >> 3] = $14 ? -$5 : $5;
   $5 = HEAPF64[$8 + 160 >> 3] - $5;
   $2 = 1;
   if (($6 | 0) > 0) {
    while (1) {
     $5 = $5 + HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3];
     $3 = ($2 | 0) != ($6 | 0);
     $2 = $2 + 1 | 0;
     if ($3) {
      continue;
     }
     break;
    }
   }
   HEAPF64[$1 + 8 >> 3] = $14 ? -$5 : $5;
   break label$51;
  }
  HEAPF64[$1 >> 3] = -$5;
  $5 = HEAPF64[$8 + 168 >> 3];
  HEAPF64[$1 + 16 >> 3] = -$20;
  HEAPF64[$1 + 8 >> 3] = -$5;
 }
 __stack_pointer = $8 + 560 | 0;
 return $16 & 7;
}

function jspeStatementFor() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = __stack_pointer - 432 | 0;
 __stack_pointer = $0;
 jslGetNextToken();
 label$1: {
  if (!(jslMatch(40) & 1)) {
   break label$1;
  }
  HEAP8[$0 + 427 | 0] = (HEAP32[91094] & 512) != 0;
  HEAP32[91094] = HEAP32[91094] | 256;
  HEAP32[$0 + 420 >> 2] = jspeBlockStart();
  HEAP32[$0 + 416 >> 2] = 0;
  HEAP8[$0 + 415 | 0] = HEAP16[HEAP32[49079] + 2 >> 1] == 174;
  if (HEAP16[HEAP32[49079] + 2 >> 1] != 59) {
   HEAP32[$0 + 416 >> 2] = jspeStatement();
  }
  if (jspIsInterrupted() & 1) {
   jsvUnLock(HEAP32[$0 + 416 >> 2]);
   jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
   break label$1;
  }
  HEAP32[91094] = HEAP32[91094] & -257;
  label$5: {
   if (!(HEAP16[HEAP32[49079] + 2 >> 1] != 185 & HEAP16[HEAP32[49079] + 2 >> 1] != 198)) {
    HEAP8[$0 + 414 | 0] = HEAP16[HEAP32[49079] + 2 >> 1] == 198;
    label$8: {
     if ((HEAP32[91094] & 63) != 1) {
      break label$8;
     }
     if (jsvIsName(HEAP32[$0 + 416 >> 2]) & 1) {
      break label$8;
     }
     jsvUnLock(HEAP32[$0 + 416 >> 2]);
     $1 = HEAP8[$0 + 414 | 0] & 1;
     HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 416 >> 2];
     HEAP32[$0 + 16 >> 2] = $1 ? 130107 : 128512;
     jsExceptionHere(1, 118113, $0 + 16 | 0);
     jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
     break label$1;
    }
    jslGetNextToken();
    HEAP32[$0 + 408 >> 2] = jsvSkipNameAndUnLock(jspeExpression());
    jslCharPosFromLex($0 + 368 | 0);
    if (!(jslMatch(41) & 1)) {
     jsvUnLock2(HEAP32[$0 + 416 >> 2], HEAP32[$0 + 408 >> 2]);
     jslCharPosFree($0 + 368 | 0);
     jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
     break label$1;
    }
    HEAP32[$0 + 364 >> 2] = HEAP32[91094];
    jspSetNoExecute();
    HEAP32[91094] = HEAP32[91094] | 512;
    jsvUnLock(jspeBlockOrStatement());
    jslCharPosNew($0 + 320 | 0, HEAP32[HEAP32[49079] + 84 >> 2], HEAP32[HEAP32[49079] + 4 >> 2]);
    if (!(HEAP8[$0 + 427 | 0] & 1)) {
     HEAP32[91094] = HEAP32[91094] & -513;
    }
    HEAP32[91094] = HEAP32[91094] & -1664 | HEAP32[$0 + 364 >> 2] & 1663;
    if ((HEAP32[91094] & 63) == 1) {
     label$12: {
      if (jsvIsIterable(HEAP32[$0 + 408 >> 2]) & 1) {
       HEAP32[$0 + 316 >> 2] = jsvGetInternalFunctionCheckerFor(HEAP32[$0 + 408 >> 2]);
       HEAP32[$0 + 312 >> 2] = 0;
       if (!(HEAP8[$0 + 414 | 0] & 1)) {
        HEAP32[$0 + 312 >> 2] = jspGetBuiltinPrototype(HEAP32[$0 + 408 >> 2]);
       }
       jsvIteratorNew($0 + 248 | 0, HEAP32[$0 + 408 >> 2], HEAP8[$0 + 414 | 0] & 1);
       HEAP8[$0 + 247 | 0] = 0;
       while (1) {
        $1 = 0;
        label$16: {
         if ((HEAP32[91094] & 63) != 1) {
          break label$16;
         }
         $1 = 0;
         if (!(jsvIteratorHasElement($0 + 248 | 0) & 1)) {
          break label$16;
         }
         $1 = HEAPU8[$0 + 247 | 0] ^ -1;
        }
        if ($1 & 1) {
         HEAP32[$0 + 240 >> 2] = jsvIteratorGetKey($0 + 248 | 0);
         HEAP8[$0 + 239 | 0] = 0;
         label$18: {
          if (!HEAP32[$0 + 316 >> 2]) {
           break label$18;
          }
          if (!(FUNCTION_TABLE[HEAP32[$0 + 316 >> 2]](HEAP32[$0 + 240 >> 2]) & 1)) {
           break label$18;
          }
          HEAP8[$0 + 239 | 0] = 1;
          label$19: {
           if (HEAP8[$0 + 414 | 0] & 1) {
            break label$19;
           }
           if (!(jsvIsString(HEAP32[$0 + 240 >> 2]) & 1)) {
            break label$19;
           }
           if (!(jsvIsStringEqual(HEAP32[$0 + 240 >> 2], 135865) & 1)) {
            break label$19;
           }
           HEAP32[$0 + 312 >> 2] = jsvSkipName(HEAP32[$0 + 240 >> 2]);
          }
         }
         if (!(HEAP8[$0 + 239 | 0] & 1)) {
          label$21: {
           if (HEAP8[$0 + 414 | 0] & 1) {
            HEAP32[$0 + 232 >> 2] = jsvIteratorGetValue($0 + 248 | 0);
            break label$21;
           }
           HEAP32[$0 + 232 >> 2] = jsvAsString(HEAP32[$0 + 240 >> 2]);
          }
          if (HEAP32[$0 + 232 >> 2] ? 1 : HEAP8[$0 + 414 | 0] & 1) {
           if (HEAP8[$0 + 415 | 0] & 1) {
            $1 = HEAP32[$0 + 416 >> 2];
            $2 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -65;
            HEAP8[$1 + 12 | 0] = $2;
            HEAP8[$1 + 13 | 0] = $2 >>> 8;
           }
           jsvReplaceWithOrAddToRoot(HEAP32[$0 + 416 >> 2], HEAP32[$0 + 232 >> 2]);
           if (HEAP8[$0 + 415 | 0] & 1) {
            $1 = HEAP32[$0 + 416 >> 2];
            $2 = HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8 | 64;
            HEAP8[$1 + 12 | 0] = $2;
            HEAP8[$1 + 13 | 0] = $2 >>> 8;
           }
           jsvUnLock(HEAP32[$0 + 232 >> 2]);
           jslSeekToP($0 + 368 | 0);
           HEAP32[91094] = HEAP32[91094] | 512;
           jspDebuggerLoopIfCtrlC();
           jsvUnLock(jspeBlockOrStatement());
           if (!(HEAP8[$0 + 427 | 0] & 1)) {
            HEAP32[91094] = HEAP32[91094] & -513;
           }
           HEAP8[$0 + 247 | 0] = jspeCheckBreakContinue() & 1 | HEAP8[$0 + 247 | 0] & 1;
          }
         }
         jsvIteratorNext($0 + 248 | 0);
         jsvUnLock(HEAP32[$0 + 240 >> 2]);
         if (!(jsvIteratorHasElement($0 + 248 | 0) & 1 | HEAP8[$0 + 414 | 0] & 1 | !HEAP32[$0 + 312 >> 2])) {
          jsvIteratorFree($0 + 248 | 0);
          HEAP32[$0 + 228 >> 2] = HEAP32[$0 + 312 >> 2];
          jsvIteratorNew($0 + 248 | 0, HEAP32[$0 + 228 >> 2], 0);
          HEAP32[$0 + 316 >> 2] = jsvGetInternalFunctionCheckerFor(HEAP32[$0 + 228 >> 2]);
          HEAP32[$0 + 312 >> 2] = jspGetBuiltinPrototype(HEAP32[$0 + 228 >> 2]);
          jsvUnLock(HEAP32[$0 + 228 >> 2]);
         }
         continue;
        }
        break;
       }
       jsvUnLock(HEAP32[$0 + 312 >> 2]);
       jsvIteratorFree($0 + 248 | 0);
       break label$12;
      }
      if (!(jsvIsUndefined(HEAP32[$0 + 408 >> 2]) & 1)) {
       HEAP32[$0 >> 2] = HEAP32[$0 + 408 >> 2];
       jsExceptionHere(1, 118047, $0);
      }
     }
    }
    jslSeekToP($0 + 320 | 0);
    jslCharPosFree($0 + 368 | 0);
    jslCharPosFree($0 + 320 | 0);
    jsvUnLock2(HEAP32[$0 + 416 >> 2], HEAP32[$0 + 408 >> 2]);
    break label$5;
   }
   HEAP8[$0 + 227 | 0] = 1;
   HEAP8[$0 + 226 | 0] = 0;
   jsvUnLock(HEAP32[$0 + 416 >> 2]);
   jslCharPosFromLex($0 + 184 | 0);
   if (!(jslMatch(59) & 1)) {
    jslCharPosFree($0 + 184 | 0);
    jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
    jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
    break label$1;
   }
   if (HEAP16[HEAP32[49079] + 2 >> 1] != 59) {
    HEAP32[$0 + 180 >> 2] = jspeExpression();
    if ((HEAP32[91094] & 63) == 1) {
     $1 = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$0 + 180 >> 2]));
    }
    HEAP8[$0 + 227 | 0] = $1 & 1;
    jsvUnLock(HEAP32[$0 + 180 >> 2]);
   }
   jslCharPosFromLex($0 + 136 | 0);
   if (!(jslMatch(59) & 1)) {
    jslCharPosFree($0 + 184 | 0);
    jslCharPosFree($0 + 136 | 0);
    jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
    break label$1;
   }
   if (HEAP16[HEAP32[49079] + 2 >> 1] != 41) {
    HEAP32[$0 + 132 >> 2] = HEAP32[91094];
    jspSetNoExecute();
    jsvUnLock(jspeExpression());
    HEAP32[91094] = HEAP32[91094] & -1664 | HEAP32[$0 + 132 >> 2] & 1663;
   }
   jslSkipWhiteSpace();
   jslCharPosFromLex($0 + 88 | 0);
   if (!(jslMatch(41) & 1)) {
    jslCharPosFree($0 + 184 | 0);
    jslCharPosFree($0 + 136 | 0);
    jslCharPosFree($0 + 88 | 0);
    jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
    break label$1;
   }
   HEAP32[$0 + 84 >> 2] = HEAP32[91094];
   if (!(HEAP8[$0 + 227 | 0] & 1)) {
    jspSetNoExecute();
   }
   HEAP32[91094] = HEAP32[91094] | 512;
   jsvUnLock(jspeBlockOrStatement());
   jslSkipWhiteSpace();
   jslCharPosNew($0 + 40 | 0, HEAP32[HEAP32[49079] + 84 >> 2], HEAP32[HEAP32[49079] + 4 >> 2]);
   if (!(HEAP8[$0 + 427 | 0] & 1)) {
    HEAP32[91094] = HEAP32[91094] & -513;
   }
   if (!(!(HEAP8[$0 + 227 | 0] & 1) & (HEAP32[91094] & 63) == 1)) {
    HEAP8[$0 + 226 | 0] = jspeCheckBreakContinue() & 1 | HEAP8[$0 + 226 | 0] & 1;
    if (HEAP8[$0 + 226 | 0] & 1) {
     HEAP8[$0 + 227 | 0] = 0;
    }
   }
   if (!(HEAP8[$0 + 227 | 0] & 1)) {
    HEAP32[91094] = HEAP32[91094] & -1664 | HEAP32[$0 + 84 >> 2] & 1663;
   }
   if (HEAP8[$0 + 227 | 0] & 1) {
    jslSeekToP($0 + 136 | 0);
    if (HEAP16[HEAP32[49079] + 2 >> 1] != 41) {
     jsvUnLock(jspeExpression());
    }
   }
   while (1) {
    $1 = 0;
    label$45: {
     if (HEAP8[$0 + 226 | 0] & 1) {
      break label$45;
     }
     $1 = 0;
     if ((HEAP32[91094] & 63) != 1) {
      break label$45;
     }
     $1 = HEAPU8[$0 + 227 | 0];
    }
    if ($1 & 1) {
     jslSeekToP($0 + 184 | 0);
     label$47: {
      if (HEAP16[HEAP32[49079] + 2 >> 1] == 59) {
       HEAP8[$0 + 227 | 0] = 1;
       break label$47;
      }
      HEAP32[$0 + 36 >> 2] = jspeExpression();
      HEAP8[$0 + 227 | 0] = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$0 + 36 >> 2])) & 1;
      jsvUnLock(HEAP32[$0 + 36 >> 2]);
     }
     if (!(!(HEAP8[$0 + 227 | 0] & 1) | (HEAP32[91094] & 63) != 1)) {
      jslSeekToP($0 + 88 | 0);
      HEAP32[91094] = HEAP32[91094] | 512;
      jspDebuggerLoopIfCtrlC();
      jsvUnLock(jspeBlockOrStatement());
      if (!(HEAP8[$0 + 427 | 0] & 1)) {
       HEAP32[91094] = HEAP32[91094] & -513;
      }
      HEAP8[$0 + 226 | 0] = jspeCheckBreakContinue() & 1 | HEAP8[$0 + 226 | 0] & 1;
     }
     if (!(HEAP8[$0 + 226 | 0] & 1 | (!(HEAP8[$0 + 227 | 0] & 1) | (HEAP32[91094] & 63) != 1))) {
      jslSeekToP($0 + 136 | 0);
      if (HEAP16[HEAP32[49079] + 2 >> 1] != 41) {
       jsvUnLock(jspeExpression());
      }
     }
     continue;
    }
    break;
   }
   jslSeekToP($0 + 40 | 0);
   jslCharPosFree($0 + 184 | 0);
   jslCharPosFree($0 + 136 | 0);
   jslCharPosFree($0 + 88 | 0);
   jslCharPosFree($0 + 40 | 0);
  }
  jspeBlockEnd(HEAP32[$0 + 420 >> 2]);
 }
 HEAP32[$0 + 428 >> 2] = 0;
 __stack_pointer = $0 + 432 | 0;
 return HEAP32[$0 + 428 >> 2];
}

function jswrap_banglejs_init() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = __stack_pointer - 272 | 0;
 __stack_pointer = $0;
 HEAP8[$0 + 270 | 0] = (HEAPU16[182206] & 4096) != 0;
 HEAP8[$0 + 269 | 0] = 0;
 if (HEAP8[$0 + 270 | 0] & 1) {
  HEAP32[97749] = 196686;
  HEAP8[391062] = 255;
  HEAP32[97771] = 0;
  healthStateClear(391088);
  healthStateClear(391104);
  healthStateClear(391120);
  if (jshPinGetValue(17) & 1) {
   HEAP8[$0 + 269 | 0] = 1;
  }
 }
 HEAP32[97749] = HEAP32[97749] | 2048;
 HEAP16[195510] = 0;
 HEAP32[97766] = 1500;
 HEAP32[97751] = 0;
 HEAP32[97753] = 3e3;
 HEAP32[97754] = 5e3;
 HEAP8[391026] = 0;
 if (jshPinGetValue(17) & 1) {
  HEAP8[391026] = 1;
 }
 HEAP8[391136] = 0;
 HEAP16[195569] = 0;
 if (!(HEAP8[$0 + 269 | 0] & 1)) {
  HEAP32[$0 + 264 >> 2] = jsvNewFromString(128098);
  HEAP32[$0 + 260 >> 2] = jswrap_storage_readJSON(HEAP32[$0 + 264 >> 2], 1);
  jsvUnLock(HEAP32[$0 + 264 >> 2]);
  label$5: {
   if (jsvIsObject(HEAP32[$0 + 260 >> 2]) & 1) {
    $1 = jsvObjectGetChildIfExists(HEAP32[$0 + 260 >> 2], 121837);
    break label$5;
   }
   $1 = 0;
  }
  HEAP32[$0 + 256 >> 2] = $1;
  label$7: {
   label$8: {
    if (!HEAP32[$0 + 256 >> 2]) {
     break label$8;
    }
    if (jsvGetBool(HEAP32[$0 + 256 >> 2]) & 1) {
     break label$8;
    }
    HEAP32[97749] = HEAP32[97749] & -257;
    break label$7;
   }
   HEAP32[97749] = HEAP32[97749] | 256;
   HEAP32[97749] = HEAP32[97749] | 128;
  }
  jsvUnLock(HEAP32[$0 + 256 >> 2]);
  label$9: {
   if (jsvIsObject(HEAP32[$0 + 260 >> 2]) & 1) {
    $1 = jsvObjectGetChildIfExists(HEAP32[$0 + 260 >> 2], 132036);
    break label$9;
   }
   $1 = 0;
  }
  HEAP32[$0 + 256 >> 2] = $1;
  label$11: {
   label$12: {
    if (!HEAP32[$0 + 256 >> 2]) {
     break label$12;
    }
    if (jsvGetBool(HEAP32[$0 + 256 >> 2]) & 1) {
     break label$12;
    }
    HEAP32[97749] = HEAP32[97749] & -513;
    break label$11;
   }
   HEAP32[97749] = HEAP32[97749] | 512;
  }
  jsvUnLock(HEAP32[$0 + 256 >> 2]);
  jswrap_banglejs_setTheme();
  label$13: {
   if (jsvIsObject(HEAP32[$0 + 260 >> 2]) & 1) {
    $1 = jsvObjectGetChildIfExists(HEAP32[$0 + 260 >> 2], 132386);
    break label$13;
   }
   $1 = 0;
  }
  HEAP32[$0 + 256 >> 2] = $1;
  if (jsvIsObject(HEAP32[$0 + 256 >> 2]) & 1) {
   $1 = jsvObjectGetIntegerChild(HEAP32[$0 + 256 >> 2], 130040);
   HEAP8[366785] = $1;
   HEAP8[366786] = $1 >>> 8;
   $1 = jsvObjectGetIntegerChild(HEAP32[$0 + 256 >> 2], 130044);
   HEAP8[366787] = $1;
   HEAP8[366788] = $1 >>> 8;
   $1 = jsvObjectGetIntegerChild(HEAP32[$0 + 256 >> 2], 139561);
   HEAP8[366789] = $1;
   HEAP8[366790] = $1 >>> 8;
   $1 = jsvObjectGetIntegerChild(HEAP32[$0 + 256 >> 2], 139565);
   HEAP8[366791] = $1;
   HEAP8[366792] = $1 >>> 8;
   $1 = jsvObjectGetIntegerChild(HEAP32[$0 + 256 >> 2], 137564);
   HEAP8[366793] = $1;
   HEAP8[366794] = $1 >>> 8;
   $1 = jsvObjectGetIntegerChild(HEAP32[$0 + 256 >> 2], 137568);
   HEAP8[366795] = $1;
   HEAP8[366796] = $1 >>> 8;
   HEAP8[366797] = jsvObjectGetBoolChild(HEAP32[$0 + 256 >> 2], 129083) & 1;
  }
  jsvUnLock(HEAP32[$0 + 256 >> 2]);
  label$16: {
   if (jsvIsObject(HEAP32[$0 + 260 >> 2]) & 1) {
    $1 = jsvObjectGetChildIfExists(HEAP32[$0 + 260 >> 2], 129519);
    break label$16;
   }
   $1 = 0;
  }
  HEAP32[$0 + 256 >> 2] = $1;
  if (jsvIsObject(HEAP32[$0 + 256 >> 2]) & 1) {
   HEAP16[195496] = jsvObjectGetIntegerChild(HEAP32[$0 + 256 >> 2], 139857);
   HEAP16[195497] = jsvObjectGetIntegerChild(HEAP32[$0 + 256 >> 2], 139854);
   HEAP16[97839] = jsvObjectGetIntegerChild(HEAP32[$0 + 256 >> 2], 139550);
   HEAP16[97840] = jsvObjectGetIntegerChild(HEAP32[$0 + 256 >> 2], 139547);
  }
  jsvUnLock(HEAP32[$0 + 256 >> 2]);
  jsvUnLock(HEAP32[$0 + 260 >> 2]);
 }
 jswrap_banglejs_setLCDOffset(0);
 graphicsStructResetState(366800);
 HEAP32[$0 + 252 >> 2] = jspNewObject(0, 120477);
 label$19: {
  if (!HEAP32[$0 + 252 >> 2]) {
   break label$19;
  }
  jsvObjectSetChild(HEAP32[91086], 130084, HEAP32[$0 + 252 >> 2]);
  jsvObjectSetChild(HEAP32[91087], 116423, HEAP32[$0 + 252 >> 2]);
  $1 = HEAP32[$0 + 252 >> 2];
  HEAP8[366800] = $1;
  HEAP8[366801] = $1 >>> 8;
  HEAP8[366802] = $1 >>> 16;
  HEAP8[366803] = $1 >>> 24;
  HEAP32[$0 + 248 >> 2] = jsvNewNativeFunction(616, 32792);
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 252 >> 2], 121824, HEAP32[$0 + 248 >> 2]);
  label$20: {
   if (HEAP8[$0 + 270 | 0] & 1) {
    break label$20;
   }
  }
  HEAP8[$0 + 247 | 0] = 1;
  if (HEAPU16[182206] & 64) {
   HEAP8[$0 + 247 | 0] = 0;
   if (!(HEAP8[$0 + 270 | 0] & 1 | HEAP8[$0 + 269 | 0] & 1)) {
    jsfNameFromString($0 + 208 | 0, 130031);
    HEAP32[$0 + 64 >> 2] = HEAP32[$0 + 232 >> 2];
    $1 = HEAP32[$0 + 228 >> 2];
    $2 = HEAP32[$0 + 224 >> 2];
    HEAP32[$0 + 56 >> 2] = $2;
    HEAP32[$0 + 60 >> 2] = $1;
    $2 = HEAP32[$0 + 220 >> 2];
    $1 = HEAP32[$0 + 216 >> 2];
    HEAP32[$0 + 48 >> 2] = $1;
    HEAP32[$0 + 52 >> 2] = $2;
    $1 = HEAP32[$0 + 212 >> 2];
    $2 = HEAP32[$0 + 208 >> 2];
    HEAP32[$0 + 40 >> 2] = $2;
    HEAP32[$0 + 44 >> 2] = $1;
    HEAP32[$0 + 240 >> 2] = jsfReadFile($0 + 40 | 0, 0, 0);
    label$23: {
     if (jsvIsString(HEAP32[$0 + 240 >> 2]) & 1) {
      if (jsvGetStringLength(HEAP32[$0 + 240 >> 2]) >>> 0 > 3) {
       HEAP32[$0 + 204 >> 2] = jsvGetCharInString(HEAP32[$0 + 240 >> 2], 0) & 255;
       HEAP32[$0 + 200 >> 2] = jsvGetCharInString(HEAP32[$0 + 240 >> 2], 1) & 255;
       jsvUnLock2(jswrap_graphics_drawImage(HEAP32[$0 + 252 >> 2], HEAP32[$0 + 240 >> 2], (176 - HEAP32[$0 + 204 >> 2] | 0) / 2 | 0, (176 - HEAP32[$0 + 200 >> 2] | 0) / 2 | 0, 0), HEAP32[$0 + 240 >> 2]);
       graphicsInternalFlip();
      }
      break label$23;
     }
     HEAP32[$0 + 196 >> 2] = 88;
     HEAP32[$0 + 192 >> 2] = 88;
     graphicsFillRect(366800, HEAP32[$0 + 196 >> 2] - 49 | 0, HEAP32[$0 + 192 >> 2] - 19 | 0, HEAP32[$0 + 196 >> 2] + 49 | 0, HEAP32[$0 + 192 >> 2] + 19 | 0, HEAPU8[366787] | HEAPU8[366788] << 8);
     $1 = HEAPU8[366785] | HEAPU8[366786] << 8;
     HEAP8[366817] = $1;
     HEAP8[366818] = $1 >>> 8;
     HEAP8[366819] = $1 >>> 16;
     HEAP8[366820] = $1 >>> 24;
     graphicsDrawRect(366800, HEAP32[$0 + 196 >> 2] - 50 | 0, HEAP32[$0 + 192 >> 2] - 20 | 0, HEAP32[$0 + 196 >> 2] + 50 | 0, HEAP32[$0 + 192 >> 2] + 20 | 0);
     HEAP32[$0 + 192 >> 2] = HEAP32[$0 + 192 >> 2] - 4;
     HEAP32[$0 + 196 >> 2] = HEAP32[$0 + 196 >> 2] - 24;
     HEAP32[$0 + 188 >> 2] = 141025;
     while (1) {
      if (HEAPU8[HEAP32[$0 + 188 >> 2]]) {
       graphicsDrawChar6x8(366800, HEAP32[$0 + 196 >> 2], HEAP32[$0 + 192 >> 2], HEAP8[HEAP32[$0 + 188 >> 2]], 1, 1, 0);
       HEAP32[$0 + 196 >> 2] = HEAP32[$0 + 196 >> 2] + 6;
       HEAP32[$0 + 188 >> 2] = HEAP32[$0 + 188 >> 2] + 1;
       continue;
      }
      break;
     }
     graphicsInternalFlip();
    }
   }
  }
  if (HEAP8[$0 + 269 | 0] & 1) {
   HEAP8[$0 + 247 | 0] = 0;
  }
  if (HEAP8[$0 + 247 | 0] & 1) {
   HEAP8[366825] = 1;
   HEAP8[366826] = 64;
   graphicsClear(366800);
   HEAP8[$0 + 187 | 0] = 0;
   jsfNameFromString($0 + 152 | 0, 129467);
   HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 176 >> 2];
   $2 = HEAP32[$0 + 172 >> 2];
   $1 = HEAP32[$0 + 168 >> 2];
   HEAP32[$0 + 24 >> 2] = $1;
   HEAP32[$0 + 28 >> 2] = $2;
   $1 = HEAP32[$0 + 164 >> 2];
   $2 = HEAP32[$0 + 160 >> 2];
   HEAP32[$0 + 16 >> 2] = $2;
   HEAP32[$0 + 20 >> 2] = $1;
   $2 = HEAP32[$0 + 156 >> 2];
   $1 = HEAP32[$0 + 152 >> 2];
   HEAP32[$0 + 8 >> 2] = $1;
   HEAP32[$0 + 12 >> 2] = $2;
   HEAP32[$0 + 180 >> 2] = jsfReadFile($0 + 8 | 0, 0, 0);
   label$30: {
    if (jsvIsString(HEAP32[$0 + 180 >> 2]) & 1) {
     if (jsvGetStringLength(HEAP32[$0 + 180 >> 2])) {
      break label$30;
     }
    }
    jsvUnLock(HEAP32[$0 + 180 >> 2]);
    HEAP8[$0 + 187 | 0] = 1;
    HEAP32[$0 + 180 >> 2] = jswrap_banglejs_getLogo();
   }
   HEAP32[$0 + 148 >> 2] = jsvGetCharInString(HEAP32[$0 + 180 >> 2], 0) & 255;
   HEAP32[$0 + 144 >> 2] = jsvGetCharInString(HEAP32[$0 + 180 >> 2], 1) & 255;
   HEAP32[$0 + 108 >> 2] = jsvNewFromString(133615);
   jsvGetString(HEAP32[$0 + 108 >> 2], $0 + 112 | 0, 20);
   jsvUnLock(HEAP32[$0 + 108 >> 2]);
   HEAP32[$0 + 104 >> 2] = (176 - HEAP32[$0 + 144 >> 2] | 0) / 2;
   jsvUnLock2(jswrap_graphics_drawImage(HEAP32[$0 + 252 >> 2], HEAP32[$0 + 180 >> 2], (176 - HEAP32[$0 + 148 >> 2] | 0) / 2 | 0, HEAP32[$0 + 104 >> 2], 0), HEAP32[$0 + 180 >> 2]);
   if (HEAP8[$0 + 187 | 0] & 1) {
    label$33: {
     if (HEAP32[$0 + 144 >> 2] > 56) {
      HEAP32[$0 + 104 >> 2] = HEAP32[$0 + 104 >> 2] + (HEAP32[$0 + 144 >> 2] - 28 | 0);
      break label$33;
     }
     HEAP32[$0 + 104 >> 2] = HEAP32[$0 + 104 >> 2] + (HEAP32[$0 + 144 >> 2] - 15 | 0);
    }
    HEAP32[$0 + 76 >> 2] = jsvNewFromString(133615);
    jsvGetString(HEAP32[$0 + 76 >> 2], $0 + 80 | 0, 20);
    jsvUnLock(HEAP32[$0 + 76 >> 2]);
    jswrap_graphics_drawCString(366800, 8, HEAP32[$0 + 104 >> 2], 139436);
    jswrap_graphics_drawCString(366800, 8, HEAP32[$0 + 104 >> 2] + 10 | 0, $0 + 80 | 0);
    jswrap_graphics_drawCString(366800, 8, HEAP32[$0 + 104 >> 2] + 20 | 0, 120110);
   }
  }
  graphicsInternalFlip();
  graphicsStructResetState(366800);
  if (HEAP8[$0 + 270 | 0] & 1) {
   stepcount_init();
   HEAP32[97767] = 0;
  }
  HEAP8[391140] = 0;
  jshPinSetState(23, 5);
  HEAP32[97786] = 0;
  HEAP32[97787] = 0;
  HEAP32[97788] = 0;
  jshSetPinShouldStayWatched(17, 1);
  HEAP8[$0 + 271 | 0] = jshPinWatch(17, 1, 0);
  if (HEAPU8[$0 + 271 | 0]) {
   jshSetEventCallback(HEAPU8[$0 + 271 | 0], 617);
  }
  if (!(HEAP8[$0 + 270 | 0] & 1)) {
   jsvUnLock(jsiSetTimeout(618, 500));
  }
  if (!(HEAP8[$0 + 269 | 0] & 1)) {
   break label$19;
  }
  jsvUnLock(jspEvaluate(145081, 1));
 }
 __stack_pointer = $0 + 272 | 0;
}

function jswrap_graphics_toColor($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 304 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 296 >> 2] = $0;
 HEAP32[$4 + 292 >> 2] = $1;
 HEAP32[$4 + 288 >> 2] = $2;
 HEAP32[$4 + 284 >> 2] = $3;
 label$1: {
  if (!(graphicsGetFromVar($4 + 208 | 0, HEAP32[$4 + 296 >> 2]) & 1)) {
   HEAP32[$4 + 300 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 204 >> 2] = 0;
  label$3: {
   if (jsvIsString(HEAP32[$4 + 292 >> 2]) & 1) {
    $1 = $4 + 167 | 0;
    HEAP8[$1 | 0] = 0;
    HEAP8[$1 + 1 | 0] = 0;
    HEAP8[$1 + 2 | 0] = 0;
    HEAP8[$1 + 3 | 0] = 0;
    HEAP8[$1 + 4 | 0] = 0;
    HEAP8[$1 + 5 | 0] = 0;
    HEAP8[$1 + 6 | 0] = 0;
    HEAP8[$1 + 7 | 0] = 0;
    HEAP8[$1 + 8 | 0] = 0;
    jsvGetString(HEAP32[$4 + 292 >> 2], $4 + 167 | 0, 9);
    label$5: {
     if (!HEAP8[$4 + 171 | 0]) {
      HEAPF64[$4 + 192 >> 3] = +(chtod(HEAP8[$4 + 168 | 0]) | 0) / 15;
      HEAPF64[$4 + 184 >> 3] = +(chtod(HEAP8[$4 + 169 | 0]) | 0) / 15;
      HEAPF64[$4 + 176 >> 3] = +(chtod(HEAP8[$4 + 170 | 0]) | 0) / 15;
      break label$5;
     }
     HEAPF64[$4 + 192 >> 3] = +(hexToByte(HEAP8[$4 + 168 | 0], HEAP8[$4 + 169 | 0]) | 0) / 255;
     HEAPF64[$4 + 184 >> 3] = +(hexToByte(HEAP8[$4 + 170 | 0], HEAP8[$4 + 171 | 0]) | 0) / 255;
     HEAPF64[$4 + 176 >> 3] = +(hexToByte(HEAP8[$4 + 172 | 0], HEAP8[$4 + 173 | 0]) | 0) / 255;
    }
    label$7: {
     if (!(HEAPF64[$4 + 192 >> 3] < 0 | HEAPF64[$4 + 184 >> 3] < 0 | HEAPF64[$4 + 176 >> 3] < 0)) {
      if (!HEAP8[$4 + 174 | 0]) {
       break label$7;
      }
     }
     jsExceptionHere(1, 145428, 0);
     HEAP32[$4 + 300 >> 2] = 0;
     break label$1;
    }
    break label$3;
   }
   HEAPF64[$4 + 192 >> 3] = jsvGetFloat(HEAP32[$4 + 292 >> 2]);
   HEAPF64[$4 + 184 >> 3] = jsvGetFloat(HEAP32[$4 + 288 >> 2]);
   HEAPF64[$4 + 176 >> 3] = jsvGetFloat(HEAP32[$4 + 284 >> 2]);
  }
  $1 = __DOUBLE_BITS_11(HEAPF64[$4 + 192 >> 3]);
  $0 = $1;
  $1 = i64toi32_i32$HIGH_BITS;
  $1 = $1 & 2147483647;
  label$9: {
   label$10: {
    if (($1 | 0) == 2146435072 | $1 >>> 0 > 2146435072) {
     break label$10;
    }
    $1 = __DOUBLE_BITS_11(HEAPF64[$4 + 184 >> 3]);
    $0 = $1;
    $1 = i64toi32_i32$HIGH_BITS;
    $1 = $1 & 2147483647;
    if (($1 | 0) == 2146435072 | $1 >>> 0 > 2146435072) {
     break label$10;
    }
    $1 = __DOUBLE_BITS_11(HEAPF64[$4 + 176 >> 3]);
    $0 = $1;
    $1 = i64toi32_i32$HIGH_BITS;
    $1 = $1 & 2147483647;
    if (($1 | 0) == 2146435072 | $1 >>> 0 > 2146435072) {
     break label$10;
    }
    $5 = HEAPF64[$4 + 192 >> 3] * 256;
    label$14: {
     if (Math_abs($5) < 2147483648) {
      $0 = ~~$5;
      break label$14;
     }
     $0 = -2147483648;
    }
    HEAP32[$4 + 160 >> 2] = $0;
    $5 = HEAPF64[$4 + 184 >> 3] * 256;
    label$16: {
     if (Math_abs($5) < 2147483648) {
      $0 = ~~$5;
      break label$16;
     }
     $0 = -2147483648;
    }
    HEAP32[$4 + 156 >> 2] = $0;
    $5 = HEAPF64[$4 + 176 >> 3] * 256;
    label$18: {
     if (Math_abs($5) < 2147483648) {
      $0 = ~~$5;
      break label$18;
     }
     $0 = -2147483648;
    }
    HEAP32[$4 + 152 >> 2] = $0;
    if (HEAP32[$4 + 160 >> 2] > 255) {
     HEAP32[$4 + 160 >> 2] = 255;
    }
    if (HEAP32[$4 + 156 >> 2] > 255) {
     HEAP32[$4 + 156 >> 2] = 255;
    }
    if (HEAP32[$4 + 152 >> 2] > 255) {
     HEAP32[$4 + 152 >> 2] = 255;
    }
    if (HEAP32[$4 + 160 >> 2] < 0) {
     HEAP32[$4 + 160 >> 2] = 0;
    }
    if (HEAP32[$4 + 156 >> 2] < 0) {
     HEAP32[$4 + 156 >> 2] = 0;
    }
    if (HEAP32[$4 + 152 >> 2] < 0) {
     HEAP32[$4 + 152 >> 2] = 0;
    }
    HEAP32[$4 + 148 >> 2] = (HEAPU8[$4 + 216 | 0] | HEAPU8[$4 + 217 | 0] << 8 | (HEAPU8[$4 + 218 | 0] << 16 | HEAPU8[$4 + 219 | 0] << 24)) & 896;
    if (HEAP32[$4 + 148 >> 2]) {
     HEAP32[$4 + 144 >> 2] = HEAP32[$4 + 160 >> 2];
     HEAP32[$4 + 140 >> 2] = HEAP32[$4 + 156 >> 2];
     HEAP32[$4 + 136 >> 2] = HEAP32[$4 + 152 >> 2];
     label$27: {
      label$28: {
       label$29: {
        label$30: {
         label$31: {
          $0 = HEAP32[$4 + 148 >> 2];
          if (($0 | 0) != 128) {
           if (($0 | 0) == 256) {
            break label$31;
           }
           if (($0 | 0) == 384) {
            break label$30;
           }
           if (($0 | 0) == 512) {
            break label$29;
           }
           if (($0 | 0) == 640) {
            break label$28;
           }
           break label$27;
          }
          HEAP32[$4 + 160 >> 2] = HEAP32[$4 + 136 >> 2];
          HEAP32[$4 + 156 >> 2] = HEAP32[$4 + 144 >> 2];
          HEAP32[$4 + 152 >> 2] = HEAP32[$4 + 140 >> 2];
          break label$27;
         }
         HEAP32[$4 + 160 >> 2] = HEAP32[$4 + 136 >> 2];
         HEAP32[$4 + 152 >> 2] = HEAP32[$4 + 144 >> 2];
         break label$27;
        }
        HEAP32[$4 + 160 >> 2] = HEAP32[$4 + 140 >> 2];
        HEAP32[$4 + 156 >> 2] = HEAP32[$4 + 136 >> 2];
        HEAP32[$4 + 152 >> 2] = HEAP32[$4 + 144 >> 2];
        break label$27;
       }
       HEAP32[$4 + 160 >> 2] = HEAP32[$4 + 140 >> 2];
       HEAP32[$4 + 156 >> 2] = HEAP32[$4 + 144 >> 2];
       break label$27;
      }
      HEAP32[$4 + 156 >> 2] = HEAP32[$4 + 136 >> 2];
      HEAP32[$4 + 152 >> 2] = HEAP32[$4 + 140 >> 2];
     }
    }
    label$33: {
     if (HEAPU8[$4 + 224 | 0] == 16) {
      HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 156 >> 2] >> 2 << 5 | HEAP32[$4 + 152 >> 2] >> 3 | HEAP32[$4 + 160 >> 2] >> 3 << 11;
      break label$33;
     }
     label$35: {
      if (HEAPU8[$4 + 224 | 0] == 32) {
       HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 152 >> 2] | HEAP32[$4 + 156 >> 2] << 8 | HEAP32[$4 + 160 >> 2] << 16 | -16777216;
       break label$35;
      }
      label$37: {
       if (HEAPU8[$4 + 224 | 0] == 24) {
        HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 152 >> 2] | HEAP32[$4 + 156 >> 2] << 8 | HEAP32[$4 + 160 >> 2] << 16;
        break label$37;
       }
       label$39: {
        if (HEAPU8[$4 + 224 | 0] == 4) {
         HEAP32[$4 + 132 >> 2] = 2147483647;
         HEAP32[$4 + 204 >> 2] = 0;
         HEAP32[$4 + 128 >> 2] = 0;
         while (1) {
          if (HEAPU32[$4 + 128 >> 2] < 16) {
           HEAP32[$4 + 124 >> 2] = HEAPU16[(HEAP32[$4 + 128 >> 2] << 1) + 188608 >> 1];
           HEAP32[$4 + 120 >> 2] = HEAP32[$4 + 124 >> 2] >> 8 & 248;
           HEAP32[$4 + 116 >> 2] = HEAP32[$4 + 124 >> 2] >> 3 & 252;
           HEAP32[$4 + 112 >> 2] = HEAP32[$4 + 124 >> 2] << 3 & 248;
           HEAP32[$4 + 120 >> 2] = HEAP32[$4 + 120 >> 2] | HEAP32[$4 + 120 >> 2] >> 5;
           HEAP32[$4 + 116 >> 2] = HEAP32[$4 + 116 >> 2] | HEAP32[$4 + 112 >> 2] >> 6;
           HEAP32[$4 + 112 >> 2] = HEAP32[$4 + 112 >> 2] | HEAP32[$4 + 112 >> 2] >> 5;
           HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 120 >> 2] - HEAP32[$4 + 160 >> 2];
           HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 116 >> 2] - HEAP32[$4 + 156 >> 2];
           HEAP32[$4 + 100 >> 2] = HEAP32[$4 + 112 >> 2] - HEAP32[$4 + 152 >> 2];
           HEAP32[$4 + 96 >> 2] = (Math_imul(HEAP32[$4 + 108 >> 2], HEAP32[$4 + 108 >> 2]) + Math_imul(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 104 >> 2]) | 0) + Math_imul(HEAP32[$4 + 100 >> 2], HEAP32[$4 + 100 >> 2]);
           if (HEAP32[$4 + 96 >> 2] < HEAP32[$4 + 132 >> 2]) {
            HEAP32[$4 + 132 >> 2] = HEAP32[$4 + 96 >> 2];
            HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 128 >> 2];
           }
           HEAP32[$4 + 128 >> 2] = HEAP32[$4 + 128 >> 2] + 1;
           continue;
          }
          break;
         }
         break label$39;
        }
        label$44: {
         if (HEAPU8[$4 + 224 | 0] == 8) {
          HEAP32[$4 + 92 >> 2] = 2147483647;
          HEAP32[$4 + 204 >> 2] = 0;
          HEAP32[$4 + 88 >> 2] = 0;
          while (1) {
           if (HEAP32[$4 + 88 >> 2] < 255) {
            HEAP32[$4 + 84 >> 2] = HEAPU16[(HEAP32[$4 + 88 >> 2] << 1) + 188640 >> 1];
            HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 84 >> 2] >> 8 & 248;
            HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 84 >> 2] >> 3 & 252;
            HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 84 >> 2] << 3 & 248;
            HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 80 >> 2] | HEAP32[$4 + 80 >> 2] >> 5;
            HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 76 >> 2] | HEAP32[$4 + 72 >> 2] >> 6;
            HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 72 >> 2] | HEAP32[$4 + 72 >> 2] >> 5;
            HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 80 >> 2] - HEAP32[$4 + 160 >> 2];
            HEAP32[$4 + 64 >> 2] = HEAP32[$4 + 76 >> 2] - HEAP32[$4 + 156 >> 2];
            HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 72 >> 2] - HEAP32[$4 + 152 >> 2];
            HEAP32[$4 + 56 >> 2] = (Math_imul(HEAP32[$4 + 68 >> 2], HEAP32[$4 + 68 >> 2]) + Math_imul(HEAP32[$4 + 64 >> 2], HEAP32[$4 + 64 >> 2]) | 0) + Math_imul(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 60 >> 2]);
            if (HEAP32[$4 + 56 >> 2] < HEAP32[$4 + 92 >> 2]) {
             HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 56 >> 2];
             HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 88 >> 2];
            }
            HEAP32[$4 + 88 >> 2] = HEAP32[$4 + 88 >> 2] + 1;
            continue;
           }
           break;
          }
          break label$44;
         }
         HEAP32[$4 + 204 >> 2] = (HEAP32[$4 + 152 >> 2] + (HEAP32[$4 + 160 >> 2] + HEAP32[$4 + 156 >> 2] | 0) | 0) >= 384 ? -1 : 0;
        }
       }
      }
     }
    }
    break label$9;
   }
   HEAP32[$4 + 204 >> 2] = jsvGetInteger(HEAP32[$4 + 292 >> 2]) & (1 << HEAPU8[$4 + 224 | 0]) - 1;
  }
  HEAP32[$4 + 300 >> 2] = HEAP32[$4 + 204 >> 2];
 }
 __stack_pointer = $4 + 304 | 0;
 return HEAP32[$4 + 300 >> 2];
}

function ccm_auth_crypt($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0;
 $11 = __stack_pointer - 128 | 0;
 __stack_pointer = $11;
 HEAP32[$11 + 120 >> 2] = $0;
 HEAP32[$11 + 116 >> 2] = $1;
 HEAP32[$11 + 112 >> 2] = $2;
 HEAP32[$11 + 108 >> 2] = $3;
 HEAP32[$11 + 104 >> 2] = $4;
 HEAP32[$11 + 100 >> 2] = $5;
 HEAP32[$11 + 96 >> 2] = $6;
 HEAP32[$11 + 92 >> 2] = $7;
 HEAP32[$11 + 88 >> 2] = $8;
 HEAP32[$11 + 84 >> 2] = $9;
 HEAP32[$11 + 80 >> 2] = $10;
 label$1: {
  if (HEAP32[$11 + 80 >> 2] & 1 ? 1 : HEAPU32[$11 + 80 >> 2] < 4 | HEAPU32[$11 + 80 >> 2] > 16) {
   HEAP32[$11 + 124 >> 2] = -13;
   break label$1;
  }
  if (!(HEAPU32[$11 + 104 >> 2] <= 13 & HEAPU32[$11 + 104 >> 2] >= 7)) {
   HEAP32[$11 + 124 >> 2] = -13;
   break label$1;
  }
  if (HEAPU32[$11 + 96 >> 2] > 65280) {
   HEAP32[$11 + 124 >> 2] = -13;
   break label$1;
  }
  HEAP8[$11 + 74 | 0] = 15 - (HEAP32[$11 + 104 >> 2] & 255);
  HEAP8[$11 + 48 | 0] = 0;
  HEAP8[$11 + 48 | 0] = HEAPU8[$11 + 48 | 0] | (HEAP32[$11 + 96 >> 2] != 0) << 6;
  HEAP8[$11 + 48 | 0] = HEAPU8[$11 + 48 | 0] | HEAP32[$11 + 80 >> 2] - 2 >>> 1 << 3;
  HEAP8[$11 + 48 | 0] = HEAPU8[$11 + 48 | 0] | HEAPU8[$11 + 74 | 0] - 1;
  __memcpy($11 + 49 | 0, HEAP32[$11 + 108 >> 2], HEAP32[$11 + 104 >> 2]);
  HEAP8[$11 + 75 | 0] = 0;
  HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 112 >> 2];
  while (1) {
   if (HEAPU8[$11 + 75 | 0] < HEAPU8[$11 + 74 | 0]) {
    HEAP8[($11 - HEAPU8[$11 + 75 | 0] | 0) + 63 | 0] = HEAP32[$11 + 68 >> 2];
    HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
    HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 68 >> 2] >>> 8;
    continue;
   }
   break;
  }
  if (HEAP32[$11 + 68 >> 2]) {
   HEAP32[$11 + 124 >> 2] = -13;
   break label$1;
  }
  $0 = $11 + 32 | 0;
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
  HEAP32[$0 + 8 >> 2] = 0;
  HEAP32[$0 + 12 >> 2] = 0;
  HEAP8[$11 + 75 | 0] = 0;
  while (1) {
   if (HEAPU8[$11 + 75 | 0] < 16) {
    $0 = HEAPU8[$11 + 75 | 0] + ($11 + 32 | 0) | 0;
    HEAP8[$0 | 0] = HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 48 | 0) | 0] ^ HEAPU8[$0 | 0];
    HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
    continue;
   }
   break;
  }
  $0 = mbedtls_cipher_update(HEAP32[$11 + 120 >> 2], $11 + 32 | 0, 16, $11 + 32 | 0, $11 - -64 | 0);
  HEAP32[$11 + 76 >> 2] = $0;
  if ($0) {
   HEAP32[$11 + 124 >> 2] = HEAP32[$11 + 76 >> 2];
   break label$1;
  }
  if (HEAP32[$11 + 96 >> 2]) {
   HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 96 >> 2];
   HEAP32[$11 + 12 >> 2] = HEAP32[$11 + 100 >> 2];
   $0 = $11 + 48 | 0;
   HEAP32[$0 >> 2] = 0;
   HEAP32[$0 + 4 >> 2] = 0;
   HEAP32[$0 + 8 >> 2] = 0;
   HEAP32[$0 + 12 >> 2] = 0;
   HEAP8[$11 + 48 | 0] = HEAP32[$11 + 96 >> 2] >>> 8;
   HEAP8[$11 + 49 | 0] = HEAP32[$11 + 96 >> 2];
   if (HEAPU32[$11 + 68 >> 2] < 14) {
    $0 = HEAP32[$11 + 68 >> 2];
   } else {
    $0 = 14;
   }
   HEAP32[$11 + 4 >> 2] = $0;
   __memcpy($11 + 50 | 0, HEAP32[$11 + 12 >> 2], HEAP32[$11 + 4 >> 2]);
   HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 68 >> 2] - HEAP32[$11 + 4 >> 2];
   HEAP32[$11 + 12 >> 2] = HEAP32[$11 + 4 >> 2] + HEAP32[$11 + 12 >> 2];
   HEAP8[$11 + 75 | 0] = 0;
   while (1) {
    if (HEAPU8[$11 + 75 | 0] < 16) {
     $0 = HEAPU8[$11 + 75 | 0] + ($11 + 32 | 0) | 0;
     HEAP8[$0 | 0] = HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 48 | 0) | 0] ^ HEAPU8[$0 | 0];
     HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
     continue;
    }
    break;
   }
   $0 = mbedtls_cipher_update(HEAP32[$11 + 120 >> 2], $11 + 32 | 0, 16, $11 + 32 | 0, $11 - -64 | 0);
   HEAP32[$11 + 76 >> 2] = $0;
   if ($0) {
    HEAP32[$11 + 124 >> 2] = HEAP32[$11 + 76 >> 2];
    break label$1;
   }
   while (1) {
    if (HEAP32[$11 + 68 >> 2]) {
     HEAP32[$11 + 4 >> 2] = HEAPU32[$11 + 68 >> 2] > 16 ? 16 : HEAP32[$11 + 68 >> 2];
     $0 = $11 + 48 | 0;
     HEAP32[$0 >> 2] = 0;
     HEAP32[$0 + 4 >> 2] = 0;
     HEAP32[$0 + 8 >> 2] = 0;
     HEAP32[$0 + 12 >> 2] = 0;
     __memcpy($11 + 48 | 0, HEAP32[$11 + 12 >> 2], HEAP32[$11 + 4 >> 2]);
     HEAP8[$11 + 75 | 0] = 0;
     while (1) {
      if (HEAPU8[$11 + 75 | 0] < 16) {
       $0 = HEAPU8[$11 + 75 | 0] + ($11 + 32 | 0) | 0;
       HEAP8[$0 | 0] = HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 48 | 0) | 0] ^ HEAPU8[$0 | 0];
       HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
       continue;
      }
      break;
     }
     $0 = mbedtls_cipher_update(HEAP32[$11 + 120 >> 2], $11 + 32 | 0, 16, $11 + 32 | 0, $11 - -64 | 0);
     HEAP32[$11 + 76 >> 2] = $0;
     if ($0) {
      HEAP32[$11 + 124 >> 2] = HEAP32[$11 + 76 >> 2];
      break label$1;
     } else {
      HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 68 >> 2] - HEAP32[$11 + 4 >> 2];
      HEAP32[$11 + 12 >> 2] = HEAP32[$11 + 4 >> 2] + HEAP32[$11 + 12 >> 2];
      continue;
     }
    }
    break;
   }
  }
  HEAP8[$11 + 16 | 0] = HEAPU8[$11 + 74 | 0] - 1;
  __memcpy($11 + 17 | 0, HEAP32[$11 + 108 >> 2], HEAP32[$11 + 104 >> 2]);
  memset(HEAP32[$11 + 104 >> 2] + ($11 + 17 | 0) | 0, 0, HEAPU8[$11 + 74 | 0]);
  HEAP8[$11 + 31 | 0] = 1;
  HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 112 >> 2];
  HEAP32[$11 + 12 >> 2] = HEAP32[$11 + 92 >> 2];
  HEAP32[$11 + 8 >> 2] = HEAP32[$11 + 88 >> 2];
  while (1) {
   if (HEAP32[$11 + 68 >> 2]) {
    HEAP32[$11 >> 2] = HEAPU32[$11 + 68 >> 2] > 16 ? 16 : HEAP32[$11 + 68 >> 2];
    if (!HEAP32[$11 + 116 >> 2]) {
     $0 = $11 + 48 | 0;
     HEAP32[$0 >> 2] = 0;
     HEAP32[$0 + 4 >> 2] = 0;
     HEAP32[$0 + 8 >> 2] = 0;
     HEAP32[$0 + 12 >> 2] = 0;
     __memcpy($11 + 48 | 0, HEAP32[$11 + 12 >> 2], HEAP32[$11 >> 2]);
     HEAP8[$11 + 75 | 0] = 0;
     while (1) {
      if (HEAPU8[$11 + 75 | 0] < 16) {
       $0 = HEAPU8[$11 + 75 | 0] + ($11 + 32 | 0) | 0;
       HEAP8[$0 | 0] = HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 48 | 0) | 0] ^ HEAPU8[$0 | 0];
       HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
       continue;
      }
      break;
     }
     $0 = mbedtls_cipher_update(HEAP32[$11 + 120 >> 2], $11 + 32 | 0, 16, $11 + 32 | 0, $11 - -64 | 0);
     HEAP32[$11 + 76 >> 2] = $0;
     if ($0) {
      HEAP32[$11 + 124 >> 2] = HEAP32[$11 + 76 >> 2];
      break label$1;
     }
    }
    $0 = mbedtls_cipher_update(HEAP32[$11 + 120 >> 2], $11 + 16 | 0, 16, $11 + 48 | 0, $11 - -64 | 0);
    HEAP32[$11 + 76 >> 2] = $0;
    if ($0) {
     HEAP32[$11 + 124 >> 2] = HEAP32[$11 + 76 >> 2];
     break label$1;
    }
    HEAP8[$11 + 75 | 0] = 0;
    while (1) {
     if (HEAPU8[$11 + 75 | 0] < HEAPU32[$11 >> 2]) {
      HEAP8[HEAP32[$11 + 8 >> 2] + HEAPU8[$11 + 75 | 0] | 0] = HEAPU8[HEAP32[$11 + 12 >> 2] + HEAPU8[$11 + 75 | 0] | 0] ^ HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 48 | 0) | 0];
      HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
      continue;
     }
     break;
    }
    if (HEAP32[$11 + 116 >> 2] == 1) {
     $0 = $11 + 48 | 0;
     HEAP32[$0 >> 2] = 0;
     HEAP32[$0 + 4 >> 2] = 0;
     HEAP32[$0 + 8 >> 2] = 0;
     HEAP32[$0 + 12 >> 2] = 0;
     __memcpy($11 + 48 | 0, HEAP32[$11 + 8 >> 2], HEAP32[$11 >> 2]);
     HEAP8[$11 + 75 | 0] = 0;
     while (1) {
      if (HEAPU8[$11 + 75 | 0] < 16) {
       $0 = HEAPU8[$11 + 75 | 0] + ($11 + 32 | 0) | 0;
       HEAP8[$0 | 0] = HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 48 | 0) | 0] ^ HEAPU8[$0 | 0];
       HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
       continue;
      }
      break;
     }
     $0 = mbedtls_cipher_update(HEAP32[$11 + 120 >> 2], $11 + 32 | 0, 16, $11 + 32 | 0, $11 - -64 | 0);
     HEAP32[$11 + 76 >> 2] = $0;
     if ($0) {
      HEAP32[$11 + 124 >> 2] = HEAP32[$11 + 76 >> 2];
      break label$1;
     }
    }
    HEAP32[$11 + 8 >> 2] = HEAP32[$11 >> 2] + HEAP32[$11 + 8 >> 2];
    HEAP32[$11 + 12 >> 2] = HEAP32[$11 >> 2] + HEAP32[$11 + 12 >> 2];
    HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 68 >> 2] - HEAP32[$11 >> 2];
    HEAP8[$11 + 75 | 0] = 0;
    while (1) {
     label$43: {
      if (HEAPU8[$11 + 75 | 0] >= HEAPU8[$11 + 74 | 0]) {
       break label$43;
      }
      $0 = ($11 - HEAPU8[$11 + 75 | 0] | 0) + 31 | 0;
      $1 = HEAPU8[$0 | 0] + 1 | 0;
      HEAP8[$0 | 0] = $1;
      if ($1 & 255) {
       break label$43;
      }
      HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
      continue;
     }
     break;
    }
    continue;
   }
   break;
  }
  HEAP8[$11 + 75 | 0] = 0;
  while (1) {
   if (HEAPU8[$11 + 75 | 0] < HEAPU8[$11 + 74 | 0]) {
    HEAP8[($11 - HEAPU8[$11 + 75 | 0] | 0) + 31 | 0] = 0;
    HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
    continue;
   }
   break;
  }
  $0 = mbedtls_cipher_update(HEAP32[$11 + 120 >> 2], $11 + 16 | 0, 16, $11 + 48 | 0, $11 - -64 | 0);
  HEAP32[$11 + 76 >> 2] = $0;
  if ($0) {
   HEAP32[$11 + 124 >> 2] = HEAP32[$11 + 76 >> 2];
   break label$1;
  }
  HEAP8[$11 + 75 | 0] = 0;
  while (1) {
   if (HEAPU8[$11 + 75 | 0] < 16) {
    HEAP8[HEAPU8[$11 + 75 | 0] + ($11 + 32 | 0) | 0] = HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 32 | 0) | 0] ^ HEAPU8[HEAPU8[$11 + 75 | 0] + ($11 + 48 | 0) | 0];
    HEAP8[$11 + 75 | 0] = HEAPU8[$11 + 75 | 0] + 1;
    continue;
   }
   break;
  }
  __memcpy(HEAP32[$11 + 84 >> 2], $11 + 32 | 0, HEAP32[$11 + 80 >> 2]);
  HEAP32[$11 + 124 >> 2] = 0;
 }
 __stack_pointer = $11 + 128 | 0;
 return HEAP32[$11 + 124 >> 2];
}

function _jsvTrace($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 336 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 332 >> 2] = $0;
 HEAP32[$4 + 328 >> 2] = $1;
 HEAP32[$4 + 324 >> 2] = $2;
 HEAP32[$4 + 320 >> 2] = $3;
 HEAP32[$4 + 316 >> 2] = 0;
 while (1) {
  if (HEAP32[$4 + 316 >> 2] < HEAP32[$4 + 328 >> 2]) {
   jsiConsolePrintString(146437);
   HEAP32[$4 + 316 >> 2] = HEAP32[$4 + 316 >> 2] + 1;
   continue;
  }
  break;
 }
 label$3: {
  if (!HEAP32[$4 + 332 >> 2]) {
   jsiConsolePrintString(133948);
   break label$3;
  }
  if (!(HEAP32[$4 + 332 >> 2] != HEAP32[91086] | HEAP32[$4 + 320 >> 2] <= 0)) {
   jsiConsolePrintString(136610);
   break label$3;
  }
  jsvTraceLockInfo(HEAP32[$4 + 332 >> 2]);
  HEAP32[$4 + 312 >> 2] = _jsvTraceGetLowestLevel(HEAP32[$4 + 324 >> 2], HEAP32[$4 + 332 >> 2]);
  if (!((HEAP32[$4 + 312 >> 2] < 0 | HEAP32[$4 + 312 >> 2] >= HEAP32[$4 + 320 >> 2]) & HEAP32[$4 + 320 >> 2] <= 16)) {
   jsiConsolePrintString(147940);
   break label$3;
  }
  label$8: {
   if (jsvIsNewChild(HEAP32[$4 + 332 >> 2]) & 1) {
    jsiConsolePrintString(139017);
    HEAP32[$4 + 308 >> 2] = jsvGetAddressOf(jsvGetNextSibling(HEAP32[$4 + 332 >> 2]) & 65535);
    _jsvTrace(HEAP32[$4 + 308 >> 2], HEAP32[$4 + 328 >> 2] + 2 | 0, HEAP32[$4 + 324 >> 2], HEAP32[$4 + 320 >> 2] + 1 | 0);
    jsiConsolePrintString(146274);
    break label$8;
   }
   if (jsvIsName(HEAP32[$4 + 332 >> 2]) & 1) {
    jsiConsolePrintString(146165);
   }
  }
  HEAP8[$4 + 307 | 0] = 32;
  label$11: {
   if (jsvIsObject(HEAP32[$4 + 332 >> 2]) & 1) {
    jsiConsolePrintString(146012);
    HEAP8[$4 + 307 | 0] = 125;
    break label$11;
   }
   label$13: {
    if (jsvIsGetterOrSetter(HEAP32[$4 + 332 >> 2]) & 1) {
     jsiConsolePrintString(146022);
     HEAP8[$4 + 307 | 0] = 125;
     break label$13;
    }
    label$15: {
     if (jsvIsArray(HEAP32[$4 + 332 >> 2]) & 1) {
      $0 = HEAP32[$4 + 332 >> 2];
      HEAP32[$4 + 48 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
      jsiConsolePrintf(146206, $4 + 48 | 0);
      HEAP8[$4 + 307 | 0] = 93;
      break label$15;
     }
     label$17: {
      if (jsvIsNativeFunction(HEAP32[$4 + 332 >> 2]) & 1) {
       $0 = HEAP32[$4 + 332 >> 2];
       $1 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
       $0 = HEAP32[$4 + 332 >> 2];
       HEAP32[$4 + 68 >> 2] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8;
       HEAP32[$4 + 64 >> 2] = $1;
       jsiConsolePrintf(146051, $4 - -64 | 0);
       HEAP8[$4 + 307 | 0] = 125;
       break label$17;
      }
      label$19: {
       if (jsvIsFunction(HEAP32[$4 + 332 >> 2]) & 1) {
        jsiConsolePrintString(146039);
        if (jsvIsFunctionReturn(HEAP32[$4 + 332 >> 2]) & 1) {
         jsiConsolePrintString(146094);
        }
        HEAP8[$4 + 307 | 0] = 125;
        break label$19;
       }
       label$22: {
        if (jsvIsPin(HEAP32[$4 + 332 >> 2]) & 1) {
         HEAP32[$4 + 80 >> 2] = jsvGetInteger(HEAP32[$4 + 332 >> 2]);
         jsiConsolePrintf(134919, $4 + 80 | 0);
         break label$22;
        }
        label$24: {
         if (jsvIsInt(HEAP32[$4 + 332 >> 2]) & 1) {
          HEAP32[$4 + 96 >> 2] = jsvGetInteger(HEAP32[$4 + 332 >> 2]);
          jsiConsolePrintf(134810, $4 + 96 | 0);
          break label$24;
         }
         label$26: {
          if (jsvIsBoolean(HEAP32[$4 + 332 >> 2]) & 1) {
           HEAP32[$4 + 112 >> 2] = jsvGetBool(HEAP32[$4 + 332 >> 2]) & 1 ? 131761 : 132085;
           jsiConsolePrintf(120571, $4 + 112 | 0);
           break label$26;
          }
          label$28: {
           if (jsvIsFloat(HEAP32[$4 + 332 >> 2]) & 1) {
            HEAPF64[$4 + 128 >> 3] = jsvGetFloat(HEAP32[$4 + 332 >> 2]);
            jsiConsolePrintf(130189, $4 + 128 | 0);
            break label$28;
           }
           label$30: {
            if (jsvIsFunctionParameter(HEAP32[$4 + 332 >> 2]) & 1) {
             HEAP32[$4 + 144 >> 2] = HEAP32[$4 + 332 >> 2];
             jsiConsolePrintf(146084, $4 + 144 | 0);
             break label$30;
            }
            label$32: {
             if (jsvIsArrayBufferName(HEAP32[$4 + 332 >> 2]) & 1) {
              HEAP32[$4 + 160 >> 2] = jsvGetInteger(HEAP32[$4 + 332 >> 2]);
              jsiConsolePrintf(146185, $4 + 160 | 0);
              break label$32;
             }
             label$34: {
              if (jsvIsArrayBuffer(HEAP32[$4 + 332 >> 2]) & 1) {
               label$36: {
                if (jswGetBasicObjectName(HEAP32[$4 + 332 >> 2])) {
                 $1 = jswGetBasicObjectName(HEAP32[$4 + 332 >> 2]);
                 break label$36;
                }
                $1 = 121309;
               }
               $0 = HEAP32[$4 + 332 >> 2];
               $2 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8;
               HEAP32[$4 + 184 >> 2] = HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8 | HEAPU8[$0 + 4 | 0] << 16;
               HEAP32[$4 + 180 >> 2] = $2;
               HEAP32[$4 + 176 >> 2] = $1;
               jsiConsolePrintf(143284, $4 + 176 | 0);
               break label$34;
              }
              label$38: {
               if (jsvIsString(HEAP32[$4 + 332 >> 2]) & 1) {
                HEAP32[$4 + 300 >> 2] = 1;
                if (jsvGetLastChild(HEAP32[$4 + 332 >> 2]) & 65535) {
                 HEAP32[$4 + 296 >> 2] = jsvGetAddressOf(jsvGetLastChild(HEAP32[$4 + 332 >> 2]) & 65535);
                 HEAP32[$4 + 300 >> 2] = jsvCountJsVarsUsed(HEAP32[$4 + 296 >> 2]) + HEAP32[$4 + 300 >> 2];
                }
                if (jsvIsFlatString(HEAP32[$4 + 332 >> 2]) & 1) {
                 HEAP32[$4 + 300 >> 2] = jsvGetFlatStringBlocks(HEAP32[$4 + 332 >> 2]) + HEAP32[$4 + 300 >> 2];
                }
                HEAP32[$4 + 292 >> 2] = 148267;
                if (jsvIsFlatString(HEAP32[$4 + 332 >> 2]) & 1) {
                 HEAP32[$4 + 292 >> 2] = 117935;
                }
                if (jsvIsNativeString(HEAP32[$4 + 332 >> 2]) & 1) {
                 HEAP32[$4 + 292 >> 2] = 131702;
                }
                if (jsvIsFlashString(HEAP32[$4 + 332 >> 2]) & 1) {
                 HEAP32[$4 + 292 >> 2] = 129475;
                }
                $0 = HEAP32[$4 + 292 >> 2];
                $1 = HEAP32[$4 + 300 >> 2];
                HEAP32[$4 + 200 >> 2] = HEAP32[$4 + 332 >> 2];
                HEAP32[$4 + 196 >> 2] = $1;
                HEAP32[$4 + 192 >> 2] = $0;
                jsiConsolePrintf(121628, $4 + 192 | 0);
                break label$38;
               }
               $0 = HEAP32[$4 + 332 >> 2];
               HEAP32[$4 + 208 >> 2] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 50175;
               jsiConsolePrintf(134908, $4 + 208 | 0);
              }
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
  if (jsvIsConstant(HEAP32[$4 + 332 >> 2]) & 1) {
   jsiConsolePrintf(146219, 0);
  }
  if (jsvIsNameInt(HEAP32[$4 + 332 >> 2]) & 1) {
   HEAP32[$4 >> 2] = jsvGetFirstChildSigned(HEAP32[$4 + 332 >> 2]) << 16 >> 16;
   jsiConsolePrintf(147228, $4);
   break label$3;
  }
  if (jsvIsNameIntBool(HEAP32[$4 + 332 >> 2]) & 1) {
   HEAP32[$4 + 16 >> 2] = jsvGetFirstChild(HEAP32[$4 + 332 >> 2]) & 65535 ? 131761 : 132085;
   jsiConsolePrintf(146623, $4 + 16 | 0);
   break label$3;
  }
  label$48: {
   if (jsvHasSingleChild(HEAP32[$4 + 332 >> 2]) & 1) {
    label$50: {
     if (jsvGetFirstChild(HEAP32[$4 + 332 >> 2]) & 65535) {
      $0 = jsvGetAddressOf(jsvGetFirstChild(HEAP32[$4 + 332 >> 2]) & 65535);
      break label$50;
     }
     $0 = 0;
    }
    HEAP32[$4 + 288 >> 2] = $0;
    _jsvTrace(HEAP32[$4 + 288 >> 2], HEAP32[$4 + 328 >> 2] + 2 | 0, HEAP32[$4 + 324 >> 2], HEAP32[$4 + 320 >> 2] + 1 | 0);
    break label$48;
   }
   if (jsvHasChildren(HEAP32[$4 + 332 >> 2]) & 1) {
    jsvIteratorNew($4 + 224 | 0, HEAP32[$4 + 332 >> 2], 0);
    HEAP8[$4 + 223 | 0] = 1;
    while (1) {
     $0 = 0;
     if (jsvIteratorHasElement($4 + 224 | 0) & 1) {
      $0 = jspIsInterrupted() ^ -1;
     }
     if ($0 & 1) {
      if (HEAP8[$4 + 223 | 0] & 1) {
       jsiConsolePrintf(148266, 0);
      }
      HEAP8[$4 + 223 | 0] = 0;
      HEAP32[$4 + 216 >> 2] = jsvIteratorGetKey($4 + 224 | 0);
      _jsvTrace(HEAP32[$4 + 216 >> 2], HEAP32[$4 + 328 >> 2] + 2 | 0, HEAP32[$4 + 324 >> 2], HEAP32[$4 + 320 >> 2] + 1 | 0);
      jsvUnLock(HEAP32[$4 + 216 >> 2]);
      jsiConsolePrintf(148266, 0);
      jsvIteratorNext($4 + 224 | 0);
      continue;
     }
     break;
    }
    jsvIteratorFree($4 + 224 | 0);
    if (!(HEAP8[$4 + 223 | 0] & 1)) {
     HEAP32[$4 + 316 >> 2] = 0;
     while (1) {
      if (HEAP32[$4 + 316 >> 2] < HEAP32[$4 + 328 >> 2]) {
       jsiConsolePrintString(146437);
       HEAP32[$4 + 316 >> 2] = HEAP32[$4 + 316 >> 2] + 1;
       continue;
      }
      break;
     }
    }
   }
  }
  HEAP32[$4 + 32 >> 2] = HEAP8[$4 + 307 | 0];
  jsiConsolePrintf(135686, $4 + 32 | 0);
 }
 __stack_pointer = $4 + 336 | 0;
}

function mbedtls_sha1_process($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 160 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 156 >> 2] = $0;
 HEAP32[$2 + 152 >> 2] = $1;
 HEAP32[$2 + 64 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 3 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2]] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 1 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 2 | 0] << 8);
 HEAP32[$2 + 68 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 7 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 4 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 5 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 6 | 0] << 8);
 HEAP32[$2 + 72 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 11 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 8 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 9 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 10 | 0] << 8);
 HEAP32[$2 + 76 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 15 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 12 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 13 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 14 | 0] << 8);
 HEAP32[$2 + 80 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 19 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 16 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 17 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 18 | 0] << 8);
 HEAP32[$2 + 84 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 23 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 20 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 21 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 22 | 0] << 8);
 HEAP32[$2 + 88 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 27 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 24 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 25 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 26 | 0] << 8);
 HEAP32[$2 + 92 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 31 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 28 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 29 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 30 | 0] << 8);
 HEAP32[$2 + 96 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 35 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 32 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 33 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 34 | 0] << 8);
 HEAP32[$2 + 100 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 39 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 36 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 37 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 38 | 0] << 8);
 HEAP32[$2 + 104 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 43 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 40 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 41 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 42 | 0] << 8);
 HEAP32[$2 + 108 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 47 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 44 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 45 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 46 | 0] << 8);
 HEAP32[$2 + 112 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 51 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 48 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 49 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 50 | 0] << 8);
 HEAP32[$2 + 116 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 55 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 52 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 53 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 54 | 0] << 8);
 HEAP32[$2 + 120 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 59 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 56 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 57 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 58 | 0] << 8);
 HEAP32[$2 + 124 >> 2] = HEAPU8[HEAP32[$2 + 152 >> 2] + 63 | 0] | (HEAPU8[HEAP32[$2 + 152 >> 2] + 60 | 0] << 24 | HEAPU8[HEAP32[$2 + 152 >> 2] + 61 | 0] << 16 | HEAPU8[HEAP32[$2 + 152 >> 2] + 62 | 0] << 8);
 HEAP32[$2 + 148 >> 2] = 0;
 while (1) {
  if (HEAPU32[$2 + 148 >> 2] < 5) {
   HEAP32[($2 + 32 | 0) + (HEAP32[$2 + 148 >> 2] << 2) >> 2] = HEAP32[(HEAP32[$2 + 156 >> 2] + 8 | 0) + (HEAP32[$2 + 148 >> 2] << 2) >> 2];
   HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$2 + 148 >> 2] = 0;
 while (1) {
  if (HEAPU32[$2 + 148 >> 2] < 20) {
   HEAP32[$2 + 28 >> 2] = HEAPU32[$2 + 148 >> 2] % 5;
   label$5: {
    if (HEAPU32[$2 + 148 >> 2] < 16) {
     HEAP32[$2 + 24 >> 2] = HEAP32[($2 - -64 | 0) + (HEAP32[$2 + 148 >> 2] << 2) >> 2];
     break label$5;
    }
    HEAP32[$2 + 24 >> 2] = mbedtls_sha1_processR($2 - -64 | 0, HEAP32[$2 + 148 >> 2]);
   }
   $0 = ((0 - HEAP32[$2 + 28 >> 2] << 2) + $2 | 0) + 48 | 0;
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + (HEAP32[$2 + 24 >> 2] + (((HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] << 5 | HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] >>> 27) + (HEAP32[($2 + 32 | 0) + ((8 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] ^ HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] & (HEAP32[($2 + 32 | 0) + ((7 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] ^ HEAP32[($2 + 32 | 0) + ((8 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2])) | 0) + 1518500249 | 0) | 0);
   HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] = HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] << 30 | HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 28 >> 2] >>> 0) % 5 << 2) >> 2] >>> 2;
   HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$2 + 148 >> 2] = 20;
 while (1) {
  if (HEAPU32[$2 + 148 >> 2] < 40) {
   HEAP32[$2 + 20 >> 2] = HEAPU32[$2 + 148 >> 2] % 5;
   $1 = ((HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] << 5 | HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] >>> 27) + (HEAP32[($2 + 32 | 0) + ((8 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] ^ (HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] ^ HEAP32[($2 + 32 | 0) + ((7 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2])) | 0) + 1859775393 | 0;
   $3 = mbedtls_sha1_processR($2 - -64 | 0, HEAP32[$2 + 148 >> 2]);
   $0 = ((0 - HEAP32[$2 + 20 >> 2] << 2) + $2 | 0) + 48 | 0;
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + ($1 + $3 | 0);
   HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] = HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] << 30 | HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 20 >> 2] >>> 0) % 5 << 2) >> 2] >>> 2;
   HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$2 + 148 >> 2] = 40;
 while (1) {
  if (HEAPU32[$2 + 148 >> 2] < 60) {
   HEAP32[$2 + 16 >> 2] = HEAPU32[$2 + 148 >> 2] % 5;
   $1 = ((HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] << 5 | HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] >>> 27) + (HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] & HEAP32[($2 + 32 | 0) + ((7 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] | HEAP32[($2 + 32 | 0) + ((8 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] & (HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] | HEAP32[($2 + 32 | 0) + ((7 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2])) | 0) - 1894007588 | 0;
   $3 = mbedtls_sha1_processR($2 - -64 | 0, HEAP32[$2 + 148 >> 2]);
   $0 = ((0 - HEAP32[$2 + 16 >> 2] << 2) + $2 | 0) + 48 | 0;
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + ($1 + $3 | 0);
   HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] = HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] << 30 | HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 16 >> 2] >>> 0) % 5 << 2) >> 2] >>> 2;
   HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$2 + 148 >> 2] = 60;
 while (1) {
  if (HEAPU32[$2 + 148 >> 2] < 80) {
   HEAP32[$2 + 12 >> 2] = HEAPU32[$2 + 148 >> 2] % 5;
   $1 = ((HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] << 5 | HEAP32[($2 + 32 | 0) + ((5 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] >>> 27) + (HEAP32[($2 + 32 | 0) + ((8 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] ^ (HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] ^ HEAP32[($2 + 32 | 0) + ((7 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2])) | 0) - 899497514 | 0;
   $3 = mbedtls_sha1_processR($2 - -64 | 0, HEAP32[$2 + 148 >> 2]);
   $0 = ((0 - HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 48 | 0;
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + ($1 + $3 | 0);
   HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] = HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] << 30 | HEAP32[($2 + 32 | 0) + ((6 - HEAP32[$2 + 12 >> 2] >>> 0) % 5 << 2) >> 2] >>> 2;
   HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$2 + 148 >> 2] = 0;
 while (1) {
  if (HEAPU32[$2 + 148 >> 2] < 5) {
   $0 = (HEAP32[$2 + 156 >> 2] + 8 | 0) + (HEAP32[$2 + 148 >> 2] << 2) | 0;
   HEAP32[$0 >> 2] = HEAP32[($2 + 32 | 0) + (HEAP32[$2 + 148 >> 2] << 2) >> 2] + HEAP32[$0 >> 2];
   HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $2 + 160 | 0;
}

function mbedtls_aes_encrypt($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer + -64 | 0;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 HEAP32[$3 + 52 >> 2] = $2;
 HEAP32[$3 + 44 >> 2] = HEAP32[HEAP32[$3 + 60 >> 2] + 4 >> 2];
 HEAP32[$3 + 40 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2]] | HEAPU8[HEAP32[$3 + 56 >> 2] + 1 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 2 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 3 | 0] << 24;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 40 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 40 >> 2];
 HEAP32[$3 + 36 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2] + 4 | 0] | HEAPU8[HEAP32[$3 + 56 >> 2] + 5 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 6 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 7 | 0] << 24;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 36 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 36 >> 2];
 HEAP32[$3 + 32 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2] + 8 | 0] | HEAPU8[HEAP32[$3 + 56 >> 2] + 9 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 10 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 11 | 0] << 24;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 32 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 32 >> 2];
 HEAP32[$3 + 28 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2] + 12 | 0] | HEAPU8[HEAP32[$3 + 56 >> 2] + 13 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 14 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 15 | 0] << 24;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 28 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 28 >> 2];
 HEAP32[$3 + 48 >> 2] = (HEAP32[HEAP32[$3 + 60 >> 2] >> 2] >> 1) - 1;
 while (1) {
  if (HEAP32[$3 + 48 >> 2] > 0) {
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 24 >> 2] = HEAP32[(HEAP32[$3 + 28 >> 2] >>> 24 << 2) + 179168 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 16 & 255) << 2) + 178144 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 8 & 255) << 2) + 177120 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 40 >> 2] & 255) << 2) + 176096 >> 2])));
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 20 >> 2] = HEAP32[(HEAP32[$3 + 40 >> 2] >>> 24 << 2) + 179168 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 16 & 255) << 2) + 178144 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 8 & 255) << 2) + 177120 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 36 >> 2] & 255) << 2) + 176096 >> 2])));
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 16 >> 2] = HEAP32[(HEAP32[$3 + 36 >> 2] >>> 24 << 2) + 179168 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 16 & 255) << 2) + 178144 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 8 & 255) << 2) + 177120 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 32 >> 2] & 255) << 2) + 176096 >> 2])));
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 12 >> 2] = HEAP32[(HEAP32[$3 + 32 >> 2] >>> 24 << 2) + 179168 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 16 & 255) << 2) + 178144 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 8 & 255) << 2) + 177120 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 28 >> 2] & 255) << 2) + 176096 >> 2])));
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 40 >> 2] = HEAP32[(HEAP32[$3 + 12 >> 2] >>> 24 << 2) + 179168 >> 2] ^ (HEAP32[((HEAP32[$3 + 16 >> 2] >>> 16 & 255) << 2) + 178144 >> 2] ^ (HEAP32[((HEAP32[$3 + 20 >> 2] >>> 8 & 255) << 2) + 177120 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 24 >> 2] & 255) << 2) + 176096 >> 2])));
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 36 >> 2] = HEAP32[(HEAP32[$3 + 24 >> 2] >>> 24 << 2) + 179168 >> 2] ^ (HEAP32[((HEAP32[$3 + 12 >> 2] >>> 16 & 255) << 2) + 178144 >> 2] ^ (HEAP32[((HEAP32[$3 + 16 >> 2] >>> 8 & 255) << 2) + 177120 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 20 >> 2] & 255) << 2) + 176096 >> 2])));
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 32 >> 2] = HEAP32[(HEAP32[$3 + 20 >> 2] >>> 24 << 2) + 179168 >> 2] ^ (HEAP32[((HEAP32[$3 + 24 >> 2] >>> 16 & 255) << 2) + 178144 >> 2] ^ (HEAP32[((HEAP32[$3 + 12 >> 2] >>> 8 & 255) << 2) + 177120 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 16 >> 2] & 255) << 2) + 176096 >> 2])));
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 28 >> 2] = HEAP32[(HEAP32[$3 + 16 >> 2] >>> 24 << 2) + 179168 >> 2] ^ (HEAP32[((HEAP32[$3 + 20 >> 2] >>> 16 & 255) << 2) + 178144 >> 2] ^ (HEAP32[((HEAP32[$3 + 24 >> 2] >>> 8 & 255) << 2) + 177120 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 12 >> 2] & 255) << 2) + 176096 >> 2])));
   HEAP32[$3 + 48 >> 2] = HEAP32[$3 + 48 >> 2] - 1;
   continue;
  }
  break;
 }
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 24 >> 2] = HEAP32[(HEAP32[$3 + 28 >> 2] >>> 24 << 2) + 179168 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 16 & 255) << 2) + 178144 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 8 & 255) << 2) + 177120 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 40 >> 2] & 255) << 2) + 176096 >> 2])));
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 20 >> 2] = HEAP32[(HEAP32[$3 + 40 >> 2] >>> 24 << 2) + 179168 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 16 & 255) << 2) + 178144 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 8 & 255) << 2) + 177120 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 36 >> 2] & 255) << 2) + 176096 >> 2])));
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 16 >> 2] = HEAP32[(HEAP32[$3 + 36 >> 2] >>> 24 << 2) + 179168 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 16 & 255) << 2) + 178144 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 8 & 255) << 2) + 177120 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 32 >> 2] & 255) << 2) + 176096 >> 2])));
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 12 >> 2] = HEAP32[(HEAP32[$3 + 32 >> 2] >>> 24 << 2) + 179168 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 16 & 255) << 2) + 178144 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 8 & 255) << 2) + 177120 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 28 >> 2] & 255) << 2) + 176096 >> 2])));
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 40 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 24 >> 2] & 255) + 171744 | 0] ^ HEAPU8[(HEAP32[$3 + 20 >> 2] >>> 8 & 255) + 171744 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 16 >> 2] >>> 16 & 255) + 171744 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 12 >> 2] >>> 24 | 0) + 171744 | 0] << 24;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 36 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 20 >> 2] & 255) + 171744 | 0] ^ HEAPU8[(HEAP32[$3 + 16 >> 2] >>> 8 & 255) + 171744 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 12 >> 2] >>> 16 & 255) + 171744 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 24 >> 2] >>> 24 | 0) + 171744 | 0] << 24;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 32 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 16 >> 2] & 255) + 171744 | 0] ^ HEAPU8[(HEAP32[$3 + 12 >> 2] >>> 8 & 255) + 171744 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 24 >> 2] >>> 16 & 255) + 171744 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 20 >> 2] >>> 24 | 0) + 171744 | 0] << 24;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 28 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 12 >> 2] & 255) + 171744 | 0] ^ HEAPU8[(HEAP32[$3 + 24 >> 2] >>> 8 & 255) + 171744 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 20 >> 2] >>> 16 & 255) + 171744 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 16 >> 2] >>> 24 | 0) + 171744 | 0] << 24;
 HEAP8[HEAP32[$3 + 52 >> 2]] = HEAP32[$3 + 40 >> 2];
 HEAP8[HEAP32[$3 + 52 >> 2] + 1 | 0] = HEAP32[$3 + 40 >> 2] >>> 8;
 HEAP8[HEAP32[$3 + 52 >> 2] + 2 | 0] = HEAP32[$3 + 40 >> 2] >>> 16;
 HEAP8[HEAP32[$3 + 52 >> 2] + 3 | 0] = HEAP32[$3 + 40 >> 2] >>> 24;
 HEAP8[HEAP32[$3 + 52 >> 2] + 4 | 0] = HEAP32[$3 + 36 >> 2];
 HEAP8[HEAP32[$3 + 52 >> 2] + 5 | 0] = HEAP32[$3 + 36 >> 2] >>> 8;
 HEAP8[HEAP32[$3 + 52 >> 2] + 6 | 0] = HEAP32[$3 + 36 >> 2] >>> 16;
 HEAP8[HEAP32[$3 + 52 >> 2] + 7 | 0] = HEAP32[$3 + 36 >> 2] >>> 24;
 HEAP8[HEAP32[$3 + 52 >> 2] + 8 | 0] = HEAP32[$3 + 32 >> 2];
 HEAP8[HEAP32[$3 + 52 >> 2] + 9 | 0] = HEAP32[$3 + 32 >> 2] >>> 8;
 HEAP8[HEAP32[$3 + 52 >> 2] + 10 | 0] = HEAP32[$3 + 32 >> 2] >>> 16;
 HEAP8[HEAP32[$3 + 52 >> 2] + 11 | 0] = HEAP32[$3 + 32 >> 2] >>> 24;
 HEAP8[HEAP32[$3 + 52 >> 2] + 12 | 0] = HEAP32[$3 + 28 >> 2];
 HEAP8[HEAP32[$3 + 52 >> 2] + 13 | 0] = HEAP32[$3 + 28 >> 2] >>> 8;
 HEAP8[HEAP32[$3 + 52 >> 2] + 14 | 0] = HEAP32[$3 + 28 >> 2] >>> 16;
 HEAP8[HEAP32[$3 + 52 >> 2] + 15 | 0] = HEAP32[$3 + 28 >> 2] >>> 24;
}

function mbedtls_aes_decrypt($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer + -64 | 0;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 HEAP32[$3 + 52 >> 2] = $2;
 HEAP32[$3 + 44 >> 2] = HEAP32[HEAP32[$3 + 60 >> 2] + 4 >> 2];
 HEAP32[$3 + 40 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2]] | HEAPU8[HEAP32[$3 + 56 >> 2] + 1 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 2 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 3 | 0] << 24;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 40 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 40 >> 2];
 HEAP32[$3 + 36 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2] + 4 | 0] | HEAPU8[HEAP32[$3 + 56 >> 2] + 5 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 6 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 7 | 0] << 24;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 36 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 36 >> 2];
 HEAP32[$3 + 32 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2] + 8 | 0] | HEAPU8[HEAP32[$3 + 56 >> 2] + 9 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 10 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 11 | 0] << 24;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 32 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 32 >> 2];
 HEAP32[$3 + 28 >> 2] = HEAPU8[HEAP32[$3 + 56 >> 2] + 12 | 0] | HEAPU8[HEAP32[$3 + 56 >> 2] + 13 | 0] << 8 | HEAPU8[HEAP32[$3 + 56 >> 2] + 14 | 0] << 16 | HEAPU8[HEAP32[$3 + 56 >> 2] + 15 | 0] << 24;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 28 >> 2] = HEAP32[$0 >> 2] ^ HEAP32[$3 + 28 >> 2];
 HEAP32[$3 + 48 >> 2] = (HEAP32[HEAP32[$3 + 60 >> 2] >> 2] >> 1) - 1;
 while (1) {
  if (HEAP32[$3 + 48 >> 2] > 0) {
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 24 >> 2] = HEAP32[(HEAP32[$3 + 36 >> 2] >>> 24 << 2) + 175072 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 16 & 255) << 2) + 174048 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 8 & 255) << 2) + 173024 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 40 >> 2] & 255) << 2) + 172e3 >> 2])));
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 20 >> 2] = HEAP32[(HEAP32[$3 + 32 >> 2] >>> 24 << 2) + 175072 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 16 & 255) << 2) + 174048 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 8 & 255) << 2) + 173024 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 36 >> 2] & 255) << 2) + 172e3 >> 2])));
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 16 >> 2] = HEAP32[(HEAP32[$3 + 28 >> 2] >>> 24 << 2) + 175072 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 16 & 255) << 2) + 174048 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 8 & 255) << 2) + 173024 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 32 >> 2] & 255) << 2) + 172e3 >> 2])));
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 12 >> 2] = HEAP32[(HEAP32[$3 + 40 >> 2] >>> 24 << 2) + 175072 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 16 & 255) << 2) + 174048 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 8 & 255) << 2) + 173024 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 28 >> 2] & 255) << 2) + 172e3 >> 2])));
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 40 >> 2] = HEAP32[(HEAP32[$3 + 20 >> 2] >>> 24 << 2) + 175072 >> 2] ^ (HEAP32[((HEAP32[$3 + 16 >> 2] >>> 16 & 255) << 2) + 174048 >> 2] ^ (HEAP32[((HEAP32[$3 + 12 >> 2] >>> 8 & 255) << 2) + 173024 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 24 >> 2] & 255) << 2) + 172e3 >> 2])));
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 36 >> 2] = HEAP32[(HEAP32[$3 + 16 >> 2] >>> 24 << 2) + 175072 >> 2] ^ (HEAP32[((HEAP32[$3 + 12 >> 2] >>> 16 & 255) << 2) + 174048 >> 2] ^ (HEAP32[((HEAP32[$3 + 24 >> 2] >>> 8 & 255) << 2) + 173024 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 20 >> 2] & 255) << 2) + 172e3 >> 2])));
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 32 >> 2] = HEAP32[(HEAP32[$3 + 12 >> 2] >>> 24 << 2) + 175072 >> 2] ^ (HEAP32[((HEAP32[$3 + 24 >> 2] >>> 16 & 255) << 2) + 174048 >> 2] ^ (HEAP32[((HEAP32[$3 + 20 >> 2] >>> 8 & 255) << 2) + 173024 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 16 >> 2] & 255) << 2) + 172e3 >> 2])));
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 44 >> 2] = $0 + 4;
   HEAP32[$3 + 28 >> 2] = HEAP32[(HEAP32[$3 + 24 >> 2] >>> 24 << 2) + 175072 >> 2] ^ (HEAP32[((HEAP32[$3 + 20 >> 2] >>> 16 & 255) << 2) + 174048 >> 2] ^ (HEAP32[((HEAP32[$3 + 16 >> 2] >>> 8 & 255) << 2) + 173024 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 12 >> 2] & 255) << 2) + 172e3 >> 2])));
   HEAP32[$3 + 48 >> 2] = HEAP32[$3 + 48 >> 2] - 1;
   continue;
  }
  break;
 }
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 24 >> 2] = HEAP32[(HEAP32[$3 + 36 >> 2] >>> 24 << 2) + 175072 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 16 & 255) << 2) + 174048 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 8 & 255) << 2) + 173024 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 40 >> 2] & 255) << 2) + 172e3 >> 2])));
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 20 >> 2] = HEAP32[(HEAP32[$3 + 32 >> 2] >>> 24 << 2) + 175072 >> 2] ^ (HEAP32[((HEAP32[$3 + 28 >> 2] >>> 16 & 255) << 2) + 174048 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 8 & 255) << 2) + 173024 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 36 >> 2] & 255) << 2) + 172e3 >> 2])));
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 16 >> 2] = HEAP32[(HEAP32[$3 + 28 >> 2] >>> 24 << 2) + 175072 >> 2] ^ (HEAP32[((HEAP32[$3 + 40 >> 2] >>> 16 & 255) << 2) + 174048 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 8 & 255) << 2) + 173024 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 32 >> 2] & 255) << 2) + 172e3 >> 2])));
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 12 >> 2] = HEAP32[(HEAP32[$3 + 40 >> 2] >>> 24 << 2) + 175072 >> 2] ^ (HEAP32[((HEAP32[$3 + 36 >> 2] >>> 16 & 255) << 2) + 174048 >> 2] ^ (HEAP32[((HEAP32[$3 + 32 >> 2] >>> 8 & 255) << 2) + 173024 >> 2] ^ (HEAP32[$0 >> 2] ^ HEAP32[((HEAP32[$3 + 28 >> 2] & 255) << 2) + 172e3 >> 2])));
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 40 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 24 >> 2] & 255) + 180192 | 0] ^ HEAPU8[(HEAP32[$3 + 12 >> 2] >>> 8 & 255) + 180192 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 16 >> 2] >>> 16 & 255) + 180192 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 20 >> 2] >>> 24 | 0) + 180192 | 0] << 24;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 36 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 20 >> 2] & 255) + 180192 | 0] ^ HEAPU8[(HEAP32[$3 + 24 >> 2] >>> 8 & 255) + 180192 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 12 >> 2] >>> 16 & 255) + 180192 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 16 >> 2] >>> 24 | 0) + 180192 | 0] << 24;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 32 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 16 >> 2] & 255) + 180192 | 0] ^ HEAPU8[(HEAP32[$3 + 20 >> 2] >>> 8 & 255) + 180192 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 24 >> 2] >>> 16 & 255) + 180192 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 12 >> 2] >>> 24 | 0) + 180192 | 0] << 24;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 44 >> 2] = $0 + 4;
 HEAP32[$3 + 28 >> 2] = HEAP32[$0 >> 2] ^ HEAPU8[(HEAP32[$3 + 12 >> 2] & 255) + 180192 | 0] ^ HEAPU8[(HEAP32[$3 + 16 >> 2] >>> 8 & 255) + 180192 | 0] << 8 ^ HEAPU8[(HEAP32[$3 + 20 >> 2] >>> 16 & 255) + 180192 | 0] << 16 ^ HEAPU8[(HEAP32[$3 + 24 >> 2] >>> 24 | 0) + 180192 | 0] << 24;
 HEAP8[HEAP32[$3 + 52 >> 2]] = HEAP32[$3 + 40 >> 2];
 HEAP8[HEAP32[$3 + 52 >> 2] + 1 | 0] = HEAP32[$3 + 40 >> 2] >>> 8;
 HEAP8[HEAP32[$3 + 52 >> 2] + 2 | 0] = HEAP32[$3 + 40 >> 2] >>> 16;
 HEAP8[HEAP32[$3 + 52 >> 2] + 3 | 0] = HEAP32[$3 + 40 >> 2] >>> 24;
 HEAP8[HEAP32[$3 + 52 >> 2] + 4 | 0] = HEAP32[$3 + 36 >> 2];
 HEAP8[HEAP32[$3 + 52 >> 2] + 5 | 0] = HEAP32[$3 + 36 >> 2] >>> 8;
 HEAP8[HEAP32[$3 + 52 >> 2] + 6 | 0] = HEAP32[$3 + 36 >> 2] >>> 16;
 HEAP8[HEAP32[$3 + 52 >> 2] + 7 | 0] = HEAP32[$3 + 36 >> 2] >>> 24;
 HEAP8[HEAP32[$3 + 52 >> 2] + 8 | 0] = HEAP32[$3 + 32 >> 2];
 HEAP8[HEAP32[$3 + 52 >> 2] + 9 | 0] = HEAP32[$3 + 32 >> 2] >>> 8;
 HEAP8[HEAP32[$3 + 52 >> 2] + 10 | 0] = HEAP32[$3 + 32 >> 2] >>> 16;
 HEAP8[HEAP32[$3 + 52 >> 2] + 11 | 0] = HEAP32[$3 + 32 >> 2] >>> 24;
 HEAP8[HEAP32[$3 + 52 >> 2] + 12 | 0] = HEAP32[$3 + 28 >> 2];
 HEAP8[HEAP32[$3 + 52 >> 2] + 13 | 0] = HEAP32[$3 + 28 >> 2] >>> 8;
 HEAP8[HEAP32[$3 + 52 >> 2] + 14 | 0] = HEAP32[$3 + 28 >> 2] >>> 16;
 HEAP8[HEAP32[$3 + 52 >> 2] + 15 | 0] = HEAP32[$3 + 28 >> 2] >>> 24;
}

function tflite__reference_integer_ops__DepthwiseConvPerChannel_28tflite__DepthwiseParams_20const__2c_20int_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0;
 $11 = __stack_pointer - 192 | 0;
 __stack_pointer = $11;
 HEAP32[$11 + 188 >> 2] = $0;
 HEAP32[$11 + 184 >> 2] = $1;
 HEAP32[$11 + 180 >> 2] = $2;
 HEAP32[$11 + 176 >> 2] = $3;
 HEAP32[$11 + 172 >> 2] = $4;
 HEAP32[$11 + 168 >> 2] = $5;
 HEAP32[$11 + 164 >> 2] = $6;
 HEAP32[$11 + 160 >> 2] = $7;
 HEAP32[$11 + 156 >> 2] = $8;
 HEAP32[$11 + 152 >> 2] = $9;
 HEAP32[$11 + 148 >> 2] = $10;
 HEAP32[$11 + 144 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 10 >> 1];
 HEAP32[$11 + 140 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 12 >> 1];
 HEAP32[$11 + 136 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 14 >> 1];
 HEAP32[$11 + 132 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 16 >> 1];
 HEAP32[$11 + 128 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 2 >> 1];
 HEAP32[$11 + 124 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 4 >> 1];
 HEAP32[$11 + 120 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 18 >> 1];
 HEAP32[$11 + 116 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 20 >> 2];
 HEAP32[$11 + 112 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 28 >> 2];
 HEAP32[$11 + 108 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 40 >> 2];
 HEAP32[$11 + 104 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 44 >> 2];
 label$1: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 176 >> 2]) | 0) != 4) {
   break label$1;
  }
 }
 label$2: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 168 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 152 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 label$4: {
  if (HEAP32[$11 + 108 >> 2] > HEAP32[$11 + 104 >> 2]) {
   break label$4;
  }
 }
 HEAP32[$11 + 100 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 176 >> 2], 0, HEAP32[$11 + 152 >> 2], 0);
 HEAP32[$11 + 96 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 168 >> 2], 3, HEAP32[$11 + 152 >> 2], 3);
 HEAP32[$11 + 92 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 176 >> 2], 1);
 HEAP32[$11 + 88 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 176 >> 2], 2);
 HEAP32[$11 + 84 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 176 >> 2], 3);
 HEAP32[$11 + 80 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 168 >> 2], 1);
 HEAP32[$11 + 76 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 168 >> 2], 2);
 HEAP32[$11 + 72 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 152 >> 2], 1);
 HEAP32[$11 + 68 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 152 >> 2], 2);
 label$5: {
  if (HEAP32[$11 + 96 >> 2] != (Math_imul(HEAP32[$11 + 84 >> 2], HEAP32[$11 + 120 >> 2]) | 0)) {
   break label$5;
  }
 }
 label$6: {
  if ((tflite__RuntimeShape__FlatSize_28_29_20const(HEAP32[$11 + 160 >> 2]) | 0) != HEAP32[$11 + 96 >> 2]) {
   break label$6;
  }
 }
 HEAP32[$11 + 64 >> 2] = 0;
 while (1) {
  if (HEAP32[$11 + 64 >> 2] < HEAP32[$11 + 100 >> 2]) {
   HEAP32[$11 + 60 >> 2] = 0;
   while (1) {
    if (HEAP32[$11 + 60 >> 2] < HEAP32[$11 + 72 >> 2]) {
     HEAP32[$11 + 56 >> 2] = 0;
     while (1) {
      if (HEAP32[$11 + 56 >> 2] < HEAP32[$11 + 68 >> 2]) {
       HEAP32[$11 + 52 >> 2] = 0;
       while (1) {
        if (HEAP32[$11 + 52 >> 2] < HEAP32[$11 + 84 >> 2]) {
         HEAP32[$11 + 48 >> 2] = 0;
         while (1) {
          if (HEAP32[$11 + 48 >> 2] < HEAP32[$11 + 120 >> 2]) {
           HEAP32[$11 + 44 >> 2] = HEAP32[$11 + 48 >> 2] + Math_imul(HEAP32[$11 + 52 >> 2], HEAP32[$11 + 120 >> 2]);
           HEAP32[$11 + 40 >> 2] = Math_imul(HEAP32[$11 + 56 >> 2], HEAP32[$11 + 144 >> 2]) - HEAP32[$11 + 128 >> 2];
           HEAP32[$11 + 36 >> 2] = Math_imul(HEAP32[$11 + 60 >> 2], HEAP32[$11 + 140 >> 2]) - HEAP32[$11 + 124 >> 2];
           HEAP32[$11 + 32 >> 2] = 0;
           HEAP32[$11 + 28 >> 2] = 0;
           while (1) {
            if (HEAP32[$11 + 28 >> 2] < HEAP32[$11 + 80 >> 2]) {
             HEAP32[$11 + 24 >> 2] = 0;
             while (1) {
              if (HEAP32[$11 + 24 >> 2] < HEAP32[$11 + 76 >> 2]) {
               HEAP32[$11 + 20 >> 2] = HEAP32[$11 + 40 >> 2] + Math_imul(HEAP32[$11 + 136 >> 2], HEAP32[$11 + 24 >> 2]);
               HEAP32[$11 + 16 >> 2] = HEAP32[$11 + 36 >> 2] + Math_imul(HEAP32[$11 + 132 >> 2], HEAP32[$11 + 28 >> 2]);
               $0 = 0;
               label$21: {
                if (HEAP32[$11 + 20 >> 2] < 0) {
                 break label$21;
                }
                $0 = 0;
                if (HEAP32[$11 + 20 >> 2] >= HEAP32[$11 + 88 >> 2]) {
                 break label$21;
                }
                $0 = 0;
                if (HEAP32[$11 + 16 >> 2] < 0) {
                 break label$21;
                }
                $0 = HEAP32[$11 + 16 >> 2] < HEAP32[$11 + 92 >> 2];
               }
               HEAP8[$11 + 15 | 0] = $0;
               if (HEAP8[$11 + 15 | 0] & 1) {
                HEAP32[$11 + 8 >> 2] = HEAP8[HEAP32[$11 + 172 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 176 >> 2], HEAP32[$11 + 64 >> 2], HEAP32[$11 + 16 >> 2], HEAP32[$11 + 20 >> 2], HEAP32[$11 + 52 >> 2]) | 0];
                HEAP32[$11 + 4 >> 2] = HEAP8[HEAP32[$11 + 164 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 168 >> 2], 0, HEAP32[$11 + 28 >> 2], HEAP32[$11 + 24 >> 2], HEAP32[$11 + 44 >> 2]) | 0];
                HEAP32[$11 + 32 >> 2] = HEAP32[$11 + 32 >> 2] + Math_imul(HEAP32[$11 + 4 >> 2], HEAP32[$11 + 8 >> 2] + HEAP32[$11 + 116 >> 2] | 0);
               }
               HEAP32[$11 + 24 >> 2] = HEAP32[$11 + 24 >> 2] + 1;
               continue;
              }
              break;
             }
             HEAP32[$11 + 28 >> 2] = HEAP32[$11 + 28 >> 2] + 1;
             continue;
            }
            break;
           }
           if (HEAP32[$11 + 156 >> 2]) {
            HEAP32[$11 + 32 >> 2] = HEAP32[HEAP32[$11 + 156 >> 2] + (HEAP32[$11 + 44 >> 2] << 2) >> 2] + HEAP32[$11 + 32 >> 2];
           }
           HEAP32[$11 + 32 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$11 + 32 >> 2], HEAP32[HEAP32[$11 + 184 >> 2] + (HEAP32[$11 + 44 >> 2] << 2) >> 2], HEAP32[HEAP32[$11 + 180 >> 2] + (HEAP32[$11 + 44 >> 2] << 2) >> 2]);
           HEAP32[$11 + 32 >> 2] = HEAP32[$11 + 112 >> 2] + HEAP32[$11 + 32 >> 2];
           HEAP32[$11 + 32 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($11 + 32 | 0, $11 + 108 | 0) >> 2];
           HEAP32[$11 + 32 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($11 + 32 | 0, $11 + 104 | 0) >> 2];
           $0 = HEAP32[$11 + 32 >> 2];
           HEAP8[HEAP32[$11 + 148 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 152 >> 2], HEAP32[$11 + 64 >> 2], HEAP32[$11 + 60 >> 2], HEAP32[$11 + 56 >> 2], HEAP32[$11 + 44 >> 2]) | 0] = $0;
           HEAP32[$11 + 48 >> 2] = HEAP32[$11 + 48 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAP32[$11 + 52 >> 2] = HEAP32[$11 + 52 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$11 + 56 >> 2] = HEAP32[$11 + 56 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$11 + 60 >> 2] = HEAP32[$11 + 60 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$11 + 64 >> 2] = HEAP32[$11 + 64 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $11 + 192 | 0;
}

function tflite__reference_integer_ops__ConvPerChannel_28tflite__ConvParams_20const__2c_20int_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0;
 $11 = __stack_pointer - 192 | 0;
 __stack_pointer = $11;
 HEAP32[$11 + 188 >> 2] = $0;
 HEAP32[$11 + 184 >> 2] = $1;
 HEAP32[$11 + 180 >> 2] = $2;
 HEAP32[$11 + 176 >> 2] = $3;
 HEAP32[$11 + 172 >> 2] = $4;
 HEAP32[$11 + 168 >> 2] = $5;
 HEAP32[$11 + 164 >> 2] = $6;
 HEAP32[$11 + 160 >> 2] = $7;
 HEAP32[$11 + 156 >> 2] = $8;
 HEAP32[$11 + 152 >> 2] = $9;
 HEAP32[$11 + 148 >> 2] = $10;
 HEAP32[$11 + 144 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 20 >> 2];
 HEAP32[$11 + 140 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 10 >> 1];
 HEAP32[$11 + 136 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 12 >> 1];
 HEAP32[$11 + 132 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 14 >> 1];
 HEAP32[$11 + 128 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 16 >> 1];
 HEAP32[$11 + 124 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 2 >> 1];
 HEAP32[$11 + 120 >> 2] = HEAP16[HEAP32[$11 + 188 >> 2] + 4 >> 1];
 HEAP32[$11 + 116 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 28 >> 2];
 HEAP32[$11 + 112 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 40 >> 2];
 HEAP32[$11 + 108 >> 2] = HEAP32[HEAP32[$11 + 188 >> 2] + 44 >> 2];
 label$1: {
  if (HEAP32[$11 + 112 >> 2] > HEAP32[$11 + 108 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 176 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 168 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 label$4: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 152 >> 2]) | 0) != 4) {
   break label$4;
  }
 }
 HEAP32[$11 + 104 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 176 >> 2], 0, HEAP32[$11 + 152 >> 2], 0);
 HEAP32[$11 + 100 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 176 >> 2], 3, HEAP32[$11 + 168 >> 2], 3);
 HEAP32[$11 + 96 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 168 >> 2], 0, HEAP32[$11 + 152 >> 2], 3);
 if (HEAP32[$11 + 156 >> 2]) {
  label$6: {
   if ((tflite__RuntimeShape__FlatSize_28_29_20const(HEAP32[$11 + 160 >> 2]) | 0) != HEAP32[$11 + 96 >> 2]) {
    break label$6;
   }
  }
 }
 HEAP32[$11 + 92 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 176 >> 2], 1);
 HEAP32[$11 + 88 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 176 >> 2], 2);
 HEAP32[$11 + 84 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 168 >> 2], 1);
 HEAP32[$11 + 80 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 168 >> 2], 2);
 HEAP32[$11 + 76 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 152 >> 2], 1);
 HEAP32[$11 + 72 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 152 >> 2], 2);
 HEAP32[$11 + 68 >> 2] = 0;
 while (1) {
  if (HEAP32[$11 + 68 >> 2] < HEAP32[$11 + 104 >> 2]) {
   HEAP32[$11 + 64 >> 2] = 0;
   while (1) {
    if (HEAP32[$11 + 64 >> 2] < HEAP32[$11 + 76 >> 2]) {
     HEAP32[$11 + 60 >> 2] = 0;
     while (1) {
      if (HEAP32[$11 + 60 >> 2] < HEAP32[$11 + 72 >> 2]) {
       HEAP32[$11 + 56 >> 2] = 0;
       while (1) {
        if (HEAP32[$11 + 56 >> 2] < HEAP32[$11 + 96 >> 2]) {
         HEAP32[$11 + 52 >> 2] = Math_imul(HEAP32[$11 + 60 >> 2], HEAP32[$11 + 140 >> 2]) - HEAP32[$11 + 124 >> 2];
         HEAP32[$11 + 48 >> 2] = Math_imul(HEAP32[$11 + 64 >> 2], HEAP32[$11 + 136 >> 2]) - HEAP32[$11 + 120 >> 2];
         HEAP32[$11 + 44 >> 2] = 0;
         HEAP32[$11 + 40 >> 2] = 0;
         while (1) {
          if (HEAP32[$11 + 40 >> 2] < HEAP32[$11 + 84 >> 2]) {
           HEAP32[$11 + 36 >> 2] = 0;
           while (1) {
            if (HEAP32[$11 + 36 >> 2] < HEAP32[$11 + 80 >> 2]) {
             HEAP32[$11 + 32 >> 2] = 0;
             while (1) {
              if (HEAP32[$11 + 32 >> 2] < HEAP32[$11 + 100 >> 2]) {
               HEAP32[$11 + 28 >> 2] = HEAP32[$11 + 52 >> 2] + Math_imul(HEAP32[$11 + 132 >> 2], HEAP32[$11 + 36 >> 2]);
               HEAP32[$11 + 24 >> 2] = HEAP32[$11 + 48 >> 2] + Math_imul(HEAP32[$11 + 128 >> 2], HEAP32[$11 + 40 >> 2]);
               $0 = 0;
               label$21: {
                if (HEAP32[$11 + 28 >> 2] < 0) {
                 break label$21;
                }
                $0 = 0;
                if (HEAP32[$11 + 28 >> 2] >= HEAP32[$11 + 88 >> 2]) {
                 break label$21;
                }
                $0 = 0;
                if (HEAP32[$11 + 24 >> 2] < 0) {
                 break label$21;
                }
                $0 = HEAP32[$11 + 24 >> 2] < HEAP32[$11 + 92 >> 2];
               }
               HEAP8[$11 + 23 | 0] = $0;
               if (HEAP8[$11 + 23 | 0] & 1) {
                HEAP32[$11 + 16 >> 2] = HEAP8[HEAP32[$11 + 172 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 176 >> 2], HEAP32[$11 + 68 >> 2], HEAP32[$11 + 24 >> 2], HEAP32[$11 + 28 >> 2], HEAP32[$11 + 32 >> 2]) | 0];
                HEAP32[$11 + 12 >> 2] = HEAP8[HEAP32[$11 + 164 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 168 >> 2], HEAP32[$11 + 56 >> 2], HEAP32[$11 + 40 >> 2], HEAP32[$11 + 36 >> 2], HEAP32[$11 + 32 >> 2]) | 0];
                HEAP32[$11 + 44 >> 2] = HEAP32[$11 + 44 >> 2] + Math_imul(HEAP32[$11 + 12 >> 2], HEAP32[$11 + 16 >> 2] + HEAP32[$11 + 144 >> 2] | 0);
               }
               HEAP32[$11 + 32 >> 2] = HEAP32[$11 + 32 >> 2] + 1;
               continue;
              }
              break;
             }
             HEAP32[$11 + 36 >> 2] = HEAP32[$11 + 36 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$11 + 40 >> 2] = HEAP32[$11 + 40 >> 2] + 1;
           continue;
          }
          break;
         }
         if (HEAP32[$11 + 156 >> 2]) {
          HEAP32[$11 + 44 >> 2] = HEAP32[HEAP32[$11 + 156 >> 2] + (HEAP32[$11 + 56 >> 2] << 2) >> 2] + HEAP32[$11 + 44 >> 2];
         }
         HEAP32[$11 + 44 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$11 + 44 >> 2], HEAP32[HEAP32[$11 + 184 >> 2] + (HEAP32[$11 + 56 >> 2] << 2) >> 2], HEAP32[HEAP32[$11 + 180 >> 2] + (HEAP32[$11 + 56 >> 2] << 2) >> 2]);
         HEAP32[$11 + 44 >> 2] = HEAP32[$11 + 116 >> 2] + HEAP32[$11 + 44 >> 2];
         HEAP32[$11 + 44 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($11 + 44 | 0, $11 + 112 | 0) >> 2];
         HEAP32[$11 + 44 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($11 + 44 | 0, $11 + 108 | 0) >> 2];
         $0 = HEAP32[$11 + 44 >> 2];
         HEAP8[HEAP32[$11 + 148 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 152 >> 2], HEAP32[$11 + 68 >> 2], HEAP32[$11 + 64 >> 2], HEAP32[$11 + 60 >> 2], HEAP32[$11 + 56 >> 2]) | 0] = $0;
         HEAP32[$11 + 56 >> 2] = HEAP32[$11 + 56 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$11 + 60 >> 2] = HEAP32[$11 + 60 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$11 + 64 >> 2] = HEAP32[$11 + 64 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$11 + 68 >> 2] = HEAP32[$11 + 68 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $11 + 192 | 0;
}

function tflite__internal__InitializeTfLiteTensorFromFlatbuffer_28tflite__SimpleMemoryAllocator__2c_20bool_2c_20tflite__Tensor_20const__2c_20flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer___20const__2c_20tflite__ErrorReporter__2c_20TfLiteTensor__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = Math_fround(0), wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0, wasm2js_i32$3 = 0;
 $6 = __stack_pointer - 128 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 120 >> 2] = $0;
 HEAP8[$6 + 119 | 0] = $1;
 HEAP32[$6 + 112 >> 2] = $2;
 HEAP32[$6 + 108 >> 2] = $3;
 HEAP32[$6 + 104 >> 2] = $4;
 HEAP32[$6 + 100 >> 2] = $5;
 label$1: {
  if (!HEAP32[$6 + 100 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$6 + 88 >> 2] = 0;
 HEAP32[$6 + 92 >> 2] = 0;
 HEAP32[$6 + 80 >> 2] = 0;
 HEAP32[$6 + 84 >> 2] = 0;
 HEAP32[$6 + 72 >> 2] = 0;
 HEAP32[$6 + 76 >> 2] = 0;
 HEAP32[$6 + 64 >> 2] = 0;
 HEAP32[$6 + 68 >> 2] = 0;
 HEAP32[$6 + 56 >> 2] = 0;
 HEAP32[$6 + 60 >> 2] = 0;
 $1 = HEAP32[$6 + 60 >> 2];
 $0 = HEAP32[$6 + 56 >> 2];
 $3 = $0;
 $2 = HEAP32[$6 + 100 >> 2];
 $0 = $2;
 HEAP32[$0 >> 2] = $3;
 HEAP32[$0 + 4 >> 2] = $1;
 $0 = HEAP32[$6 + 92 >> 2];
 $1 = HEAP32[$6 + 88 >> 2];
 $3 = $1;
 $1 = $2;
 HEAP32[$1 + 32 >> 2] = $3;
 HEAP32[$1 + 36 >> 2] = $0;
 $1 = HEAP32[$6 + 84 >> 2];
 $0 = HEAP32[$6 + 80 >> 2];
 $3 = $0;
 $0 = $2;
 HEAP32[$0 + 24 >> 2] = $3;
 HEAP32[$0 + 28 >> 2] = $1;
 $0 = HEAP32[$6 + 76 >> 2];
 $1 = HEAP32[$6 + 72 >> 2];
 $3 = $1;
 $1 = $2;
 HEAP32[$1 + 16 >> 2] = $3;
 HEAP32[$1 + 20 >> 2] = $0;
 $1 = HEAP32[$6 + 68 >> 2];
 $0 = HEAP32[$6 + 64 >> 2];
 $3 = $0;
 $0 = $2;
 HEAP32[$0 + 8 >> 2] = $3;
 HEAP32[$0 + 12 >> 2] = $1;
 HEAP32[$6 + 52 >> 2] = tflite__ConvertTensorType_28tflite__TensorType_2c_20TfLiteType__2c_20tflite__ErrorReporter__29(tflite__Tensor__type_28_29_20const(HEAP32[$6 + 112 >> 2]), HEAP32[$6 + 100 >> 2] + 28 | 0, HEAP32[$6 + 104 >> 2]);
 label$2: {
  if (HEAP32[$6 + 52 >> 2]) {
   HEAP32[$6 + 124 >> 2] = HEAP32[$6 + 52 >> 2];
   break label$2;
  }
  $0 = tflite__Tensor__is_variable_28_29_20const(HEAP32[$6 + 112 >> 2]);
  HEAP8[HEAP32[$6 + 100 >> 2] + 36 | 0] = $0 & 1;
  $0 = tflite__internal__GetFlatbufferTensorBuffer_28tflite__Tensor_20const__2c_20flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer___20const__29(HEAP32[$6 + 112 >> 2], HEAP32[$6 + 108 >> 2]);
  HEAP32[HEAP32[$6 + 100 >> 2] + 16 >> 2] = $0;
  label$4: {
   if (!HEAP32[HEAP32[$6 + 100 >> 2] + 16 >> 2]) {
    HEAP32[HEAP32[$6 + 100 >> 2] + 32 >> 2] = 2;
    break label$4;
   }
   HEAP32[HEAP32[$6 + 100 >> 2] + 32 >> 2] = 1;
  }
  HEAP32[$6 + 44 >> 2] = tflite__BytesRequiredForTensor_28tflite__Tensor_20const__2c_20unsigned_20long__2c_20unsigned_20long__2c_20tflite__ErrorReporter__29(HEAP32[$6 + 112 >> 2], HEAP32[$6 + 100 >> 2] + 24 | 0, $6 + 48 | 0, HEAP32[$6 + 104 >> 2]);
  if (HEAP32[$6 + 44 >> 2]) {
   HEAP32[$6 + 124 >> 2] = HEAP32[$6 + 44 >> 2];
   break label$2;
  }
  label$7: {
   if (!tflite__Tensor__shape_28_29_20const(HEAP32[$6 + 112 >> 2])) {
    HEAP32[HEAP32[$6 + 100 >> 2] + 20 >> 2] = 189760;
    break label$7;
   }
   HEAP32[$6 + 40 >> 2] = TfLiteStatus_20tflite__internal__FlatBufferVectorToTfLiteTypeArray_int_2c_20TfLiteIntArray__28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__2c_20flatbuffers__Vector_int__20const__2c_20TfLiteIntArray___29(HEAP32[$6 + 120 >> 2], HEAP32[$6 + 104 >> 2], tflite__Tensor__shape_28_29_20const(HEAP32[$6 + 112 >> 2]), HEAP32[$6 + 100 >> 2] + 20 | 0);
   if (HEAP32[$6 + 40 >> 2]) {
    HEAP32[$6 + 124 >> 2] = HEAP32[$6 + 40 >> 2];
    break label$2;
   }
  }
  HEAP32[$6 + 36 >> 2] = tflite__Tensor__quantization_28_29_20const(HEAP32[$6 + 112 >> 2]);
  label$10: {
   if (!HEAP32[$6 + 36 >> 2]) {
    break label$10;
   }
   if (!tflite__QuantizationParameters__scale_28_29_20const(HEAP32[$6 + 36 >> 2])) {
    break label$10;
   }
   if (!flatbuffers__Vector_float___size_28_29_20const(tflite__QuantizationParameters__scale_28_29_20const(HEAP32[$6 + 36 >> 2]))) {
    break label$10;
   }
   if (!tflite__QuantizationParameters__zero_point_28_29_20const(HEAP32[$6 + 36 >> 2])) {
    break label$10;
   }
   if (!flatbuffers__Vector_long_20long___size_28_29_20const(tflite__QuantizationParameters__zero_point_28_29_20const(HEAP32[$6 + 36 >> 2]))) {
    break label$10;
   }
   $7 = flatbuffers__Vector_float___Get_28unsigned_20int_29_20const(tflite__QuantizationParameters__scale_28_29_20const(HEAP32[$6 + 36 >> 2]), 0);
   HEAPF32[HEAP32[$6 + 100 >> 2] + 8 >> 2] = $7;
   $1 = flatbuffers__Vector_long_20long___Get_28unsigned_20int_29_20const(tflite__QuantizationParameters__zero_point_28_29_20const(HEAP32[$6 + 36 >> 2]), 0);
   HEAP32[HEAP32[$6 + 100 >> 2] + 12 >> 2] = $1;
   HEAP32[$6 + 32 >> 2] = flatbuffers__Vector_float___size_28_29_20const(tflite__QuantizationParameters__scale_28_29_20const(HEAP32[$6 + 36 >> 2]));
   label$11: {
    if (HEAP8[$6 + 119 | 0] & 1) {
     $0 = HEAP32[$6 + 120 >> 2];
     $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 16 >> 2]]($0, 12, 4) | 0;
     break label$11;
    }
    $0 = HEAP32[$6 + 120 >> 2];
    $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 12 >> 2]]($0, 12, 4) | 0;
   }
   HEAP32[$6 + 28 >> 2] = $0;
   if (!HEAP32[$6 + 28 >> 2]) {
    tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$6 + 104 >> 2], 147576, 0);
    HEAP32[$6 + 124 >> 2] = 1;
    break label$2;
   }
   label$14: {
    if (HEAP8[$6 + 119 | 0] & 1) {
     $0 = HEAP32[$6 + 120 >> 2];
     $0 = (wasm2js_i32$1 = $0, wasm2js_i32$2 = TfLiteIntArrayGetSizeInBytes(HEAP32[$6 + 32 >> 2]), 
     wasm2js_i32$3 = 4, wasm2js_i32$0 = HEAP32[HEAP32[$0 >> 2] + 16 >> 2], FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$1 | 0, wasm2js_i32$2 | 0, wasm2js_i32$3 | 0) | 0);
     break label$14;
    }
    $0 = HEAP32[$6 + 120 >> 2];
    $0 = (wasm2js_i32$3 = $0, wasm2js_i32$2 = TfLiteIntArrayGetSizeInBytes(HEAP32[$6 + 32 >> 2]), 
    wasm2js_i32$1 = 4, wasm2js_i32$0 = HEAP32[HEAP32[$0 >> 2] + 12 >> 2], FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$3 | 0, wasm2js_i32$2 | 0, wasm2js_i32$1 | 0) | 0);
   }
   HEAP32[HEAP32[$6 + 28 >> 2] + 4 >> 2] = $0;
   if (!HEAP32[HEAP32[$6 + 28 >> 2] + 4 >> 2]) {
    tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$6 + 104 >> 2], 147460, 0);
    HEAP32[$6 + 124 >> 2] = 1;
    break label$2;
   }
   HEAP32[$6 + 24 >> 2] = TfLiteStatus_20tflite__internal__FlatBufferVectorToTfLiteTypeArray_float_2c_20TfLiteFloatArray__28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__2c_20flatbuffers__Vector_float__20const__2c_20TfLiteFloatArray___29(HEAP32[$6 + 120 >> 2], HEAP32[$6 + 104 >> 2], tflite__QuantizationParameters__scale_28_29_20const(HEAP32[$6 + 36 >> 2]), HEAP32[$6 + 28 >> 2]);
   if (HEAP32[$6 + 24 >> 2]) {
    HEAP32[$6 + 124 >> 2] = HEAP32[$6 + 24 >> 2];
    break label$2;
   }
   HEAP32[HEAP32[HEAP32[$6 + 28 >> 2] + 4 >> 2] >> 2] = HEAP32[$6 + 32 >> 2];
   HEAP32[$6 + 20 >> 2] = HEAP32[HEAP32[$6 + 28 >> 2] + 4 >> 2] + 4;
   HEAP32[$6 + 16 >> 2] = 0;
   while (1) {
    if (HEAP32[$6 + 16 >> 2] < HEAP32[$6 + 32 >> 2]) {
     $0 = flatbuffers__Vector_long_20long___Get_28unsigned_20int_29_20const(tflite__QuantizationParameters__zero_point_28_29_20const(HEAP32[$6 + 36 >> 2]), HEAP32[$6 + 16 >> 2]);
     HEAP32[HEAP32[$6 + 20 >> 2] + (HEAP32[$6 + 16 >> 2] << 2) >> 2] = $0;
     HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 16 >> 2] + 1;
     continue;
    }
    break;
   }
   $0 = tflite__QuantizationParameters__quantized_dimension_28_29_20const(HEAP32[$6 + 36 >> 2]);
   HEAP32[HEAP32[$6 + 28 >> 2] + 8 >> 2] = $0;
   HEAP32[$6 + 8 >> 2] = 1;
   HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 28 >> 2];
   $0 = HEAP32[$6 + 12 >> 2];
   $1 = HEAP32[$6 + 8 >> 2];
   $2 = $1;
   $1 = HEAP32[$6 + 100 >> 2];
   HEAP32[$1 >> 2] = $2;
   HEAP32[$1 + 4 >> 2] = $0;
  }
  HEAP32[$6 + 124 >> 2] = 0;
 }
 __stack_pointer = $6 + 128 | 0;
 return HEAP32[$6 + 124 >> 2];
}

function tflite__ops__micro__quantize__Eval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 240 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 232 >> 2] = $0;
 HEAP32[$2 + 228 >> 2] = $1;
 label$1: {
  if (!HEAP32[HEAP32[$2 + 228 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 224 >> 2] = HEAP32[HEAP32[$2 + 228 >> 2] + 8 >> 2];
 HEAP32[$2 + 220 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 232 >> 2], HEAP32[$2 + 228 >> 2], 0);
 HEAP32[$2 + 216 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 232 >> 2], HEAP32[$2 + 228 >> 2], 0);
 label$2: {
  label$3: {
   if (HEAP32[HEAP32[$2 + 220 >> 2] + 8 >> 2] == 1) {
    label$5: {
     switch (HEAP32[HEAP32[$2 + 216 >> 2] + 8 >> 2] - 3 | 0) {
     case 6:
      $0 = HEAP32[$2 + 224 >> 2];
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 192 | 0, HEAP32[$2 + 220 >> 2]);
      $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 220 >> 2]);
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 168 | 0, HEAP32[$2 + 216 >> 2]);
      void_20tflite__reference_ops__AffineQuantize_float_2c_20signed_20char__28tflite__QuantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $2 + 192 | 0, $1, $2 + 168 | 0, signed_20char__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor__29(HEAP32[$2 + 216 >> 2]));
      tflite__RuntimeShape___RuntimeShape_28_29($2 + 168 | 0);
      tflite__RuntimeShape___RuntimeShape_28_29($2 + 192 | 0);
      break label$3;

     case 0:
      $0 = HEAP32[$2 + 224 >> 2];
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 144 | 0, HEAP32[$2 + 220 >> 2]);
      $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 220 >> 2]);
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 120 | 0, HEAP32[$2 + 216 >> 2]);
      void_20tflite__reference_ops__AffineQuantize_float_2c_20unsigned_20char__28tflite__QuantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $2 + 144 | 0, $1, $2 + 120 | 0, unsigned_20char__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor__29(HEAP32[$2 + 216 >> 2]));
      tflite__RuntimeShape___RuntimeShape_28_29($2 + 120 | 0);
      tflite__RuntimeShape___RuntimeShape_28_29($2 + 144 | 0);
      break label$3;

     case 4:
      $0 = HEAP32[$2 + 224 >> 2];
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 96 | 0, HEAP32[$2 + 220 >> 2]);
      $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 220 >> 2]);
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 72 | 0, HEAP32[$2 + 216 >> 2]);
      void_20tflite__reference_ops__AffineQuantize_float_2c_20short__28tflite__QuantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20short__29($0, $2 + 96 | 0, $1, $2 + 72 | 0, short__20tflite__micro__GetTensorData_short__28TfLiteEvalTensor__29(HEAP32[$2 + 216 >> 2]));
      tflite__RuntimeShape___RuntimeShape_28_29($2 + 72 | 0);
      tflite__RuntimeShape___RuntimeShape_28_29($2 + 96 | 0);
      HEAP32[$2 + 236 >> 2] = 0;
      break label$2;

     default:
      break label$5;
     }
    }
    $0 = HEAP32[HEAP32[$2 + 232 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 232 >> 2];
    $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 220 >> 2] + 8 >> 2]);
    HEAP32[$2 + 4 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 216 >> 2] + 8 >> 2]);
    HEAP32[$2 >> 2] = $3;
    FUNCTION_TABLE[$0 | 0]($1, 140784, $2);
    HEAP32[$2 + 236 >> 2] = 1;
    break label$2;
   }
   label$9: {
    if (HEAP32[HEAP32[$2 + 220 >> 2] + 8 >> 2] == 7) {
     HEAP32[$2 + 68 >> 2] = tflite__ElementCount_28TfLiteIntArray_20const__29(HEAP32[HEAP32[$2 + 220 >> 2] + 4 >> 2]);
     label$11: {
      label$12: {
       switch (HEAP32[HEAP32[$2 + 216 >> 2] + 8 >> 2] - 7 | 0) {
       case 2:
        void_20tflite__reference_ops__Requantize_short_2c_20signed_20char__28short_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20signed_20char__29(short_20const__20tflite__micro__GetTensorData_short__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 220 >> 2]), HEAP32[$2 + 68 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 16 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 20 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 24 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] >> 2], signed_20char__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor__29(HEAP32[$2 + 216 >> 2]));
        break label$11;

       case 0:
        void_20tflite__reference_ops__Requantize_short_2c_20short__28short_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20short__29(short_20const__20tflite__micro__GetTensorData_short__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 220 >> 2]), HEAP32[$2 + 68 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 16 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 20 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 24 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] >> 2], short__20tflite__micro__GetTensorData_short__28TfLiteEvalTensor__29(HEAP32[$2 + 216 >> 2]));
        HEAP32[$2 + 236 >> 2] = 0;
        break label$2;

       default:
        break label$12;
       }
      }
      $0 = HEAP32[HEAP32[$2 + 232 >> 2] + 20 >> 2];
      $1 = HEAP32[$2 + 232 >> 2];
      $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 220 >> 2] + 8 >> 2]);
      HEAP32[$2 + 20 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 216 >> 2] + 8 >> 2]);
      HEAP32[$2 + 16 >> 2] = $3;
      FUNCTION_TABLE[$0 | 0]($1, 140784, $2 + 16 | 0);
      HEAP32[$2 + 236 >> 2] = 1;
      break label$2;
     }
     break label$9;
    }
    label$15: {
     if (HEAP32[HEAP32[$2 + 220 >> 2] + 8 >> 2] == 9) {
      HEAP32[$2 + 64 >> 2] = tflite__ElementCount_28TfLiteIntArray_20const__29(HEAP32[HEAP32[$2 + 220 >> 2] + 4 >> 2]);
      label$17: {
       if (HEAP32[HEAP32[$2 + 216 >> 2] + 8 >> 2] == 9) {
        void_20tflite__reference_ops__Requantize_signed_20char_2c_20signed_20char__28signed_20char_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20signed_20char__29(signed_20char_20const__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 220 >> 2]), HEAP32[$2 + 64 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 16 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 20 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] + 24 >> 2], HEAP32[HEAP32[$2 + 224 >> 2] >> 2], signed_20char__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor__29(HEAP32[$2 + 216 >> 2]));
        break label$17;
       }
       $0 = HEAP32[HEAP32[$2 + 232 >> 2] + 20 >> 2];
       $1 = HEAP32[$2 + 232 >> 2];
       $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 220 >> 2] + 8 >> 2]);
       HEAP32[$2 + 36 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 216 >> 2] + 8 >> 2]);
       HEAP32[$2 + 32 >> 2] = $3;
       FUNCTION_TABLE[$0 | 0]($1, 140784, $2 + 32 | 0);
       HEAP32[$2 + 236 >> 2] = 1;
       break label$2;
      }
      break label$15;
     }
     $0 = HEAP32[HEAP32[$2 + 232 >> 2] + 20 >> 2];
     $1 = HEAP32[$2 + 232 >> 2];
     $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 220 >> 2] + 8 >> 2]);
     HEAP32[$2 + 52 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 216 >> 2] + 8 >> 2]);
     HEAP32[$2 + 48 >> 2] = $3;
     FUNCTION_TABLE[$0 | 0]($1, 140784, $2 + 48 | 0);
     HEAP32[$2 + 236 >> 2] = 1;
     break label$2;
    }
   }
  }
  HEAP32[$2 + 236 >> 2] = 0;
 }
 __stack_pointer = $2 + 240 | 0;
 return HEAP32[$2 + 236 >> 2];
}

function vcbprintf($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 144 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 140 >> 2] = $0;
 HEAP32[$4 + 136 >> 2] = $1;
 HEAP32[$4 + 132 >> 2] = $2;
 HEAP32[$4 + 128 >> 2] = $3;
 while (1) {
  label$2: {
   if (!HEAPU8[HEAP32[$4 + 132 >> 2]]) {
    break label$2;
   }
   label$3: {
    if (HEAP8[HEAP32[$4 + 132 >> 2]] == 37) {
     HEAP32[$4 + 132 >> 2] = HEAP32[$4 + 132 >> 2] + 1;
     $0 = HEAP32[$4 + 132 >> 2];
     HEAP32[$4 + 132 >> 2] = $0 + 1;
     HEAP8[$4 + 95 | 0] = HEAPU8[$0 | 0];
     label$5: {
      label$6: {
       switch (HEAP8[$4 + 95 | 0] - 32 | 0) {
       case 0:
       case 16:
       case 17:
       case 18:
       case 19:
       case 20:
       case 21:
       case 22:
       case 23:
       case 24:
       case 25:
        HEAP32[$4 + 88 >> 2] = 146437;
        if (!HEAPU8[HEAP32[$4 + 132 >> 2]]) {
         break label$5;
        }
        if (HEAP8[$4 + 95 | 0] == 48) {
         HEAP32[$4 + 88 >> 2] = 140086;
         $0 = HEAP32[$4 + 132 >> 2];
         HEAP32[$4 + 132 >> 2] = $0 + 1;
         HEAP8[$4 + 95 | 0] = HEAPU8[$0 | 0];
         if (!HEAPU8[HEAP32[$4 + 132 >> 2]]) {
          break label$5;
         }
        }
        HEAP32[$4 + 84 >> 2] = HEAP8[$4 + 95 | 0] - 48;
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        HEAP32[$4 + 80 >> 2] = HEAP32[$0 >> 2];
        label$18: {
         if (HEAP8[HEAP32[$4 + 132 >> 2]] == 120) {
          itostr_extra(HEAP32[$4 + 80 >> 2], $4 + 96 | 0, 0, 16);
          break label$18;
         }
         itostr_1(HEAP32[$4 + 80 >> 2], $4 + 96 | 0, 10);
        }
        HEAP32[$4 + 132 >> 2] = HEAP32[$4 + 132 >> 2] + 1;
        HEAP32[$4 + 76 >> 2] = strlen($4 + 96 | 0);
        while (1) {
         if (HEAP32[$4 + 76 >> 2] < HEAP32[$4 + 84 >> 2]) {
          FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](HEAP32[$4 + 88 >> 2], HEAP32[$4 + 136 >> 2]);
          HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 76 >> 2] + 1;
          continue;
         }
         break;
        }
        ;
        FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
        break label$5;

       case 68:
       case 73:
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        itostr_1(HEAP32[$0 >> 2], $4 + 96 | 0, 10);
        FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
        break label$5;

       case 88:
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        itostr_extra(HEAP32[$0 >> 2], $4 + 96 | 0, 0, 16);
        FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
        break label$5;

       case 44:
        HEAP32[$4 + 72 >> 2] = 10;
        HEAP8[$4 + 71 | 0] = 1;
        if (HEAP8[HEAP32[$4 + 132 >> 2]] == 120) {
         HEAP32[$4 + 72 >> 2] = 16;
         HEAP32[$4 + 132 >> 2] = HEAP32[$4 + 132 >> 2] + 1;
         HEAP8[$4 + 71 | 0] = 0;
        }
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        itostr_extra(HEAP32[$0 >> 2], $4 + 96 | 0, HEAP8[$4 + 71 | 0] & 1, HEAP32[$4 + 72 >> 2]);
        FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
        break label$5;

       case 70:
        $0 = HEAP32[$4 + 128 >> 2] + 7 & -8;
        HEAP32[$4 + 128 >> 2] = $0 + 8;
        ftoa_bounded(HEAPF64[$0 >> 3], $4 + 96 | 0, 32);
        FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
        break label$5;

       case 83:
        $1 = HEAP32[$4 + 140 >> 2];
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        FUNCTION_TABLE[$1 | 0](HEAP32[$0 >> 2], HEAP32[$4 + 136 >> 2]);
        break label$5;

       case 67:
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        HEAP8[$4 + 96 | 0] = HEAP32[$0 >> 2];
        HEAP8[$4 + 97 | 0] = 0;
        FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
        break label$5;

       case 49:
       case 81:
       case 86:
        HEAP8[$4 + 70 | 0] = HEAP8[$4 + 95 | 0] != 118;
        HEAP8[$4 + 69 | 0] = HEAP8[$4 + 95 | 0] == 81;
        if (HEAP8[$4 + 70 | 0] & 1) {
         FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](145507, HEAP32[$4 + 136 >> 2]);
        }
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        HEAP32[$4 + 64 >> 2] = jsvAsString(HEAP32[$0 >> 2]);
        if (jsvIsUTF8String(HEAP32[$4 + 64 >> 2]) & 1) {
         HEAP8[$4 + 69 | 0] = 1;
        }
        HEAP8[$4 + 97 | 0] = 0;
        if (jsvIsString(HEAP32[$4 + 64 >> 2]) & 1) {
         jsvStringIteratorNewUTF8($4 + 24 | 0, HEAP32[$4 + 64 >> 2], 0);
         label$26: {
          if (HEAP8[$4 + 70 | 0] & 1) {
           HEAP32[$4 + 20 >> 2] = jsvStringIteratorGetUTF8CharAndNext($4 + 24 | 0);
           while (1) {
            $0 = 1;
            if (!(jsvStringIteratorHasChar_3($4 + 24 | 0) & 1)) {
             $0 = HEAP32[$4 + 20 >> 2] >= 0;
            }
            if ($0) {
             HEAP32[$4 + 16 >> 2] = jsvStringIteratorGetUTF8CharAndNext($4 + 24 | 0);
             label$31: {
              if (HEAP8[$4 + 70 | 0] & 1) {
               $0 = HEAP32[$4 + 140 >> 2];
               FUNCTION_TABLE[$0 | 0](escapeCharacter(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2], HEAP8[$4 + 69 | 0] & 1), HEAP32[$4 + 136 >> 2]);
               break label$31;
              }
              FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
             }
             HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 16 >> 2];
             continue;
            }
            break;
           }
           break label$26;
          }
          while (1) {
           if (jsvStringIteratorHasChar_3($4 + 24 | 0) & 1) {
            HEAP8[$4 + 96 | 0] = jsvStringIteratorGetCharAndNext($4 + 24 | 0);
            FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
            continue;
           }
           break;
          }
         }
         jsvStringIteratorFree_3($4 + 24 | 0);
         jsvUnLock(HEAP32[$4 + 64 >> 2]);
        }
        if (HEAP8[$4 + 70 | 0] & 1) {
         FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](145507, HEAP32[$4 + 136 >> 2]);
        }
        break label$5;

       case 74:
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        HEAP32[$4 + 12 >> 2] = HEAP32[$0 >> 2];
        jsfGetJSONWithCallback(HEAP32[$4 + 12 >> 2], 0, 8229, 0, HEAP32[$4 + 140 >> 2], HEAP32[$4 + 136 >> 2]);
        break label$5;

       case 84:
        $0 = HEAP32[$4 + 128 >> 2];
        HEAP32[$4 + 128 >> 2] = $0 + 4;
        HEAP32[$4 + 8 >> 2] = HEAP32[$0 >> 2];
        if (jsvIsNull(HEAP32[$4 + 8 >> 2]) & 1) {
         $0 = 128729;
        } else {
         $0 = jswGetBasicObjectName(HEAP32[$4 + 8 >> 2]);
        }
        HEAP32[$4 + 4 >> 2] = $0;
        if (!HEAP32[$4 + 4 >> 2]) {
         HEAP32[$4 + 4 >> 2] = jsvGetTypeOf(HEAP32[$4 + 8 >> 2]);
        }
        FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]](HEAP32[$4 + 4 >> 2], HEAP32[$4 + 136 >> 2]);
        break label$5;

       case 80:
        break label$6;

       default:
        break label$2;
       }
      }
      $0 = HEAP32[$4 + 128 >> 2];
      HEAP32[$4 + 128 >> 2] = $0 + 4;
      jshGetPinString($4 + 96 | 0, HEAP32[$0 >> 2] & 255);
      FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
     }
     break label$3;
    }
    $0 = HEAP32[$4 + 132 >> 2];
    HEAP32[$4 + 132 >> 2] = $0 + 1;
    HEAP8[$4 + 96 | 0] = HEAPU8[$0 | 0];
    HEAP8[$4 + 97 | 0] = 0;
    FUNCTION_TABLE[HEAP32[$4 + 140 >> 2]]($4 + 96 | 0, HEAP32[$4 + 136 >> 2]);
   }
   continue;
  }
  break;
 }
 __stack_pointer = $4 + 144 | 0;
}

function tflite__reference_ops__depthwise_conv__DepthwiseConvBasicKernel__28tflite__DepthwiseConvOutputRounding_291___Run_28tflite__DepthwiseParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0;
 $9 = __stack_pointer - 192 | 0;
 __stack_pointer = $9;
 HEAP32[$9 + 188 >> 2] = $0;
 HEAP32[$9 + 184 >> 2] = $1;
 HEAP32[$9 + 180 >> 2] = $2;
 HEAP32[$9 + 176 >> 2] = $3;
 HEAP32[$9 + 172 >> 2] = $4;
 HEAP32[$9 + 168 >> 2] = $5;
 HEAP32[$9 + 164 >> 2] = $6;
 HEAP32[$9 + 160 >> 2] = $7;
 HEAP32[$9 + 156 >> 2] = $8;
 HEAP32[$9 + 152 >> 2] = HEAP16[HEAP32[$9 + 188 >> 2] + 10 >> 1];
 HEAP32[$9 + 148 >> 2] = HEAP16[HEAP32[$9 + 188 >> 2] + 12 >> 1];
 HEAP32[$9 + 144 >> 2] = HEAP16[HEAP32[$9 + 188 >> 2] + 14 >> 1];
 HEAP32[$9 + 140 >> 2] = HEAP16[HEAP32[$9 + 188 >> 2] + 16 >> 1];
 HEAP32[$9 + 136 >> 2] = HEAP16[HEAP32[$9 + 188 >> 2] + 2 >> 1];
 HEAP32[$9 + 132 >> 2] = HEAP16[HEAP32[$9 + 188 >> 2] + 4 >> 1];
 HEAP32[$9 + 128 >> 2] = HEAP16[HEAP32[$9 + 188 >> 2] + 18 >> 1];
 HEAP32[$9 + 124 >> 2] = HEAP32[HEAP32[$9 + 188 >> 2] + 40 >> 2];
 HEAP32[$9 + 120 >> 2] = HEAP32[HEAP32[$9 + 188 >> 2] + 44 >> 2];
 HEAP32[$9 + 116 >> 2] = HEAP32[HEAP32[$9 + 188 >> 2] + 20 >> 2];
 HEAP32[$9 + 112 >> 2] = HEAP32[HEAP32[$9 + 188 >> 2] + 24 >> 2];
 HEAP32[$9 + 108 >> 2] = HEAP32[HEAP32[$9 + 188 >> 2] + 28 >> 2];
 HEAP32[$9 + 104 >> 2] = HEAP32[HEAP32[$9 + 188 >> 2] + 32 >> 2];
 HEAP32[$9 + 100 >> 2] = HEAP32[HEAP32[$9 + 188 >> 2] + 36 >> 2];
 label$1: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 184 >> 2]) | 0) != 4) {
   break label$1;
  }
 }
 label$2: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 176 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 160 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 label$4: {
  if (HEAP32[$9 + 124 >> 2] > HEAP32[$9 + 120 >> 2]) {
   break label$4;
  }
 }
 HEAP32[$9 + 96 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 184 >> 2], 0, HEAP32[$9 + 160 >> 2], 0);
 HEAP32[$9 + 92 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 176 >> 2], 3, HEAP32[$9 + 160 >> 2], 3);
 HEAP32[$9 + 88 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 184 >> 2], 1);
 HEAP32[$9 + 84 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 184 >> 2], 2);
 HEAP32[$9 + 80 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 184 >> 2], 3);
 HEAP32[$9 + 76 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 176 >> 2], 1);
 HEAP32[$9 + 72 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 176 >> 2], 2);
 HEAP32[$9 + 68 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 160 >> 2], 1);
 HEAP32[$9 + 64 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 160 >> 2], 2);
 label$5: {
  if (HEAP32[$9 + 92 >> 2] != (Math_imul(HEAP32[$9 + 80 >> 2], HEAP32[$9 + 128 >> 2]) | 0)) {
   break label$5;
  }
 }
 label$6: {
  if ((tflite__RuntimeShape__FlatSize_28_29_20const(HEAP32[$9 + 168 >> 2]) | 0) != HEAP32[$9 + 92 >> 2]) {
   break label$6;
  }
 }
 HEAP32[$9 + 60 >> 2] = 0;
 while (1) {
  if (HEAP32[$9 + 60 >> 2] < HEAP32[$9 + 96 >> 2]) {
   HEAP32[$9 + 56 >> 2] = 0;
   while (1) {
    if (HEAP32[$9 + 56 >> 2] < HEAP32[$9 + 68 >> 2]) {
     HEAP32[$9 + 52 >> 2] = 0;
     while (1) {
      if (HEAP32[$9 + 52 >> 2] < HEAP32[$9 + 64 >> 2]) {
       HEAP32[$9 + 48 >> 2] = 0;
       while (1) {
        if (HEAP32[$9 + 48 >> 2] < HEAP32[$9 + 80 >> 2]) {
         HEAP32[$9 + 44 >> 2] = 0;
         while (1) {
          if (HEAP32[$9 + 44 >> 2] < HEAP32[$9 + 128 >> 2]) {
           HEAP32[$9 + 40 >> 2] = HEAP32[$9 + 44 >> 2] + Math_imul(HEAP32[$9 + 48 >> 2], HEAP32[$9 + 128 >> 2]);
           HEAP32[$9 + 36 >> 2] = Math_imul(HEAP32[$9 + 52 >> 2], HEAP32[$9 + 152 >> 2]) - HEAP32[$9 + 136 >> 2];
           HEAP32[$9 + 32 >> 2] = Math_imul(HEAP32[$9 + 56 >> 2], HEAP32[$9 + 148 >> 2]) - HEAP32[$9 + 132 >> 2];
           HEAP32[$9 + 28 >> 2] = 0;
           HEAP32[$9 + 24 >> 2] = 0;
           while (1) {
            if (HEAP32[$9 + 24 >> 2] < HEAP32[$9 + 76 >> 2]) {
             HEAP32[$9 + 20 >> 2] = 0;
             while (1) {
              if (HEAP32[$9 + 20 >> 2] < HEAP32[$9 + 72 >> 2]) {
               HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 36 >> 2] + Math_imul(HEAP32[$9 + 144 >> 2], HEAP32[$9 + 20 >> 2]);
               HEAP32[$9 + 12 >> 2] = HEAP32[$9 + 32 >> 2] + Math_imul(HEAP32[$9 + 140 >> 2], HEAP32[$9 + 24 >> 2]);
               if (!(HEAP32[$9 + 16 >> 2] < 0 | HEAP32[$9 + 16 >> 2] >= HEAP32[$9 + 84 >> 2] | (HEAP32[$9 + 12 >> 2] < 0 | HEAP32[$9 + 12 >> 2] >= HEAP32[$9 + 88 >> 2]))) {
                HEAP32[$9 + 8 >> 2] = HEAPU8[HEAP32[$9 + 180 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$9 + 184 >> 2], HEAP32[$9 + 60 >> 2], HEAP32[$9 + 12 >> 2], HEAP32[$9 + 16 >> 2], HEAP32[$9 + 48 >> 2]) | 0];
                HEAP32[$9 + 4 >> 2] = HEAPU8[HEAP32[$9 + 172 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$9 + 176 >> 2], 0, HEAP32[$9 + 24 >> 2], HEAP32[$9 + 20 >> 2], HEAP32[$9 + 40 >> 2]) | 0];
                HEAP32[$9 + 28 >> 2] = HEAP32[$9 + 28 >> 2] + Math_imul(HEAP32[$9 + 4 >> 2] + HEAP32[$9 + 112 >> 2] | 0, HEAP32[$9 + 8 >> 2] + HEAP32[$9 + 116 >> 2] | 0);
               }
               HEAP32[$9 + 20 >> 2] = HEAP32[$9 + 20 >> 2] + 1;
               continue;
              }
              break;
             }
             HEAP32[$9 + 24 >> 2] = HEAP32[$9 + 24 >> 2] + 1;
             continue;
            }
            break;
           }
           if (HEAP32[$9 + 164 >> 2]) {
            HEAP32[$9 + 28 >> 2] = HEAP32[HEAP32[$9 + 164 >> 2] + (HEAP32[$9 + 40 >> 2] << 2) >> 2] + HEAP32[$9 + 28 >> 2];
           }
           HEAP32[$9 + 28 >> 2] = int_20tflite__reference_ops__depthwise_conv__DepthwiseConvRound__28tflite__DepthwiseConvOutputRounding_291__28int_2c_20int_2c_20int_29(HEAP32[$9 + 28 >> 2], HEAP32[$9 + 104 >> 2], HEAP32[$9 + 100 >> 2]);
           HEAP32[$9 + 28 >> 2] = HEAP32[$9 + 108 >> 2] + HEAP32[$9 + 28 >> 2];
           HEAP32[$9 + 28 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($9 + 28 | 0, $9 + 124 | 0) >> 2];
           HEAP32[$9 + 28 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($9 + 28 | 0, $9 + 120 | 0) >> 2];
           $0 = HEAP32[$9 + 28 >> 2];
           HEAP8[HEAP32[$9 + 156 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$9 + 160 >> 2], HEAP32[$9 + 60 >> 2], HEAP32[$9 + 56 >> 2], HEAP32[$9 + 52 >> 2], HEAP32[$9 + 40 >> 2]) | 0] = $0;
           HEAP32[$9 + 44 >> 2] = HEAP32[$9 + 44 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAP32[$9 + 48 >> 2] = HEAP32[$9 + 48 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$9 + 52 >> 2] = HEAP32[$9 + 52 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$9 + 56 >> 2] = HEAP32[$9 + 56 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$9 + 60 >> 2] = HEAP32[$9 + 60 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $9 + 192 | 0;
}

function tflite__reference_ops__Conv_28tflite__ConvParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__2c_20void__29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) {
 var $12 = 0;
 $12 = __stack_pointer - 192 | 0;
 __stack_pointer = $12;
 HEAP32[$12 + 188 >> 2] = $0;
 HEAP32[$12 + 184 >> 2] = $1;
 HEAP32[$12 + 180 >> 2] = $2;
 HEAP32[$12 + 176 >> 2] = $3;
 HEAP32[$12 + 172 >> 2] = $4;
 HEAP32[$12 + 168 >> 2] = $5;
 HEAP32[$12 + 164 >> 2] = $6;
 HEAP32[$12 + 160 >> 2] = $7;
 HEAP32[$12 + 156 >> 2] = $8;
 HEAP32[$12 + 152 >> 2] = $9;
 HEAP32[$12 + 148 >> 2] = $10;
 HEAP32[$12 + 144 >> 2] = $11;
 HEAP32[$12 + 140 >> 2] = HEAP16[HEAP32[$12 + 188 >> 2] + 10 >> 1];
 HEAP32[$12 + 136 >> 2] = HEAP16[HEAP32[$12 + 188 >> 2] + 12 >> 1];
 HEAP32[$12 + 132 >> 2] = HEAP16[HEAP32[$12 + 188 >> 2] + 14 >> 1];
 HEAP32[$12 + 128 >> 2] = HEAP16[HEAP32[$12 + 188 >> 2] + 16 >> 1];
 HEAP32[$12 + 124 >> 2] = HEAP16[HEAP32[$12 + 188 >> 2] + 2 >> 1];
 HEAP32[$12 + 120 >> 2] = HEAP16[HEAP32[$12 + 188 >> 2] + 4 >> 1];
 HEAP32[$12 + 116 >> 2] = HEAP32[HEAP32[$12 + 188 >> 2] + 20 >> 2];
 HEAP32[$12 + 112 >> 2] = HEAP32[HEAP32[$12 + 188 >> 2] + 24 >> 2];
 HEAP32[$12 + 108 >> 2] = HEAP32[HEAP32[$12 + 188 >> 2] + 28 >> 2];
 HEAP32[$12 + 104 >> 2] = HEAP32[HEAP32[$12 + 188 >> 2] + 32 >> 2];
 HEAP32[$12 + 100 >> 2] = HEAP32[HEAP32[$12 + 188 >> 2] + 36 >> 2];
 HEAP32[$12 + 96 >> 2] = HEAP32[HEAP32[$12 + 188 >> 2] + 40 >> 2];
 HEAP32[$12 + 92 >> 2] = HEAP32[HEAP32[$12 + 188 >> 2] + 44 >> 2];
 label$1: {
  if (HEAP32[$12 + 96 >> 2] > HEAP32[$12 + 92 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$12 + 184 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$12 + 176 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 label$4: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$12 + 160 >> 2]) | 0) != 4) {
   break label$4;
  }
 }
 HEAP32[$12 + 88 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$12 + 184 >> 2], 0, HEAP32[$12 + 160 >> 2], 0);
 HEAP32[$12 + 84 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$12 + 184 >> 2], 3, HEAP32[$12 + 176 >> 2], 3);
 HEAP32[$12 + 80 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$12 + 176 >> 2], 0, HEAP32[$12 + 160 >> 2], 3);
 if (HEAP32[$12 + 164 >> 2]) {
  label$6: {
   if ((tflite__RuntimeShape__FlatSize_28_29_20const(HEAP32[$12 + 168 >> 2]) | 0) != HEAP32[$12 + 80 >> 2]) {
    break label$6;
   }
  }
 }
 HEAP32[$12 + 76 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$12 + 184 >> 2], 1);
 HEAP32[$12 + 72 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$12 + 184 >> 2], 2);
 HEAP32[$12 + 68 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$12 + 176 >> 2], 1);
 HEAP32[$12 + 64 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$12 + 176 >> 2], 2);
 HEAP32[$12 + 60 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$12 + 160 >> 2], 1);
 HEAP32[$12 + 56 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$12 + 160 >> 2], 2);
 HEAP32[$12 + 52 >> 2] = 0;
 while (1) {
  if (HEAP32[$12 + 52 >> 2] < HEAP32[$12 + 88 >> 2]) {
   HEAP32[$12 + 48 >> 2] = 0;
   while (1) {
    if (HEAP32[$12 + 48 >> 2] < HEAP32[$12 + 60 >> 2]) {
     HEAP32[$12 + 44 >> 2] = 0;
     while (1) {
      if (HEAP32[$12 + 44 >> 2] < HEAP32[$12 + 56 >> 2]) {
       HEAP32[$12 + 40 >> 2] = 0;
       while (1) {
        if (HEAP32[$12 + 40 >> 2] < HEAP32[$12 + 80 >> 2]) {
         HEAP32[$12 + 36 >> 2] = Math_imul(HEAP32[$12 + 44 >> 2], HEAP32[$12 + 140 >> 2]) - HEAP32[$12 + 124 >> 2];
         HEAP32[$12 + 32 >> 2] = Math_imul(HEAP32[$12 + 48 >> 2], HEAP32[$12 + 136 >> 2]) - HEAP32[$12 + 120 >> 2];
         HEAP32[$12 + 28 >> 2] = 0;
         HEAP32[$12 + 24 >> 2] = 0;
         while (1) {
          if (HEAP32[$12 + 24 >> 2] < HEAP32[$12 + 68 >> 2]) {
           HEAP32[$12 + 20 >> 2] = 0;
           while (1) {
            if (HEAP32[$12 + 20 >> 2] < HEAP32[$12 + 64 >> 2]) {
             HEAP32[$12 + 16 >> 2] = 0;
             while (1) {
              if (HEAP32[$12 + 16 >> 2] < HEAP32[$12 + 84 >> 2]) {
               HEAP32[$12 + 12 >> 2] = HEAP32[$12 + 36 >> 2] + Math_imul(HEAP32[$12 + 132 >> 2], HEAP32[$12 + 20 >> 2]);
               HEAP32[$12 + 8 >> 2] = HEAP32[$12 + 32 >> 2] + Math_imul(HEAP32[$12 + 128 >> 2], HEAP32[$12 + 24 >> 2]);
               if (!(HEAP32[$12 + 12 >> 2] < 0 | HEAP32[$12 + 12 >> 2] >= HEAP32[$12 + 72 >> 2] | (HEAP32[$12 + 8 >> 2] < 0 | HEAP32[$12 + 8 >> 2] >= HEAP32[$12 + 76 >> 2]))) {
                HEAP32[$12 + 4 >> 2] = HEAPU8[HEAP32[$12 + 180 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$12 + 184 >> 2], HEAP32[$12 + 52 >> 2], HEAP32[$12 + 8 >> 2], HEAP32[$12 + 12 >> 2], HEAP32[$12 + 16 >> 2]) | 0];
                HEAP32[$12 >> 2] = HEAPU8[HEAP32[$12 + 172 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$12 + 176 >> 2], HEAP32[$12 + 40 >> 2], HEAP32[$12 + 24 >> 2], HEAP32[$12 + 20 >> 2], HEAP32[$12 + 16 >> 2]) | 0];
                HEAP32[$12 + 28 >> 2] = HEAP32[$12 + 28 >> 2] + Math_imul(HEAP32[$12 >> 2] + HEAP32[$12 + 112 >> 2] | 0, HEAP32[$12 + 4 >> 2] + HEAP32[$12 + 116 >> 2] | 0);
               }
               HEAP32[$12 + 16 >> 2] = HEAP32[$12 + 16 >> 2] + 1;
               continue;
              }
              break;
             }
             HEAP32[$12 + 20 >> 2] = HEAP32[$12 + 20 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$12 + 24 >> 2] = HEAP32[$12 + 24 >> 2] + 1;
           continue;
          }
          break;
         }
         if (HEAP32[$12 + 164 >> 2]) {
          HEAP32[$12 + 28 >> 2] = HEAP32[HEAP32[$12 + 164 >> 2] + (HEAP32[$12 + 40 >> 2] << 2) >> 2] + HEAP32[$12 + 28 >> 2];
         }
         HEAP32[$12 + 28 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$12 + 28 >> 2], HEAP32[$12 + 104 >> 2], HEAP32[$12 + 100 >> 2]);
         HEAP32[$12 + 28 >> 2] = HEAP32[$12 + 108 >> 2] + HEAP32[$12 + 28 >> 2];
         HEAP32[$12 + 28 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($12 + 28 | 0, $12 + 96 | 0) >> 2];
         HEAP32[$12 + 28 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($12 + 28 | 0, $12 + 92 | 0) >> 2];
         $0 = HEAP32[$12 + 28 >> 2];
         HEAP8[HEAP32[$12 + 156 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$12 + 160 >> 2], HEAP32[$12 + 52 >> 2], HEAP32[$12 + 48 >> 2], HEAP32[$12 + 44 >> 2], HEAP32[$12 + 40 >> 2]) | 0] = $0;
         HEAP32[$12 + 40 >> 2] = HEAP32[$12 + 40 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$12 + 44 >> 2] = HEAP32[$12 + 44 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$12 + 48 >> 2] = HEAP32[$12 + 48 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$12 + 52 >> 2] = HEAP32[$12 + 52 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $12 + 192 | 0;
}

function jswrap_graphics_wrapString($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $3 = __stack_pointer - 352 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 344 >> 2] = $0;
 HEAP32[$3 + 340 >> 2] = $1;
 HEAP32[$3 + 336 >> 2] = $2;
 label$1: {
  if (!HEAP32[$3 + 340 >> 2]) {
   HEAP32[$3 + 348 >> 2] = jsvNewEmptyArray();
   break label$1;
  }
  if (HEAP32[$3 + 336 >> 2] <= 0) {
   HEAP32[$3 + 348 >> 2] = 0;
   break label$1;
  }
  if (!(graphicsGetFromVar($3 + 264 | 0, HEAP32[$3 + 344 >> 2]) & 1)) {
   HEAP32[$3 + 348 >> 2] = 0;
   break label$1;
  }
  _jswrap_graphics_getFontInfo($3 + 264 | 0, $3 + 240 | 0);
  HEAP32[$3 + 340 >> 2] = jsvAsString(HEAP32[$3 + 340 >> 2]);
  HEAP32[$3 + 236 >> 2] = jsvNewEmptyArray();
  HEAP32[$3 + 232 >> 2] = jsvNewFromEmptyString_14();
  HEAP32[$3 + 228 >> 2] = _jswrap_graphics_getCharWidth($3 + 240 | 0, 32);
  HEAP32[$3 + 224 >> 2] = 0;
  HEAP32[$3 + 220 >> 2] = 0;
  HEAP8[$3 + 219 | 0] = 0;
  HEAP8[$3 + 218 | 0] = 0;
  HEAP32[$3 + 212 >> 2] = 0;
  HEAP8[$3 + 211 | 0] = 0;
  HEAP8[$3 + 210 | 0] = 0;
  jsvStringIteratorNewUTF8($3 + 168 | 0, HEAP32[$3 + 340 >> 2], 0);
  while (1) {
   label$6: {
    label$7: {
     if (!(jsvStringIteratorHasChar_12($3 + 168 | 0) & 1)) {
      $0 = 0;
      if (!(HEAP8[$3 + 211 | 0] & 1)) {
       break label$7;
      }
     }
     $0 = jspIsInterrupted() ^ -1;
    }
    if (!($0 & 1)) {
     break label$6;
    }
    HEAP32[$3 + 164 >> 2] = jsvStringIteratorGetUTF8CharAndNext($3 + 168 | 0);
    $0 = 1;
    label$9: {
     if (HEAP8[$3 + 211 | 0] & 1) {
      break label$9;
     }
     $0 = 1;
     if (HEAP32[$3 + 164 >> 2] == 10) {
      break label$9;
     }
     $0 = HEAP32[$3 + 164 >> 2] == 32;
    }
    HEAP8[$3 + 163 | 0] = $0;
    if (HEAP8[$3 + 219 | 0] & 1 ? 1 : HEAP8[$3 + 163 | 0] & 1) {
     HEAP32[$3 + 156 >> 2] = jsvStringIteratorGetIndex_6($3 + 168 | 0);
     label$12: {
      if (!(HEAP8[$3 + 210 | 0] & 1 | HEAP32[$3 + 336 >> 2] < (HEAP32[$3 + 224 >> 2] + (HEAP32[$3 + 220 >> 2] + HEAP32[$3 + 228 >> 2] | 0) | 0))) {
       if (!(!HEAP8[$3 + 218 | 0] | !HEAP32[$3 + 220 >> 2] & HEAP8[$3 + 218 | 0] == 32)) {
        jsvAppendCharacter_2(HEAP32[$3 + 232 >> 2], HEAP8[$3 + 218 | 0]);
        HEAP32[$3 + 220 >> 2] = HEAP32[$3 + 228 >> 2] + HEAP32[$3 + 220 >> 2];
       }
       jsvAppendStringVar(HEAP32[$3 + 232 >> 2], HEAP32[$3 + 340 >> 2], HEAP32[$3 + 212 >> 2], HEAP32[$3 + 156 >> 2] - (HEAP32[$3 + 212 >> 2] + 1 | 0) | 0);
       HEAP32[$3 + 220 >> 2] = HEAP32[$3 + 224 >> 2] + HEAP32[$3 + 220 >> 2];
       break label$12;
      }
      HEAP32[$3 + 220 >> 2] = HEAP32[$3 + 224 >> 2];
      if (wasm2js_i32$0 = 1, wasm2js_i32$1 = jsvGetStringLength(HEAP32[$3 + 232 >> 2]), 
      wasm2js_i32$2 = HEAP8[$3 + 210 | 0] & 1, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1) {
       jsvArrayPush(HEAP32[$3 + 236 >> 2], HEAP32[$3 + 232 >> 2]);
      }
      jsvUnLock(HEAP32[$3 + 232 >> 2]);
      HEAP32[$3 + 232 >> 2] = 0;
      while (1) {
       if (HEAP32[$3 + 224 >> 2] > HEAP32[$3 + 336 >> 2]) {
        HEAP32[$3 + 152 >> 2] = 0;
        HEAP32[$3 + 232 >> 2] = jsvNewFromEmptyString_14();
        jsvStringIteratorNew($3 + 112 | 0, HEAP32[$3 + 340 >> 2], HEAP32[$3 + 212 >> 2]);
        while (1) {
         label$21: {
          if (jsvStringIteratorGetIndex_6($3 + 112 | 0) >>> 0 >= HEAPU32[$3 + 156 >> 2]) {
           break label$21;
          }
          HEAP32[$3 + 108 >> 2] = jsvStringIteratorGetUTF8CharAndNext($3 + 112 | 0);
          if (!HEAP32[$3 + 108 >> 2]) {
           jsvAppendStringVar(HEAP32[$3 + 232 >> 2], HEAP32[$3 + 340 >> 2], HEAP32[$3 + 212 >> 2], HEAP32[$3 + 156 >> 2] - (HEAP32[$3 + 212 >> 2] + 1 | 0) | 0);
           HEAP32[$3 + 220 >> 2] = HEAP32[$3 + 224 >> 2] + HEAP32[$3 + 220 >> 2];
           HEAP32[$3 + 224 >> 2] = 0;
           HEAP32[$3 + 212 >> 2] = HEAP32[$3 + 156 >> 2] - 1;
           break label$21;
          }
          HEAP32[$3 + 104 >> 2] = _jswrap_graphics_getCharWidth($3 + 240 | 0, HEAP32[$3 + 108 >> 2]);
          if (HEAP32[$3 + 152 >> 2] ? HEAP32[$3 + 336 >> 2] <= (HEAP32[$3 + 152 >> 2] + HEAP32[$3 + 104 >> 2] | 0) : 0) {
           break label$21;
          }
          HEAP32[$3 + 224 >> 2] = HEAP32[$3 + 224 >> 2] - HEAP32[$3 + 104 >> 2];
          HEAP32[$3 + 220 >> 2] = HEAP32[$3 + 220 >> 2] - HEAP32[$3 + 104 >> 2];
          HEAP32[$3 + 152 >> 2] = HEAP32[$3 + 104 >> 2] + HEAP32[$3 + 152 >> 2];
          HEAP32[$3 + 212 >> 2] = jsvStringIteratorGetIndex_6($3 + 112 | 0);
          jsvAppendCharacter_2(HEAP32[$3 + 232 >> 2], HEAP32[$3 + 108 >> 2] << 24 >> 24);
          continue;
         }
         break;
        }
        jsvStringIteratorFree_16($3 + 112 | 0);
        jsvArrayPush(HEAP32[$3 + 236 >> 2], HEAP32[$3 + 232 >> 2]);
        jsvUnLock(HEAP32[$3 + 232 >> 2]);
        continue;
       }
       break;
      }
      HEAP32[$3 + 232 >> 2] = jsvNewWritableStringFromStringVar(HEAP32[$3 + 340 >> 2], HEAP32[$3 + 212 >> 2], HEAP32[$3 + 156 >> 2] - (HEAP32[$3 + 212 >> 2] + 1 | 0) | 0);
      if (HEAP8[$3 + 210 | 0] & 1) {
       HEAP8[$3 + 218 | 0] = 32;
      }
     }
     HEAP8[$3 + 218 | 0] = 0;
     if (!(!(HEAP8[$3 + 219 | 0] & 1) | HEAP8[$3 + 163 | 0] & 1)) {
      HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] - 1;
     }
     if (!(!(HEAP8[$3 + 163 | 0] & 1) | HEAP32[$3 + 164 >> 2] <= 0)) {
      HEAP8[$3 + 218 | 0] = HEAP32[$3 + 164 >> 2];
     }
     HEAP32[$3 + 224 >> 2] = 0;
     HEAP32[$3 + 212 >> 2] = HEAP32[$3 + 156 >> 2];
     HEAP8[$3 + 210 | 0] = HEAP32[$3 + 164 >> 2] == 10;
     HEAP8[$3 + 219 | 0] = !HEAP32[$3 + 164 >> 2];
     if (HEAP8[$3 + 211 | 0] & 1) {
      break label$6;
     }
     if (HEAP32[$3 + 164 >> 2]) {
      if (!(jsvStringIteratorHasChar_12($3 + 168 | 0) & 1)) {
       HEAP8[$3 + 211 | 0] = 1;
      }
      continue;
     }
    }
    HEAP8[$3 + 219 | 0] = 0;
    if (!HEAP32[$3 + 164 >> 2]) {
     HEAP32[$3 + 12 >> 2] = jsvConvertToUTF8Index(HEAP32[$3 + 340 >> 2], jsvStringIteratorGetIndex_6($3 + 168 | 0));
     if (_jswrap_graphics_parseImage($3 + 264 | 0, HEAP32[$3 + 340 >> 2], HEAP32[$3 + 12 >> 2], $3 + 16 | 0) & 1) {
      jsvStringIteratorGotoUTF8($3 + 168 | 0, HEAP32[$3 + 340 >> 2], HEAPU16[$3 + 66 >> 1] + (HEAP32[$3 + 12 >> 2] + HEAPU16[$3 + 64 >> 1] | 0) | 0);
      _jswrap_graphics_freeImageInfo($3 + 16 | 0);
      HEAP32[$3 + 224 >> 2] = HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 224 >> 2];
      HEAP8[$3 + 219 | 0] = 1;
      if (!(jsvStringIteratorHasChar_12($3 + 168 | 0) & 1)) {
       HEAP8[$3 + 211 | 0] = 1;
      }
     }
     continue;
    }
    HEAP32[$3 + 224 >> 2] = _jswrap_graphics_getCharWidth($3 + 240 | 0, HEAP32[$3 + 164 >> 2]) + HEAP32[$3 + 224 >> 2];
    label$32: {
     label$33: {
      if (HEAP32[$3 + 164 >> 2] == 44 | HEAP32[$3 + 164 >> 2] == 46 | (HEAP32[$3 + 164 >> 2] == 45 | HEAP32[$3 + 164 >> 2] == 47)) {
       break label$33;
      }
      if (HEAP32[$3 + 164 >> 2] == 92) {
       break label$33;
      }
      if (HEAP32[$3 + 164 >> 2] != 58) {
       break label$32;
      }
     }
     HEAP8[$3 + 219 | 0] = 1;
    }
    if (!(jsvStringIteratorHasChar_12($3 + 168 | 0) & 1)) {
     HEAP8[$3 + 211 | 0] = 1;
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree_16($3 + 168 | 0);
  if (jsvGetStringLength(HEAP32[$3 + 232 >> 2])) {
   jsvArrayPush(HEAP32[$3 + 236 >> 2], HEAP32[$3 + 232 >> 2]);
  }
  jsvUnLock2(HEAP32[$3 + 340 >> 2], HEAP32[$3 + 232 >> 2]);
  _jswrap_graphics_freeFontInfo($3 + 240 | 0);
  HEAP32[$3 + 348 >> 2] = HEAP32[$3 + 236 >> 2];
 }
 __stack_pointer = $3 + 352 | 0;
 return HEAP32[$3 + 348 >> 2];
}

function tflite__MicroAllocator__PrepareNodeAndRegistrationDataFromFlatbuffer_28tflite__Model_20const__2c_20tflite__MicroOpResolver_20const__2c_20tflite__NodeAndRegistration__29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 208 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 200 >> 2] = $0;
 HEAP32[$4 + 196 >> 2] = $1;
 HEAP32[$4 + 192 >> 2] = $2;
 HEAP32[$4 + 188 >> 2] = $3;
 $5 = HEAP32[$4 + 200 >> 2];
 label$1: {
  if (!HEAP32[$4 + 196 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (!HEAP32[$4 + 188 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$4 + 184 >> 2] = tflite__MicroAllocator__GetSubGraphFromModel_28tflite__Model_20const__29($5, HEAP32[$4 + 196 >> 2]);
 label$3: {
  if (!HEAP32[$4 + 184 >> 2]) {
   break label$3;
  }
 }
 HEAP32[$4 + 180 >> 2] = 0;
 HEAP32[$4 + 176 >> 2] = tflite__Model__operator_codes_28_29_20const(HEAP32[$4 + 196 >> 2]);
 tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator__MicroBuiltinDataAllocator_28tflite__SimpleMemoryAllocator__29($4 + 168 | 0, HEAP32[$5 + 4 >> 2]);
 HEAP32[$4 + 164 >> 2] = 0;
 label$4: {
  while (1) {
   if (HEAPU32[$4 + 164 >> 2] < flatbuffers__Vector_flatbuffers__Offset_tflite__Operator____size_28_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$4 + 184 >> 2])) >>> 0) {
    HEAP32[$4 + 160 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__Operator____Get_28unsigned_20int_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$4 + 184 >> 2]), HEAP32[$4 + 164 >> 2]);
    HEAP32[$4 + 156 >> 2] = tflite__Operator__opcode_index_28_29_20const(HEAP32[$4 + 160 >> 2]);
    if (HEAPU32[$4 + 156 >> 2] >= flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode____size_28_29_20const(HEAP32[$4 + 176 >> 2]) >>> 0) {
     $0 = HEAP32[$5 + 8 >> 2];
     HEAP32[$4 >> 2] = HEAP32[$4 + 156 >> 2];
     tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 147186, $4);
     HEAP32[$4 + 204 >> 2] = 1;
     break label$4;
    }
    HEAP32[$4 + 148 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode____operator_5b_5d_28unsigned_20int_29_20const(HEAP32[$4 + 176 >> 2], HEAP32[$4 + 156 >> 2]);
    HEAP32[$4 + 180 >> 2] = tflite__GetRegistrationFromOpCode_28tflite__OperatorCode_20const__2c_20tflite__OpResolver_20const__2c_20tflite__ErrorReporter__2c_20TfLiteRegistration_20const___29(HEAP32[$4 + 148 >> 2], HEAP32[$4 + 192 >> 2], HEAP32[$5 + 8 >> 2], (HEAP32[$4 + 188 >> 2] + Math_imul(HEAP32[$4 + 164 >> 2], 28) | 0) + 24 | 0);
    if (HEAP32[$4 + 180 >> 2]) {
     $0 = HEAP32[$5 + 8 >> 2];
     HEAP32[$4 + 16 >> 2] = tflite__EnumNameBuiltinOperator_28tflite__BuiltinOperator_29(tflite__OperatorCode__builtin_code_28_29_20const(HEAP32[$4 + 148 >> 2]));
     tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 146391, $4 + 16 | 0);
     HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 180 >> 2];
     break label$4;
    }
    HEAP32[$4 + 144 >> 2] = HEAP32[(HEAP32[$4 + 188 >> 2] + Math_imul(HEAP32[$4 + 164 >> 2], 28) | 0) + 24 >> 2];
    if (!HEAP32[$4 + 144 >> 2]) {
     $0 = HEAP32[$5 + 8 >> 2];
     HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 156 >> 2];
     tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 147153, $4 + 32 | 0);
     HEAP32[$4 + 204 >> 2] = 1;
     break label$4;
    }
    HEAP32[$4 + 140 >> 2] = HEAP32[HEAP32[$4 + 144 >> 2] + 20 >> 2];
    HEAP32[$4 + 136 >> 2] = 0;
    HEAP32[$4 + 132 >> 2] = 0;
    HEAP32[$4 + 128 >> 2] = 0;
    label$10: {
     if (HEAP32[$4 + 140 >> 2] == 32) {
      if (tflite__Operator__custom_options_28_29_20const(HEAP32[$4 + 160 >> 2])) {
       HEAP32[$4 + 136 >> 2] = flatbuffers__Vector_unsigned_20char___data_28_29_20const(tflite__Operator__custom_options_28_29_20const(HEAP32[$4 + 160 >> 2]));
       HEAP32[$4 + 132 >> 2] = flatbuffers__Vector_unsigned_20char___size_28_29_20const(tflite__Operator__custom_options_28_29_20const(HEAP32[$4 + 160 >> 2]));
      }
      break label$10;
     }
     if (tflite__Operator__custom_options_28_29_20const(HEAP32[$4 + 160 >> 2])) {
      $0 = HEAP32[$5 + 8 >> 2];
      HEAP32[$4 + 48 >> 2] = tflite__EnumNameBuiltinOperator_28tflite__BuiltinOperator_29(HEAP32[$4 + 140 >> 2]);
      tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 147506, $4 + 48 | 0);
      HEAP32[$4 + 204 >> 2] = 1;
      break label$4;
     }
     $0 = HEAP32[$4 + 192 >> 2];
     HEAP32[$4 + 124 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 28 >> 2]]($0, HEAP32[$4 + 140 >> 2]);
     if (!HEAP32[$4 + 124 >> 2]) {
      $0 = HEAP32[$5 + 8 >> 2];
      HEAP32[$4 + 64 >> 2] = tflite__EnumNameBuiltinOperator_28tflite__BuiltinOperator_29(HEAP32[$4 + 140 >> 2]);
      tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 120542, $4 - -64 | 0);
      HEAP32[$4 + 204 >> 2] = 1;
      break label$4;
     }
     HEAP32[$4 + 120 >> 2] = FUNCTION_TABLE[HEAP32[$4 + 124 >> 2]](HEAP32[$4 + 160 >> 2], HEAP32[$5 + 8 >> 2], $4 + 168 | 0, $4 + 128 | 0);
     if (HEAP32[$4 + 120 >> 2]) {
      HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 120 >> 2];
      break label$4;
     }
    }
    HEAP32[$4 + 112 >> 2] = TfLiteStatus_20tflite__internal__FlatBufferVectorToTfLiteTypeArray_int_2c_20TfLiteIntArray__28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__2c_20flatbuffers__Vector_int__20const__2c_20TfLiteIntArray___29(HEAP32[$5 + 4 >> 2], HEAP32[$5 + 8 >> 2], tflite__Operator__inputs_28_29_20const(HEAP32[$4 + 160 >> 2]), $4 + 116 | 0);
    if (HEAP32[$4 + 112 >> 2]) {
     HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 112 >> 2];
     break label$4;
    }
    HEAP32[$4 + 104 >> 2] = TfLiteStatus_20tflite__internal__FlatBufferVectorToTfLiteTypeArray_int_2c_20TfLiteIntArray__28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__2c_20flatbuffers__Vector_int__20const__2c_20TfLiteIntArray___29(HEAP32[$5 + 4 >> 2], HEAP32[$5 + 8 >> 2], tflite__Operator__outputs_28_29_20const(HEAP32[$4 + 160 >> 2]), $4 + 108 | 0);
    if (HEAP32[$4 + 104 >> 2]) {
     HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 104 >> 2];
     break label$4;
    } else {
     HEAP32[$4 + 100 >> 2] = HEAP32[$4 + 188 >> 2] + Math_imul(HEAP32[$4 + 164 >> 2], 28);
     HEAP32[$4 + 88 >> 2] = 0;
     HEAP32[$4 + 92 >> 2] = 0;
     HEAP32[$4 + 80 >> 2] = 0;
     HEAP32[$4 + 84 >> 2] = 0;
     HEAP32[$4 + 72 >> 2] = 0;
     HEAP32[$4 + 76 >> 2] = 0;
     $2 = HEAP32[$4 + 76 >> 2];
     $0 = HEAP32[$4 + 72 >> 2];
     $3 = $0;
     $1 = HEAP32[$4 + 100 >> 2];
     $0 = $1;
     HEAP32[$0 >> 2] = $3;
     HEAP32[$0 + 4 >> 2] = $2;
     $0 = HEAP32[$4 + 92 >> 2];
     $2 = HEAP32[$4 + 88 >> 2];
     $3 = $2;
     $2 = $1;
     HEAP32[$2 + 16 >> 2] = $3;
     HEAP32[$2 + 20 >> 2] = $0;
     $2 = HEAP32[$4 + 84 >> 2];
     $0 = HEAP32[$4 + 80 >> 2];
     $3 = $0;
     $0 = $1;
     HEAP32[$0 + 8 >> 2] = $3;
     HEAP32[$0 + 12 >> 2] = $2;
     HEAP32[HEAP32[$4 + 100 >> 2] >> 2] = HEAP32[$4 + 116 >> 2];
     HEAP32[HEAP32[$4 + 100 >> 2] + 4 >> 2] = HEAP32[$4 + 108 >> 2];
     HEAP32[HEAP32[$4 + 100 >> 2] + 12 >> 2] = HEAP32[$4 + 128 >> 2];
     HEAP32[HEAP32[$4 + 100 >> 2] + 16 >> 2] = HEAP32[$4 + 136 >> 2];
     HEAP32[HEAP32[$4 + 100 >> 2] + 20 >> 2] = HEAP32[$4 + 132 >> 2];
     HEAP32[$4 + 164 >> 2] = HEAP32[$4 + 164 >> 2] + 1;
     continue;
    }
   }
   break;
  }
  HEAP32[$4 + 204 >> 2] = 0;
 }
 HEAP32[$4 + 152 >> 2] = 1;
 tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29($4 + 168 | 0);
 __stack_pointer = $4 + 208 | 0;
 return HEAP32[$4 + 204 >> 2];
}

function jsiDumpState($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = __stack_pointer - 272 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 268 >> 2] = $0;
 HEAP32[$2 + 264 >> 2] = $1;
 jsvObjectIteratorNew($2 + 256 | 0, HEAP32[91086]);
 while (1) {
  if (jsvObjectIteratorHasValue_3($2 + 256 | 0) & 1) {
   HEAP32[$2 + 252 >> 2] = jsvObjectIteratorGetKey_3($2 + 256 | 0);
   HEAP32[$2 + 248 >> 2] = jsvObjectIteratorGetValue_3($2 + 256 | 0);
   jsvGetString(HEAP32[$2 + 252 >> 2], $2 + 176 | 0, 64);
   HEAP8[$2 + 175 | 0] = 0;
   HEAP32[$2 + 168 >> 2] = 166430;
   while (1) {
    if (HEAPU8[HEAP32[$2 + 168 >> 2]]) {
     if (!strcmp(HEAP32[$2 + 168 >> 2], $2 + 176 | 0)) {
      HEAP8[$2 + 175 | 0] = 1;
     }
     HEAP32[$2 + 168 >> 2] = (strlen(HEAP32[$2 + 168 >> 2]) + 1 | 0) + HEAP32[$2 + 168 >> 2];
     continue;
    }
    break;
   }
   if (!(HEAP8[$2 + 175 | 0] & 1)) {
    label$7: {
     if (jswIsBuiltInObject($2 + 176 | 0) & 1) {
      jsiDumpObjectState(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2]);
      break label$7;
     }
     if (!(jsvIsStringEqualOrStartsWith(HEAP32[$2 + 252 >> 2], 128471, 1) & 1)) {
      if (!(jsvIsStringEqual(HEAP32[$2 + 252 >> 2], 119955) & 1)) {
       if (!(jsvIsStringEqual(HEAP32[$2 + 252 >> 2], 120298) & 1)) {
        label$12: {
         if (HEAP8[HEAP32[$2 + 252 >> 2]] == -1) {
          break label$12;
         }
         if (jshFromDeviceString($2 + 176 | 0) & 255) {
          break label$12;
         }
         if (!(jsvIsNativeFunction(HEAP32[$2 + 248 >> 2]) & 1)) {
          label$15: {
           if (jsvIsFunction(HEAP32[$2 + 248 >> 2]) & 1) {
            $0 = HEAP32[$2 + 268 >> 2];
            $1 = HEAP32[$2 + 264 >> 2];
            HEAP32[$2 >> 2] = HEAP32[$2 + 252 >> 2];
            cbprintf($0, $1, 116838, $2);
            jsfGetJSONForFunctionWithCallback(HEAP32[$2 + 248 >> 2], 32, HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2]);
            FUNCTION_TABLE[HEAP32[$2 + 268 >> 2]](148266, HEAP32[$2 + 264 >> 2]);
            jsiDumpObjectState(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2]);
            break label$15;
           }
           $0 = HEAP32[$2 + 268 >> 2];
           $1 = HEAP32[$2 + 264 >> 2];
           HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 252 >> 2];
           cbprintf($0, $1, 146241, $2 + 32 | 0);
           HEAP8[$2 + 167 | 0] = 0;
           if (jsvIsObject(HEAP32[$2 + 248 >> 2]) & 1) {
            HEAP32[$2 + 160 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 248 >> 2], 135865);
            if (HEAP32[$2 + 160 >> 2]) {
             HEAP32[$2 + 156 >> 2] = jsvGetPathTo(HEAP32[91086], HEAP32[$2 + 160 >> 2], 4, HEAP32[$2 + 248 >> 2]);
             if (HEAP32[$2 + 156 >> 2]) {
              $0 = HEAP32[$2 + 268 >> 2];
              $1 = HEAP32[$2 + 264 >> 2];
              HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 156 >> 2];
              cbprintf($0, $1, 147311, $2 + 16 | 0);
              jsiDumpObjectState(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], HEAP32[$2 + 252 >> 2], HEAP32[$2 + 248 >> 2]);
              HEAP8[$2 + 167 | 0] = 1;
             }
            }
           }
           if (!(HEAP8[$2 + 167 | 0] & 1)) {
            jsiDumpJSON(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], HEAP32[$2 + 248 >> 2], HEAP32[$2 + 252 >> 2]);
            FUNCTION_TABLE[HEAP32[$2 + 268 >> 2]](147435, HEAP32[$2 + 264 >> 2]);
           }
          }
         }
        }
       }
      }
     }
    }
   }
   jsvUnLock2(HEAP32[$2 + 248 >> 2], HEAP32[$2 + 252 >> 2]);
   jsvObjectIteratorNext($2 + 256 | 0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree_3($2 + 256 | 0);
 HEAP32[$2 + 152 >> 2] = jsvLock(HEAPU16[182204]);
 jsvObjectIteratorNew($2 + 256 | 0, HEAP32[$2 + 152 >> 2]);
 jsvUnLock(HEAP32[$2 + 152 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue_3($2 + 256 | 0) & 1) {
   HEAP32[$2 + 148 >> 2] = jsvObjectIteratorGetValue_3($2 + 256 | 0);
   HEAP32[$2 + 144 >> 2] = jsvObjectIteratorGetKey_3($2 + 256 | 0);
   HEAP32[$2 + 140 >> 2] = jsvSkipOneNameAndUnLock(jsvFindChildFromString(HEAP32[$2 + 148 >> 2], 135710));
   HEAP32[$2 + 136 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 148 >> 2], 120745);
   FUNCTION_TABLE[HEAP32[$2 + 268 >> 2]](HEAP32[$2 + 136 >> 2] ? 145205 : 145183, HEAP32[$2 + 264 >> 2]);
   jsiDumpJSON(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], HEAP32[$2 + 140 >> 2], 0);
   $4 = HEAP32[$2 + 268 >> 2];
   $5 = HEAP32[$2 + 264 >> 2];
   label$23: {
    if (HEAP32[$2 + 136 >> 2]) {
     $0 = jsvGetLongInteger(HEAP32[$2 + 136 >> 2]);
     $3 = $0;
     $1 = i64toi32_i32$HIGH_BITS;
     $0 = $1;
     break label$23;
    }
    $1 = jsvGetLongIntegerAndUnLock(jsvObjectGetChildIfExists(HEAP32[$2 + 148 >> 2], 132372));
    $3 = $1;
    $0 = i64toi32_i32$HIGH_BITS;
   }
   $6 = jshGetMillisecondsFromTime($3, $0);
   HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 144 >> 2];
   HEAPF64[$2 + 48 >> 3] = $6;
   cbprintf($4, $5, 146521, $2 + 48 | 0);
   jsvUnLock3(HEAP32[$2 + 136 >> 2], HEAP32[$2 + 140 >> 2], HEAP32[$2 + 144 >> 2]);
   jsvUnLock(HEAP32[$2 + 148 >> 2]);
   jsvObjectIteratorNext($2 + 256 | 0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree_3($2 + 256 | 0);
 HEAP32[$2 + 132 >> 2] = jsvLock(HEAPU16[182205]);
 jsvObjectIteratorNew($2 + 256 | 0, HEAP32[$2 + 132 >> 2]);
 jsvUnLock(HEAP32[$2 + 132 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue_3($2 + 256 | 0) & 1) {
   HEAP32[$2 + 128 >> 2] = jsvObjectIteratorGetValue_3($2 + 256 | 0);
   HEAP32[$2 + 124 >> 2] = jsvSkipOneNameAndUnLock(jsvFindChildFromString(HEAP32[$2 + 128 >> 2], 135710));
   HEAP8[$2 + 123 | 0] = jsvObjectGetBoolChild(HEAP32[$2 + 128 >> 2], 120696) & 1;
   HEAP32[$2 + 116 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 128 >> 2], 132661);
   HEAP32[$2 + 112 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 128 >> 2], 128488);
   HEAP32[$2 + 108 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 128 >> 2], 132809);
   FUNCTION_TABLE[HEAP32[$2 + 268 >> 2]](145232, HEAP32[$2 + 264 >> 2]);
   jsiDumpJSON(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], HEAP32[$2 + 124 >> 2], 0);
   $0 = HEAP32[$2 + 268 >> 2];
   $1 = HEAP32[$2 + 264 >> 2];
   $3 = HEAP32[$2 + 112 >> 2];
   $4 = HEAP8[$2 + 123 | 0] & 1 ? 131761 : 132085;
   HEAP32[$2 + 88 >> 2] = HEAP32[$2 + 116 >> 2] < 0 ? 130011 : HEAP32[$2 + 116 >> 2] > 0 ? 129725 : 129325;
   HEAP32[$2 + 84 >> 2] = $4;
   HEAP32[$2 + 80 >> 2] = $3;
   cbprintf($0, $1, 145295, $2 + 80 | 0);
   if (HEAP32[$2 + 108 >> 2] > 0) {
    $3 = HEAP32[$2 + 268 >> 2];
    $4 = HEAP32[$2 + 264 >> 2];
    $0 = HEAP32[$2 + 108 >> 2];
    $1 = $0 >> 31;
    HEAPF64[$2 + 64 >> 3] = jshGetMillisecondsFromTime($0, $1);
    cbprintf($3, $4, 130199, $2 - -64 | 0);
   }
   FUNCTION_TABLE[HEAP32[$2 + 268 >> 2]](147305, HEAP32[$2 + 264 >> 2]);
   jsvUnLock2(HEAP32[$2 + 112 >> 2], HEAP32[$2 + 124 >> 2]);
   jsvUnLock(HEAP32[$2 + 128 >> 2]);
   jsvObjectIteratorNext($2 + 256 | 0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree_3($2 + 256 | 0);
 jsiDumpHardwareInitialisation(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], 1);
 HEAP32[$2 + 104 >> 2] = jsfGetBootCodeFromFlash(0);
 if (HEAP32[$2 + 104 >> 2]) {
  cbprintf(HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2], 147020, 0);
  jslPrintTokenisedString(HEAP32[$2 + 104 >> 2], HEAP32[$2 + 268 >> 2], HEAP32[$2 + 264 >> 2]);
  jsvUnLock(HEAP32[$2 + 104 >> 2]);
 }
 __stack_pointer = $2 + 272 | 0;
}

function __jspeBinaryExpression($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 208 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 204 >> 2] = $0;
 HEAP32[$2 + 200 >> 2] = $1;
 HEAP32[$2 + 196 >> 2] = jspeGetBinaryExpressionPrecedence(HEAP16[HEAP32[49079] + 2 >> 1]);
 while (1) {
  $0 = 0;
  $0 = HEAP32[$2 + 196 >> 2] ? HEAPU32[$2 + 196 >> 2] > HEAPU32[$2 + 200 >> 2] : $0;
  if ($0) {
   HEAP32[$2 + 192 >> 2] = HEAP16[HEAP32[49079] + 2 >> 1];
   jslGetNextToken();
   if ((HEAP32[91094] & 63) == 1) {
    HEAP32[$2 + 188 >> 2] = jsvSkipNameAndUnLock(HEAP32[$2 + 204 >> 2]);
    HEAP32[$2 + 204 >> 2] = jsvGetValueOf(HEAP32[$2 + 188 >> 2]);
    jsvUnLock(HEAP32[$2 + 188 >> 2]);
   }
   label$5: {
    if (!(HEAP32[$2 + 192 >> 2] != 158 & HEAP32[$2 + 192 >> 2] != 160)) {
     HEAP8[$2 + 187 | 0] = jsvGetBool(HEAP32[$2 + 204 >> 2]) & 1;
     label$8: {
      if (!(!(!(HEAP8[$2 + 187 | 0] & 1) & HEAP32[$2 + 192 >> 2] == 158) & (!(HEAP8[$2 + 187 | 0] & 1) | HEAP32[$2 + 192 >> 2] != 160))) {
       HEAP32[$2 + 180 >> 2] = HEAP32[91094];
       jspSetNoExecute();
       jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(), HEAP32[$2 + 196 >> 2]));
       HEAP32[91094] = HEAP32[91094] & -1664 | HEAP32[$2 + 180 >> 2] & 1663;
       break label$8;
      }
      jsvUnLock(HEAP32[$2 + 204 >> 2]);
      HEAP32[$2 + 204 >> 2] = __jspeBinaryExpression(jspeUnaryExpression(), HEAP32[$2 + 196 >> 2]);
     }
     break label$5;
    }
    label$12: {
     if (HEAP32[$2 + 192 >> 2] == 208) {
      if (jsvIsNullish(HEAP32[$2 + 204 >> 2]) & 1) {
       jsvUnLock(HEAP32[$2 + 204 >> 2]);
       HEAP32[$2 + 204 >> 2] = __jspeBinaryExpression(jspeUnaryExpression(), HEAP32[$2 + 196 >> 2]);
       break label$12;
      }
      HEAP32[$2 + 176 >> 2] = HEAP32[91094];
      jspSetNoExecute();
      jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(), HEAP32[$2 + 196 >> 2]));
      HEAP32[91094] = HEAP32[91094] & -1664 | HEAP32[$2 + 176 >> 2] & 1663;
      break label$12;
     }
     HEAP32[$2 + 172 >> 2] = __jspeBinaryExpression(jspeUnaryExpression(), HEAP32[$2 + 196 >> 2]);
     if ((HEAP32[91094] & 63) == 1) {
      label$16: {
       if (HEAP32[$2 + 192 >> 2] == 185) {
        HEAP32[$2 + 168 >> 2] = jsvSkipName(HEAP32[$2 + 172 >> 2]);
        label$18: {
         if (jsvHasChildren(HEAP32[$2 + 168 >> 2]) & 1) {
          HEAP32[$2 + 164 >> 2] = jsvAsArrayIndexAndUnLock(HEAP32[$2 + 204 >> 2]);
          HEAP32[$2 + 160 >> 2] = jspGetVarNamedField(HEAP32[$2 + 168 >> 2], HEAP32[$2 + 164 >> 2], 1);
          HEAP32[$2 + 204 >> 2] = jsvNewFromBool(HEAP32[$2 + 160 >> 2] != 0);
          jsvUnLock2(HEAP32[$2 + 164 >> 2], HEAP32[$2 + 160 >> 2]);
          break label$18;
         }
         HEAP32[$2 + 156 >> 2] = jswGetSymbolListForObjectProto(HEAP32[$2 + 168 >> 2]);
         label$20: {
          if (HEAP32[$2 + 156 >> 2]) {
           HEAP32[$2 + 152 >> 2] = 0;
           if (jsvGetString(HEAP32[$2 + 204 >> 2], $2 + 80 | 0, 64) >>> 0 < 64) {
            HEAP32[$2 + 152 >> 2] = jswBinarySearch(HEAP32[$2 + 156 >> 2], HEAP32[$2 + 168 >> 2], $2 + 80 | 0);
           }
           HEAP8[$2 + 79 | 0] = HEAP32[$2 + 152 >> 2] != 0;
           jsvUnLock(HEAP32[$2 + 152 >> 2]);
           label$23: {
            if (HEAP8[$2 + 79 | 0] & 1) {
             break label$23;
            }
            if (!(jsvIsArrayBuffer(HEAP32[$2 + 168 >> 2]) & 1)) {
             break label$23;
            }
            HEAPF64[$2 + 64 >> 3] = jsvGetFloat(HEAP32[$2 + 204 >> 2]);
            label$24: {
             if (!(HEAPF64[$2 + 64 >> 3] >= 0) | HEAPF64[$2 + 64 >> 3] != Math_floor(HEAPF64[$2 + 64 >> 3])) {
              break label$24;
             }
             if (!(HEAPF64[$2 + 64 >> 3] < +(jsvGetArrayBufferLength(HEAP32[$2 + 168 >> 2]) >>> 0))) {
              break label$24;
             }
             HEAP8[$2 + 79 | 0] = 1;
            }
           }
           jsvUnLock(HEAP32[$2 + 204 >> 2]);
           HEAP32[$2 + 204 >> 2] = jsvNewFromBool(HEAP8[$2 + 79 | 0] & 1);
           break label$20;
          }
          HEAP32[$2 >> 2] = HEAP32[$2 + 168 >> 2];
          jsExceptionHere(1, 119489, $2);
          jsvUnLock(HEAP32[$2 + 204 >> 2]);
          HEAP32[$2 + 204 >> 2] = 0;
         }
        }
        jsvUnLock(HEAP32[$2 + 168 >> 2]);
        break label$16;
       }
       label$25: {
        if (HEAP32[$2 + 192 >> 2] == 186) {
         HEAP8[$2 + 63 | 0] = 0;
         HEAP32[$2 + 56 >> 2] = jsvSkipName(HEAP32[$2 + 172 >> 2]);
         label$27: {
          if (!(jsvIsFunction(HEAP32[$2 + 56 >> 2]) & 1)) {
           HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 56 >> 2];
           jsExceptionHere(1, 119116, $2 + 16 | 0);
           break label$27;
          }
          label$29: {
           if (!(jsvIsObject(HEAP32[$2 + 204 >> 2]) & 1)) {
            if (!(jsvIsFunction(HEAP32[$2 + 204 >> 2]) & 1)) {
             break label$29;
            }
           }
           HEAP32[$2 + 52 >> 2] = jspGetNamedField(HEAP32[$2 + 56 >> 2], 132159, 0);
           HEAP32[$2 + 48 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 204 >> 2], 135865);
           while (1) {
            if (jsvHasChildren(HEAP32[$2 + 48 >> 2]) & 1) {
             if (HEAP32[$2 + 48 >> 2] == HEAP32[$2 + 52 >> 2]) {
              HEAP8[$2 + 63 | 0] = 1;
             }
             HEAP32[$2 + 44 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 48 >> 2], 135865);
             jsvUnLock(HEAP32[$2 + 48 >> 2]);
             HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 44 >> 2];
             continue;
            }
            break;
           }
           if (jspIsConstructor(HEAP32[$2 + 56 >> 2], 117903) & 1) {
            HEAP8[$2 + 63 | 0] = 1;
           }
           jsvUnLock2(HEAP32[$2 + 52 >> 2], HEAP32[$2 + 48 >> 2]);
          }
          if (!(HEAP8[$2 + 63 | 0] & 1)) {
           HEAP32[$2 + 40 >> 2] = jswGetBasicObjectName(HEAP32[$2 + 204 >> 2]);
           if (HEAP32[$2 + 40 >> 2]) {
            HEAP8[$2 + 63 | 0] = jspIsConstructor(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 40 >> 2]) & 1;
           }
           label$37: {
            if (HEAP8[$2 + 63 | 0] & 1) {
             break label$37;
            }
            if (!(jsvIsArray(HEAP32[$2 + 204 >> 2]) & 1)) {
             if (!(jsvIsArrayBuffer(HEAP32[$2 + 204 >> 2]) & 1)) {
              break label$37;
             }
            }
            if (!(jspIsConstructor(HEAP32[$2 + 56 >> 2], 117903) & 1)) {
             break label$37;
            }
            HEAP8[$2 + 63 | 0] = 1;
           }
          }
         }
         jsvUnLock2(HEAP32[$2 + 204 >> 2], HEAP32[$2 + 56 >> 2]);
         HEAP32[$2 + 204 >> 2] = jsvNewFromBool(HEAP8[$2 + 63 | 0] & 1);
         break label$25;
        }
        HEAP32[$2 + 36 >> 2] = jsvSkipName(HEAP32[$2 + 172 >> 2]);
        HEAP32[$2 + 32 >> 2] = jsvGetValueOf(HEAP32[$2 + 36 >> 2]);
        jsvUnLock(HEAP32[$2 + 36 >> 2]);
        HEAP32[$2 + 28 >> 2] = jsvMathsOp(HEAP32[$2 + 204 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 192 >> 2]);
        jsvUnLock2(HEAP32[$2 + 204 >> 2], HEAP32[$2 + 32 >> 2]);
        HEAP32[$2 + 204 >> 2] = HEAP32[$2 + 28 >> 2];
       }
      }
     }
     jsvUnLock(HEAP32[$2 + 172 >> 2]);
    }
   }
   HEAP32[$2 + 196 >> 2] = jspeGetBinaryExpressionPrecedence(HEAP16[HEAP32[49079] + 2 >> 1]);
   continue;
  }
  break;
 }
 __stack_pointer = $2 + 208 | 0;
 return HEAP32[$2 + 204 >> 2];
}

function jswrap_graphics_asImage($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 272 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 264 >> 2] = $0;
 HEAP32[$2 + 260 >> 2] = $1;
 label$1: {
  if (!(graphicsGetFromVar($2 + 184 | 0, HEAP32[$2 + 264 >> 2]) & 1)) {
   HEAP32[$2 + 268 >> 2] = 0;
   break label$1;
  }
  label$3: {
   label$4: {
    if (!(jsvIsUndefined(HEAP32[$2 + 260 >> 2]) & 1)) {
     if (!(jsvIsStringEqual(HEAP32[$2 + 260 >> 2], 117896) & 1)) {
      break label$4;
     }
    }
    HEAP8[$2 + 183 | 0] = 1;
    break label$3;
   }
   label$6: {
    if (jsvIsStringEqual(HEAP32[$2 + 260 >> 2], 129769) & 1) {
     HEAP8[$2 + 183 | 0] = 0;
     break label$6;
    }
    HEAP32[$2 >> 2] = HEAP32[$2 + 260 >> 2];
    jsExceptionHere(1, 129274, $2);
    HEAP32[$2 + 268 >> 2] = 0;
    break label$1;
   }
  }
  HEAP32[$2 + 176 >> 2] = jswrap_graphics_getWidthOrHeight(HEAP32[$2 + 264 >> 2], 0);
  HEAP32[$2 + 172 >> 2] = jswrap_graphics_getWidthOrHeight(HEAP32[$2 + 264 >> 2], 1);
  HEAP32[$2 + 168 >> 2] = HEAPU8[$2 + 200 | 0];
  HEAP32[$2 + 164 >> 2] = 1 << HEAP32[$2 + 168 >> 2];
  if ((HEAPU8[$2 + 188 | 0] | HEAPU8[$2 + 189 | 0] << 8 | (HEAPU8[$2 + 190 | 0] << 16 | HEAPU8[$2 + 191 | 0] << 24)) == 6) {
   HEAP32[$2 + 168 >> 2] = 3;
  }
  HEAP32[$2 + 160 >> 2] = Math_imul(HEAP32[$2 + 168 >> 2], Math_imul(HEAP32[$2 + 176 >> 2], HEAP32[$2 + 172 >> 2])) + 7 >> 3;
  HEAP32[$2 + 156 >> 2] = -1;
  HEAP32[$2 + 152 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 264 >> 2], 117520);
  if (HEAP32[$2 + 152 >> 2]) {
   HEAP32[$2 + 156 >> 2] = jsvGetIntegerAndUnLock(HEAP32[$2 + 152 >> 2]);
  }
  HEAP32[$2 + 148 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 264 >> 2], 131932);
  label$10: {
   if (jsvIsArray(HEAP32[$2 + 148 >> 2]) & 1) {
    break label$10;
   }
   if (jsvIsArrayBuffer(HEAP32[$2 + 148 >> 2]) & 1) {
    break label$10;
   }
   jsvUnLock(HEAP32[$2 + 148 >> 2]);
   HEAP32[$2 + 148 >> 2] = 0;
  }
  HEAP32[$2 + 144 >> 2] = 0;
  label$11: {
   if (HEAP8[$2 + 183 | 0] & 1) {
    HEAP32[$2 + 144 >> 2] = jsvNewObject();
    if (!HEAP32[$2 + 144 >> 2]) {
     HEAP32[$2 + 268 >> 2] = 0;
     break label$1;
    }
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 144 >> 2], 129398, jsvNewFromInteger(HEAP32[$2 + 176 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 144 >> 2], 117745, jsvNewFromInteger(HEAP32[$2 + 172 >> 2]));
    if (HEAP32[$2 + 168 >> 2] != 1) {
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 144 >> 2], 121714, jsvNewFromInteger(HEAP32[$2 + 168 >> 2]));
    }
    if (!(HEAPU8[$2 + 188 | 0] | HEAPU8[$2 + 189 | 0] << 8 | (HEAPU8[$2 + 190 | 0] << 16 | HEAPU8[$2 + 191 | 0] << 24) | (!((HEAPU8[$2 + 192 | 0] | HEAPU8[$2 + 193 | 0] << 8 | (HEAPU8[$2 + 194 | 0] << 16 | HEAPU8[$2 + 195 | 0] << 24)) & 4) | (HEAPU8[$2 + 192 | 0] | HEAPU8[$2 + 193 | 0] << 8 | (HEAPU8[$2 + 194 | 0] << 16 | HEAPU8[$2 + 195 | 0] << 24)) & 11 ? HEAP32[$2 + 168 >> 2] != 8 : 0))) {
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 144 >> 2], 121187, jsvObjectGetChildIfExists(HEAPU8[$2 + 184 | 0] | HEAPU8[$2 + 185 | 0] << 8 | (HEAPU8[$2 + 186 | 0] << 16 | HEAPU8[$2 + 187 | 0] << 24), 121187));
     HEAP32[$2 + 268 >> 2] = HEAP32[$2 + 144 >> 2];
     break label$1;
    }
    if (HEAP32[$2 + 156 >> 2] >= 0) {
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 144 >> 2], 117520, jsvNewFromInteger(HEAP32[$2 + 156 >> 2]));
    }
    if (HEAP32[$2 + 148 >> 2]) {
     jsvObjectSetChild(HEAP32[$2 + 144 >> 2], 131932, HEAP32[$2 + 148 >> 2]);
    }
    break label$11;
   }
   $1 = HEAP32[$2 + 160 >> 2];
   if (HEAP32[$2 + 148 >> 2]) {
    $0 = HEAP32[$2 + 164 >> 2] << 1;
   } else {
    $0 = 0;
   }
   HEAP32[$2 + 160 >> 2] = $1 + ($0 + ((HEAP32[$2 + 156 >> 2] >= 0) + 3 | 0) | 0);
  }
  HEAP32[$2 + 140 >> 2] = jsvNewStringOfLength(HEAP32[$2 + 160 >> 2], 0);
  if (!HEAP32[$2 + 140 >> 2]) {
   jsvUnLock(HEAP32[$2 + 144 >> 2]);
   HEAP32[$2 + 268 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 136 >> 2] = 0;
  HEAP32[$2 + 132 >> 2] = 0;
  HEAP32[$2 + 128 >> 2] = 0;
  HEAP32[$2 + 124 >> 2] = 0;
  jsvStringIteratorNew($2 + 88 | 0, HEAP32[$2 + 140 >> 2], 0);
  if (!(HEAP8[$2 + 183 | 0] & 1)) {
   jsvStringIteratorSetCharAndNext($2 + 88 | 0, HEAP32[$2 + 176 >> 2] << 24 >> 24);
   jsvStringIteratorSetCharAndNext($2 + 88 | 0, HEAP32[$2 + 172 >> 2] << 24 >> 24);
   jsvStringIteratorSetCharAndNext($2 + 88 | 0, ((HEAP32[$2 + 168 >> 2] | (HEAP32[$2 + 156 >> 2] >= 0 ? 128 : 0)) << 24 >> 24 | (HEAP32[$2 + 148 >> 2] ? 64 : 0)) << 24 >> 24);
   if (HEAP32[$2 + 156 >> 2] >= 0) {
    jsvStringIteratorSetCharAndNext($2 + 88 | 0, HEAP32[$2 + 156 >> 2] << 24 >> 24);
   }
   if (HEAP32[$2 + 148 >> 2]) {
    HEAP32[$2 + 20 >> 2] = 0;
    jsvIteratorNew($2 + 24 | 0, HEAP32[$2 + 148 >> 2], 1);
    while (1) {
     if (jsvIteratorHasElement($2 + 24 | 0) & 1) {
      HEAP32[$2 + 16 >> 2] = jsvIteratorGetIntegerValue($2 + 24 | 0);
      if (HEAP32[$2 + 20 >> 2] < HEAP32[$2 + 164 >> 2]) {
       jsvStringIteratorSetCharAndNext($2 + 88 | 0, HEAP32[$2 + 16 >> 2] << 24 >> 24);
       jsvStringIteratorSetCharAndNext($2 + 88 | 0, HEAP32[$2 + 16 >> 2] >> 8 << 24 >> 24);
      }
      jsvIteratorNext($2 + 24 | 0);
      HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] + 1;
      continue;
     }
     break;
    }
    jsvIteratorFree($2 + 24 | 0);
    while (1) {
     if (HEAP32[$2 + 20 >> 2] < HEAP32[$2 + 164 >> 2]) {
      jsvStringIteratorSetCharAndNext($2 + 88 | 0, 0);
      jsvStringIteratorSetCharAndNext($2 + 88 | 0, 0);
      HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] + 1;
      continue;
     }
     break;
    }
   }
  }
  while (1) {
   if (jsvStringIteratorHasChar_12($2 + 88 | 0) & 1) {
    HEAP32[$2 + 12 >> 2] = graphicsGetPixel($2 + 184 | 0, HEAP32[$2 + 136 >> 2], HEAP32[$2 + 132 >> 2]);
    if ((HEAPU8[$2 + 188 | 0] | HEAPU8[$2 + 189 | 0] << 8 | (HEAPU8[$2 + 190 | 0] << 16 | HEAPU8[$2 + 191 | 0] << 24)) == 6) {
     HEAP32[$2 + 12 >> 2] = !!(HEAP32[$2 + 12 >> 2] & 16) | ((HEAP32[$2 + 12 >> 2] & 32768 ? 4 : 0) | (HEAP32[$2 + 12 >> 2] & 1024 ? 2 : 0));
    }
    HEAP32[$2 + 128 >> 2] = HEAP32[$2 + 12 >> 2] | HEAP32[$2 + 128 >> 2] << HEAP32[$2 + 168 >> 2];
    HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 168 >> 2] + HEAP32[$2 + 124 >> 2];
    HEAP32[$2 + 136 >> 2] = HEAP32[$2 + 136 >> 2] + 1;
    if (HEAP32[$2 + 136 >> 2] >= HEAP32[$2 + 176 >> 2]) {
     HEAP32[$2 + 136 >> 2] = 0;
     HEAP32[$2 + 132 >> 2] = HEAP32[$2 + 132 >> 2] + 1;
    }
    while (1) {
     if (HEAPU32[$2 + 124 >> 2] >= 8) {
      jsvStringIteratorSetCharAndNext($2 + 88 | 0, HEAP32[$2 + 128 >> 2] >>> HEAP32[$2 + 124 >> 2] - 8 << 24 >> 24);
      HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 124 >> 2] - 8;
      continue;
     }
     break;
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree_16($2 + 88 | 0);
  jsvUnLock(HEAP32[$2 + 148 >> 2]);
  if (HEAP8[$2 + 183 | 0] & 1) {
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 144 >> 2], 121187, HEAP32[$2 + 140 >> 2]);
   HEAP32[$2 + 268 >> 2] = HEAP32[$2 + 144 >> 2];
   break label$1;
  }
  HEAP32[$2 + 268 >> 2] = HEAP32[$2 + 140 >> 2];
 }
 __stack_pointer = $2 + 272 | 0;
 return HEAP32[$2 + 268 >> 2];
}

function tflite__reference_ops__Conv_28tflite__ConvParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0, $12 = Math_fround(0);
 $11 = __stack_pointer - 176 | 0;
 __stack_pointer = $11;
 HEAP32[$11 + 172 >> 2] = $0;
 HEAP32[$11 + 168 >> 2] = $1;
 HEAP32[$11 + 164 >> 2] = $2;
 HEAP32[$11 + 160 >> 2] = $3;
 HEAP32[$11 + 156 >> 2] = $4;
 HEAP32[$11 + 152 >> 2] = $5;
 HEAP32[$11 + 148 >> 2] = $6;
 HEAP32[$11 + 144 >> 2] = $7;
 HEAP32[$11 + 140 >> 2] = $8;
 HEAP32[$11 + 136 >> 2] = $9;
 HEAP32[$11 + 132 >> 2] = $10;
 HEAP32[$11 + 128 >> 2] = HEAP16[HEAP32[$11 + 172 >> 2] + 10 >> 1];
 HEAP32[$11 + 124 >> 2] = HEAP16[HEAP32[$11 + 172 >> 2] + 12 >> 1];
 HEAP32[$11 + 120 >> 2] = HEAP16[HEAP32[$11 + 172 >> 2] + 14 >> 1];
 HEAP32[$11 + 116 >> 2] = HEAP16[HEAP32[$11 + 172 >> 2] + 16 >> 1];
 HEAP32[$11 + 112 >> 2] = HEAP16[HEAP32[$11 + 172 >> 2] + 2 >> 1];
 HEAP32[$11 + 108 >> 2] = HEAP16[HEAP32[$11 + 172 >> 2] + 4 >> 1];
 HEAPF32[$11 + 104 >> 2] = HEAPF32[HEAP32[$11 + 172 >> 2] + 48 >> 2];
 HEAPF32[$11 + 100 >> 2] = HEAPF32[HEAP32[$11 + 172 >> 2] + 52 >> 2];
 label$1: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 168 >> 2]) | 0) != 4) {
   break label$1;
  }
 }
 label$2: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 160 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$11 + 144 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 HEAP32[$11 + 96 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 168 >> 2], 0, HEAP32[$11 + 144 >> 2], 0);
 HEAP32[$11 + 92 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 168 >> 2], 3, HEAP32[$11 + 160 >> 2], 3);
 HEAP32[$11 + 88 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$11 + 160 >> 2], 0, HEAP32[$11 + 144 >> 2], 3);
 if (HEAP32[$11 + 148 >> 2]) {
  label$5: {
   if ((tflite__RuntimeShape__FlatSize_28_29_20const(HEAP32[$11 + 152 >> 2]) | 0) != HEAP32[$11 + 88 >> 2]) {
    break label$5;
   }
  }
 }
 HEAP32[$11 + 84 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 168 >> 2], 1);
 HEAP32[$11 + 80 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 168 >> 2], 2);
 HEAP32[$11 + 76 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 160 >> 2], 1);
 HEAP32[$11 + 72 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 160 >> 2], 2);
 HEAP32[$11 + 68 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 144 >> 2], 1);
 HEAP32[$11 + 64 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$11 + 144 >> 2], 2);
 HEAP32[$11 + 60 >> 2] = 0;
 while (1) {
  if (HEAP32[$11 + 60 >> 2] < HEAP32[$11 + 96 >> 2]) {
   HEAP32[$11 + 56 >> 2] = 0;
   while (1) {
    if (HEAP32[$11 + 56 >> 2] < HEAP32[$11 + 68 >> 2]) {
     HEAP32[$11 + 52 >> 2] = 0;
     while (1) {
      if (HEAP32[$11 + 52 >> 2] < HEAP32[$11 + 64 >> 2]) {
       HEAP32[$11 + 48 >> 2] = 0;
       while (1) {
        if (HEAP32[$11 + 48 >> 2] < HEAP32[$11 + 88 >> 2]) {
         HEAP32[$11 + 44 >> 2] = Math_imul(HEAP32[$11 + 52 >> 2], HEAP32[$11 + 128 >> 2]) - HEAP32[$11 + 112 >> 2];
         HEAP32[$11 + 40 >> 2] = Math_imul(HEAP32[$11 + 56 >> 2], HEAP32[$11 + 124 >> 2]) - HEAP32[$11 + 108 >> 2];
         HEAPF32[$11 + 36 >> 2] = 0;
         HEAP32[$11 + 32 >> 2] = 0;
         while (1) {
          if (HEAP32[$11 + 32 >> 2] < HEAP32[$11 + 76 >> 2]) {
           HEAP32[$11 + 28 >> 2] = 0;
           while (1) {
            if (HEAP32[$11 + 28 >> 2] < HEAP32[$11 + 72 >> 2]) {
             HEAP32[$11 + 24 >> 2] = 0;
             while (1) {
              if (HEAP32[$11 + 24 >> 2] < HEAP32[$11 + 92 >> 2]) {
               HEAP32[$11 + 20 >> 2] = HEAP32[$11 + 44 >> 2] + Math_imul(HEAP32[$11 + 120 >> 2], HEAP32[$11 + 28 >> 2]);
               HEAP32[$11 + 16 >> 2] = HEAP32[$11 + 40 >> 2] + Math_imul(HEAP32[$11 + 116 >> 2], HEAP32[$11 + 32 >> 2]);
               if (!(HEAP32[$11 + 20 >> 2] < 0 | HEAP32[$11 + 20 >> 2] >= HEAP32[$11 + 80 >> 2] | (HEAP32[$11 + 16 >> 2] < 0 | HEAP32[$11 + 16 >> 2] >= HEAP32[$11 + 84 >> 2]))) {
                HEAPF32[$11 + 12 >> 2] = HEAPF32[HEAP32[$11 + 164 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 168 >> 2], HEAP32[$11 + 60 >> 2], HEAP32[$11 + 16 >> 2], HEAP32[$11 + 20 >> 2], HEAP32[$11 + 24 >> 2]) << 2) >> 2];
                HEAPF32[$11 + 8 >> 2] = HEAPF32[HEAP32[$11 + 156 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 160 >> 2], HEAP32[$11 + 48 >> 2], HEAP32[$11 + 32 >> 2], HEAP32[$11 + 28 >> 2], HEAP32[$11 + 24 >> 2]) << 2) >> 2];
                HEAPF32[$11 + 36 >> 2] = Math_fround(HEAPF32[$11 + 12 >> 2] * HEAPF32[$11 + 8 >> 2]) + HEAPF32[$11 + 36 >> 2];
               }
               HEAP32[$11 + 24 >> 2] = HEAP32[$11 + 24 >> 2] + 1;
               continue;
              }
              break;
             }
             HEAP32[$11 + 28 >> 2] = HEAP32[$11 + 28 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$11 + 32 >> 2] = HEAP32[$11 + 32 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAPF32[$11 + 4 >> 2] = 0;
         if (HEAP32[$11 + 148 >> 2]) {
          HEAPF32[$11 + 4 >> 2] = HEAPF32[HEAP32[$11 + 148 >> 2] + (HEAP32[$11 + 48 >> 2] << 2) >> 2];
         }
         $12 = float_20tflite__ActivationFunctionWithMinMax_float__28float_2c_20float_2c_20float_29(Math_fround(HEAPF32[$11 + 36 >> 2] + HEAPF32[$11 + 4 >> 2]), HEAPF32[$11 + 104 >> 2], HEAPF32[$11 + 100 >> 2]);
         HEAPF32[HEAP32[$11 + 140 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$11 + 144 >> 2], HEAP32[$11 + 60 >> 2], HEAP32[$11 + 56 >> 2], HEAP32[$11 + 52 >> 2], HEAP32[$11 + 48 >> 2]) << 2) >> 2] = $12;
         HEAP32[$11 + 48 >> 2] = HEAP32[$11 + 48 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$11 + 52 >> 2] = HEAP32[$11 + 52 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$11 + 56 >> 2] = HEAP32[$11 + 56 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$11 + 60 >> 2] = HEAP32[$11 + 60 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $11 + 176 | 0;
}

function _jswrap_string_replace($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 240 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 232 >> 2] = $0;
 HEAP32[$4 + 228 >> 2] = $1;
 HEAP32[$4 + 224 >> 2] = $2;
 HEAP8[$4 + 223 | 0] = $3;
 HEAP32[$4 + 216 >> 2] = jsvAsString(HEAP32[$4 + 232 >> 2]);
 label$1: {
  if (jsvIsInstanceOf(HEAP32[$4 + 228 >> 2], 121677) & 1) {
   label$3: {
    label$4: {
     if (!(jsvIsFunction(HEAP32[$4 + 224 >> 2]) & 1)) {
      if (!(jsvIsString(HEAP32[$4 + 224 >> 2]) & 1)) {
       break label$4;
      }
     }
     HEAP32[$4 + 212 >> 2] = jsvLockAgain(HEAP32[$4 + 224 >> 2]);
     break label$3;
    }
    HEAP32[$4 + 212 >> 2] = jsvAsString(HEAP32[$4 + 224 >> 2]);
   }
   jsvObjectSetChildAndUnLock(HEAP32[$4 + 228 >> 2], 116445, jsvNewFromInteger(0));
   HEAP8[$4 + 211 | 0] = jswrap_regexp_hasFlag(HEAP32[$4 + 228 >> 2], 103) & 1;
   if (HEAP8[$4 + 223 | 0] & 1) {
    HEAP8[$4 + 211 | 0] = 1;
   }
   HEAP32[$4 + 204 >> 2] = jsvNewFromEmptyString_8();
   jsvStringIteratorNew($4 + 168 | 0, HEAP32[$4 + 204 >> 2], 0);
   HEAP32[$4 + 164 >> 2] = 0;
   HEAP32[$4 + 160 >> 2] = jswrap_regexp_exec(HEAP32[$4 + 228 >> 2], HEAP32[$4 + 216 >> 2]);
   while (1) {
    $0 = 0;
    label$8: {
     if (!HEAP32[$4 + 160 >> 2]) {
      break label$8;
     }
     $0 = 0;
     if (jsvIsNull(HEAP32[$4 + 160 >> 2]) & 1) {
      break label$8;
     }
     $0 = jspIsInterrupted() ^ -1;
    }
    if ($0 & 1) {
     HEAP32[$4 + 156 >> 2] = jsvGetArrayItem(HEAP32[$4 + 160 >> 2], 0);
     HEAP32[$4 + 152 >> 2] = jsvObjectGetIntegerChild(HEAP32[$4 + 160 >> 2], 116439);
     HEAP32[$4 + 148 >> 2] = jsvGetStringLength(HEAP32[$4 + 156 >> 2]);
     jsvStringIteratorAppendString($4 + 168 | 0, HEAP32[$4 + 216 >> 2], HEAP32[$4 + 164 >> 2], HEAP32[$4 + 152 >> 2] - HEAP32[$4 + 164 >> 2] | 0);
     label$10: {
      if (jsvIsFunction(HEAP32[$4 + 212 >> 2]) & 1) {
       HEAP32[$4 + 144 >> 2] = 0;
       $1 = jsvLockAgain(HEAP32[$4 + 156 >> 2]);
       $0 = HEAP32[$4 + 144 >> 2];
       HEAP32[$4 + 144 >> 2] = $0 + 1;
       HEAP32[($4 + 80 | 0) + ($0 << 2) >> 2] = $1;
       while (1) {
        $1 = jsvGetArrayItem(HEAP32[$4 + 160 >> 2], HEAP32[$4 + 144 >> 2]);
        HEAP32[$4 + 76 >> 2] = $1;
        $0 = 0;
        $0 = $1 ? HEAPU32[$4 + 144 >> 2] < 11 : $0;
        if ($0) {
         $1 = HEAP32[$4 + 76 >> 2];
         $0 = HEAP32[$4 + 144 >> 2];
         HEAP32[$4 + 144 >> 2] = $0 + 1;
         HEAP32[($4 + 80 | 0) + ($0 << 2) >> 2] = $1;
         continue;
        }
        break;
       }
       $1 = jsvObjectGetChildIfExists(HEAP32[$4 + 160 >> 2], 116439);
       $0 = HEAP32[$4 + 144 >> 2];
       HEAP32[$4 + 144 >> 2] = $0 + 1;
       HEAP32[($4 + 80 | 0) + ($0 << 2) >> 2] = $1;
       $1 = jsvObjectGetChildIfExists(HEAP32[$4 + 160 >> 2], 117136);
       $0 = HEAP32[$4 + 144 >> 2];
       HEAP32[$4 + 144 >> 2] = $0 + 1;
       HEAP32[($4 + 80 | 0) + ($0 << 2) >> 2] = $1;
       HEAP32[$4 + 72 >> 2] = jsvAsStringAndUnLock(jspeFunctionCall(HEAP32[$4 + 212 >> 2], 0, 0, 0, HEAP32[$4 + 144 >> 2], $4 + 80 | 0));
       jsvUnLockMany(HEAP32[$4 + 144 >> 2], $4 + 80 | 0);
       jsvStringIteratorAppendString($4 + 168 | 0, HEAP32[$4 + 72 >> 2], 0, 2147483647);
       jsvUnLock(HEAP32[$4 + 72 >> 2]);
       break label$10;
      }
      jsvStringIteratorNew($4 + 32 | 0, HEAP32[$4 + 212 >> 2], 0);
      while (1) {
       if (jsvStringIteratorHasChar_8($4 + 32 | 0) & 1) {
        HEAP8[$4 + 31 | 0] = jsvStringIteratorGetCharAndNext($4 + 32 | 0);
        label$17: {
         if (HEAP8[$4 + 31 | 0] == 36) {
          HEAP8[$4 + 31 | 0] = jsvStringIteratorGetCharAndNext($4 + 32 | 0);
          HEAP32[$4 + 24 >> 2] = 0;
          if (!(HEAP8[$4 + 31 | 0] <= 48 | HEAP8[$4 + 31 | 0] > 57)) {
           HEAP32[$4 + 24 >> 2] = jsvGetArrayItem(HEAP32[$4 + 160 >> 2], HEAP8[$4 + 31 | 0] - 48 | 0);
          }
          label$20: {
           if (HEAP32[$4 + 24 >> 2]) {
            jsvStringIteratorAppendString($4 + 168 | 0, HEAP32[$4 + 24 >> 2], 0, 2147483647);
            jsvUnLock(HEAP32[$4 + 24 >> 2]);
            break label$20;
           }
           jsvStringIteratorAppend($4 + 168 | 0, 36);
           jsvStringIteratorAppend($4 + 168 | 0, HEAP8[$4 + 31 | 0]);
          }
          break label$17;
         }
         jsvStringIteratorAppend($4 + 168 | 0, HEAP8[$4 + 31 | 0]);
        }
        continue;
       }
       break;
      }
      jsvStringIteratorFree_10($4 + 32 | 0);
     }
     HEAP32[$4 + 164 >> 2] = HEAP32[$4 + 152 >> 2] + HEAP32[$4 + 148 >> 2];
     jsvUnLock(HEAP32[$4 + 156 >> 2]);
     jsvUnLock(HEAP32[$4 + 160 >> 2]);
     HEAP32[$4 + 160 >> 2] = 0;
     if (HEAP8[$4 + 211 | 0] & 1) {
      jsvObjectSetChildAndUnLock(HEAP32[$4 + 228 >> 2], 116445, jsvNewFromInteger(HEAP32[$4 + 164 >> 2] + !HEAP32[$4 + 148 >> 2] | 0));
      HEAP32[$4 + 160 >> 2] = jswrap_regexp_exec(HEAP32[$4 + 228 >> 2], HEAP32[$4 + 216 >> 2]);
     }
     continue;
    }
    break;
   }
   jsvStringIteratorAppendString($4 + 168 | 0, HEAP32[$4 + 216 >> 2], HEAP32[$4 + 164 >> 2], 2147483647);
   jsvStringIteratorFree_10($4 + 168 | 0);
   jsvUnLock3(HEAP32[$4 + 160 >> 2], HEAP32[$4 + 212 >> 2], HEAP32[$4 + 216 >> 2]);
   if (HEAP8[$4 + 211 | 0] & 1) {
    jsvObjectSetChildAndUnLock(HEAP32[$4 + 228 >> 2], 116445, jsvNewFromInteger(0));
   }
   HEAP32[$4 + 236 >> 2] = HEAP32[$4 + 204 >> 2];
   break label$1;
  }
  HEAP32[$4 + 224 >> 2] = jsvAsString(HEAP32[$4 + 224 >> 2]);
  HEAP32[$4 + 228 >> 2] = jsvAsString(HEAP32[$4 + 228 >> 2]);
  HEAP32[$4 + 20 >> 2] = jswrap_string_indexOf(HEAP32[$4 + 216 >> 2], HEAP32[$4 + 228 >> 2], 0, 0);
  while (1) {
   $0 = 0;
   if (HEAP32[$4 + 20 >> 2] >= 0) {
    $0 = jspIsInterrupted() ^ -1;
   }
   if ($0 & 1) {
    HEAP32[$4 + 16 >> 2] = jsvNewWritableStringFromStringVar(HEAP32[$4 + 216 >> 2], 0, HEAP32[$4 + 20 >> 2]);
    jsvAppendStringVarComplete(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 224 >> 2]);
    jsvAppendStringVar(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 216 >> 2], HEAP32[$4 + 20 >> 2] + jsvGetStringLength(HEAP32[$4 + 228 >> 2]) | 0, 2147483647);
    jsvUnLock(HEAP32[$4 + 216 >> 2]);
    HEAP32[$4 + 216 >> 2] = HEAP32[$4 + 16 >> 2];
    label$27: {
     if (HEAP8[$4 + 223 | 0] & 1) {
      HEAP32[$4 + 12 >> 2] = jsvNewFromInteger(HEAP32[$4 + 20 >> 2] + jsvGetStringLength(HEAP32[$4 + 224 >> 2]) | 0);
      HEAP32[$4 + 20 >> 2] = jswrap_string_indexOf(HEAP32[$4 + 216 >> 2], HEAP32[$4 + 228 >> 2], HEAP32[$4 + 12 >> 2], 0);
      jsvUnLock(HEAP32[$4 + 12 >> 2]);
      break label$27;
     }
     HEAP32[$4 + 20 >> 2] = -1;
    }
    continue;
   }
   break;
  }
  jsvUnLock2(HEAP32[$4 + 228 >> 2], HEAP32[$4 + 224 >> 2]);
  HEAP32[$4 + 236 >> 2] = HEAP32[$4 + 216 >> 2];
 }
 __stack_pointer = $4 + 240 | 0;
 return HEAP32[$4 + 236 >> 2];
}

function tflite__PopulateConvolutionQuantizationParams_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20TfLiteFusedActivation_20const__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int_29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12) {
 var $13 = 0, $14 = Math_fround(0);
 $13 = __stack_pointer - 256 | 0;
 __stack_pointer = $13;
 HEAP32[$13 + 248 >> 2] = $0;
 HEAP32[$13 + 244 >> 2] = $1;
 HEAP32[$13 + 240 >> 2] = $2;
 HEAP32[$13 + 236 >> 2] = $3;
 HEAP32[$13 + 232 >> 2] = $4;
 HEAP32[$13 + 228 >> 2] = $5;
 HEAP32[$13 + 224 >> 2] = $6;
 HEAP32[$13 + 220 >> 2] = $7;
 HEAP32[$13 + 216 >> 2] = $8;
 HEAP32[$13 + 212 >> 2] = $9;
 HEAP32[$13 + 208 >> 2] = $10;
 HEAP32[$13 + 204 >> 2] = $11;
 HEAP32[$13 + 200 >> 2] = $12;
 label$1: {
  if (HEAP32[HEAP32[$13 + 244 >> 2] >> 2] != 1) {
   $0 = HEAP32[HEAP32[$13 + 248 >> 2] + 20 >> 2];
   $1 = HEAP32[$13 + 248 >> 2];
   $2 = HEAP32[HEAP32[$13 + 244 >> 2] >> 2];
   HEAP32[$13 + 12 >> 2] = 1;
   HEAP32[$13 + 8 >> 2] = $2;
   HEAP32[$13 + 4 >> 2] = 128383;
   HEAP32[$13 >> 2] = 132279;
   FUNCTION_TABLE[$0 | 0]($1, 143305, $13);
   HEAP32[$13 + 252 >> 2] = 1;
   break label$1;
  }
  if (HEAP32[HEAP32[$13 + 240 >> 2] >> 2] != 1) {
   $0 = HEAP32[HEAP32[$13 + 248 >> 2] + 20 >> 2];
   $1 = HEAP32[$13 + 248 >> 2];
   $2 = HEAP32[HEAP32[$13 + 240 >> 2] >> 2];
   HEAP32[$13 + 28 >> 2] = 1;
   HEAP32[$13 + 24 >> 2] = $2;
   HEAP32[$13 + 20 >> 2] = 128383;
   HEAP32[$13 + 16 >> 2] = 132304;
   FUNCTION_TABLE[$0 | 0]($1, 143305, $13 + 16 | 0);
   HEAP32[$13 + 252 >> 2] = 1;
   break label$1;
  }
  HEAP32[$13 + 196 >> 2] = HEAP32[HEAP32[$13 + 240 >> 2] + 4 >> 2];
  if (!HEAP32[$13 + 196 >> 2]) {
   $0 = HEAP32[HEAP32[$13 + 248 >> 2] + 20 >> 2];
   $1 = HEAP32[$13 + 248 >> 2];
   HEAP32[$13 + 112 >> 2] = 128363;
   FUNCTION_TABLE[$0 | 0]($1, 140586, $13 + 112 | 0);
   HEAP32[$13 + 252 >> 2] = 1;
   break label$1;
  }
  if (!HEAP32[HEAP32[$13 + 196 >> 2] >> 2]) {
   $0 = HEAP32[HEAP32[$13 + 248 >> 2] + 20 >> 2];
   $1 = HEAP32[$13 + 248 >> 2];
   HEAP32[$13 + 96 >> 2] = 132598;
   FUNCTION_TABLE[$0 | 0]($1, 140586, $13 + 96 | 0);
   HEAP32[$13 + 252 >> 2] = 1;
   break label$1;
  }
  HEAP8[$13 + 195 | 0] = HEAP32[HEAP32[HEAP32[$13 + 196 >> 2] >> 2] >> 2] > 1;
  if (HEAP8[$13 + 195 | 0] & 1) {
   if (!(HEAP32[HEAP32[$13 + 244 >> 2] + 28 >> 2] == 9 | HEAP32[HEAP32[$13 + 244 >> 2] + 28 >> 2] == 7)) {
    $0 = HEAP32[HEAP32[$13 + 248 >> 2] + 20 >> 2];
    $1 = HEAP32[$13 + 248 >> 2];
    HEAP32[$13 + 80 >> 2] = 139341;
    FUNCTION_TABLE[$0 | 0]($1, 140586, $13 + 80 | 0);
    HEAP32[$13 + 252 >> 2] = 1;
    break label$1;
   }
   if (HEAP32[HEAP32[$13 + 240 >> 2] + 28 >> 2] != 9) {
    $0 = HEAP32[HEAP32[$13 + 248 >> 2] + 20 >> 2];
    $1 = HEAP32[$13 + 248 >> 2];
    $2 = HEAP32[HEAP32[$13 + 240 >> 2] + 28 >> 2];
    HEAP32[$13 + 44 >> 2] = 9;
    HEAP32[$13 + 40 >> 2] = $2;
    HEAP32[$13 + 36 >> 2] = 139120;
    HEAP32[$13 + 32 >> 2] = 132240;
    FUNCTION_TABLE[$0 | 0]($1, 143305, $13 + 32 | 0);
    HEAP32[$13 + 252 >> 2] = 1;
    break label$1;
   }
   if (HEAP32[HEAP32[HEAP32[$13 + 196 >> 2] >> 2] >> 2] != HEAP32[$13 + 200 >> 2]) {
    $0 = HEAP32[HEAP32[$13 + 248 >> 2] + 20 >> 2];
    $1 = HEAP32[$13 + 248 >> 2];
    $2 = HEAP32[HEAP32[HEAP32[$13 + 196 >> 2] >> 2] >> 2];
    HEAP32[$13 + 60 >> 2] = HEAP32[$13 + 200 >> 2];
    HEAP32[$13 + 56 >> 2] = $2;
    HEAP32[$13 + 52 >> 2] = 120136;
    HEAP32[$13 + 48 >> 2] = 131592;
    FUNCTION_TABLE[$0 | 0]($1, 143305, $13 + 48 | 0);
    HEAP32[$13 + 252 >> 2] = 1;
    break label$1;
   }
   if (HEAP32[$13 + 200 >> 2] != HEAP32[(HEAP32[HEAP32[$13 + 240 >> 2] + 20 >> 2] + 4 | 0) + (HEAP32[HEAP32[$13 + 196 >> 2] + 8 >> 2] << 2) >> 2]) {
    $0 = HEAP32[HEAP32[$13 + 248 >> 2] + 20 >> 2];
    $1 = HEAP32[$13 + 248 >> 2];
    $2 = HEAP32[$13 + 200 >> 2];
    HEAP32[$13 + 76 >> 2] = HEAP32[(HEAP32[HEAP32[$13 + 240 >> 2] + 20 >> 2] + 4 | 0) + (HEAP32[HEAP32[$13 + 196 >> 2] + 8 >> 2] << 2) >> 2];
    HEAP32[$13 + 72 >> 2] = $2;
    HEAP32[$13 + 68 >> 2] = 135907;
    HEAP32[$13 + 64 >> 2] = 120136;
    FUNCTION_TABLE[$0 | 0]($1, 143305, $13 - -64 | 0);
    HEAP32[$13 + 252 >> 2] = 1;
    break label$1;
   }
  }
  HEAPF32[$13 + 188 >> 2] = HEAPF32[HEAP32[$13 + 244 >> 2] + 8 >> 2];
  HEAPF32[$13 + 184 >> 2] = HEAPF32[HEAP32[$13 + 232 >> 2] + 8 >> 2];
  HEAP32[$13 + 180 >> 2] = HEAP32[HEAP32[$13 + 196 >> 2] >> 2] + 4;
  HEAP32[$13 + 176 >> 2] = 0;
  while (1) {
   if (HEAP32[$13 + 176 >> 2] < HEAP32[$13 + 200 >> 2]) {
    if (HEAP8[$13 + 195 | 0] & 1) {
     $14 = HEAPF32[HEAP32[$13 + 180 >> 2] + (HEAP32[$13 + 176 >> 2] << 2) >> 2];
    } else {
     $14 = HEAPF32[HEAP32[$13 + 180 >> 2] >> 2];
    }
    HEAPF32[$13 + 172 >> 2] = $14;
    HEAPF64[$13 + 160 >> 3] = HEAPF32[$13 + 172 >> 2];
    HEAPF64[$13 + 152 >> 3] = +HEAPF32[$13 + 188 >> 2] * HEAPF64[$13 + 160 >> 3] / +HEAPF32[$13 + 184 >> 2];
    tflite__QuantizeMultiplier_28double_2c_20int__2c_20int__29(HEAPF64[$13 + 152 >> 3], $13 + 148 | 0, $13 + 144 | 0);
    HEAP32[HEAP32[$13 + 208 >> 2] + (HEAP32[$13 + 176 >> 2] << 2) >> 2] = HEAP32[$13 + 148 >> 2];
    HEAP32[HEAP32[$13 + 204 >> 2] + (HEAP32[$13 + 176 >> 2] << 2) >> 2] = HEAP32[$13 + 144 >> 2];
    HEAP32[$13 + 176 >> 2] = HEAP32[$13 + 176 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[HEAP32[$13 + 244 >> 2] + 28 >> 2] == 3) {
   HEAPF64[$13 + 136 >> 3] = 0;
   HEAP32[$13 + 132 >> 2] = tflite__GetQuantizedConvolutionMultipler_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20double__29(HEAP32[$13 + 248 >> 2], HEAP32[$13 + 244 >> 2], HEAP32[$13 + 240 >> 2], HEAP32[$13 + 236 >> 2], HEAP32[$13 + 232 >> 2], $13 + 136 | 0);
   if (HEAP32[$13 + 132 >> 2]) {
    HEAP32[$13 + 252 >> 2] = HEAP32[$13 + 132 >> 2];
    break label$1;
   }
   tflite__QuantizeMultiplier_28double_2c_20int__2c_20int__29(HEAPF64[$13 + 136 >> 3], HEAP32[$13 + 224 >> 2], $13 + 128 | 0);
   HEAP32[HEAP32[$13 + 220 >> 2] >> 2] = 0 - HEAP32[$13 + 128 >> 2];
  }
  if (!(!(HEAP32[HEAP32[$13 + 244 >> 2] + 28 >> 2] == 9 | HEAP32[HEAP32[$13 + 244 >> 2] + 28 >> 2] == 3) & HEAP32[HEAP32[$13 + 244 >> 2] + 28 >> 2] != 7)) {
   HEAP32[$13 + 124 >> 2] = tflite__CalculateActivationRangeQuantized_28TfLiteContext__2c_20TfLiteFusedActivation_2c_20TfLiteTensor__2c_20int__2c_20int__29(HEAP32[$13 + 248 >> 2], HEAP32[HEAP32[$13 + 228 >> 2] >> 2], HEAP32[$13 + 232 >> 2], HEAP32[$13 + 216 >> 2], HEAP32[$13 + 212 >> 2]);
   if (HEAP32[$13 + 124 >> 2]) {
    HEAP32[$13 + 252 >> 2] = HEAP32[$13 + 124 >> 2];
    break label$1;
   }
  }
  HEAP32[$13 + 252 >> 2] = 0;
 }
 __stack_pointer = $13 + 256 | 0;
 return HEAP32[$13 + 252 >> 2];
}

function tflite__ops__micro__dequantize__Eval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 272 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 264 >> 2] = $0;
 HEAP32[$2 + 260 >> 2] = $1;
 label$1: {
  if (!HEAP32[HEAP32[$2 + 260 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 256 >> 2] = HEAP32[HEAP32[$2 + 260 >> 2] + 8 >> 2];
 HEAP32[$2 + 252 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 264 >> 2], HEAP32[$2 + 260 >> 2], 0);
 HEAP32[$2 + 248 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 264 >> 2], HEAP32[$2 + 260 >> 2], 0);
 label$2: {
  label$3: {
   if (HEAP32[HEAP32[$2 + 248 >> 2] + 8 >> 2] == 1) {
    label$5: {
     switch (HEAP32[HEAP32[$2 + 252 >> 2] + 8 >> 2] - 3 | 0) {
     case 0:
      $0 = HEAP32[$2 + 256 >> 2];
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 224 | 0, HEAP32[$2 + 252 >> 2]);
      $1 = unsigned_20char_20const__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 252 >> 2]);
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 200 | 0, HEAP32[$2 + 248 >> 2]);
      void_20tflite__reference_ops__Dequantize_unsigned_20char_2c_20float__28tflite__DequantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $2 + 224 | 0, $1, $2 + 200 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$2 + 248 >> 2]));
      tflite__RuntimeShape___RuntimeShape_28_29($2 + 200 | 0);
      tflite__RuntimeShape___RuntimeShape_28_29($2 + 224 | 0);
      break label$3;

     case 6:
      $0 = HEAP32[$2 + 256 >> 2];
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 176 | 0, HEAP32[$2 + 252 >> 2]);
      $1 = signed_20char_20const__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 252 >> 2]);
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 152 | 0, HEAP32[$2 + 248 >> 2]);
      void_20tflite__reference_ops__Dequantize_signed_20char_2c_20float__28tflite__DequantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $2 + 176 | 0, $1, $2 + 152 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$2 + 248 >> 2]));
      tflite__RuntimeShape___RuntimeShape_28_29($2 + 152 | 0);
      tflite__RuntimeShape___RuntimeShape_28_29($2 + 176 | 0);
      break label$3;

     case 4:
      $0 = HEAP32[$2 + 256 >> 2];
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 128 | 0, HEAP32[$2 + 252 >> 2]);
      $1 = short_20const__20tflite__micro__GetTensorData_short__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 252 >> 2]);
      tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 104 | 0, HEAP32[$2 + 248 >> 2]);
      void_20tflite__reference_ops__Dequantize_short_2c_20float__28tflite__DequantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20short_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $2 + 128 | 0, $1, $2 + 104 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$2 + 248 >> 2]));
      tflite__RuntimeShape___RuntimeShape_28_29($2 + 104 | 0);
      tflite__RuntimeShape___RuntimeShape_28_29($2 + 128 | 0);
      break label$3;

     default:
      break label$5;
     }
    }
    $0 = HEAP32[HEAP32[$2 + 264 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 264 >> 2];
    $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 252 >> 2] + 8 >> 2]);
    HEAP32[$2 + 4 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 248 >> 2] + 8 >> 2]);
    HEAP32[$2 >> 2] = $3;
    FUNCTION_TABLE[$0 | 0]($1, 140784, $2);
    HEAP32[$2 + 268 >> 2] = 1;
    break label$2;
   }
   label$9: {
    if (HEAP32[HEAP32[$2 + 248 >> 2] + 8 >> 2] == 2) {
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 72 | 0, HEAP32[$2 + 252 >> 2]);
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($2 + 48 | 0, HEAP32[$2 + 248 >> 2]);
     $0 = tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29($2 + 72 | 0, $2 + 48 | 0);
     tflite__RuntimeShape___RuntimeShape_28_29($2 + 48 | 0);
     tflite__RuntimeShape___RuntimeShape_28_29($2 + 72 | 0);
     HEAP32[$2 + 100 >> 2] = $0;
     label$11: {
      label$12: {
       switch (HEAP32[HEAP32[$2 + 252 >> 2] + 8 >> 2] - 7 | 0) {
       case 0:
        void_20tflite__reference_ops__Requantize_short_2c_20int__28short_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int__29(short_20const__20tflite__micro__GetTensorData_short__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 252 >> 2]), HEAP32[$2 + 100 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 16 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 20 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 8 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 24 >> 2], int__20tflite__micro__GetTensorData_int__28TfLiteEvalTensor__29(HEAP32[$2 + 248 >> 2]));
        break label$11;

       case 2:
        void_20tflite__reference_ops__Requantize_signed_20char_2c_20int__28signed_20char_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int__29(signed_20char_20const__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor_20const__29(HEAP32[$2 + 252 >> 2]), HEAP32[$2 + 100 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 16 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 20 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 8 >> 2], HEAP32[HEAP32[$2 + 256 >> 2] + 24 >> 2], int__20tflite__micro__GetTensorData_int__28TfLiteEvalTensor__29(HEAP32[$2 + 248 >> 2]));
        break label$11;

       default:
        break label$12;
       }
      }
      $0 = HEAP32[HEAP32[$2 + 264 >> 2] + 20 >> 2];
      $1 = HEAP32[$2 + 264 >> 2];
      $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 252 >> 2] + 8 >> 2]);
      HEAP32[$2 + 20 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 248 >> 2] + 8 >> 2]);
      HEAP32[$2 + 16 >> 2] = $3;
      FUNCTION_TABLE[$0 | 0]($1, 140784, $2 + 16 | 0);
      HEAP32[$2 + 268 >> 2] = 1;
      break label$2;
     }
     break label$9;
    }
    $0 = HEAP32[HEAP32[$2 + 264 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 264 >> 2];
    $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 252 >> 2] + 8 >> 2]);
    HEAP32[$2 + 36 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 248 >> 2] + 8 >> 2]);
    HEAP32[$2 + 32 >> 2] = $3;
    FUNCTION_TABLE[$0 | 0]($1, 140784, $2 + 32 | 0);
    HEAP32[$2 + 268 >> 2] = 1;
    break label$2;
   }
  }
  HEAP32[$2 + 268 >> 2] = 0;
 }
 __stack_pointer = $2 + 272 | 0;
 return HEAP32[$2 + 268 >> 2];
}

function tflite__reference_ops__DepthwiseConv_28tflite__DepthwiseParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = Math_fround(0);
 $9 = __stack_pointer - 176 | 0;
 __stack_pointer = $9;
 HEAP32[$9 + 172 >> 2] = $0;
 HEAP32[$9 + 168 >> 2] = $1;
 HEAP32[$9 + 164 >> 2] = $2;
 HEAP32[$9 + 160 >> 2] = $3;
 HEAP32[$9 + 156 >> 2] = $4;
 HEAP32[$9 + 152 >> 2] = $5;
 HEAP32[$9 + 148 >> 2] = $6;
 HEAP32[$9 + 144 >> 2] = $7;
 HEAP32[$9 + 140 >> 2] = $8;
 HEAP32[$9 + 136 >> 2] = HEAP16[HEAP32[$9 + 172 >> 2] + 10 >> 1];
 HEAP32[$9 + 132 >> 2] = HEAP16[HEAP32[$9 + 172 >> 2] + 12 >> 1];
 HEAP32[$9 + 128 >> 2] = HEAP16[HEAP32[$9 + 172 >> 2] + 14 >> 1];
 HEAP32[$9 + 124 >> 2] = HEAP16[HEAP32[$9 + 172 >> 2] + 16 >> 1];
 HEAP32[$9 + 120 >> 2] = HEAP16[HEAP32[$9 + 172 >> 2] + 2 >> 1];
 HEAP32[$9 + 116 >> 2] = HEAP16[HEAP32[$9 + 172 >> 2] + 4 >> 1];
 HEAP32[$9 + 112 >> 2] = HEAP16[HEAP32[$9 + 172 >> 2] + 18 >> 1];
 HEAPF32[$9 + 108 >> 2] = HEAPF32[HEAP32[$9 + 172 >> 2] + 48 >> 2];
 HEAPF32[$9 + 104 >> 2] = HEAPF32[HEAP32[$9 + 172 >> 2] + 52 >> 2];
 label$1: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 168 >> 2]) | 0) != 4) {
   break label$1;
  }
 }
 label$2: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 160 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 144 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 HEAP32[$9 + 100 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 168 >> 2], 0, HEAP32[$9 + 144 >> 2], 0);
 HEAP32[$9 + 96 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 160 >> 2], 3, HEAP32[$9 + 144 >> 2], 3);
 HEAP32[$9 + 92 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 168 >> 2], 1);
 HEAP32[$9 + 88 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 168 >> 2], 2);
 HEAP32[$9 + 84 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 168 >> 2], 3);
 HEAP32[$9 + 80 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 160 >> 2], 1);
 HEAP32[$9 + 76 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 160 >> 2], 2);
 HEAP32[$9 + 72 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 144 >> 2], 1);
 HEAP32[$9 + 68 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 144 >> 2], 2);
 label$4: {
  if (HEAP32[$9 + 96 >> 2] != (Math_imul(HEAP32[$9 + 84 >> 2], HEAP32[$9 + 112 >> 2]) | 0)) {
   break label$4;
  }
 }
 label$5: {
  if ((tflite__RuntimeShape__FlatSize_28_29_20const(HEAP32[$9 + 152 >> 2]) | 0) != HEAP32[$9 + 96 >> 2]) {
   break label$5;
  }
 }
 HEAP32[$9 + 64 >> 2] = 0;
 while (1) {
  if (HEAP32[$9 + 64 >> 2] < HEAP32[$9 + 100 >> 2]) {
   HEAP32[$9 + 60 >> 2] = 0;
   while (1) {
    if (HEAP32[$9 + 60 >> 2] < HEAP32[$9 + 72 >> 2]) {
     HEAP32[$9 + 56 >> 2] = 0;
     while (1) {
      if (HEAP32[$9 + 56 >> 2] < HEAP32[$9 + 68 >> 2]) {
       HEAP32[$9 + 52 >> 2] = 0;
       while (1) {
        if (HEAP32[$9 + 52 >> 2] < HEAP32[$9 + 84 >> 2]) {
         HEAP32[$9 + 48 >> 2] = 0;
         while (1) {
          if (HEAP32[$9 + 48 >> 2] < HEAP32[$9 + 112 >> 2]) {
           HEAP32[$9 + 44 >> 2] = HEAP32[$9 + 48 >> 2] + Math_imul(HEAP32[$9 + 52 >> 2], HEAP32[$9 + 112 >> 2]);
           HEAP32[$9 + 40 >> 2] = Math_imul(HEAP32[$9 + 56 >> 2], HEAP32[$9 + 136 >> 2]) - HEAP32[$9 + 120 >> 2];
           HEAP32[$9 + 36 >> 2] = Math_imul(HEAP32[$9 + 60 >> 2], HEAP32[$9 + 132 >> 2]) - HEAP32[$9 + 116 >> 2];
           HEAPF32[$9 + 32 >> 2] = 0;
           HEAP32[$9 + 28 >> 2] = 0;
           while (1) {
            if (HEAP32[$9 + 28 >> 2] < HEAP32[$9 + 80 >> 2]) {
             HEAP32[$9 + 24 >> 2] = 0;
             while (1) {
              if (HEAP32[$9 + 24 >> 2] < HEAP32[$9 + 76 >> 2]) {
               HEAP32[$9 + 20 >> 2] = HEAP32[$9 + 40 >> 2] + Math_imul(HEAP32[$9 + 128 >> 2], HEAP32[$9 + 24 >> 2]);
               HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 36 >> 2] + Math_imul(HEAP32[$9 + 124 >> 2], HEAP32[$9 + 28 >> 2]);
               if (!(HEAP32[$9 + 20 >> 2] < 0 | HEAP32[$9 + 20 >> 2] >= HEAP32[$9 + 88 >> 2] | (HEAP32[$9 + 16 >> 2] < 0 | HEAP32[$9 + 16 >> 2] >= HEAP32[$9 + 92 >> 2]))) {
                HEAPF32[$9 + 12 >> 2] = HEAPF32[HEAP32[$9 + 164 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$9 + 168 >> 2], HEAP32[$9 + 64 >> 2], HEAP32[$9 + 16 >> 2], HEAP32[$9 + 20 >> 2], HEAP32[$9 + 52 >> 2]) << 2) >> 2];
                HEAPF32[$9 + 8 >> 2] = HEAPF32[HEAP32[$9 + 156 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$9 + 160 >> 2], 0, HEAP32[$9 + 28 >> 2], HEAP32[$9 + 24 >> 2], HEAP32[$9 + 44 >> 2]) << 2) >> 2];
                HEAPF32[$9 + 32 >> 2] = Math_fround(HEAPF32[$9 + 12 >> 2] * HEAPF32[$9 + 8 >> 2]) + HEAPF32[$9 + 32 >> 2];
               }
               HEAP32[$9 + 24 >> 2] = HEAP32[$9 + 24 >> 2] + 1;
               continue;
              }
              break;
             }
             HEAP32[$9 + 28 >> 2] = HEAP32[$9 + 28 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAPF32[$9 + 4 >> 2] = 0;
           if (HEAP32[$9 + 148 >> 2]) {
            HEAPF32[$9 + 4 >> 2] = HEAPF32[HEAP32[$9 + 148 >> 2] + (HEAP32[$9 + 44 >> 2] << 2) >> 2];
           }
           $10 = float_20tflite__ActivationFunctionWithMinMax_float__28float_2c_20float_2c_20float_29(Math_fround(HEAPF32[$9 + 32 >> 2] + HEAPF32[$9 + 4 >> 2]), HEAPF32[$9 + 108 >> 2], HEAPF32[$9 + 104 >> 2]);
           HEAPF32[HEAP32[$9 + 140 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$9 + 144 >> 2], HEAP32[$9 + 64 >> 2], HEAP32[$9 + 60 >> 2], HEAP32[$9 + 56 >> 2], HEAP32[$9 + 44 >> 2]) << 2) >> 2] = $10;
           HEAP32[$9 + 48 >> 2] = HEAP32[$9 + 48 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAP32[$9 + 52 >> 2] = HEAP32[$9 + 52 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$9 + 56 >> 2] = HEAP32[$9 + 56 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$9 + 60 >> 2] = HEAP32[$9 + 60 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$9 + 64 >> 2] = HEAP32[$9 + 64 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $9 + 176 | 0;
}

function utilTimerInsertTask($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 label$1: {
  if (utilTimerIsFull() & 1) {
   HEAP8[$3 + 31 | 0] = 0;
   break label$1;
  }
  jshInterruptOff();
  if (HEAP32[$3 + 20 >> 2]) {
   $0 = HEAP32[$3 + 24 >> 2];
   $1 = (HEAP32[HEAP32[$3 + 20 >> 2] >> 2] - HEAP32[91692] | 0) + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0;
   HEAP8[$0 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1 >>> 8;
   HEAP8[$0 + 2 | 0] = $1 >>> 16;
   HEAP8[$0 + 3 | 0] = $1 >>> 24;
  }
  $2 = jshGetSystemTime();
  $0 = $2;
  $2 = HEAP32[91695];
  $5 = HEAP32[91694];
  $1 = $2 + ($0 >>> 0 < $5 >>> 0) | 0;
  $2 = i64toi32_i32$HIGH_BITS;
  HEAP32[$3 + 16 >> 2] = $0 - $5;
  HEAP8[$3 + 15 | 0] = HEAPU8[366354];
  while (1) {
   $0 = 0;
   if (HEAPU8[$3 + 15 | 0] != HEAPU8[366353]) {
    $0 = HEAP32[$3 + 24 >> 2];
    $1 = Math_imul(HEAPU8[$3 + 15 | 0], 25) + 366368 | 0;
    $0 = HEAP32[$3 + 16 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) >>> 0 > (HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24)) >>> 0;
   }
   if ($0) {
    HEAP8[$3 + 15 | 0] = HEAPU8[$3 + 15 | 0] + 1 & 15;
    continue;
   }
   break;
  }
  HEAP8[$3 + 14 | 0] = HEAPU8[$3 + 15 | 0] == HEAPU8[366354];
  HEAP32[$3 + 8 >> 2] = HEAPU8[366353];
  while (1) {
   if (HEAP32[$3 + 8 >> 2] != HEAPU8[$3 + 15 | 0]) {
    HEAP8[$3 + 7 | 0] = HEAP32[$3 + 8 >> 2] + 15 & 15;
    $2 = Math_imul(HEAPU8[$3 + 7 | 0], 25) + 366368 | 0;
    $1 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
    $0 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
    $4 = $1;
    $5 = Math_imul(HEAP32[$3 + 8 >> 2], 25) + 366368 | 0;
    $1 = $5;
    HEAP8[$1 | 0] = $4;
    HEAP8[$1 + 1 | 0] = $4 >>> 8;
    HEAP8[$1 + 2 | 0] = $4 >>> 16;
    HEAP8[$1 + 3 | 0] = $4 >>> 24;
    HEAP8[$1 + 4 | 0] = $0;
    HEAP8[$1 + 5 | 0] = $0 >>> 8;
    HEAP8[$1 + 6 | 0] = $0 >>> 16;
    HEAP8[$1 + 7 | 0] = $0 >>> 24;
    HEAP8[$1 + 24 | 0] = HEAPU8[$2 + 24 | 0];
    $1 = HEAPU8[$2 + 20 | 0] | HEAPU8[$2 + 21 | 0] << 8 | (HEAPU8[$2 + 22 | 0] << 16 | HEAPU8[$2 + 23 | 0] << 24);
    $0 = HEAPU8[$2 + 16 | 0] | HEAPU8[$2 + 17 | 0] << 8 | (HEAPU8[$2 + 18 | 0] << 16 | HEAPU8[$2 + 19 | 0] << 24);
    $4 = $0;
    $0 = $5;
    HEAP8[$0 + 16 | 0] = $4;
    HEAP8[$0 + 17 | 0] = $4 >>> 8;
    HEAP8[$0 + 18 | 0] = $4 >>> 16;
    HEAP8[$0 + 19 | 0] = $4 >>> 24;
    HEAP8[$0 + 20 | 0] = $1;
    HEAP8[$0 + 21 | 0] = $1 >>> 8;
    HEAP8[$0 + 22 | 0] = $1 >>> 16;
    HEAP8[$0 + 23 | 0] = $1 >>> 24;
    $0 = HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8 | (HEAPU8[$2 + 14 | 0] << 16 | HEAPU8[$2 + 15 | 0] << 24);
    $1 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
    $4 = $1;
    $1 = $5;
    HEAP8[$1 + 8 | 0] = $4;
    HEAP8[$1 + 9 | 0] = $4 >>> 8;
    HEAP8[$1 + 10 | 0] = $4 >>> 16;
    HEAP8[$1 + 11 | 0] = $4 >>> 24;
    HEAP8[$1 + 12 | 0] = $0;
    HEAP8[$1 + 13 | 0] = $0 >>> 8;
    HEAP8[$1 + 14 | 0] = $0 >>> 16;
    HEAP8[$1 + 15 | 0] = $0 >>> 24;
    HEAP32[$3 + 8 >> 2] = HEAPU8[$3 + 7 | 0];
    continue;
   }
   break;
  }
  HEAP8[366353] = HEAPU8[366353] + 1 & 15;
  label$9: {
   if (HEAP8[$3 + 14 | 0] & 1) {
    HEAP32[$3 + 8 >> 2] = HEAPU8[366354];
    while (1) {
     if (HEAP32[$3 + 8 >> 2] != HEAPU8[366353]) {
      $0 = Math_imul(HEAP32[$3 + 8 >> 2], 25) + 366368 | 0;
      label$13: {
       if (HEAPU32[$3 + 16 >> 2] < (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) >>> 0) {
        $0 = Math_imul(HEAP32[$3 + 8 >> 2], 25) + 366368 | 0;
        $1 = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) - HEAP32[$3 + 16 >> 2] | 0;
        HEAP8[$0 | 0] = $1;
        HEAP8[$0 + 1 | 0] = $1 >>> 8;
        HEAP8[$0 + 2 | 0] = $1 >>> 16;
        HEAP8[$0 + 3 | 0] = $1 >>> 24;
        break label$13;
       }
       $0 = Math_imul(HEAP32[$3 + 8 >> 2], 25) + 366368 | 0;
       HEAP8[$0 | 0] = 0;
       HEAP8[$0 + 1 | 0] = 0;
       HEAP8[$0 + 2 | 0] = 0;
       HEAP8[$0 + 3 | 0] = 0;
      }
      HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + 1 & 15;
      continue;
     }
     break;
    }
    break label$9;
   }
   $0 = HEAP32[$3 + 24 >> 2];
   $1 = HEAP32[$3 + 16 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0;
   HEAP8[$0 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1 >>> 8;
   HEAP8[$0 + 2 | 0] = $1 >>> 16;
   HEAP8[$0 + 3 | 0] = $1 >>> 24;
  }
  $2 = HEAP32[$3 + 24 >> 2];
  $0 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
  $1 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
  $4 = $0;
  $5 = Math_imul(HEAPU8[$3 + 15 | 0], 25) + 366368 | 0;
  $0 = $5;
  HEAP8[$0 | 0] = $4;
  HEAP8[$0 + 1 | 0] = $4 >>> 8;
  HEAP8[$0 + 2 | 0] = $4 >>> 16;
  HEAP8[$0 + 3 | 0] = $4 >>> 24;
  HEAP8[$0 + 4 | 0] = $1;
  HEAP8[$0 + 5 | 0] = $1 >>> 8;
  HEAP8[$0 + 6 | 0] = $1 >>> 16;
  HEAP8[$0 + 7 | 0] = $1 >>> 24;
  HEAP8[$0 + 24 | 0] = HEAPU8[$2 + 24 | 0];
  $0 = HEAPU8[$2 + 20 | 0] | HEAPU8[$2 + 21 | 0] << 8 | (HEAPU8[$2 + 22 | 0] << 16 | HEAPU8[$2 + 23 | 0] << 24);
  $1 = HEAPU8[$2 + 16 | 0] | HEAPU8[$2 + 17 | 0] << 8 | (HEAPU8[$2 + 18 | 0] << 16 | HEAPU8[$2 + 19 | 0] << 24);
  $4 = $1;
  $1 = $5;
  HEAP8[$1 + 16 | 0] = $4;
  HEAP8[$1 + 17 | 0] = $4 >>> 8;
  HEAP8[$1 + 18 | 0] = $4 >>> 16;
  HEAP8[$1 + 19 | 0] = $4 >>> 24;
  HEAP8[$1 + 20 | 0] = $0;
  HEAP8[$1 + 21 | 0] = $0 >>> 8;
  HEAP8[$1 + 22 | 0] = $0 >>> 16;
  HEAP8[$1 + 23 | 0] = $0 >>> 24;
  $1 = HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8 | (HEAPU8[$2 + 14 | 0] << 16 | HEAPU8[$2 + 15 | 0] << 24);
  $0 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
  $4 = $0;
  $0 = $5;
  HEAP8[$0 + 8 | 0] = $4;
  HEAP8[$0 + 9 | 0] = $4 >>> 8;
  HEAP8[$0 + 10 | 0] = $4 >>> 16;
  HEAP8[$0 + 11 | 0] = $4 >>> 24;
  HEAP8[$0 + 12 | 0] = $1;
  HEAP8[$0 + 13 | 0] = $1 >>> 8;
  HEAP8[$0 + 14 | 0] = $1 >>> 16;
  HEAP8[$0 + 15 | 0] = $1 >>> 24;
  if (!(HEAP8[$3 + 14 | 0] & 1 ? 0 : HEAP8[366355] & 1)) {
   HEAP8[366355] = 1;
   jstRestartUtilTimer();
  }
  jshInterruptOn();
  HEAP8[$3 + 31 | 0] = 1;
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP8[$3 + 31 | 0] & 1;
}

function tflite___28anonymous_20namespace_29__AllocationInfoBuilder__AddTensors_28tflite__SubGraph_20const__2c_20int_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 112 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 104 >> 2] = $0;
 HEAP32[$4 + 100 >> 2] = $1;
 HEAP32[$4 + 96 >> 2] = $2;
 HEAP32[$4 + 92 >> 2] = $3;
 $1 = HEAP32[$4 + 104 >> 2];
 label$1: {
  if (!HEAP32[$4 + 92 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$4 + 88 >> 2] = 0;
 label$2: {
  while (1) {
   if (HEAPU32[$4 + 88 >> 2] < HEAPU32[$1 + 8 >> 2]) {
    HEAP32[$4 + 84 >> 2] = HEAP32[$1 + 16 >> 2] + Math_imul(HEAP32[$4 + 88 >> 2], 24);
    HEAP32[HEAP32[$4 + 84 >> 2] + 4 >> 2] = HEAP32[$4 + 92 >> 2] + Math_imul(HEAP32[$4 + 88 >> 2], 12);
    HEAP32[$4 + 80 >> 2] = tflite__TfLiteEvalTensorByteLength_28TfLiteEvalTensor_20const__2c_20unsigned_20long__29(HEAP32[$4 + 92 >> 2] + Math_imul(HEAP32[$4 + 88 >> 2], 12) | 0, HEAP32[$4 + 84 >> 2]);
    if (HEAP32[$4 + 80 >> 2]) {
     HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 80 >> 2];
     break label$2;
    } else {
     HEAP32[HEAP32[$4 + 84 >> 2] + 8 >> 2] = -1;
     HEAP32[HEAP32[$4 + 84 >> 2] + 12 >> 2] = -1;
     $0 = 0;
     if (!HEAP32[HEAP32[$4 + 92 >> 2] + Math_imul(HEAP32[$4 + 88 >> 2], 12) >> 2]) {
      $0 = tflite__Tensor__is_variable_28_29_20const(flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor____Get_28unsigned_20int_29_20const(tflite__SubGraph__tensors_28_29_20const(HEAP32[$4 + 100 >> 2]), HEAP32[$4 + 88 >> 2])) ^ -1;
     }
     HEAP8[HEAP32[$4 + 84 >> 2] + 20 | 0] = $0 & 1;
     label$8: {
      if (HEAP32[$4 + 96 >> 2]) {
       HEAP32[HEAP32[$4 + 84 >> 2] + 16 >> 2] = HEAP32[HEAP32[$4 + 96 >> 2] + (HEAP32[$4 + 88 >> 2] << 2) >> 2];
       break label$8;
      }
      HEAP32[HEAP32[$4 + 84 >> 2] + 16 >> 2] = -1;
     }
     HEAP32[$4 + 88 >> 2] = HEAP32[$4 + 88 >> 2] + 1;
     continue;
    }
   }
   break;
  }
  HEAP32[$4 + 76 >> 2] = 0;
  while (1) {
   if (HEAPU32[$4 + 76 >> 2] < flatbuffers__Vector_int___size_28_29_20const(tflite__SubGraph__inputs_28_29_20const(HEAP32[$4 + 100 >> 2])) >>> 0) {
    HEAP32[$4 + 72 >> 2] = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__SubGraph__inputs_28_29_20const(HEAP32[$4 + 100 >> 2]), HEAP32[$4 + 76 >> 2]);
    HEAP32[$4 + 68 >> 2] = HEAP32[$1 + 16 >> 2] + Math_imul(HEAP32[$4 + 72 >> 2], 24);
    HEAP32[HEAP32[$4 + 68 >> 2] + 8 >> 2] = 0;
    HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 76 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$4 + 64 >> 2] = 0;
  while (1) {
   if (HEAPU32[$4 + 64 >> 2] < flatbuffers__Vector_int___size_28_29_20const(tflite__SubGraph__outputs_28_29_20const(HEAP32[$4 + 100 >> 2])) >>> 0) {
    HEAP32[$4 + 60 >> 2] = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__SubGraph__outputs_28_29_20const(HEAP32[$4 + 100 >> 2]), HEAP32[$4 + 64 >> 2]);
    HEAP32[$4 + 56 >> 2] = HEAP32[$1 + 16 >> 2] + Math_imul(HEAP32[$4 + 60 >> 2], 24);
    $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__Operator____size_28_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$4 + 100 >> 2]));
    HEAP32[HEAP32[$4 + 56 >> 2] + 12 >> 2] = $0 - 1;
    HEAP32[$4 + 64 >> 2] = HEAP32[$4 + 64 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$4 + 52 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__Operator____size_28_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$4 + 100 >> 2])) - 1;
  while (1) {
   if (HEAP32[$4 + 52 >> 2] >= 0) {
    HEAP32[$4 + 48 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__Operator____Get_28unsigned_20int_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$4 + 100 >> 2]), HEAP32[$4 + 52 >> 2]);
    HEAP32[$4 + 44 >> 2] = 0;
    while (1) {
     if (HEAPU32[$4 + 44 >> 2] < flatbuffers__Vector_int___size_28_29_20const(tflite__Operator__inputs_28_29_20const(HEAP32[$4 + 48 >> 2])) >>> 0) {
      HEAP32[$4 + 40 >> 2] = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__Operator__inputs_28_29_20const(HEAP32[$4 + 48 >> 2]), HEAP32[$4 + 44 >> 2]);
      HEAP32[$4 + 36 >> 2] = HEAP32[$1 + 16 >> 2] + Math_imul(HEAP32[$4 + 40 >> 2], 24);
      if (!(HEAP32[HEAP32[$4 + 36 >> 2] + 12 >> 2] != -1 & HEAP32[HEAP32[$4 + 36 >> 2] + 12 >> 2] >= HEAP32[$4 + 52 >> 2])) {
       HEAP32[HEAP32[$4 + 36 >> 2] + 12 >> 2] = HEAP32[$4 + 52 >> 2];
      }
      HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 44 >> 2] + 1;
      continue;
     }
     break;
    }
    HEAP32[$4 + 32 >> 2] = 0;
    while (1) {
     if (HEAPU32[$4 + 32 >> 2] < flatbuffers__Vector_int___size_28_29_20const(tflite__Operator__outputs_28_29_20const(HEAP32[$4 + 48 >> 2])) >>> 0) {
      HEAP32[$4 + 28 >> 2] = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__Operator__outputs_28_29_20const(HEAP32[$4 + 48 >> 2]), HEAP32[$4 + 32 >> 2]);
      HEAP32[$4 + 24 >> 2] = HEAP32[$1 + 16 >> 2] + Math_imul(HEAP32[$4 + 28 >> 2], 24);
      if (!(HEAP32[HEAP32[$4 + 24 >> 2] + 8 >> 2] != -1 & HEAP32[HEAP32[$4 + 24 >> 2] + 8 >> 2] <= HEAP32[$4 + 52 >> 2])) {
       HEAP32[HEAP32[$4 + 24 >> 2] + 8 >> 2] = HEAP32[$4 + 52 >> 2];
      }
      HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 32 >> 2] + 1;
      continue;
     }
     break;
    }
    HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] - 1;
    continue;
   }
   break;
  }
  HEAP32[$4 + 20 >> 2] = 0;
  while (1) {
   if (HEAPU32[$4 + 20 >> 2] < HEAPU32[$1 + 8 >> 2]) {
    HEAP32[$4 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + Math_imul(HEAP32[$4 + 20 >> 2], 24);
    $0 = 0;
    $0 = HEAP32[HEAP32[$4 + 16 >> 2] + 8 >> 2] == -1 ? HEAP32[HEAP32[$4 + 16 >> 2] + 12 >> 2] != -1 : $0;
    HEAP8[$4 + 15 | 0] = $0;
    if (HEAP8[$4 + 15 | 0] & 1) {
     HEAP8[HEAP32[$4 + 16 >> 2] + 20 | 0] = 0;
    }
    $0 = 0;
    if (!(HEAP8[$4 + 15 | 0] & 1)) {
     $0 = 1;
     $0 = HEAP32[HEAP32[$4 + 16 >> 2] + 8 >> 2] != -1 ? HEAP32[HEAP32[$4 + 16 >> 2] + 12 >> 2] == -1 : $0;
    }
    HEAP8[$4 + 14 | 0] = $0 & 1;
    if (!(!(HEAP8[$4 + 14 | 0] & 1) | !(HEAP8[HEAP32[$4 + 16 >> 2] + 20 | 0] & 1))) {
     $0 = HEAP32[$1 >> 2];
     $1 = HEAP32[$4 + 20 >> 2];
     $2 = HEAP32[HEAP32[$4 + 16 >> 2] + 8 >> 2];
     HEAP32[$4 + 8 >> 2] = HEAP32[HEAP32[$4 + 16 >> 2] + 12 >> 2];
     HEAP32[$4 + 4 >> 2] = $2;
     HEAP32[$4 >> 2] = $1;
     tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 135012, $4);
     HEAP32[$4 + 108 >> 2] = 1;
     break label$2;
    }
    HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$4 + 108 >> 2] = 0;
 }
 __stack_pointer = $4 + 112 | 0;
 return HEAP32[$4 + 108 >> 2];
}

function lcdSetCallbacks_ArrayBuffer($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 121187);
 HEAP32[$1 + 4 >> 2] = 0;
 HEAP32[$1 >> 2] = jsvGetDataPointer(HEAP32[$1 + 8 >> 2], $1 + 4 | 0);
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 label$1: {
  label$2: {
   if (!HEAP32[$1 >> 2]) {
    break label$2;
   }
   if (HEAPU32[$1 + 4 >> 2] < graphicsGetMemoryRequired(HEAP32[$1 + 12 >> 2]) >>> 0) {
    break label$2;
   }
   $0 = HEAP32[$1 + 12 >> 2];
   if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 1) {
    break label$2;
   }
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = HEAP32[$1 >> 2];
   HEAP8[$0 + 48 | 0] = $2;
   HEAP8[$0 + 49 | 0] = $2 >>> 8;
   HEAP8[$0 + 50 | 0] = $2 >>> 16;
   HEAP8[$0 + 51 | 0] = $2 >>> 24;
   label$3: {
    label$4: {
     if (HEAPU8[HEAP32[$1 + 12 >> 2] + 16 | 0] != 1) {
      break label$4;
     }
     $0 = HEAP32[$1 + 12 >> 2];
     if (!((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4)) {
      break label$4;
     }
     $0 = HEAP32[$1 + 12 >> 2];
     if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 11) {
      break label$4;
     }
     $0 = HEAP32[$1 + 12 >> 2];
     HEAP8[$0 + 52 | 0] = 70;
     HEAP8[$0 + 53 | 0] = 2;
     HEAP8[$0 + 54 | 0] = 0;
     HEAP8[$0 + 55 | 0] = 0;
     $0 = HEAP32[$1 + 12 >> 2];
     HEAP8[$0 + 60 | 0] = 71;
     HEAP8[$0 + 61 | 0] = 2;
     HEAP8[$0 + 62 | 0] = 0;
     HEAP8[$0 + 63 | 0] = 0;
     $0 = HEAP32[$1 + 12 >> 2];
     HEAP8[$0 + 56 | 0] = 72;
     HEAP8[$0 + 57 | 0] = 2;
     HEAP8[$0 + 58 | 0] = 0;
     HEAP8[$0 + 59 | 0] = 0;
     break label$3;
    }
    label$5: {
     label$6: {
      if (HEAPU8[HEAP32[$1 + 12 >> 2] + 16 | 0] != 2) {
       break label$6;
      }
      $0 = HEAP32[$1 + 12 >> 2];
      if (!((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4)) {
       break label$6;
      }
      $0 = HEAP32[$1 + 12 >> 2];
      if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 11) {
       break label$6;
      }
      $0 = HEAP32[$1 + 12 >> 2];
      HEAP8[$0 + 52 | 0] = 73;
      HEAP8[$0 + 53 | 0] = 2;
      HEAP8[$0 + 54 | 0] = 0;
      HEAP8[$0 + 55 | 0] = 0;
      $0 = HEAP32[$1 + 12 >> 2];
      HEAP8[$0 + 60 | 0] = 74;
      HEAP8[$0 + 61 | 0] = 2;
      HEAP8[$0 + 62 | 0] = 0;
      HEAP8[$0 + 63 | 0] = 0;
      $0 = HEAP32[$1 + 12 >> 2];
      HEAP8[$0 + 56 | 0] = 75;
      HEAP8[$0 + 57 | 0] = 2;
      HEAP8[$0 + 58 | 0] = 0;
      HEAP8[$0 + 59 | 0] = 0;
      break label$5;
     }
     label$7: {
      label$8: {
       if (HEAPU8[HEAP32[$1 + 12 >> 2] + 16 | 0] != 4) {
        break label$8;
       }
       $0 = HEAP32[$1 + 12 >> 2];
       if (!((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4)) {
        break label$8;
       }
       $0 = HEAP32[$1 + 12 >> 2];
       if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 11) {
        break label$8;
       }
       $0 = HEAP32[$1 + 12 >> 2];
       HEAP8[$0 + 52 | 0] = 76;
       HEAP8[$0 + 53 | 0] = 2;
       HEAP8[$0 + 54 | 0] = 0;
       HEAP8[$0 + 55 | 0] = 0;
       $0 = HEAP32[$1 + 12 >> 2];
       HEAP8[$0 + 60 | 0] = 77;
       HEAP8[$0 + 61 | 0] = 2;
       HEAP8[$0 + 62 | 0] = 0;
       HEAP8[$0 + 63 | 0] = 0;
       $0 = HEAP32[$1 + 12 >> 2];
       HEAP8[$0 + 56 | 0] = 78;
       HEAP8[$0 + 57 | 0] = 2;
       HEAP8[$0 + 58 | 0] = 0;
       HEAP8[$0 + 59 | 0] = 0;
       break label$7;
      }
      label$9: {
       label$10: {
        if (HEAPU8[HEAP32[$1 + 12 >> 2] + 16 | 0] != 8) {
         break label$10;
        }
        $0 = HEAP32[$1 + 12 >> 2];
        if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 11) {
         break label$10;
        }
        $0 = HEAP32[$1 + 12 >> 2];
        HEAP8[$0 + 52 | 0] = 79;
        HEAP8[$0 + 53 | 0] = 2;
        HEAP8[$0 + 54 | 0] = 0;
        HEAP8[$0 + 55 | 0] = 0;
        $0 = HEAP32[$1 + 12 >> 2];
        HEAP8[$0 + 60 | 0] = 80;
        HEAP8[$0 + 61 | 0] = 2;
        HEAP8[$0 + 62 | 0] = 0;
        HEAP8[$0 + 63 | 0] = 0;
        $0 = HEAP32[$1 + 12 >> 2];
        HEAP8[$0 + 56 | 0] = 81;
        HEAP8[$0 + 57 | 0] = 2;
        HEAP8[$0 + 58 | 0] = 0;
        HEAP8[$0 + 59 | 0] = 0;
        $0 = HEAP32[$1 + 12 >> 2];
        HEAP8[$0 + 68 | 0] = 82;
        HEAP8[$0 + 69 | 0] = 2;
        HEAP8[$0 + 70 | 0] = 0;
        HEAP8[$0 + 71 | 0] = 0;
        break label$9;
       }
       $0 = HEAP32[$1 + 12 >> 2];
       HEAP8[$0 + 52 | 0] = 83;
       HEAP8[$0 + 53 | 0] = 2;
       HEAP8[$0 + 54 | 0] = 0;
       HEAP8[$0 + 55 | 0] = 0;
       $0 = HEAP32[$1 + 12 >> 2];
       HEAP8[$0 + 60 | 0] = 84;
       HEAP8[$0 + 61 | 0] = 2;
       HEAP8[$0 + 62 | 0] = 0;
       HEAP8[$0 + 63 | 0] = 0;
       $0 = HEAP32[$1 + 12 >> 2];
       HEAP8[$0 + 56 | 0] = 85;
       HEAP8[$0 + 57 | 0] = 2;
       HEAP8[$0 + 58 | 0] = 0;
       HEAP8[$0 + 59 | 0] = 0;
       $0 = HEAP32[$1 + 12 >> 2];
       HEAP8[$0 + 68 | 0] = 86;
       HEAP8[$0 + 69 | 0] = 2;
       HEAP8[$0 + 70 | 0] = 0;
       HEAP8[$0 + 71 | 0] = 0;
      }
     }
    }
   }
   break label$1;
  }
  if (jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1) {
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = HEAP32[$1 + 8 >> 2];
   HEAP8[$0 + 48 | 0] = $2;
   HEAP8[$0 + 49 | 0] = $2 >>> 8;
   HEAP8[$0 + 50 | 0] = $2 >>> 16;
   HEAP8[$0 + 51 | 0] = $2 >>> 24;
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP8[$0 + 52 | 0] = 87;
   HEAP8[$0 + 53 | 0] = 2;
   HEAP8[$0 + 54 | 0] = 0;
   HEAP8[$0 + 55 | 0] = 0;
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP8[$0 + 60 | 0] = 88;
   HEAP8[$0 + 61 | 0] = 2;
   HEAP8[$0 + 62 | 0] = 0;
   HEAP8[$0 + 63 | 0] = 0;
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP8[$0 + 56 | 0] = 89;
   HEAP8[$0 + 57 | 0] = 2;
   HEAP8[$0 + 58 | 0] = 0;
   HEAP8[$0 + 59 | 0] = 0;
  }
 }
 __stack_pointer = $1 + 16 | 0;
}

function jspeFactor() {
 var $0 = 0, $1 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $0 = __stack_pointer - 96 | 0;
 __stack_pointer = $0;
 label$1: {
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 128) {
   HEAP32[$0 + 88 >> 2] = jspGetNamedVariable(jslGetTokenValueAsString());
   jslGetNextToken();
   label$3: {
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 133) {
     jsExceptionHere(2, 133435, 0);
     break label$3;
    }
    label$5: {
     if (HEAP16[HEAP32[49079] + 2 >> 1] != 162) {
      break label$5;
     }
     if (!(wasm2js_i32$0 = jsvIsName(HEAP32[$0 + 88 >> 2]) & 1, wasm2js_i32$1 = 1, wasm2js_i32$2 = HEAP32[$0 + 88 >> 2] | (HEAP32[91094] & 63) == 1, 
     wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1)) {
      break label$5;
     }
     HEAP32[$0 + 84 >> 2] = jspeArrowFunction(0, HEAP32[$0 + 88 >> 2]);
     jsvUnLock(HEAP32[$0 + 88 >> 2]);
     HEAP32[$0 + 88 >> 2] = HEAP32[$0 + 84 >> 2];
    }
   }
   HEAP32[$0 + 92 >> 2] = HEAP32[$0 + 88 >> 2];
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 129) {
   HEAP32[$0 + 80 >> 2] = 0;
   if ((HEAP32[91094] & 63) == 1) {
    HEAP32[$0 + 80 >> 2] = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString()), i64toi32_i32$HIGH_BITS);
   }
   jslGetNextToken();
   HEAP32[$0 + 92 >> 2] = HEAP32[$0 + 80 >> 2];
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 130) {
   HEAP32[$0 + 76 >> 2] = 0;
   if ((HEAP32[91094] & 63) == 1) {
    HEAP32[$0 + 76 >> 2] = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString()));
   }
   jslGetNextToken();
   HEAP32[$0 + 92 >> 2] = HEAP32[$0 + 76 >> 2];
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 40) {
   jslGetNextToken();
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 92 >> 2] = 0;
    break label$1;
   }
   HEAP32[$0 + 92 >> 2] = jspeExpressionOrArrowFunction();
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 180) {
   jslGetNextToken();
   label$14: {
    if ((HEAP32[91094] & 63) == 1) {
     $1 = jsvNewFromBool(1);
     break label$14;
    }
    $1 = 0;
   }
   HEAP32[$0 + 92 >> 2] = $1;
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 181) {
   jslGetNextToken();
   label$17: {
    if ((HEAP32[91094] & 63) == 1) {
     $1 = jsvNewFromBool(0);
     break label$17;
    }
    $1 = 0;
   }
   HEAP32[$0 + 92 >> 2] = $1;
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 182) {
   jslGetNextToken();
   label$20: {
    if ((HEAP32[91094] & 63) == 1) {
     $1 = jsvNewWithFlags(2);
     break label$20;
    }
    $1 = 0;
   }
   HEAP32[$0 + 92 >> 2] = $1;
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 183) {
   jslGetNextToken();
   HEAP32[$0 + 92 >> 2] = 0;
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 131) {
   HEAP32[$0 + 72 >> 2] = 0;
   if ((HEAP32[91094] & 63) == 1) {
    HEAP32[$0 + 72 >> 2] = jslGetTokenValueAsVar();
   }
   jslGetNextToken();
   HEAP32[$0 + 92 >> 2] = HEAP32[$0 + 72 >> 2];
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 133) {
   HEAP32[$0 + 92 >> 2] = jspeTemplateLiteral();
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 135) {
   HEAP32[$0 + 68 >> 2] = 0;
   if ((HEAP32[91094] & 63) == 1) {
    HEAP32[$0 + 64 >> 2] = jslGetTokenValueAsVar();
    HEAP32[$0 + 60 >> 2] = 0;
    HEAP32[$0 + 56 >> 2] = 0;
    jsvStringIteratorNew($0 + 16 | 0, HEAP32[$0 + 64 >> 2], 0);
    while (1) {
     if (jsvStringIteratorHasChar_4($0 + 16 | 0) & 1) {
      HEAP32[$0 + 56 >> 2] = HEAP32[$0 + 56 >> 2] + 1;
      if ((jsvStringIteratorGetCharAndNext($0 + 16 | 0) & 255) == 47) {
       HEAP32[$0 + 60 >> 2] = HEAP32[$0 + 56 >> 2];
      }
      continue;
     }
     break;
    }
    jsvStringIteratorFree_4($0 + 16 | 0);
    HEAP32[$0 + 12 >> 2] = 0;
    if (HEAPU32[$0 + 60 >> 2] < HEAPU32[$0 + 56 >> 2]) {
     HEAP32[$0 + 12 >> 2] = jsvNewFromStringVar(HEAP32[$0 + 64 >> 2], HEAP32[$0 + 60 >> 2], 2147483647);
    }
    HEAP32[$0 + 8 >> 2] = jsvNewFromStringVar(HEAP32[$0 + 64 >> 2], 1, HEAP32[$0 + 60 >> 2] - 2 | 0);
    HEAP32[$0 + 68 >> 2] = jswrap_regexp_constructor(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 12 >> 2]);
    jsvUnLock3(HEAP32[$0 + 64 >> 2], HEAP32[$0 + 12 >> 2], HEAP32[$0 + 8 >> 2]);
   }
   jslGetNextToken();
   HEAP32[$0 + 92 >> 2] = HEAP32[$0 + 68 >> 2];
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 123) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 92 >> 2] = 0;
    break label$1;
   }
   HEAP32[$0 + 92 >> 2] = jspeFactorObject();
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 91) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 92 >> 2] = 0;
    break label$1;
   }
   HEAP32[$0 + 92 >> 2] = jspeFactorArray();
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 170) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 92 >> 2] = 0;
    break label$1;
   }
   jslGetNextToken();
   HEAP32[$0 + 92 >> 2] = jspeFunctionDefinition(1);
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 194) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 92 >> 2] = 0;
    break label$1;
   }
   jslGetNextToken();
   HEAP32[$0 + 92 >> 2] = jspeClassDefinition(1);
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 175) {
   jslGetNextToken();
   if (HEAP32[91092]) {
    $1 = HEAP32[91092];
   } else {
    $1 = HEAP32[91086];
   }
   HEAP32[$0 + 92 >> 2] = jsvLockAgain($1);
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 190) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 92 >> 2] = 0;
    break label$1;
   }
   HEAP32[$0 + 92 >> 2] = jspeFactorDelete();
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 191) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 92 >> 2] = 0;
    break label$1;
   }
   HEAP32[$0 + 92 >> 2] = jspeFactorTypeOf();
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 192) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 92 >> 2] = 0;
    break label$1;
   }
   jslGetNextToken();
   jsvUnLock(jspeUnaryExpression());
   HEAP32[$0 + 92 >> 2] = 0;
   break label$1;
  }
  if (!(jslMatch(0) & 1)) {
   HEAP32[$0 + 92 >> 2] = 0;
   break label$1;
  }
  jsExceptionHere(2, 117142, 0);
  HEAP32[$0 + 92 >> 2] = 0;
 }
 __stack_pointer = $0 + 96 | 0;
 return HEAP32[$0 + 92 >> 2];
}

function ftoa_bounded_extra($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 96 | 0;
 __stack_pointer = $5;
 HEAPF64[$5 + 88 >> 3] = $0;
 HEAP32[$5 + 84 >> 2] = $1;
 HEAP32[$5 + 80 >> 2] = $2;
 HEAP32[$5 + 76 >> 2] = $3;
 HEAP32[$5 + 72 >> 2] = $4;
 HEAPF64[$5 + 64 >> 3] = 1e-7;
 $2 = __DOUBLE_BITS_1(HEAPF64[$5 + 88 >> 3]);
 $3 = $2;
 $1 = i64toi32_i32$HIGH_BITS;
 $2 = $1 & 2147483647;
 $1 = $3;
 label$1: {
  if (!(!$1 & ($2 | 0) == 2146435072 | $2 >>> 0 < 2146435072)) {
   strcpy(HEAP32[$5 + 84 >> 2], 136967);
   break label$1;
  }
  $1 = __DOUBLE_BITS_1(HEAPF64[$5 + 88 >> 3]);
  $3 = $1;
  $2 = i64toi32_i32$HIGH_BITS;
  $1 = $2 & 2147483647;
  label$4: {
   if (($1 | 0) == 2146435072 | $1 >>> 0 > 2146435072) {
    if (HEAPF64[$5 + 88 >> 3] < 0) {
     strcpy(HEAP32[$5 + 84 >> 2], 116118);
     break label$4;
    }
    strcpy(HEAP32[$5 + 84 >> 2], 116119);
    break label$4;
   }
   if (HEAPF64[$5 + 88 >> 3] < 0) {
    $1 = HEAP32[$5 + 80 >> 2] - 1 | 0;
    HEAP32[$5 + 80 >> 2] = $1;
    if (!$1) {
     HEAP8[HEAP32[$5 + 84 >> 2]] = 0;
     break label$1;
    }
    $1 = HEAP32[$5 + 84 >> 2];
    HEAP32[$5 + 84 >> 2] = $1 + 1;
    HEAP8[$1 | 0] = 45;
    HEAPF64[$5 + 88 >> 3] = -HEAPF64[$5 + 88 >> 3];
   }
   HEAP32[$5 + 60 >> 2] = 0;
   if (!(!(HEAPF64[$5 + 88 >> 3] > 0) | HEAP32[$5 + 76 >> 2] != 10 | HEAP32[$5 + 72 >> 2] >= 0)) {
    label$11: {
     if (HEAPF64[$5 + 88 >> 3] >= 1e21) {
      while (1) {
       if (HEAPF64[$5 + 88 >> 3] > 1e5) {
        HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] / 1e5;
        HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 60 >> 2] + 5;
        continue;
       }
       break;
      }
      while (1) {
       if (HEAPF64[$5 + 88 >> 3] > 10) {
        HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] / 10;
        HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 60 >> 2] + 1;
        continue;
       }
       break;
      }
      break label$11;
     }
     if (HEAPF64[$5 + 88 >> 3] < 1e-6) {
      while (1) {
       if (HEAPF64[$5 + 88 >> 3] < 1e-5) {
        HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] * 1e5;
        HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 60 >> 2] - 5;
        continue;
       }
       break;
      }
      while (1) {
       if (HEAPF64[$5 + 88 >> 3] < 1) {
        HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] * 10;
        HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 60 >> 2] - 1;
        continue;
       }
       break;
      }
     }
    }
   }
   $0 = HEAPF64[$5 + 88 >> 3] + 1e-7;
   label$22: {
    if (Math_abs($0) < 2147483648) {
     $1 = ~~$0;
     break label$22;
    }
    $1 = -2147483648;
   }
   $0 = HEAPF64[$5 + 88 >> 3];
   label$24: {
    if (Math_abs($0) < 2147483648) {
     $2 = ~~$0;
     break label$24;
    }
    $2 = -2147483648;
   }
   if (($1 | 0) == ($2 + 1 | 0)) {
    $0 = HEAPF64[$5 + 88 >> 3];
    label$27: {
     if (Math_abs($0) < 2147483648) {
      $1 = ~~$0;
      break label$27;
     }
     $1 = -2147483648;
    }
    HEAPF64[$5 + 88 >> 3] = $1 + 1 | 0;
   }
   HEAPF64[$5 + 48 >> 3] = 1;
   while (1) {
    if (HEAPF64[$5 + 88 >> 3] >= HEAPF64[$5 + 48 >> 3] * +HEAP32[$5 + 76 >> 2]) {
     HEAPF64[$5 + 48 >> 3] = HEAPF64[$5 + 48 >> 3] * +HEAP32[$5 + 76 >> 2];
     continue;
    }
    break;
   }
   while (1) {
    if (HEAPF64[$5 + 48 >> 3] >= 1) {
     $0 = HEAPF64[$5 + 88 >> 3] / HEAPF64[$5 + 48 >> 3];
     label$33: {
      if (Math_abs($0) < 2147483648) {
       $1 = ~~$0;
       break label$33;
      }
      $1 = -2147483648;
     }
     HEAP32[$5 + 44 >> 2] = $1;
     HEAPF64[$5 + 88 >> 3] = - +HEAP32[$5 + 44 >> 2] * HEAPF64[$5 + 48 >> 3] + HEAPF64[$5 + 88 >> 3];
     $1 = HEAP32[$5 + 80 >> 2] - 1 | 0;
     HEAP32[$5 + 80 >> 2] = $1;
     if ($1) {
      $2 = itoch(HEAP32[$5 + 44 >> 2]);
      $1 = HEAP32[$5 + 84 >> 2];
      HEAP32[$5 + 84 >> 2] = $1 + 1;
      HEAP8[$1 | 0] = $2;
      HEAPF64[$5 + 48 >> 3] = HEAPF64[$5 + 48 >> 3] / +HEAP32[$5 + 76 >> 2];
      continue;
     } else {
      HEAP8[HEAP32[$5 + 84 >> 2]] = 0;
      break label$1;
     }
    }
    break;
   }
   if (!(!(HEAP32[$5 + 72 >> 2] < 0 & HEAPF64[$5 + 88 >> 3] > 0) & HEAP32[$5 + 72 >> 2] <= 0)) {
    HEAP8[$5 + 43 | 0] = 0;
    HEAPF64[$5 + 88 >> 3] = HEAPF64[$5 + 88 >> 3] * +HEAP32[$5 + 76 >> 2];
    while (1) {
     label$41: {
      if (!(HEAP32[$5 + 72 >> 2] <= -12 | HEAP32[$5 + 72 >> 2] >= 0)) {
       $1 = 1;
       if (HEAPF64[$5 + 88 >> 3] > 1e-7) {
        break label$41;
       }
      }
      $1 = HEAP32[$5 + 72 >> 2] > 0;
     }
     if ($1) {
      $0 = HEAPF64[$5 + 88 >> 3] + (HEAP32[$5 + 72 >> 2] == 1 ? .5 : 1e-8);
      label$44: {
       if (Math_abs($0) < 2147483648) {
        $1 = ~~$0;
        break label$44;
       }
       $1 = -2147483648;
      }
      HEAP32[$5 + 36 >> 2] = $1;
      HEAPF64[$5 + 88 >> 3] = (HEAPF64[$5 + 88 >> 3] - +HEAP32[$5 + 36 >> 2]) * +HEAP32[$5 + 76 >> 2];
      if (HEAP32[$5 + 36 >> 2] == HEAP32[$5 + 76 >> 2]) {
       HEAP32[$5 + 36 >> 2] = HEAP32[$5 + 76 >> 2] - 1;
      }
      if (!(HEAP8[$5 + 43 | 0] & 1)) {
       HEAP8[$5 + 43 | 0] = 1;
       $1 = HEAP32[$5 + 80 >> 2] - 1 | 0;
       HEAP32[$5 + 80 >> 2] = $1;
       if (!$1) {
        HEAP8[HEAP32[$5 + 84 >> 2]] = 0;
        break label$1;
       }
       $1 = HEAP32[$5 + 84 >> 2];
       HEAP32[$5 + 84 >> 2] = $1 + 1;
       HEAP8[$1 | 0] = 46;
      }
      $1 = HEAP32[$5 + 80 >> 2] - 1 | 0;
      HEAP32[$5 + 80 >> 2] = $1;
      if (!$1) {
       HEAP8[HEAP32[$5 + 84 >> 2]] = 0;
       break label$1;
      }
      $2 = itoch(HEAP32[$5 + 36 >> 2]);
      $1 = HEAP32[$5 + 84 >> 2];
      HEAP32[$5 + 84 >> 2] = $1 + 1;
      HEAP8[$1 | 0] = $2;
      HEAP32[$5 + 72 >> 2] = HEAP32[$5 + 72 >> 2] - 1;
      continue;
     }
     break;
    }
   }
   if (!(!HEAP32[$5 + 60 >> 2] | HEAPU32[$5 + 80 >> 2] <= 5)) {
    $1 = HEAP32[$5 + 84 >> 2];
    HEAP32[$5 + 84 >> 2] = $1 + 1;
    HEAP8[$1 | 0] = 101;
    if (HEAP32[$5 + 60 >> 2] > 0) {
     $1 = HEAP32[$5 + 84 >> 2];
     HEAP32[$5 + 84 >> 2] = $1 + 1;
     HEAP8[$1 | 0] = 43;
    }
    itostr_1(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 84 >> 2], 10);
    break label$1;
   }
   $1 = HEAP32[$5 + 84 >> 2];
   HEAP32[$5 + 84 >> 2] = $1 + 1;
   HEAP8[$1 | 0] = 0;
  }
 }
 __stack_pointer = $5 + 96 | 0;
}

function jsfBankFindFile($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 480 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 472 >> 2] = $0;
 HEAP32[$4 + 468 >> 2] = $1;
 HEAP32[$4 + 464 >> 2] = $3;
 HEAP32[$4 + 460 >> 2] = HEAP32[$4 + 472 >> 2];
 label$1: {
  label$2: {
   if (!(!HEAP32[91095] | HEAP32[$4 + 460 >> 2] != 134217728)) {
    HEAP32[$4 + 156 >> 2] = HEAP32[$4 + 460 >> 2];
    HEAP32[$4 + 152 >> 2] = HEAP32[91095];
    HEAP32[$4 + 148 >> 2] = HEAP32[$4 + 152 >> 2] + HEAP32[91096];
    HEAP32[$4 + 144 >> 2] = HEAP32[$4 + 148 >> 2] - HEAP32[$4 + 152 >> 2] >>> 5;
    while (1) {
     if (HEAP32[$4 + 144 >> 2]) {
      HEAP32[$4 + 140 >> 2] = HEAP32[$4 + 144 >> 2];
      if (HEAP32[$4 + 140 >> 2] > 8) {
       HEAP32[$4 + 140 >> 2] = 8;
      }
      jshFlashRead($4 + 160 | 0, HEAP32[$4 + 152 >> 2], HEAP32[$4 + 140 >> 2] << 5);
      HEAP32[$4 + 152 >> 2] = HEAP32[$4 + 152 >> 2] + (HEAP32[$4 + 140 >> 2] << 5);
      HEAP32[$4 + 144 >> 2] = HEAP32[$4 + 144 >> 2] - HEAP32[$4 + 140 >> 2];
      HEAP32[$4 + 136 >> 2] = 0;
      while (1) {
       if (HEAP32[$4 + 136 >> 2] < HEAP32[$4 + 140 >> 2]) {
        $3 = ($4 + 160 | 0) + (HEAP32[$4 + 136 >> 2] << 5) | 0;
        HEAP32[$4 + 64 >> 2] = HEAP32[$3 + 28 >> 2];
        $1 = HEAP32[$3 + 20 >> 2];
        $0 = HEAP32[$3 + 24 >> 2];
        HEAP32[$4 + 56 >> 2] = $1;
        HEAP32[$4 + 60 >> 2] = $0;
        $1 = HEAP32[$3 + 16 >> 2];
        $0 = HEAP32[$3 + 12 >> 2];
        HEAP32[$4 + 48 >> 2] = $0;
        HEAP32[$4 + 52 >> 2] = $1;
        $0 = HEAP32[$3 + 8 >> 2];
        $1 = HEAP32[$3 + 4 >> 2];
        HEAP32[$4 + 40 >> 2] = $1;
        HEAP32[$4 + 44 >> 2] = $0;
        HEAP32[$4 + 32 >> 2] = HEAP32[$2 + 24 >> 2];
        $3 = $2;
        $0 = HEAP32[$3 + 16 >> 2];
        $1 = HEAP32[$3 + 20 >> 2];
        HEAP32[$4 + 24 >> 2] = $0;
        HEAP32[$4 + 28 >> 2] = $1;
        $0 = HEAP32[$3 + 12 >> 2];
        $1 = HEAP32[$3 + 8 >> 2];
        HEAP32[$4 + 16 >> 2] = $1;
        HEAP32[$4 + 20 >> 2] = $0;
        $1 = HEAP32[$3 + 4 >> 2];
        $0 = HEAP32[$3 >> 2];
        HEAP32[$4 + 8 >> 2] = $0;
        HEAP32[$4 + 12 >> 2] = $1;
        if (jsfIsNameEqual($4 + 40 | 0, $4 + 8 | 0) & 1) {
         HEAP32[$4 + 132 >> 2] = HEAP32[$4 + 156 >> 2] + HEAP32[($4 + 160 | 0) + (HEAP32[$4 + 136 >> 2] << 5) >> 2];
         if (!(!(jsfGetFileHeader(HEAP32[$4 + 132 >> 2], ($4 + 160 | 0) + (HEAP32[$4 + 136 >> 2] << 5) | 0, 1) & 1) | !HEAP32[(($4 + 160 | 0) + (HEAP32[$4 + 136 >> 2] << 5) | 0) + 4 >> 2])) {
          if (HEAP32[$4 + 464 >> 2]) {
           $3 = ($4 + 160 | 0) + (HEAP32[$4 + 136 >> 2] << 5) | 0;
           $1 = HEAP32[$3 >> 2];
           $0 = HEAP32[$3 + 4 >> 2];
           $5 = $1;
           $2 = HEAP32[$4 + 464 >> 2];
           $1 = $2;
           HEAP32[$1 >> 2] = $5;
           HEAP32[$1 + 4 >> 2] = $0;
           $1 = HEAP32[$3 + 28 >> 2];
           $0 = HEAP32[$3 + 24 >> 2];
           $5 = $0;
           $0 = $2;
           HEAP32[$0 + 24 >> 2] = $5;
           HEAP32[$0 + 28 >> 2] = $1;
           $0 = HEAP32[$3 + 20 >> 2];
           $1 = HEAP32[$3 + 16 >> 2];
           $5 = $1;
           $1 = $2;
           HEAP32[$1 + 16 >> 2] = $5;
           HEAP32[$1 + 20 >> 2] = $0;
           $1 = HEAP32[$3 + 12 >> 2];
           $0 = HEAP32[$3 + 8 >> 2];
           $3 = $0;
           $0 = $2;
           HEAP32[$0 + 8 >> 2] = $3;
           HEAP32[$0 + 12 >> 2] = $1;
          }
          HEAP32[$4 + 476 >> 2] = HEAP32[$4 + 132 >> 2] + 32;
          break label$1;
         }
        }
        HEAP32[$4 + 136 >> 2] = HEAP32[$4 + 136 >> 2] + 1;
        continue;
       }
       break;
      }
      continue;
     }
     break;
    }
    HEAP32[$4 + 460 >> 2] = HEAP32[91095] - 32;
    HEAP32[$4 + 428 >> 2] = 0;
    HEAP32[$4 + 424 >> 2] = HEAP32[91096];
    break label$2;
   }
   if (!(jsfGetFileHeader(HEAP32[$4 + 460 >> 2], $4 + 424 | 0, 0) & 1)) {
    HEAP32[$4 + 476 >> 2] = 0;
    break label$1;
   }
  }
  while (1) {
   if (HEAP32[$4 + 428 >> 2] == HEAP32[$2 >> 2]) {
    label$15: {
     if (!(jsfGetFileHeader(HEAP32[$4 + 460 >> 2], $4 + 424 | 0, 1) & 1)) {
      break label$15;
     }
     $3 = $4 + 424 | 0;
     HEAP32[$4 + 128 >> 2] = HEAP32[$3 + 28 >> 2];
     $1 = HEAP32[$3 + 20 >> 2];
     $0 = HEAP32[$3 + 24 >> 2];
     HEAP32[$4 + 120 >> 2] = $1;
     HEAP32[$4 + 124 >> 2] = $0;
     $1 = HEAP32[$3 + 16 >> 2];
     $0 = HEAP32[$3 + 12 >> 2];
     HEAP32[$4 + 112 >> 2] = $0;
     HEAP32[$4 + 116 >> 2] = $1;
     $0 = HEAP32[$3 + 8 >> 2];
     $1 = HEAP32[$3 + 4 >> 2];
     HEAP32[$4 + 104 >> 2] = $1;
     HEAP32[$4 + 108 >> 2] = $0;
     HEAP32[$4 + 96 >> 2] = HEAP32[$2 + 24 >> 2];
     $3 = $2;
     $0 = HEAP32[$3 + 16 >> 2];
     $1 = HEAP32[$3 + 20 >> 2];
     HEAP32[$4 + 88 >> 2] = $0;
     HEAP32[$4 + 92 >> 2] = $1;
     $0 = HEAP32[$3 + 12 >> 2];
     $1 = HEAP32[$3 + 8 >> 2];
     HEAP32[$4 + 80 >> 2] = $1;
     HEAP32[$4 + 84 >> 2] = $0;
     $1 = HEAP32[$3 + 4 >> 2];
     $0 = HEAP32[$3 >> 2];
     HEAP32[$4 + 72 >> 2] = $0;
     HEAP32[$4 + 76 >> 2] = $1;
     if (!(jsfIsNameEqual($4 + 104 | 0, $4 + 72 | 0) & 1)) {
      break label$15;
     }
     if (HEAP32[$4 + 464 >> 2]) {
      $0 = HEAP32[$4 + 428 >> 2];
      $1 = HEAP32[$4 + 424 >> 2];
      $3 = $1;
      $2 = HEAP32[$4 + 464 >> 2];
      $1 = $2;
      HEAP32[$1 >> 2] = $3;
      HEAP32[$1 + 4 >> 2] = $0;
      $1 = HEAP32[$4 + 452 >> 2];
      $0 = HEAP32[$4 + 448 >> 2];
      $3 = $0;
      $0 = $2;
      HEAP32[$0 + 24 >> 2] = $3;
      HEAP32[$0 + 28 >> 2] = $1;
      $0 = HEAP32[$4 + 444 >> 2];
      $1 = HEAP32[$4 + 440 >> 2];
      $3 = $1;
      $1 = $2;
      HEAP32[$1 + 16 >> 2] = $3;
      HEAP32[$1 + 20 >> 2] = $0;
      $1 = HEAP32[$4 + 436 >> 2];
      $0 = HEAP32[$4 + 432 >> 2];
      $3 = $0;
      $0 = $2;
      HEAP32[$0 + 8 >> 2] = $3;
      HEAP32[$0 + 12 >> 2] = $1;
     }
     HEAP32[$4 + 476 >> 2] = HEAP32[$4 + 460 >> 2] + 32;
     break label$1;
    }
   }
   if (jsfGetNextFileHeader($4 + 460 | 0, $4 + 424 | 0, 3) & 1) {
    continue;
   }
   break;
  }
  HEAP32[$4 + 476 >> 2] = 0;
 }
 __stack_pointer = $4 + 480 | 0;
 return HEAP32[$4 + 476 >> 2];
}

function jswrap_graphics_createArrayBuffer($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 112 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 104 >> 2] = $0;
 HEAP32[$4 + 100 >> 2] = $1;
 HEAP32[$4 + 96 >> 2] = $2;
 HEAP32[$4 + 92 >> 2] = $3;
 label$1: {
  label$2: {
   if (!(HEAP32[$4 + 104 >> 2] <= 0 | HEAP32[$4 + 100 >> 2] <= 0 | HEAP32[$4 + 104 >> 2] > 32767)) {
    if (HEAP32[$4 + 100 >> 2] <= 32767) {
     break label$2;
    }
   }
   jsExceptionHere(1, 131663, 0);
   HEAP32[$4 + 108 >> 2] = 0;
   break label$1;
  }
  if (!(isValidBPP(HEAP32[$4 + 96 >> 2]) & 1)) {
   jsExceptionHere(1, 136950, 0);
   HEAP32[$4 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 88 >> 2] = jspNewObject(0, 120477);
  if (!HEAP32[$4 + 88 >> 2]) {
   HEAP32[$4 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP8[$4 + 20 | 0] = 0;
  HEAP8[$4 + 21 | 0] = 0;
  HEAP8[$4 + 22 | 0] = 0;
  HEAP8[$4 + 23 | 0] = 0;
  graphicsStructInit($4 + 16 | 0, HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2], HEAP32[$4 + 96 >> 2]);
  HEAP8[$4 + 24 | 0] = 4;
  HEAP8[$4 + 25 | 0] = 0;
  HEAP8[$4 + 26 | 0] = 0;
  HEAP8[$4 + 27 | 0] = 0;
  $0 = HEAP32[$4 + 88 >> 2];
  HEAP8[$4 + 16 | 0] = $0;
  HEAP8[$4 + 17 | 0] = $0 >>> 8;
  HEAP8[$4 + 18 | 0] = $0 >>> 16;
  HEAP8[$4 + 19 | 0] = $0 >>> 24;
  HEAP32[$4 + 12 >> 2] = 0;
  if (jsvIsObject(HEAP32[$4 + 92 >> 2]) & 1) {
   if (jsvObjectGetBoolChild(HEAP32[$4 + 92 >> 2], 130047) & 1) {
    $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 1;
    HEAP8[$4 + 24 | 0] = $0;
    HEAP8[$4 + 25 | 0] = $0 >>> 8;
    HEAP8[$4 + 26 | 0] = $0 >>> 16;
    HEAP8[$4 + 27 | 0] = $0 >>> 24;
   }
   $0 = jsvObjectGetChildIfExists(HEAP32[$4 + 92 >> 2], 135689);
   HEAP32[$4 + 8 >> 2] = $0;
   if ($0) {
    if (!(jsvGetBoolAndUnLock(HEAP32[$4 + 8 >> 2]) & 1)) {
     $0 = (HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24)) & -5;
     HEAP8[$4 + 24 | 0] = $0;
     HEAP8[$4 + 25 | 0] = $0 >>> 8;
     HEAP8[$4 + 26 | 0] = $0 >>> 16;
     HEAP8[$4 + 27 | 0] = $0 >>> 24;
    }
   }
   if (jsvObjectGetBoolChild(HEAP32[$4 + 92 >> 2], 116427) & 1) {
    $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 8;
    HEAP8[$4 + 24 | 0] = $0;
    HEAP8[$4 + 25 | 0] = $0 >>> 8;
    HEAP8[$4 + 26 | 0] = $0 >>> 16;
    HEAP8[$4 + 27 | 0] = $0 >>> 24;
   }
   if (jsvObjectGetBoolChild(HEAP32[$4 + 92 >> 2], 131918) & 1) {
    label$12: {
     if (HEAPU8[$4 + 32 | 0] == 1) {
      $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 2;
      HEAP8[$4 + 24 | 0] = $0;
      HEAP8[$4 + 25 | 0] = $0 >>> 8;
      HEAP8[$4 + 26 | 0] = $0 >>> 16;
      HEAP8[$4 + 27 | 0] = $0 >>> 24;
      break label$12;
     }
     jsExceptionHere(1, 120004, 0);
     HEAP32[$4 + 108 >> 2] = 0;
     break label$1;
    }
    if ((HEAPU8[$4 + 30 | 0] | HEAPU8[$4 + 31 | 0] << 8) & 7) {
     jsExceptionHere(1, 131876, 0);
     HEAP32[$4 + 108 >> 2] = 0;
     break label$1;
    }
   }
   HEAP32[$4 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 92 >> 2], 121356);
   if (HEAP32[$4 + 4 >> 2]) {
    if (!(jsvIsStringEqual(HEAP32[$4 + 4 >> 2], 135706) & 1)) {
     label$17: {
      if (!(jsvIsStringEqual(HEAP32[$4 + 4 >> 2], 129678) & 1)) {
       $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 128;
       HEAP8[$4 + 24 | 0] = $0;
       HEAP8[$4 + 25 | 0] = $0 >>> 8;
       HEAP8[$4 + 26 | 0] = $0 >>> 16;
       HEAP8[$4 + 27 | 0] = $0 >>> 24;
       break label$17;
      }
      label$19: {
       if (!(jsvIsStringEqual(HEAP32[$4 + 4 >> 2], 120983) & 1)) {
        $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 256;
        HEAP8[$4 + 24 | 0] = $0;
        HEAP8[$4 + 25 | 0] = $0 >>> 8;
        HEAP8[$4 + 26 | 0] = $0 >>> 16;
        HEAP8[$4 + 27 | 0] = $0 >>> 24;
        break label$19;
       }
       label$21: {
        if (!(jsvIsStringEqual(HEAP32[$4 + 4 >> 2], 121458) & 1)) {
         $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 384;
         HEAP8[$4 + 24 | 0] = $0;
         HEAP8[$4 + 25 | 0] = $0 >>> 8;
         HEAP8[$4 + 26 | 0] = $0 >>> 16;
         HEAP8[$4 + 27 | 0] = $0 >>> 24;
         break label$21;
        }
        label$23: {
         if (!(jsvIsStringEqual(HEAP32[$4 + 4 >> 2], 135697) & 1)) {
          $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 512;
          HEAP8[$4 + 24 | 0] = $0;
          HEAP8[$4 + 25 | 0] = $0 >>> 8;
          HEAP8[$4 + 26 | 0] = $0 >>> 16;
          HEAP8[$4 + 27 | 0] = $0 >>> 24;
          break label$23;
         }
         label$25: {
          if (!(jsvIsStringEqual(HEAP32[$4 + 4 >> 2], 130043) & 1)) {
           $0 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24) | 640;
           HEAP8[$4 + 24 | 0] = $0;
           HEAP8[$4 + 25 | 0] = $0 >>> 8;
           HEAP8[$4 + 26 | 0] = $0 >>> 16;
           HEAP8[$4 + 27 | 0] = $0 >>> 24;
           break label$25;
          }
          jsWarn(119922, 0);
         }
        }
       }
      }
     }
    }
    jsvUnLock(HEAP32[$4 + 4 >> 2]);
   }
   HEAP32[$4 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 92 >> 2], 121187);
   label$27: {
    if (!HEAP32[$4 + 12 >> 2]) {
     break label$27;
    }
    if (jsvIsArrayBuffer(HEAP32[$4 + 12 >> 2]) & 1) {
     break label$27;
    }
    HEAP32[$4 >> 2] = HEAP32[$4 + 12 >> 2];
    jsExceptionHere(1, 118671, $4);
    jsvUnLock(HEAP32[$4 + 12 >> 2]);
    HEAP32[$4 + 108 >> 2] = 0;
    break label$1;
   }
  }
  lcdInit_ArrayBuffer($4 + 16 | 0, HEAP32[$4 + 12 >> 2]);
  jsvUnLock(HEAP32[$4 + 12 >> 2]);
  graphicsSetVarInitial($4 + 16 | 0);
  HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 88 >> 2];
 }
 __stack_pointer = $4 + 112 | 0;
 return HEAP32[$4 + 108 >> 2];
}

function void_20tflite__reference_ops__Softmax_unsigned_20char_2c_20unsigned_20char__28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 208 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 204 >> 2] = $0;
 HEAP32[$5 + 200 >> 2] = $1;
 HEAP32[$5 + 196 >> 2] = $2;
 HEAP32[$5 + 192 >> 2] = $3;
 HEAP32[$5 + 188 >> 2] = $4;
 HEAP32[$5 + 184 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 8 >> 2];
 HEAP32[$5 + 180 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 12 >> 2];
 HEAP32[$5 + 176 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 24 >> 2];
 HEAP32[$5 + 172 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 200 >> 2]) - 1;
 HEAP32[$5 + 168 >> 2] = tflite__MatchingFlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 200 >> 2], HEAP32[$5 + 172 >> 2], HEAP32[$5 + 192 >> 2]);
 HEAP32[$5 + 164 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 200 >> 2], HEAP32[$5 + 172 >> 2], HEAP32[$5 + 192 >> 2], HEAP32[$5 + 172 >> 2]);
 HEAP32[$5 + 160 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 160 >> 2] < HEAP32[$5 + 168 >> 2]) {
   HEAP8[$5 + 159 | 0] = std____2__numeric_limits_unsigned_20char___min_28_29();
   HEAP32[$5 + 152 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 152 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP8[$5 + 159 | 0] = HEAPU8[unsigned_20char_20const__20std____2__max_unsigned_20char__28unsigned_20char_20const__2c_20unsigned_20char_20const__29($5 + 159 | 0, HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 152 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0) | 0];
     HEAP32[$5 + 152 >> 2] = HEAP32[$5 + 152 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 144 >> 2] = gemmlowp__FixedPoint_int_2c_2012___Zero_28_29();
   HEAP32[$5 + 140 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 140 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP32[$5 + 136 >> 2] = HEAPU8[HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 140 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] - HEAPU8[$5 + 159 | 0];
     if (HEAP32[$5 + 136 >> 2] >= HEAP32[$5 + 176 >> 2]) {
      HEAP32[$5 + 132 >> 2] = tflite__MultiplyByQuantizedMultiplierGreaterThanOne_28int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 184 >> 2], HEAP32[$5 + 180 >> 2]);
      HEAP32[$5 + 128 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(HEAP32[$5 + 132 >> 2]);
      HEAP32[$5 + 112 >> 2] = HEAP32[$5 + 144 >> 2];
      HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 128 >> 2];
      HEAP32[$5 + 96 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_negative_values_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$5 + 88 >> 2]);
      HEAP32[$5 + 104 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__Rescale_12_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$5 + 96 >> 2]);
      HEAP32[$5 + 120 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__operator__int_2c_2012__28gemmlowp__FixedPoint_int_2c_2012__2c_20gemmlowp__FixedPoint_int_2c_2012__29(HEAP32[$5 + 112 >> 2], HEAP32[$5 + 104 >> 2]);
      HEAP32[$5 + 144 >> 2] = HEAP32[$5 + 120 >> 2];
     }
     HEAP32[$5 + 140 >> 2] = HEAP32[$5 + 140 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 80 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromRaw_28int_29(tflite__GetReciprocal_28int_2c_20int_2c_20int__29(HEAP32[gemmlowp__FixedPoint_int_2c_2012___raw_28_29($5 + 144 | 0) >> 2], 12, $5 + 84 | 0));
   HEAP32[$5 + 76 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP32[$5 + 72 >> 2] = HEAPU8[HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 76 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] - HEAPU8[$5 + 159 | 0];
     label$10: {
      if (HEAP32[$5 + 72 >> 2] >= HEAP32[$5 + 176 >> 2]) {
       HEAP32[$5 + 68 >> 2] = tflite__MultiplyByQuantizedMultiplierGreaterThanOne_28int_2c_20int_2c_20int_29(HEAP32[$5 + 72 >> 2], HEAP32[$5 + 184 >> 2], HEAP32[$5 + 180 >> 2]);
       HEAP32[$5 + 64 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(HEAP32[$5 + 68 >> 2]);
       HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 64 >> 2];
       HEAP32[$5 + 56 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_negative_values_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$5 + 48 >> 2]);
       HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 80 >> 2];
       HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 56 >> 2];
       HEAP32[$5 + 40 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$5 + 32 >> 2], HEAP32[$5 + 24 >> 2]);
       HEAP32[$5 + 44 >> 2] = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($5 + 40 | 0) >> 2], HEAP32[$5 + 84 >> 2] + 23 | 0);
       HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 44 >> 2] + (std____2__numeric_limits_unsigned_20char___min_28_29() & 255);
       HEAP32[$5 + 16 >> 2] = std____2__numeric_limits_unsigned_20char___max_28_29() & 255;
       $0 = int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($5 + 20 | 0, $5 + 16 | 0);
       HEAP32[$5 + 12 >> 2] = std____2__numeric_limits_unsigned_20char___min_28_29() & 255;
       $0 = int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($0, $5 + 12 | 0);
       HEAP8[HEAP32[$5 + 188 >> 2] + (HEAP32[$5 + 76 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] = HEAP32[$0 >> 2];
       break label$10;
      }
      $0 = std____2__numeric_limits_unsigned_20char___min_28_29();
      HEAP8[HEAP32[$5 + 188 >> 2] + (HEAP32[$5 + 76 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] = $0;
     }
     HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 160 >> 2] = HEAP32[$5 + 160 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 208 | 0;
}

function jswGetSymbolListForObject($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (jsvIsNativeFunction(HEAP32[$1 + 8 >> 2]) & 1) {
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 27) {
    HEAP32[$1 + 12 >> 2] = 159040;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 28) {
    HEAP32[$1 + 12 >> 2] = 159067;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 29) {
    HEAP32[$1 + 12 >> 2] = 159076;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 30) {
    HEAP32[$1 + 12 >> 2] = 159094;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 31) {
    HEAP32[$1 + 12 >> 2] = 159103;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 32) {
    HEAP32[$1 + 12 >> 2] = 159121;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 12) {
    HEAP32[$1 + 12 >> 2] = 159157;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 33) {
    HEAP32[$1 + 12 >> 2] = 159220;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 34) {
    HEAP32[$1 + 12 >> 2] = 159229;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 35) {
    HEAP32[$1 + 12 >> 2] = 159238;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 36) {
    HEAP32[$1 + 12 >> 2] = 159265;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 37) {
    HEAP32[$1 + 12 >> 2] = 159301;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 38) {
    HEAP32[$1 + 12 >> 2] = 159310;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 39) {
    HEAP32[$1 + 12 >> 2] = 159319;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 40) {
    HEAP32[$1 + 12 >> 2] = 159328;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 41) {
    HEAP32[$1 + 12 >> 2] = 159337;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 42) {
    HEAP32[$1 + 12 >> 2] = 159346;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 20) {
    HEAP32[$1 + 12 >> 2] = 159364;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 21) {
    HEAP32[$1 + 12 >> 2] = 159382;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 43) {
    HEAP32[$1 + 12 >> 2] = 159400;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 23) {
    HEAP32[$1 + 12 >> 2] = 159418;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 24) {
    HEAP32[$1 + 12 >> 2] = 159436;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 25) {
    HEAP32[$1 + 12 >> 2] = 159454;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 44) {
    HEAP32[$1 + 12 >> 2] = 159472;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 10) {
    HEAP32[$1 + 12 >> 2] = 159481;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 45) {
    HEAP32[$1 + 12 >> 2] = 159490;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 46) {
    HEAP32[$1 + 12 >> 2] = 159499;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 47) {
    HEAP32[$1 + 12 >> 2] = 159508;
    break label$1;
   }
  }
  if (HEAP32[$1 + 8 >> 2] == HEAP32[91086]) {
   HEAP32[$1 + 12 >> 2] = 159058;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function graphicsFillPoly($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $4 = __stack_pointer - 96 | 0;
 $3 = $4;
 __stack_pointer = $3;
 HEAP32[$3 + 92 >> 2] = $0;
 HEAP32[$3 + 88 >> 2] = $1;
 HEAP32[$3 + 84 >> 2] = $2;
 HEAP32[$3 + 80 >> 2] = HEAP32[$3 + 84 >> 2];
 $0 = HEAP32[$3 + 92 >> 2];
 HEAP32[$3 + 64 >> 2] = (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) - 1;
 HEAP32[$3 + 60 >> 2] = 0;
 HEAP32[$3 + 76 >> 2] = 0;
 while (1) {
  if (HEAP32[$3 + 76 >> 2] < HEAP32[$3 + 88 >> 2]) {
   HEAP32[$3 + 56 >> 2] = HEAP16[HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) >> 1];
   HEAP32[$3 + 52 >> 2] = HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) | 0) + 2 >> 1];
   graphicsToDeviceCoordinates16x(HEAP32[$3 + 92 >> 2], $3 + 56 | 0, $3 + 52 | 0);
   HEAP16[HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) >> 1] = HEAP32[$3 + 56 >> 2];
   HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) | 0) + 2 >> 1] = HEAP32[$3 + 52 >> 2];
   HEAP16[$3 + 50 >> 1] = HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) | 0) + 2 >> 1] >> 4;
   if (HEAP16[$3 + 50 >> 1] < HEAP32[$3 + 64 >> 2]) {
    HEAP32[$3 + 64 >> 2] = HEAP16[$3 + 50 >> 1];
   }
   if (HEAP16[$3 + 50 >> 1] > HEAP32[$3 + 60 >> 2]) {
    HEAP32[$3 + 60 >> 2] = HEAP16[$3 + 50 >> 1];
   }
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
   continue;
  }
  break;
 }
 $0 = HEAP32[$3 + 92 >> 2];
 if (HEAP32[$3 + 64 >> 2] < (HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8)) {
  $0 = HEAP32[$3 + 92 >> 2];
  HEAP32[$3 + 64 >> 2] = HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8;
 }
 $0 = HEAP32[$3 + 92 >> 2];
 if (HEAP32[$3 + 60 >> 2] > (HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8)) {
  $0 = HEAP32[$3 + 92 >> 2];
  HEAP32[$3 + 60 >> 2] = HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8;
 }
 HEAP32[$3 + 44 >> 2] = 64;
 HEAP32[$3 + 68 >> 2] = HEAP32[$3 + 64 >> 2] << 4;
 while (1) {
  if (HEAP32[$3 + 68 >> 2] <= HEAP32[$3 + 60 >> 2] << 4) {
   HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 68 >> 2] >> 4;
   HEAP32[$3 + 36 >> 2] = $4;
   $4 = $4 - 128 | 0;
   __stack_pointer = $4;
   $0 = $4 + -64 | 0;
   __stack_pointer = $0;
   HEAP32[$3 + 32 >> 2] = 0;
   HEAP32[$3 + 72 >> 2] = HEAP32[$3 + 88 >> 2] - 1;
   HEAP32[$3 + 76 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 76 >> 2] < HEAP32[$3 + 88 >> 2]) {
     if (!(!(HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) | 0) + 2 >> 1] <= HEAP32[$3 + 68 >> 2] & HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 72 >> 2] << 2) | 0) + 2 >> 1] > HEAP32[$3 + 68 >> 2]) & (HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) | 0) + 2 >> 1] <= HEAP32[$3 + 68 >> 2] | HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 72 >> 2] << 2) | 0) + 2 >> 1] > HEAP32[$3 + 68 >> 2]))) {
      if (HEAP32[$3 + 32 >> 2] < 64) {
       HEAP32[$3 + 28 >> 2] = HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 72 >> 2] << 2) | 0) + 2 >> 1] - HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) | 0) + 2 >> 1];
       if (HEAP32[$3 + 28 >> 2]) {
        HEAP16[(HEAP32[$3 + 32 >> 2] << 1) + $4 >> 1] = HEAP16[HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) >> 1] + ((Math_imul(HEAP32[$3 + 68 >> 2] - HEAP16[(HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) | 0) + 2 >> 1] | 0, HEAP16[HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 72 >> 2] << 2) >> 1] - HEAP16[HEAP32[$3 + 80 >> 2] + (HEAP32[$3 + 76 >> 2] << 2) >> 1] | 0) | 0) / HEAP32[$3 + 28 >> 2] | 0);
        HEAP8[HEAP32[$3 + 32 >> 2] + $0 | 0] = HEAP32[$3 + 28 >> 2] > 1;
        HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] + 1;
       }
      }
     }
     HEAP32[$3 + 72 >> 2] = HEAP32[$3 + 76 >> 2];
     HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$3 + 76 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 76 >> 2] < (HEAP32[$3 + 32 >> 2] - 1 | 0)) {
     if (HEAP16[(HEAP32[$3 + 76 >> 2] << 1) + $4 >> 1] > HEAP16[(HEAP32[$3 + 76 >> 2] + 1 << 1) + $4 >> 1]) {
      HEAP16[$3 + 26 >> 1] = HEAPU16[(HEAP32[$3 + 76 >> 2] << 1) + $4 >> 1];
      HEAP16[(HEAP32[$3 + 76 >> 2] << 1) + $4 >> 1] = HEAPU16[(HEAP32[$3 + 76 >> 2] + 1 << 1) + $4 >> 1];
      HEAP16[(HEAP32[$3 + 76 >> 2] + 1 << 1) + $4 >> 1] = HEAPU16[$3 + 26 >> 1];
      HEAP8[$3 + 25 | 0] = HEAP8[HEAP32[$3 + 76 >> 2] + $0 | 0] & 1;
      HEAP8[HEAP32[$3 + 76 >> 2] + $0 | 0] = HEAP8[(HEAP32[$3 + 76 >> 2] + 1 | 0) + $0 | 0] & 1;
      HEAP8[(HEAP32[$3 + 76 >> 2] + 1 | 0) + $0 | 0] = HEAP8[$3 + 25 | 0] & 1;
      if (HEAP32[$3 + 76 >> 2]) {
       HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] - 1;
      }
      continue;
     }
     HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$3 + 20 >> 2] = 0;
   HEAP32[$3 + 16 >> 2] = 0;
   HEAP32[$3 + 76 >> 2] = 0;
   while (1) {
    label$21: {
     if (HEAP32[$3 + 76 >> 2] >= HEAP32[$3 + 32 >> 2]) {
      break label$21;
     }
     if (!HEAP32[$3 + 16 >> 2]) {
      HEAP32[$3 + 20 >> 2] = HEAP16[(HEAP32[$3 + 76 >> 2] << 1) + $4 >> 1];
     }
     label$23: {
      if (HEAP8[HEAP32[$3 + 76 >> 2] + $0 | 0] & 1) {
       HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
       break label$23;
      }
      HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] - 1;
     }
     if (!(HEAP32[$3 + 76 >> 2] != (HEAP32[$3 + 32 >> 2] - 1 | 0) ? HEAP32[$3 + 16 >> 2] : 0)) {
      HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 20 >> 2] + 15 >> 4;
      HEAP32[$3 + 8 >> 2] = HEAP16[(HEAP32[$3 + 76 >> 2] << 1) + $4 >> 1] + 15 >> 4;
      if (HEAP32[$3 + 8 >> 2] > HEAP32[$3 + 12 >> 2]) {
       $1 = HEAP32[$3 + 92 >> 2];
       graphicsFillRectDevice(HEAP32[$3 + 92 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 40 >> 2], HEAP32[$3 + 8 >> 2] - 1 | 0, HEAP32[$3 + 40 >> 2], HEAPU8[$1 + 17 | 0] | HEAPU8[$1 + 18 | 0] << 8 | (HEAPU8[$1 + 19 | 0] << 16 | HEAPU8[$1 + 20 | 0] << 24));
      }
     }
     if (jspIsInterrupted() & 1) {
      break label$21;
     }
     HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
     continue;
    }
    break;
   }
   $4 = HEAP32[$3 + 36 >> 2];
   HEAP32[$3 + 68 >> 2] = HEAP32[$3 + 68 >> 2] + 16;
   continue;
  }
  break;
 }
 __stack_pointer = $3 + 96 | 0;
}

function void_20tflite__reference_ops__Softmax_signed_20char_2c_20signed_20char__28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 208 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 204 >> 2] = $0;
 HEAP32[$5 + 200 >> 2] = $1;
 HEAP32[$5 + 196 >> 2] = $2;
 HEAP32[$5 + 192 >> 2] = $3;
 HEAP32[$5 + 188 >> 2] = $4;
 HEAP32[$5 + 184 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 8 >> 2];
 HEAP32[$5 + 180 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 12 >> 2];
 HEAP32[$5 + 176 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 24 >> 2];
 HEAP32[$5 + 172 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 200 >> 2]) - 1;
 HEAP32[$5 + 168 >> 2] = tflite__MatchingFlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 200 >> 2], HEAP32[$5 + 172 >> 2], HEAP32[$5 + 192 >> 2]);
 HEAP32[$5 + 164 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 200 >> 2], HEAP32[$5 + 172 >> 2], HEAP32[$5 + 192 >> 2], HEAP32[$5 + 172 >> 2]);
 HEAP32[$5 + 160 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 160 >> 2] < HEAP32[$5 + 168 >> 2]) {
   HEAP8[$5 + 159 | 0] = std____2__numeric_limits_signed_20char___min_28_29();
   HEAP32[$5 + 152 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 152 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP8[$5 + 159 | 0] = HEAPU8[signed_20char_20const__20std____2__max_signed_20char__28signed_20char_20const__2c_20signed_20char_20const__29($5 + 159 | 0, HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 152 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0) | 0];
     HEAP32[$5 + 152 >> 2] = HEAP32[$5 + 152 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 144 >> 2] = gemmlowp__FixedPoint_int_2c_2012___Zero_28_29();
   HEAP32[$5 + 140 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 140 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP32[$5 + 136 >> 2] = HEAP8[HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 140 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] - HEAP8[$5 + 159 | 0];
     if (HEAP32[$5 + 136 >> 2] >= HEAP32[$5 + 176 >> 2]) {
      HEAP32[$5 + 132 >> 2] = tflite__MultiplyByQuantizedMultiplierGreaterThanOne_28int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 184 >> 2], HEAP32[$5 + 180 >> 2]);
      HEAP32[$5 + 128 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(HEAP32[$5 + 132 >> 2]);
      HEAP32[$5 + 112 >> 2] = HEAP32[$5 + 144 >> 2];
      HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 128 >> 2];
      HEAP32[$5 + 96 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_negative_values_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$5 + 88 >> 2]);
      HEAP32[$5 + 104 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__Rescale_12_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$5 + 96 >> 2]);
      HEAP32[$5 + 120 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__operator__int_2c_2012__28gemmlowp__FixedPoint_int_2c_2012__2c_20gemmlowp__FixedPoint_int_2c_2012__29(HEAP32[$5 + 112 >> 2], HEAP32[$5 + 104 >> 2]);
      HEAP32[$5 + 144 >> 2] = HEAP32[$5 + 120 >> 2];
     }
     HEAP32[$5 + 140 >> 2] = HEAP32[$5 + 140 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 80 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromRaw_28int_29(tflite__GetReciprocal_28int_2c_20int_2c_20int__29(HEAP32[gemmlowp__FixedPoint_int_2c_2012___raw_28_29($5 + 144 | 0) >> 2], 12, $5 + 84 | 0));
   HEAP32[$5 + 76 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP32[$5 + 72 >> 2] = HEAP8[HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 76 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] - HEAP8[$5 + 159 | 0];
     label$10: {
      if (HEAP32[$5 + 72 >> 2] >= HEAP32[$5 + 176 >> 2]) {
       HEAP32[$5 + 68 >> 2] = tflite__MultiplyByQuantizedMultiplierGreaterThanOne_28int_2c_20int_2c_20int_29(HEAP32[$5 + 72 >> 2], HEAP32[$5 + 184 >> 2], HEAP32[$5 + 180 >> 2]);
       HEAP32[$5 + 64 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(HEAP32[$5 + 68 >> 2]);
       HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 64 >> 2];
       HEAP32[$5 + 56 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_negative_values_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$5 + 48 >> 2]);
       HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 80 >> 2];
       HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 56 >> 2];
       HEAP32[$5 + 40 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$5 + 32 >> 2], HEAP32[$5 + 24 >> 2]);
       HEAP32[$5 + 44 >> 2] = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($5 + 40 | 0) >> 2], HEAP32[$5 + 84 >> 2] + 23 | 0);
       HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 44 >> 2] + (std____2__numeric_limits_signed_20char___min_28_29() << 24 >> 24);
       HEAP32[$5 + 16 >> 2] = std____2__numeric_limits_signed_20char___max_28_29() << 24 >> 24;
       $0 = int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($5 + 20 | 0, $5 + 16 | 0);
       HEAP32[$5 + 12 >> 2] = std____2__numeric_limits_signed_20char___min_28_29() << 24 >> 24;
       $0 = int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($0, $5 + 12 | 0);
       HEAP8[HEAP32[$5 + 188 >> 2] + (HEAP32[$5 + 76 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] = HEAP32[$0 >> 2];
       break label$10;
      }
      $0 = std____2__numeric_limits_signed_20char___min_28_29();
      HEAP8[HEAP32[$5 + 188 >> 2] + (HEAP32[$5 + 76 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] = $0;
     }
     HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 160 >> 2] = HEAP32[$5 + 160 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 208 | 0;
}

function tflite__reference_integer_ops__MaxPool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 144 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 140 >> 2] = $0;
 HEAP32[$5 + 136 >> 2] = $1;
 HEAP32[$5 + 132 >> 2] = $2;
 HEAP32[$5 + 128 >> 2] = $3;
 HEAP32[$5 + 124 >> 2] = $4;
 label$1: {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2] > HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2] < std____2__numeric_limits_signed_20char___min_28_29() << 24 >> 24) {
   break label$2;
  }
 }
 label$3: {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2] > std____2__numeric_limits_signed_20char___max_28_29() << 24 >> 24) {
   break label$3;
  }
 }
 label$4: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 136 >> 2]) | 0) != 4) {
   break label$4;
  }
 }
 label$5: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 128 >> 2]) | 0) != 4) {
   break label$5;
  }
 }
 HEAP32[$5 + 120 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 0, HEAP32[$5 + 128 >> 2], 0);
 HEAP32[$5 + 116 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 3, HEAP32[$5 + 128 >> 2], 3);
 HEAP32[$5 + 112 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 1);
 HEAP32[$5 + 108 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 2);
 HEAP32[$5 + 104 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 1);
 HEAP32[$5 + 100 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 2);
 HEAP32[$5 + 96 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 12 >> 2];
 HEAP32[$5 + 92 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 16 >> 2];
 HEAP32[$5 + 88 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 88 >> 2] < HEAP32[$5 + 120 >> 2]) {
   HEAP32[$5 + 84 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 84 >> 2] < HEAP32[$5 + 104 >> 2]) {
     HEAP32[$5 + 80 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 80 >> 2] < HEAP32[$5 + 100 >> 2]) {
       HEAP32[$5 + 76 >> 2] = 0;
       while (1) {
        if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 116 >> 2]) {
         HEAP32[$5 + 72 >> 2] = Math_imul(HEAP32[$5 + 80 >> 2], HEAP32[$5 + 92 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 2 >> 1];
         HEAP32[$5 + 68 >> 2] = Math_imul(HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 4 >> 1];
         HEAP32[$5 + 60 >> 2] = 0;
         HEAP32[$5 + 56 >> 2] = 0 - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 64 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 60 | 0, $5 + 56 | 0) >> 2];
         $0 = HEAP32[$5 + 140 >> 2];
         HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 108 >> 2] - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 52 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0 + 24 | 0, $5 + 48 | 0) >> 2];
         HEAP32[$5 + 40 >> 2] = 0;
         HEAP32[$5 + 36 >> 2] = 0 - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 44 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 40 | 0, $5 + 36 | 0) >> 2];
         $0 = HEAP32[$5 + 140 >> 2];
         HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 112 >> 2] - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 32 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0 + 20 | 0, $5 + 28 | 0) >> 2];
         HEAP8[$5 + 27 | 0] = std____2__numeric_limits_signed_20char___lowest_28_29();
         HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 44 >> 2];
         while (1) {
          if (HEAP32[$5 + 20 >> 2] < HEAP32[$5 + 32 >> 2]) {
           HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 64 >> 2];
           while (1) {
            if (HEAP32[$5 + 16 >> 2] < HEAP32[$5 + 52 >> 2]) {
             HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 72 >> 2] + HEAP32[$5 + 16 >> 2];
             HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 68 >> 2] + HEAP32[$5 + 20 >> 2];
             HEAP8[$5 + 27 | 0] = HEAPU8[signed_20char_20const__20std____2__max_signed_20char__28signed_20char_20const__2c_20signed_20char_20const__29($5 + 27 | 0, HEAP32[$5 + 132 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 76 >> 2]) | 0) | 0];
             HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAP8[$5 + 7 | 0] = HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2];
         HEAP8[$5 + 27 | 0] = HEAPU8[signed_20char_20const__20std____2__max_signed_20char__28signed_20char_20const__2c_20signed_20char_20const__29($5 + 27 | 0, $5 + 7 | 0) | 0];
         HEAP8[$5 + 6 | 0] = HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2];
         HEAP8[$5 + 27 | 0] = HEAPU8[signed_20char_20const__20std____2__min_signed_20char__28signed_20char_20const__2c_20signed_20char_20const__29($5 + 27 | 0, $5 + 6 | 0) | 0];
         $0 = HEAPU8[$5 + 27 | 0];
         HEAP8[HEAP32[$5 + 124 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 128 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2]) | 0] = $0;
         HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 80 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 84 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 144 | 0;
}

function void_20tflite__reference_ops__Softmax_signed_20char_2c_20short__28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20short__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 208 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 204 >> 2] = $0;
 HEAP32[$5 + 200 >> 2] = $1;
 HEAP32[$5 + 196 >> 2] = $2;
 HEAP32[$5 + 192 >> 2] = $3;
 HEAP32[$5 + 188 >> 2] = $4;
 HEAP32[$5 + 184 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 8 >> 2];
 HEAP32[$5 + 180 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 12 >> 2];
 HEAP32[$5 + 176 >> 2] = HEAP32[HEAP32[$5 + 204 >> 2] + 24 >> 2];
 HEAP32[$5 + 172 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 200 >> 2]) - 1;
 HEAP32[$5 + 168 >> 2] = tflite__MatchingFlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 200 >> 2], HEAP32[$5 + 172 >> 2], HEAP32[$5 + 192 >> 2]);
 HEAP32[$5 + 164 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 200 >> 2], HEAP32[$5 + 172 >> 2], HEAP32[$5 + 192 >> 2], HEAP32[$5 + 172 >> 2]);
 HEAP32[$5 + 160 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 160 >> 2] < HEAP32[$5 + 168 >> 2]) {
   HEAP8[$5 + 159 | 0] = std____2__numeric_limits_signed_20char___min_28_29();
   HEAP32[$5 + 152 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 152 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP8[$5 + 159 | 0] = HEAPU8[signed_20char_20const__20std____2__max_signed_20char__28signed_20char_20const__2c_20signed_20char_20const__29($5 + 159 | 0, HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 152 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0) | 0];
     HEAP32[$5 + 152 >> 2] = HEAP32[$5 + 152 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 144 >> 2] = gemmlowp__FixedPoint_int_2c_2012___Zero_28_29();
   HEAP32[$5 + 140 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 140 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP32[$5 + 136 >> 2] = HEAP8[HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 140 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] - HEAP8[$5 + 159 | 0];
     if (HEAP32[$5 + 136 >> 2] >= HEAP32[$5 + 176 >> 2]) {
      HEAP32[$5 + 132 >> 2] = tflite__MultiplyByQuantizedMultiplierGreaterThanOne_28int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 184 >> 2], HEAP32[$5 + 180 >> 2]);
      HEAP32[$5 + 128 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(HEAP32[$5 + 132 >> 2]);
      HEAP32[$5 + 112 >> 2] = HEAP32[$5 + 144 >> 2];
      HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 128 >> 2];
      HEAP32[$5 + 96 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_negative_values_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$5 + 88 >> 2]);
      HEAP32[$5 + 104 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__Rescale_12_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$5 + 96 >> 2]);
      HEAP32[$5 + 120 >> 2] = gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__operator__int_2c_2012__28gemmlowp__FixedPoint_int_2c_2012__2c_20gemmlowp__FixedPoint_int_2c_2012__29(HEAP32[$5 + 112 >> 2], HEAP32[$5 + 104 >> 2]);
      HEAP32[$5 + 144 >> 2] = HEAP32[$5 + 120 >> 2];
     }
     HEAP32[$5 + 140 >> 2] = HEAP32[$5 + 140 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 80 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromRaw_28int_29(tflite__GetReciprocal_28int_2c_20int_2c_20int__29(HEAP32[gemmlowp__FixedPoint_int_2c_2012___raw_28_29($5 + 144 | 0) >> 2], 12, $5 + 84 | 0));
   HEAP32[$5 + 76 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 164 >> 2]) {
     HEAP32[$5 + 72 >> 2] = HEAP8[HEAP32[$5 + 196 >> 2] + (HEAP32[$5 + 76 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) | 0) | 0] - HEAP8[$5 + 159 | 0];
     label$10: {
      if (HEAP32[$5 + 72 >> 2] >= HEAP32[$5 + 176 >> 2]) {
       HEAP32[$5 + 68 >> 2] = tflite__MultiplyByQuantizedMultiplierGreaterThanOne_28int_2c_20int_2c_20int_29(HEAP32[$5 + 72 >> 2], HEAP32[$5 + 184 >> 2], HEAP32[$5 + 180 >> 2]);
       HEAP32[$5 + 64 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(HEAP32[$5 + 68 >> 2]);
       HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 64 >> 2];
       HEAP32[$5 + 56 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_negative_values_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29(HEAP32[$5 + 48 >> 2]);
       HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 80 >> 2];
       HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 56 >> 2];
       HEAP32[$5 + 40 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$5 + 32 >> 2], HEAP32[$5 + 24 >> 2]);
       HEAP32[$5 + 44 >> 2] = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($5 + 40 | 0) >> 2], HEAP32[$5 + 84 >> 2] + 15 | 0);
       HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 44 >> 2] + (std____2__numeric_limits_short___min_28_29() << 16 >> 16);
       HEAP32[$5 + 16 >> 2] = std____2__numeric_limits_short___max_28_29() << 16 >> 16;
       $0 = int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($5 + 20 | 0, $5 + 16 | 0);
       HEAP32[$5 + 12 >> 2] = std____2__numeric_limits_short___min_28_29() << 16 >> 16;
       $0 = int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($0, $5 + 12 | 0);
       HEAP16[HEAP32[$5 + 188 >> 2] + (HEAP32[$5 + 76 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) << 1) >> 1] = HEAP32[$0 >> 2];
       break label$10;
      }
      $0 = std____2__numeric_limits_short___min_28_29();
      HEAP16[HEAP32[$5 + 188 >> 2] + (HEAP32[$5 + 76 >> 2] + Math_imul(HEAP32[$5 + 160 >> 2], HEAP32[$5 + 164 >> 2]) << 1) >> 1] = $0;
     }
     HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 160 >> 2] = HEAP32[$5 + 160 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 208 | 0;
}

function matchcharacter($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 HEAP32[HEAP32[$4 + 32 >> 2] >> 2] = 1;
 HEAP8[$4 + 27 | 0] = jsvStringIteratorGetChar_5(HEAP32[$4 + 36 >> 2]);
 label$1: {
  if (HEAP8[HEAP32[$4 + 40 >> 2]] == 46) {
   HEAP8[$4 + 47 | 0] = 1;
   break label$1;
  }
  if (HEAP8[HEAP32[$4 + 40 >> 2]] == 91) {
   HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] = 1;
   HEAP8[$4 + 26 | 0] = HEAP8[HEAP32[$4 + 40 >> 2] + 1 | 0] == 94;
   if (HEAP8[$4 + 26 | 0] & 1) {
    $0 = HEAP32[$4 + 32 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
   }
   HEAP8[$4 + 25 | 0] = 0;
   while (1) {
    $0 = 0;
    $0 = HEAP8[HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0] ? HEAP8[HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0] != 93 : $0;
    if ($0) {
     if (HEAP8[HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0] == 46) {
      HEAP8[$4 + 25 | 0] = HEAP8[$4 + 25 | 0] & 1 | HEAP8[$4 + 27 | 0] == 46;
      $0 = HEAP32[$4 + 32 >> 2];
      HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
      continue;
     }
     HEAP8[$4 + 25 | 0] = matchcharacter(HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0, HEAP32[$4 + 36 >> 2], $4 + 20 | 0, HEAP32[$4 + 28 >> 2]) & 1 | HEAP8[$4 + 25 | 0] & 1;
     $0 = HEAP32[$4 + 32 >> 2];
     HEAP32[$0 >> 2] = HEAP32[$4 + 20 >> 2] + HEAP32[$0 >> 2];
     continue;
    }
    break;
   }
   label$9: {
    if (HEAP8[HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0] == 93) {
     $0 = HEAP32[$4 + 32 >> 2];
     HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
     break label$9;
    }
    jsExceptionHere(1, 116469, 0);
    HEAP8[$4 + 47 | 0] = 0;
    break label$1;
   }
   HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] = 0;
   HEAP8[$4 + 47 | 0] = (HEAP8[$4 + 25 | 0] & 1) != (HEAP8[$4 + 26 | 0] & 1);
   break label$1;
  }
  HEAP8[$4 + 19 | 0] = HEAPU8[HEAP32[$4 + 40 >> 2]];
  label$11: {
   if (HEAP8[$4 + 19 | 0] != 92) {
    break label$11;
   }
   HEAP32[HEAP32[$4 + 32 >> 2] >> 2] = 2;
   HEAP8[$4 + 19 | 0] = HEAPU8[HEAP32[$4 + 40 >> 2] + 1 | 0];
   if (HEAP8[$4 + 19 | 0] == 100) {
    HEAP8[$4 + 47 | 0] = isNumeric(HEAP8[$4 + 27 | 0]) & 1;
    break label$1;
   }
   if (HEAP8[$4 + 19 | 0] == 68) {
    HEAP8[$4 + 47 | 0] = (isNumeric(HEAP8[$4 + 27 | 0]) ^ -1) & 1;
    break label$1;
   }
   if (HEAP8[$4 + 19 | 0] == 102) {
    HEAP8[$4 + 19 | 0] = 12;
    break label$11;
   }
   if (HEAP8[$4 + 19 | 0] == 98) {
    HEAP8[$4 + 19 | 0] = 8;
    break label$11;
   }
   if (HEAP8[$4 + 19 | 0] == 110) {
    HEAP8[$4 + 19 | 0] = 10;
    break label$11;
   }
   if (HEAP8[$4 + 19 | 0] == 114) {
    HEAP8[$4 + 19 | 0] = 13;
    break label$11;
   }
   if (HEAP8[$4 + 19 | 0] == 115) {
    HEAP8[$4 + 47 | 0] = isWhitespace(HEAP8[$4 + 27 | 0]) & 1;
    break label$1;
   }
   if (HEAP8[$4 + 19 | 0] == 83) {
    HEAP8[$4 + 47 | 0] = (isWhitespace(HEAP8[$4 + 27 | 0]) ^ -1) & 1;
    break label$1;
   }
   if (HEAP8[$4 + 19 | 0] == 116) {
    HEAP8[$4 + 19 | 0] = 9;
    break label$11;
   }
   if (HEAP8[$4 + 19 | 0] == 118) {
    HEAP8[$4 + 19 | 0] = 11;
    break label$11;
   }
   if (HEAP8[$4 + 19 | 0] == 119) {
    $0 = 1;
    label$23: {
     if (isNumeric(HEAP8[$4 + 27 | 0]) & 1) {
      break label$23;
     }
     $0 = 1;
     if (isAlpha(HEAP8[$4 + 27 | 0]) & 1) {
      break label$23;
     }
     $0 = HEAP8[$4 + 27 | 0] == 95;
    }
    HEAP8[$4 + 47 | 0] = $0;
    break label$1;
   }
   if (HEAP8[$4 + 19 | 0] == 87) {
    $0 = 1;
    label$25: {
     if (isNumeric(HEAP8[$4 + 27 | 0]) & 1) {
      break label$25;
     }
     $0 = 1;
     if (isAlpha(HEAP8[$4 + 27 | 0]) & 1) {
      break label$25;
     }
     $0 = HEAP8[$4 + 27 | 0] == 95;
    }
    HEAP8[$4 + 47 | 0] = ($0 ^ -1) & 1;
    break label$1;
   }
   if (HEAP8[$4 + 19 | 0] == 48) {
    HEAP8[$4 + 19 | 0] = 0;
    break label$11;
   }
   if (!(HEAP8[$4 + 19 | 0] < 49 | HEAP8[$4 + 19 | 0] > 57)) {
    jsExceptionHere(1, 133474, 0);
    HEAP8[$4 + 47 | 0] = 0;
    break label$1;
   }
   if (!(!HEAP8[HEAP32[$4 + 40 >> 2] + 3 | 0] | (!HEAP8[HEAP32[$4 + 40 >> 2] + 2 | 0] | HEAP8[$4 + 19 | 0] != 120))) {
    HEAP32[HEAP32[$4 + 32 >> 2] >> 2] = 4;
    HEAP8[$4 + 19 | 0] = hexToByte(HEAP8[HEAP32[$4 + 40 >> 2] + 2 | 0], HEAP8[HEAP32[$4 + 40 >> 2] + 3 | 0]);
   }
  }
  if (!(!(HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] & 1) | HEAP8[HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0] != 45 | HEAP8[HEAP32[$4 + 40 >> 2] + (HEAP32[HEAP32[$4 + 32 >> 2] >> 2] + 1 | 0) | 0] == 93)) {
   HEAP16[HEAP32[$4 + 28 >> 2] + 10 >> 1] = HEAP8[$4 + 19 | 0];
   $0 = HEAP32[$4 + 32 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
   HEAP8[$4 + 11 | 0] = matchcharacter(HEAP32[$4 + 40 >> 2] + HEAP32[HEAP32[$4 + 32 >> 2] >> 2] | 0, HEAP32[$4 + 36 >> 2], $4 + 12 | 0, HEAP32[$4 + 28 >> 2]) & 1;
   $0 = HEAP32[$4 + 32 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$4 + 12 >> 2] + HEAP32[$0 >> 2];
   HEAP8[$4 + 47 | 0] = HEAP8[$4 + 11 | 0] & 1;
   break label$1;
  }
  if (HEAP8[HEAP32[$4 + 28 >> 2] + 8 | 0] & 1) {
   HEAP8[$4 + 27 | 0] = charToLowerCase(HEAP8[$4 + 27 | 0]);
   HEAP8[$4 + 19 | 0] = charToLowerCase(HEAP8[$4 + 19 | 0]);
  }
  if (HEAP16[HEAP32[$4 + 28 >> 2] + 10 >> 1] != 256) {
   HEAP8[$4 + 10 | 0] = HEAPU16[HEAP32[$4 + 28 >> 2] + 10 >> 1];
   if (HEAP8[HEAP32[$4 + 28 >> 2] + 8 | 0] & 1) {
    HEAP8[$4 + 10 | 0] = charToLowerCase(HEAP8[$4 + 10 | 0]);
   }
   HEAP16[HEAP32[$4 + 28 >> 2] + 10 >> 1] = 256;
   $0 = 0;
   label$33: {
    if (HEAP8[$4 + 27 | 0] < HEAP8[$4 + 10 | 0]) {
     break label$33;
    }
    $0 = 0;
    if (HEAP8[$4 + 27 | 0] > HEAP8[$4 + 19 | 0]) {
     break label$33;
    }
    $0 = HEAP8[$4 + 10 | 0] < HEAP8[$4 + 19 | 0];
   }
   HEAP8[$4 + 47 | 0] = $0;
   break label$1;
  }
  HEAP8[$4 + 47 | 0] = HEAP8[$4 + 19 | 0] == HEAP8[$4 + 27 | 0];
 }
 __stack_pointer = $4 + 48 | 0;
 return HEAP8[$4 + 47 | 0] & 1;
}

function mbedtls_aes_setkey_enc($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      $0 = HEAP32[$3 + 16 >> 2];
      if (($0 | 0) != 128) {
       if (($0 | 0) == 192) {
        break label$5;
       }
       if (($0 | 0) == 256) {
        break label$4;
       }
       break label$3;
      }
      HEAP32[HEAP32[$3 + 24 >> 2] >> 2] = 10;
      break label$2;
     }
     HEAP32[HEAP32[$3 + 24 >> 2] >> 2] = 12;
     break label$2;
    }
    HEAP32[HEAP32[$3 + 24 >> 2] >> 2] = 14;
    break label$2;
   }
   HEAP32[$3 + 28 >> 2] = -32;
   break label$1;
  }
  $0 = HEAP32[$3 + 24 >> 2] + 8 | 0;
  HEAP32[$3 + 8 >> 2] = $0;
  HEAP32[HEAP32[$3 + 24 >> 2] + 4 >> 2] = $0;
  HEAP32[$3 + 12 >> 2] = 0;
  while (1) {
   if (HEAPU32[$3 + 12 >> 2] < HEAP32[$3 + 16 >> 2] >>> 5 >>> 0) {
    HEAP32[HEAP32[$3 + 8 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) >> 2] = HEAPU8[HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) | 0] | HEAPU8[HEAP32[$3 + 20 >> 2] + ((HEAP32[$3 + 12 >> 2] << 2) + 1 | 0) | 0] << 8 | HEAPU8[HEAP32[$3 + 20 >> 2] + ((HEAP32[$3 + 12 >> 2] << 2) + 2 | 0) | 0] << 16 | HEAPU8[HEAP32[$3 + 20 >> 2] + ((HEAP32[$3 + 12 >> 2] << 2) + 3 | 0) | 0] << 24;
    HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
  label$9: {
   label$10: {
    switch (HEAP32[HEAP32[$3 + 24 >> 2] >> 2] - 10 | 0) {
    case 0:
     HEAP32[$3 + 12 >> 2] = 0;
     while (1) {
      if (HEAPU32[$3 + 12 >> 2] < 10) {
       HEAP32[HEAP32[$3 + 8 >> 2] + 16 >> 2] = HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 12 >> 2] >>> 8 & 255) + 171744 | 0] ^ (HEAP32[HEAP32[$3 + 8 >> 2] >> 2] ^ HEAP32[(HEAP32[$3 + 12 >> 2] << 2) + 171696 >> 2]) ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 12 >> 2] >>> 16 & 255) + 171744 | 0] << 8 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 12 >> 2] >>> 24 | 0) + 171744 | 0] << 16 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 12 >> 2] & 255) + 171744 | 0] << 24;
       HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 4 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 16 >> 2];
       HEAP32[HEAP32[$3 + 8 >> 2] + 24 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 8 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2];
       HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 12 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 24 >> 2];
       HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
       HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + 16;
       continue;
      }
      break;
     }
     ;
     break label$9;

    case 2:
     HEAP32[$3 + 12 >> 2] = 0;
     while (1) {
      if (HEAPU32[$3 + 12 >> 2] < 8) {
       HEAP32[HEAP32[$3 + 8 >> 2] + 24 >> 2] = HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2] >>> 8 & 255) + 171744 | 0] ^ (HEAP32[HEAP32[$3 + 8 >> 2] >> 2] ^ HEAP32[(HEAP32[$3 + 12 >> 2] << 2) + 171696 >> 2]) ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2] >>> 16 & 255) + 171744 | 0] << 8 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2] >>> 24 | 0) + 171744 | 0] << 16 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2] & 255) + 171744 | 0] << 24;
       HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 4 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 24 >> 2];
       HEAP32[HEAP32[$3 + 8 >> 2] + 32 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 8 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2];
       HEAP32[HEAP32[$3 + 8 >> 2] + 36 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 12 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 32 >> 2];
       HEAP32[HEAP32[$3 + 8 >> 2] + 40 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 16 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 36 >> 2];
       HEAP32[HEAP32[$3 + 8 >> 2] + 44 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 40 >> 2];
       HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
       HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + 24;
       continue;
      }
      break;
     }
     ;
     break label$9;

    case 4:
     break label$10;

    default:
     break label$9;
    }
   }
   HEAP32[$3 + 12 >> 2] = 0;
   while (1) {
    if (HEAPU32[$3 + 12 >> 2] < 7) {
     HEAP32[HEAP32[$3 + 8 >> 2] + 32 >> 2] = HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2] >>> 8 & 255) + 171744 | 0] ^ (HEAP32[HEAP32[$3 + 8 >> 2] >> 2] ^ HEAP32[(HEAP32[$3 + 12 >> 2] << 2) + 171696 >> 2]) ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2] >>> 16 & 255) + 171744 | 0] << 8 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2] >>> 24 | 0) + 171744 | 0] << 16 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2] & 255) + 171744 | 0] << 24;
     HEAP32[HEAP32[$3 + 8 >> 2] + 36 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 4 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 32 >> 2];
     HEAP32[HEAP32[$3 + 8 >> 2] + 40 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 8 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 36 >> 2];
     HEAP32[HEAP32[$3 + 8 >> 2] + 44 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 12 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 40 >> 2];
     HEAP32[HEAP32[$3 + 8 >> 2] + 48 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 16 >> 2] ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 44 >> 2] & 255) + 171744 | 0] ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 44 >> 2] >>> 8 & 255) + 171744 | 0] << 8 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 44 >> 2] >>> 16 & 255) + 171744 | 0] << 16 ^ HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] + 44 >> 2] >>> 24 | 0) + 171744 | 0] << 24;
     HEAP32[HEAP32[$3 + 8 >> 2] + 52 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 20 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 48 >> 2];
     HEAP32[HEAP32[$3 + 8 >> 2] + 56 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 24 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 52 >> 2];
     HEAP32[HEAP32[$3 + 8 >> 2] + 60 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 28 >> 2] ^ HEAP32[HEAP32[$3 + 8 >> 2] + 56 >> 2];
     HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
     HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + 32;
     continue;
    }
    break;
   }
  }
  HEAP32[$3 + 28 >> 2] = 0;
 }
 return HEAP32[$3 + 28 >> 2];
}

function tflite__reference_ops__MaxPool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 144 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 140 >> 2] = $0;
 HEAP32[$5 + 136 >> 2] = $1;
 HEAP32[$5 + 132 >> 2] = $2;
 HEAP32[$5 + 128 >> 2] = $3;
 HEAP32[$5 + 124 >> 2] = $4;
 label$1: {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2] > HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2] < 0) {
   break label$2;
  }
 }
 label$3: {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2] > 255) {
   break label$3;
  }
 }
 label$4: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 136 >> 2]) | 0) != 4) {
   break label$4;
  }
 }
 label$5: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 128 >> 2]) | 0) != 4) {
   break label$5;
  }
 }
 HEAP32[$5 + 120 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 0, HEAP32[$5 + 128 >> 2], 0);
 HEAP32[$5 + 116 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 3, HEAP32[$5 + 128 >> 2], 3);
 HEAP32[$5 + 112 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 1);
 HEAP32[$5 + 108 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 2);
 HEAP32[$5 + 104 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 1);
 HEAP32[$5 + 100 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 2);
 HEAP32[$5 + 96 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 12 >> 2];
 HEAP32[$5 + 92 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 16 >> 2];
 HEAP32[$5 + 88 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 88 >> 2] < HEAP32[$5 + 120 >> 2]) {
   HEAP32[$5 + 84 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 84 >> 2] < HEAP32[$5 + 104 >> 2]) {
     HEAP32[$5 + 80 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 80 >> 2] < HEAP32[$5 + 100 >> 2]) {
       HEAP32[$5 + 76 >> 2] = 0;
       while (1) {
        if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 116 >> 2]) {
         HEAP32[$5 + 72 >> 2] = Math_imul(HEAP32[$5 + 80 >> 2], HEAP32[$5 + 92 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 2 >> 1];
         HEAP32[$5 + 68 >> 2] = Math_imul(HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 4 >> 1];
         HEAP32[$5 + 60 >> 2] = 0;
         HEAP32[$5 + 56 >> 2] = 0 - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 64 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 60 | 0, $5 + 56 | 0) >> 2];
         $0 = HEAP32[$5 + 140 >> 2];
         HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 108 >> 2] - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 52 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0 + 24 | 0, $5 + 48 | 0) >> 2];
         HEAP32[$5 + 40 >> 2] = 0;
         HEAP32[$5 + 36 >> 2] = 0 - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 44 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 40 | 0, $5 + 36 | 0) >> 2];
         $0 = HEAP32[$5 + 140 >> 2];
         HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 112 >> 2] - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 32 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0 + 20 | 0, $5 + 28 | 0) >> 2];
         HEAP8[$5 + 27 | 0] = 0;
         HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 44 >> 2];
         while (1) {
          if (HEAP32[$5 + 20 >> 2] < HEAP32[$5 + 32 >> 2]) {
           HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 64 >> 2];
           while (1) {
            if (HEAP32[$5 + 16 >> 2] < HEAP32[$5 + 52 >> 2]) {
             HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 72 >> 2] + HEAP32[$5 + 16 >> 2];
             HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 68 >> 2] + HEAP32[$5 + 20 >> 2];
             HEAP8[$5 + 27 | 0] = HEAPU8[unsigned_20char_20const__20std____2__max_unsigned_20char__28unsigned_20char_20const__2c_20unsigned_20char_20const__29($5 + 27 | 0, HEAP32[$5 + 132 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 76 >> 2]) | 0) | 0];
             HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAP8[$5 + 7 | 0] = HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2];
         HEAP8[$5 + 27 | 0] = HEAPU8[unsigned_20char_20const__20std____2__max_unsigned_20char__28unsigned_20char_20const__2c_20unsigned_20char_20const__29($5 + 27 | 0, $5 + 7 | 0) | 0];
         HEAP8[$5 + 6 | 0] = HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2];
         HEAP8[$5 + 27 | 0] = HEAPU8[unsigned_20char_20const__20std____2__min_unsigned_20char__28unsigned_20char_20const__2c_20unsigned_20char_20const__29($5 + 27 | 0, $5 + 6 | 0) | 0];
         $0 = HEAPU8[$5 + 27 | 0];
         HEAP8[HEAP32[$5 + 124 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 128 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2]) | 0] = $0;
         HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 80 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 84 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 144 | 0;
}

function tflite__reference_integer_ops__AveragePool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 144 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 140 >> 2] = $0;
 HEAP32[$5 + 136 >> 2] = $1;
 HEAP32[$5 + 132 >> 2] = $2;
 HEAP32[$5 + 128 >> 2] = $3;
 HEAP32[$5 + 124 >> 2] = $4;
 label$1: {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2] > HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 136 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 128 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 HEAP32[$5 + 120 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 0, HEAP32[$5 + 128 >> 2], 0);
 HEAP32[$5 + 116 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 3, HEAP32[$5 + 128 >> 2], 3);
 HEAP32[$5 + 112 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 1);
 HEAP32[$5 + 108 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 2);
 HEAP32[$5 + 104 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 1);
 HEAP32[$5 + 100 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 2);
 HEAP32[$5 + 96 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 12 >> 2];
 HEAP32[$5 + 92 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 16 >> 2];
 HEAP32[$5 + 88 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 88 >> 2] < HEAP32[$5 + 120 >> 2]) {
   HEAP32[$5 + 84 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 84 >> 2] < HEAP32[$5 + 104 >> 2]) {
     HEAP32[$5 + 80 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 80 >> 2] < HEAP32[$5 + 100 >> 2]) {
       HEAP32[$5 + 76 >> 2] = 0;
       while (1) {
        if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 116 >> 2]) {
         HEAP32[$5 + 72 >> 2] = Math_imul(HEAP32[$5 + 80 >> 2], HEAP32[$5 + 92 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 2 >> 1];
         HEAP32[$5 + 68 >> 2] = Math_imul(HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 4 >> 1];
         HEAP32[$5 + 60 >> 2] = 0;
         HEAP32[$5 + 56 >> 2] = 0 - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 64 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 60 | 0, $5 + 56 | 0) >> 2];
         $0 = HEAP32[$5 + 140 >> 2];
         HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 108 >> 2] - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 52 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0 + 24 | 0, $5 + 48 | 0) >> 2];
         HEAP32[$5 + 40 >> 2] = 0;
         HEAP32[$5 + 36 >> 2] = 0 - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 44 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 40 | 0, $5 + 36 | 0) >> 2];
         $0 = HEAP32[$5 + 140 >> 2];
         HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 112 >> 2] - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 32 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0 + 20 | 0, $5 + 28 | 0) >> 2];
         HEAP32[$5 + 24 >> 2] = 0;
         HEAP32[$5 + 20 >> 2] = 0;
         HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 44 >> 2];
         while (1) {
          if (HEAP32[$5 + 16 >> 2] < HEAP32[$5 + 32 >> 2]) {
           HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 64 >> 2];
           while (1) {
            if (HEAP32[$5 + 12 >> 2] < HEAP32[$5 + 52 >> 2]) {
             HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 72 >> 2] + HEAP32[$5 + 12 >> 2];
             HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 68 >> 2] + HEAP32[$5 + 16 >> 2];
             HEAP32[$5 + 24 >> 2] = HEAP8[HEAP32[$5 + 132 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 4 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 76 >> 2]) | 0] + HEAP32[$5 + 24 >> 2];
             HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
             HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + 1;
           continue;
          }
          break;
         }
         if (HEAP32[$5 + 24 >> 2] > 0) {
          $0 = (HEAP32[$5 + 24 >> 2] + (HEAP32[$5 + 20 >> 2] / 2 | 0) | 0) / HEAP32[$5 + 20 >> 2] | 0;
         } else {
          $0 = (HEAP32[$5 + 24 >> 2] - (HEAP32[$5 + 20 >> 2] / 2 | 0) | 0) / HEAP32[$5 + 20 >> 2] | 0;
         }
         HEAP32[$5 + 24 >> 2] = $0;
         HEAP32[$5 + 24 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 24 | 0, HEAP32[$5 + 140 >> 2] + 28 | 0) >> 2];
         HEAP32[$5 + 24 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($5 + 24 | 0, HEAP32[$5 + 140 >> 2] + 32 | 0) >> 2];
         $0 = HEAP32[$5 + 24 >> 2];
         HEAP8[HEAP32[$5 + 124 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 128 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2]) | 0] = $0;
         HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 80 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 84 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 144 | 0;
}

function jstDumpUtilityTimers() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $0 = __stack_pointer - 528 | 0;
 __stack_pointer = $0;
 jshInterruptOff();
 HEAP32[$0 + 524 >> 2] = 0;
 while (1) {
  if (HEAP32[$0 + 524 >> 2] < 16) {
   $1 = Math_imul(HEAP32[$0 + 524 >> 2], 25) + 366368 | 0;
   $2 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
   $3 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
   $4 = $2;
   $5 = ($0 + 112 | 0) + Math_imul(HEAP32[$0 + 524 >> 2], 25) | 0;
   $2 = $5;
   HEAP8[$2 | 0] = $4;
   HEAP8[$2 + 1 | 0] = $4 >>> 8;
   HEAP8[$2 + 2 | 0] = $4 >>> 16;
   HEAP8[$2 + 3 | 0] = $4 >>> 24;
   HEAP8[$2 + 4 | 0] = $3;
   HEAP8[$2 + 5 | 0] = $3 >>> 8;
   HEAP8[$2 + 6 | 0] = $3 >>> 16;
   HEAP8[$2 + 7 | 0] = $3 >>> 24;
   HEAP8[$2 + 24 | 0] = HEAPU8[$1 + 24 | 0];
   $2 = HEAPU8[$1 + 20 | 0] | HEAPU8[$1 + 21 | 0] << 8 | (HEAPU8[$1 + 22 | 0] << 16 | HEAPU8[$1 + 23 | 0] << 24);
   $3 = HEAPU8[$1 + 16 | 0] | HEAPU8[$1 + 17 | 0] << 8 | (HEAPU8[$1 + 18 | 0] << 16 | HEAPU8[$1 + 19 | 0] << 24);
   $4 = $3;
   $3 = $5;
   HEAP8[$3 + 16 | 0] = $4;
   HEAP8[$3 + 17 | 0] = $4 >>> 8;
   HEAP8[$3 + 18 | 0] = $4 >>> 16;
   HEAP8[$3 + 19 | 0] = $4 >>> 24;
   HEAP8[$3 + 20 | 0] = $2;
   HEAP8[$3 + 21 | 0] = $2 >>> 8;
   HEAP8[$3 + 22 | 0] = $2 >>> 16;
   HEAP8[$3 + 23 | 0] = $2 >>> 24;
   $3 = HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8 | (HEAPU8[$1 + 14 | 0] << 16 | HEAPU8[$1 + 15 | 0] << 24);
   $2 = HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24);
   $4 = $2;
   $2 = $5;
   HEAP8[$2 + 8 | 0] = $4;
   HEAP8[$2 + 9 | 0] = $4 >>> 8;
   HEAP8[$2 + 10 | 0] = $4 >>> 16;
   HEAP8[$2 + 11 | 0] = $4 >>> 24;
   HEAP8[$2 + 12 | 0] = $3;
   HEAP8[$2 + 13 | 0] = $3 >>> 8;
   HEAP8[$2 + 14 | 0] = $3 >>> 16;
   HEAP8[$2 + 15 | 0] = $3 >>> 24;
   HEAP32[$0 + 524 >> 2] = HEAP32[$0 + 524 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP8[$0 + 111 | 0] = HEAPU8[366353];
 HEAP8[$0 + 110 | 0] = HEAPU8[366354];
 jshInterruptOn();
 HEAP32[$0 + 64 >> 2] = HEAP8[366355] & 1 ? 128472 : 130136;
 jsiConsolePrintf(146608, $0 - -64 | 0);
 HEAP8[$0 + 109 | 0] = HEAPU8[$0 + 110 | 0];
 HEAP8[$0 + 108 | 0] = 0;
 while (1) {
  if (HEAPU8[$0 + 109 | 0] != HEAPU8[$0 + 111 | 0]) {
   HEAP8[$0 + 108 | 0] = 1;
   $1 = ($0 + 112 | 0) + Math_imul(HEAPU8[$0 + 109 | 0], 25) | 0;
   HEAP8[$0 + 104 | 0] = HEAPU8[$1 + 24 | 0];
   $3 = HEAPU8[$1 + 16 | 0] | HEAPU8[$1 + 17 | 0] << 8 | (HEAPU8[$1 + 18 | 0] << 16 | HEAPU8[$1 + 19 | 0] << 24);
   $2 = HEAPU8[$1 + 20 | 0] | HEAPU8[$1 + 21 | 0] << 8 | (HEAPU8[$1 + 22 | 0] << 16 | HEAPU8[$1 + 23 | 0] << 24);
   HEAP32[$0 + 96 >> 2] = $3;
   HEAP32[$0 + 100 >> 2] = $2;
   $3 = HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8 | (HEAPU8[$1 + 14 | 0] << 16 | HEAPU8[$1 + 15 | 0] << 24);
   $2 = HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24);
   HEAP32[$0 + 88 >> 2] = $2;
   HEAP32[$0 + 92 >> 2] = $3;
   $2 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
   $3 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
   HEAP32[$0 + 80 >> 2] = $3;
   HEAP32[$0 + 84 >> 2] = $2;
   $2 = HEAPU8[$0 + 80 | 0] | HEAPU8[$0 + 81 | 0] << 8 | (HEAPU8[$0 + 82 | 0] << 16 | HEAPU8[$0 + 83 | 0] << 24);
   $3 = $2 >> 31;
   $6 = jshGetMillisecondsFromTime($2, $3) * 1e3;
   label$5: {
    if (Math_abs($6) < 2147483648) {
     $2 = ~~$6;
     break label$5;
    }
    $2 = -2147483648;
   }
   $3 = HEAPU8[$0 + 84 | 0] | HEAPU8[$0 + 85 | 0] << 8 | (HEAPU8[$0 + 86 | 0] << 16 | HEAPU8[$0 + 87 | 0] << 24);
   $6 = jshGetMillisecondsFromTime($3, 0) * 1e3;
   label$7: {
    if (Math_abs($6) < 2147483648) {
     $5 = ~~$6;
     break label$7;
    }
    $5 = -2147483648;
   }
   HEAP32[$0 + 48 >> 2] = $2;
   HEAP32[$0 + 52 >> 2] = $5;
   jsiConsolePrintf(146282, $0 + 48 | 0);
   label$9: {
    label$10: {
     switch (HEAPU8[$0 + 104 | 0] - 1 | 0) {
     case 0:
      jsiConsolePrintf(147299, 0);
      break label$9;

     case 1:
      jsiConsolePrintf(146227, 0);
      HEAP32[$0 + 524 >> 2] = 0;
      while (1) {
       if (HEAP32[$0 + 524 >> 2] < 8) {
        if (HEAPU8[HEAP32[$0 + 524 >> 2] + ($0 + 88 | 0) | 0] != 255) {
         $2 = HEAPU8[HEAP32[$0 + 524 >> 2] + ($0 + 88 | 0) | 0];
         HEAP32[$0 + 20 >> 2] = HEAPU8[$0 + 96 | 0] >> HEAP32[$0 + 524 >> 2] & 1;
         HEAP32[$0 + 16 >> 2] = $2;
         jsiConsolePrintf(141306, $0 + 16 | 0);
        }
        HEAP32[$0 + 524 >> 2] = HEAP32[$0 + 524 >> 2] + 1;
        continue;
       }
       break;
      }
      ;
      jsiConsolePrintf(148266, 0);
      break label$9;

     case 3:
      jsiConsolePrintf(147438, 0);
      break label$9;

     case 4:
      jsiConsolePrintf(147443, 0);
      break label$9;

     case 5:
      jsiConsolePrintf(147448, 0);
      break label$9;

     case 6:
      jsiConsolePrintf(147454, 0);
      break label$9;

     case 2:
      $2 = HEAPU8[$0 + 88 | 0] | HEAPU8[$0 + 89 | 0] << 8 | (HEAPU8[$0 + 90 | 0] << 16 | HEAPU8[$0 + 91 | 0] << 24);
      HEAP32[$0 + 36 >> 2] = HEAPU8[$0 + 92 | 0] | HEAPU8[$0 + 93 | 0] << 8 | (HEAPU8[$0 + 94 | 0] << 16 | HEAPU8[$0 + 95 | 0] << 24);
      HEAP32[$0 + 32 >> 2] = $2;
      jsiConsolePrintf(148056, $0 + 32 | 0);
      break label$9;

     default:
      break label$10;
     }
    }
    HEAP32[$0 >> 2] = HEAPU8[$0 + 104 | 0];
    jsiConsolePrintf(147292, $0);
   }
   HEAP8[$0 + 109 | 0] = HEAPU8[$0 + 109 | 0] + 1 & 15;
   continue;
  }
  break;
 }
 if (!(HEAP8[$0 + 108 | 0] & 1)) {
  jsiConsolePrintf(147810, 0);
 }
 __stack_pointer = $0 + 528 | 0;
}

function tflite__ops__micro__activations___28anonymous_20namespace_29__CalculateSoftmaxParams_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20TfLiteSoftmaxParams_20const__2c_20tflite__SoftmaxParams__29($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $5 = __stack_pointer - 176 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 168 >> 2] = $0;
 HEAP32[$5 + 164 >> 2] = $1;
 HEAP32[$5 + 160 >> 2] = $2;
 HEAP32[$5 + 156 >> 2] = $3;
 HEAP32[$5 + 152 >> 2] = $4;
 label$1: {
  label$2: {
   if (!(HEAP32[HEAP32[$5 + 164 >> 2] + 28 >> 2] != 3 & HEAP32[HEAP32[$5 + 164 >> 2] + 28 >> 2] != 9)) {
    label$5: {
     if (HEAP32[HEAP32[$5 + 164 >> 2] + 28 >> 2] == 3) {
      if (HEAP32[HEAP32[$5 + 160 >> 2] + 28 >> 2] != 3) {
       $0 = HEAP32[HEAP32[$5 + 168 >> 2] + 20 >> 2];
       $1 = HEAP32[$5 + 168 >> 2];
       $2 = TfLiteTypeGetName(HEAP32[HEAP32[$5 + 160 >> 2] + 28 >> 2]);
       HEAP32[$5 + 12 >> 2] = TfLiteTypeGetName(3);
       HEAP32[$5 + 8 >> 2] = $2;
       HEAP32[$5 + 4 >> 2] = 139132;
       HEAP32[$5 >> 2] = 132215;
       FUNCTION_TABLE[$0 | 0]($1, 142883, $5);
       HEAP32[$5 + 172 >> 2] = 1;
       break label$1;
      }
      if (HEAP32[HEAP32[$5 + 160 >> 2] + 12 >> 2]) {
       $0 = HEAP32[HEAP32[$5 + 168 >> 2] + 20 >> 2];
       $1 = HEAP32[$5 + 168 >> 2];
       $2 = HEAP32[HEAP32[$5 + 160 >> 2] + 12 >> 2];
       HEAP32[$5 + 28 >> 2] = 0;
       HEAP32[$5 + 24 >> 2] = $2;
       HEAP32[$5 + 20 >> 2] = 140086;
       HEAP32[$5 + 16 >> 2] = 117494;
       FUNCTION_TABLE[$0 | 0]($1, 143305, $5 + 16 | 0);
       HEAP32[$5 + 172 >> 2] = 1;
       break label$1;
      }
      break label$5;
     }
     if (HEAP32[HEAP32[$5 + 164 >> 2] + 28 >> 2] != 9) {
      $0 = HEAP32[HEAP32[$5 + 168 >> 2] + 20 >> 2];
      $1 = HEAP32[$5 + 168 >> 2];
      $2 = TfLiteTypeGetName(HEAP32[HEAP32[$5 + 164 >> 2] + 28 >> 2]);
      HEAP32[$5 + 44 >> 2] = TfLiteTypeGetName(9);
      HEAP32[$5 + 40 >> 2] = $2;
      HEAP32[$5 + 36 >> 2] = 139120;
      HEAP32[$5 + 32 >> 2] = 132228;
      FUNCTION_TABLE[$0 | 0]($1, 142883, $5 + 32 | 0);
      HEAP32[$5 + 172 >> 2] = 1;
      break label$1;
     }
     label$10: {
      if (HEAP32[HEAP32[$5 + 160 >> 2] + 28 >> 2] == 7) {
       if (HEAP32[HEAP32[$5 + 160 >> 2] + 12 >> 2] != -32768) {
        $0 = HEAP32[HEAP32[$5 + 168 >> 2] + 20 >> 2];
        $1 = HEAP32[$5 + 168 >> 2];
        $2 = HEAP32[HEAP32[$5 + 160 >> 2] + 12 >> 2];
        HEAP32[$5 + 60 >> 2] = -32768;
        HEAP32[$5 + 56 >> 2] = $2;
        HEAP32[$5 + 52 >> 2] = 139151;
        HEAP32[$5 + 48 >> 2] = 117494;
        FUNCTION_TABLE[$0 | 0]($1, 143305, $5 + 48 | 0);
        HEAP32[$5 + 172 >> 2] = 1;
        break label$1;
       }
       break label$10;
      }
      if (HEAP32[HEAP32[$5 + 160 >> 2] + 28 >> 2] != 9) {
       $0 = HEAP32[HEAP32[$5 + 168 >> 2] + 20 >> 2];
       $1 = HEAP32[$5 + 168 >> 2];
       $2 = TfLiteTypeGetName(HEAP32[HEAP32[$5 + 160 >> 2] + 28 >> 2]);
       HEAP32[$5 + 76 >> 2] = TfLiteTypeGetName(9);
       HEAP32[$5 + 72 >> 2] = $2;
       HEAP32[$5 + 68 >> 2] = 139120;
       HEAP32[$5 + 64 >> 2] = 132215;
       FUNCTION_TABLE[$0 | 0]($1, 142883, $5 - -64 | 0);
       HEAP32[$5 + 172 >> 2] = 1;
       break label$1;
      }
      if (HEAP32[HEAP32[$5 + 160 >> 2] + 12 >> 2] != -128) {
       $0 = HEAP32[HEAP32[$5 + 168 >> 2] + 20 >> 2];
       $1 = HEAP32[$5 + 168 >> 2];
       $2 = HEAP32[HEAP32[$5 + 160 >> 2] + 12 >> 2];
       HEAP32[$5 + 92 >> 2] = -128;
       HEAP32[$5 + 88 >> 2] = $2;
       HEAP32[$5 + 84 >> 2] = 139169;
       HEAP32[$5 + 80 >> 2] = 117494;
       FUNCTION_TABLE[$0 | 0]($1, 143305, $5 + 80 | 0);
       HEAP32[$5 + 172 >> 2] = 1;
       break label$1;
      }
      if (HEAPF32[HEAP32[$5 + 160 >> 2] + 8 >> 2] != Math_fround(.00390625)) {
       $0 = HEAP32[HEAP32[$5 + 168 >> 2] + 20 >> 2];
       $1 = HEAP32[$5 + 168 >> 2];
       HEAP32[$5 + 96 >> 2] = 139184;
       FUNCTION_TABLE[$0 | 0]($1, 140586, $5 + 96 | 0);
       HEAP32[$5 + 172 >> 2] = 1;
       break label$1;
      }
     }
    }
    tflite__PreprocessSoftmaxScaling_28double_2c_20double_2c_20int_2c_20int__2c_20int__29(+HEAPF32[HEAP32[$5 + 156 >> 2] >> 2], +HEAPF32[HEAP32[$5 + 164 >> 2] + 8 >> 2], 5, HEAP32[$5 + 152 >> 2] + 8 | 0, $5 + 148 | 0);
    HEAP32[HEAP32[$5 + 152 >> 2] + 12 >> 2] = HEAP32[$5 + 148 >> 2];
    $6 = -0 - +(tflite__CalculateInputRadius_28int_2c_20int_2c_20int_29(5, HEAP32[HEAP32[$5 + 152 >> 2] + 12 >> 2], 31) | 0);
    label$16: {
     if (Math_abs($6) < 2147483648) {
      $0 = ~~$6;
      break label$16;
     }
     $0 = -2147483648;
    }
    HEAP32[HEAP32[$5 + 152 >> 2] + 24 >> 2] = $0;
    break label$2;
   }
   if (HEAP32[HEAP32[$5 + 164 >> 2] + 28 >> 2] != 1) {
    $0 = HEAP32[HEAP32[$5 + 168 >> 2] + 20 >> 2];
    $1 = HEAP32[$5 + 168 >> 2];
    $2 = TfLiteTypeGetName(HEAP32[HEAP32[$5 + 164 >> 2] + 28 >> 2]);
    HEAP32[$5 + 124 >> 2] = TfLiteTypeGetName(1);
    HEAP32[$5 + 120 >> 2] = $2;
    HEAP32[$5 + 116 >> 2] = 139710;
    HEAP32[$5 + 112 >> 2] = 132228;
    FUNCTION_TABLE[$0 | 0]($1, 142883, $5 + 112 | 0);
    HEAP32[$5 + 172 >> 2] = 1;
    break label$1;
   }
   if (HEAP32[HEAP32[$5 + 160 >> 2] + 28 >> 2] != 1) {
    $0 = HEAP32[HEAP32[$5 + 168 >> 2] + 20 >> 2];
    $1 = HEAP32[$5 + 168 >> 2];
    $2 = TfLiteTypeGetName(HEAP32[HEAP32[$5 + 160 >> 2] + 28 >> 2]);
    HEAP32[$5 + 140 >> 2] = TfLiteTypeGetName(1);
    HEAP32[$5 + 136 >> 2] = $2;
    HEAP32[$5 + 132 >> 2] = 139710;
    HEAP32[$5 + 128 >> 2] = 132215;
    FUNCTION_TABLE[$0 | 0]($1, 142883, $5 + 128 | 0);
    HEAP32[$5 + 172 >> 2] = 1;
    break label$1;
   }
   HEAPF64[HEAP32[$5 + 152 >> 2] >> 3] = HEAPF32[HEAP32[$5 + 156 >> 2] >> 2];
  }
  HEAP32[$5 + 172 >> 2] = 0;
 }
 __stack_pointer = $5 + 176 | 0;
 return HEAP32[$5 + 172 >> 2];
}

function tflite__MicroAllocator__CommitStaticMemoryPlan_28tflite__Model_20const__2c_20tflite__SubGraph_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 208 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 200 >> 2] = $0;
 HEAP32[$4 + 196 >> 2] = $1;
 HEAP32[$4 + 192 >> 2] = $2;
 HEAP32[$4 + 188 >> 2] = $3;
 $0 = HEAP32[$4 + 200 >> 2];
 HEAP32[$4 + 184 >> 2] = 0;
 tflite__SimpleMemoryAllocator__SimpleMemoryAllocator_28tflite__ErrorReporter__2c_20unsigned_20char__2c_20unsigned_20char__29($4 + 152 | 0, HEAP32[$0 + 8 >> 2], tflite__SimpleMemoryAllocator__GetBufferHead_28_29_20const(HEAP32[$0 + 4 >> 2]), tflite__SimpleMemoryAllocator__GetTail_28_29_20const(HEAP32[$0 + 4 >> 2]));
 tflite___28anonymous_20namespace_29__AllocationInfoBuilder__AllocationInfoBuilder_28tflite__ErrorReporter__2c_20tflite__SimpleMemoryAllocator__29($4 + 128 | 0, HEAP32[$0 + 8 >> 2], $4 + 152 | 0);
 HEAP32[$4 + 124 >> 2] = tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Init_28unsigned_20long_2c_20unsigned_20long_29($4 + 128 | 0, flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor____size_28_29_20const(tflite__SubGraph__tensors_28_29_20const(HEAP32[$4 + 192 >> 2])), HEAP32[$0 + 20 >> 2]);
 label$1: {
  if (HEAP32[$4 + 124 >> 2]) {
   HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 124 >> 2];
   HEAP32[$4 + 120 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 116 >> 2] = 0;
  HEAP32[$4 + 112 >> 2] = tflite___28anonymous_20namespace_29__AllocationInfoBuilder__GetOfflinePlannedOffsets_28tflite__Model_20const__2c_20int_20const___29($4 + 128 | 0, HEAP32[$4 + 196 >> 2], $4 + 116 | 0);
  if (HEAP32[$4 + 112 >> 2]) {
   HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 112 >> 2];
   HEAP32[$4 + 120 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 108 >> 2] = tflite___28anonymous_20namespace_29__AllocationInfoBuilder__AddTensors_28tflite__SubGraph_20const__2c_20int_20const__2c_20TfLiteEvalTensor__29($4 + 128 | 0, HEAP32[$4 + 192 >> 2], HEAP32[$4 + 116 >> 2], HEAP32[$4 + 188 >> 2]);
  if (HEAP32[$4 + 108 >> 2]) {
   HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 108 >> 2];
   HEAP32[$4 + 120 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 104 >> 2] = tflite___28anonymous_20namespace_29__AllocationInfoBuilder__AddScratchBuffers_28tflite__internal__ScratchBufferHandle__29($4 + 128 | 0, HEAP32[$0 + 16 >> 2]);
  if (HEAP32[$4 + 104 >> 2]) {
   HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 104 >> 2];
   HEAP32[$4 + 120 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 100 >> 2] = tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Finish_28_29_20const($4 + 128 | 0);
  HEAP32[$4 + 96 >> 2] = tflite__SimpleMemoryAllocator__GetAvailableMemory_28unsigned_20long_29_20const($4 + 152 | 0, 16);
  HEAP32[$4 + 92 >> 2] = tflite__SimpleMemoryAllocator__AllocateTemp_28unsigned_20long_2c_20unsigned_20long_29($4 + 152 | 0, HEAP32[$4 + 96 >> 2], 16);
  if (!HEAP32[$4 + 92 >> 2]) {
   $1 = HEAP32[$0 + 8 >> 2];
   $2 = HEAP32[$0 + 8 >> 2];
   HEAP32[$4 + 16 >> 2] = 120720;
   tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($1, $2, 140586, $4 + 16 | 0);
   HEAP32[$4 + 204 >> 2] = 1;
   HEAP32[$4 + 120 >> 2] = 1;
   break label$1;
  }
  tflite__GreedyMemoryPlanner__GreedyMemoryPlanner_28unsigned_20char__2c_20int_29($4 + 48 | 0, HEAP32[$4 + 92 >> 2], HEAP32[$4 + 96 >> 2]);
  HEAP32[$4 + 44 >> 2] = tflite___28anonymous_20namespace_29__CreatePlan_28tflite__ErrorReporter__2c_20tflite__GreedyMemoryPlanner__2c_20tflite___28anonymous_20namespace_29__AllocationInfo_20const__2c_20unsigned_20long_29(HEAP32[$0 + 8 >> 2], $4 + 48 | 0, HEAP32[$4 + 100 >> 2], tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Size_28_29_20const($4 + 128 | 0));
  label$7: {
   if (HEAP32[$4 + 44 >> 2]) {
    HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 44 >> 2];
    HEAP32[$4 + 120 >> 2] = 1;
    break label$7;
   }
   HEAP32[$4 + 40 >> 2] = tflite__SimpleMemoryAllocator__GetAvailableMemory_28unsigned_20long_29_20const(HEAP32[$0 + 4 >> 2], 16);
   if (tflite__GreedyMemoryPlanner__GetMaximumMemorySize_28_29($4 + 48 | 0) >>> 0 > HEAPU32[$4 + 40 >> 2]) {
    $1 = HEAP32[$0 + 8 >> 2];
    $2 = tflite__GreedyMemoryPlanner__GetMaximumMemorySize_28_29($4 + 48 | 0);
    HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 40 >> 2];
    HEAP32[$4 >> 2] = $2;
    tflite__ErrorReporter__Report_28char_20const__2c_20____29($1, 140646, $4);
    HEAP32[$4 + 204 >> 2] = 1;
    HEAP32[$4 + 120 >> 2] = 1;
    break label$7;
   }
   HEAP32[$4 + 36 >> 2] = tflite___28anonymous_20namespace_29__CommitPlan_28tflite__ErrorReporter__2c_20tflite__MemoryPlanner__2c_20unsigned_20char__2c_20tflite___28anonymous_20namespace_29__AllocationInfo_20const__2c_20unsigned_20long_29(HEAP32[$0 + 8 >> 2], $4 + 48 | 0, tflite__SimpleMemoryAllocator__GetBufferHead_28_29_20const(HEAP32[$0 + 4 >> 2]), HEAP32[$4 + 100 >> 2], tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Size_28_29_20const($4 + 128 | 0));
   if (HEAP32[$4 + 36 >> 2]) {
    HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 36 >> 2];
    HEAP32[$4 + 120 >> 2] = 1;
    break label$7;
   }
   HEAP32[$4 + 184 >> 2] = tflite__GreedyMemoryPlanner__GetMaximumMemorySize_28_29($4 + 48 | 0);
   HEAP32[$4 + 120 >> 2] = 0;
  }
  tflite__GreedyMemoryPlanner___GreedyMemoryPlanner_28_29($4 + 48 | 0);
 }
 tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($4 + 152 | 0);
 label$11: {
  if (HEAP32[$4 + 120 >> 2] == 1) {
   break label$11;
  }
  $0 = HEAP32[$0 + 4 >> 2];
  HEAP32[$4 + 32 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 8 >> 2]]($0, HEAP32[$4 + 184 >> 2], 16);
  if (HEAP32[$4 + 32 >> 2]) {
   HEAP32[$4 + 204 >> 2] = HEAP32[$4 + 32 >> 2];
   break label$11;
  }
  HEAP32[$4 + 204 >> 2] = 0;
 }
 __stack_pointer = $4 + 208 | 0;
 return HEAP32[$4 + 204 >> 2];
}

function jswrap_interface_setWatch($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 80 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 72 >> 2] = $0;
 HEAP8[$3 + 71 | 0] = $1;
 HEAP32[$3 + 64 >> 2] = $2;
 label$1: {
  if (!(jshIsPinValid(HEAPU8[$3 + 71 | 0]) & 1)) {
   jsError(128480, 0);
   HEAP32[$3 + 76 >> 2] = 0;
   break label$1;
  }
  label$3: {
   if (jsiIsWatchingPin(HEAPU8[$3 + 71 | 0]) & 1) {
    break label$3;
   }
   if (jshCanWatch(HEAPU8[$3 + 71 | 0]) & 1) {
    break label$3;
   }
   jsWarn(129543, 0);
   HEAP32[$3 + 76 >> 2] = 0;
   break label$1;
  }
  HEAP8[$3 + 63 | 0] = 0;
  HEAPF64[$3 + 48 >> 3] = 0;
  HEAP32[$3 + 44 >> 2] = 0;
  HEAP8[$3 + 43 | 0] = 0;
  HEAP8[$3 + 42 | 0] = 0;
  HEAP8[$3 + 41 | 0] = 255;
  if (HEAPU8[$3 + 71 | 0] == 17) {
   HEAP32[$3 + 44 >> 2] = 1;
   HEAPF64[$3 + 48 >> 3] = 25;
  }
  label$5: {
   if (jsvIsObject(HEAP32[$3 + 64 >> 2]) & 1) {
    HEAP32[$3 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 64 >> 2], 117940);
    if (HEAP32[$3 + 36 >> 2]) {
     HEAP8[$3 + 63 | 0] = jsvGetBoolAndUnLock(HEAP32[$3 + 36 >> 2]) & 1;
    }
    HEAP32[$3 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 64 >> 2], 132809);
    if (HEAP32[$3 + 36 >> 2]) {
     HEAPF64[$3 + 48 >> 3] = jsvGetFloatAndUnLock(HEAP32[$3 + 36 >> 2]);
    }
    $1 = __DOUBLE_BITS_9(HEAPF64[$3 + 48 >> 3]);
    $0 = $1;
    $2 = i64toi32_i32$HIGH_BITS;
    $1 = $2 & 2147483647;
    $2 = $0;
    if (!(HEAPF64[$3 + 48 >> 3] < 0 ? 0 : !$2 & ($1 | 0) == 2146435072 | $1 >>> 0 < 2146435072)) {
     HEAPF64[$3 + 48 >> 3] = 0;
    }
    HEAP32[$3 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 64 >> 2], 132661);
    if (!(jsvIsUndefined(HEAP32[$3 + 36 >> 2]) & 1)) {
     label$12: {
      if (jsvIsNumeric(HEAP32[$3 + 36 >> 2]) & 1) {
       HEAP32[$3 + 32 >> 2] = jsvGetInteger(HEAP32[$3 + 36 >> 2]);
       HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 32 >> 2] > 0 ? 1 : HEAP32[$3 + 32 >> 2] < 0 ? -1 : 0;
       break label$12;
      }
      HEAP32[$3 + 44 >> 2] = -1e3;
      if (jsvIsString(HEAP32[$3 + 36 >> 2]) & 1) {
       label$17: {
        if (jsvIsStringEqual(HEAP32[$3 + 36 >> 2], 129725) & 1) {
         HEAP32[$3 + 44 >> 2] = 1;
         break label$17;
        }
        label$19: {
         if (jsvIsStringEqual(HEAP32[$3 + 36 >> 2], 130011) & 1) {
          HEAP32[$3 + 44 >> 2] = -1;
          break label$19;
         }
         if (jsvIsStringEqual(HEAP32[$3 + 36 >> 2], 129325) & 1) {
          HEAP32[$3 + 44 >> 2] = 0;
         }
        }
       }
      }
     }
    }
    jsvUnLock(HEAP32[$3 + 36 >> 2]);
    if (!(HEAP32[$3 + 44 >> 2] <= 1 & HEAP32[$3 + 44 >> 2] >= -1)) {
     jsExceptionHere(3, 145324, 0);
     HEAP32[$3 + 76 >> 2] = 0;
     break label$1;
    }
    HEAP8[$3 + 43 | 0] = jsvObjectGetBoolChild(HEAP32[$3 + 64 >> 2], 121471) & 1;
    HEAP8[$3 + 41 | 0] = jshGetPinFromVarAndUnLock(jsvObjectGetChildIfExists(HEAP32[$3 + 64 >> 2], 135835));
    break label$5;
   }
   HEAP8[$3 + 63 | 0] = jsvGetBool(HEAP32[$3 + 64 >> 2]) & 1;
  }
  HEAP32[$3 + 28 >> 2] = -1;
  label$24: {
   label$25: {
    if (jsvIsFunction(HEAP32[$3 + 72 >> 2]) & 1) {
     break label$25;
    }
    if (jsvIsString(HEAP32[$3 + 72 >> 2]) & 1) {
     break label$25;
    }
    jsExceptionHere(1, 145837, 0);
    break label$24;
   }
   HEAP32[$3 + 24 >> 2] = jsvNewObject();
   if (HEAP32[$3 + 24 >> 2]) {
    jsvObjectSetChildAndUnLock(HEAP32[$3 + 24 >> 2], 128488, jsvNewFromPin(HEAPU8[$3 + 71 | 0]));
    if (HEAP8[$3 + 63 | 0] & 1) {
     jsvObjectSetChildAndUnLock(HEAP32[$3 + 24 >> 2], 120696, jsvNewFromBool(HEAP8[$3 + 63 | 0] & 1));
    }
    if (HEAPF64[$3 + 48 >> 3] > 0) {
     $0 = HEAP32[$3 + 24 >> 2];
     $2 = jshGetTimeFromMilliseconds(HEAPF64[$3 + 48 >> 3]);
     jsvObjectSetChildAndUnLock($0, 132809, jsvNewFromInteger($2));
    }
    if (HEAP32[$3 + 44 >> 2]) {
     jsvObjectSetChildAndUnLock(HEAP32[$3 + 24 >> 2], 132661, jsvNewFromInteger(HEAP32[$3 + 44 >> 2]));
    }
    jsvObjectSetChild(HEAP32[$3 + 24 >> 2], 135710, HEAP32[$3 + 72 >> 2]);
    jsvObjectSetChildAndUnLock(HEAP32[$3 + 24 >> 2], 131993, jsvNewFromBool(jshPinInput(HEAPU8[$3 + 71 | 0]) & 1));
    if (HEAP8[$3 + 42 | 0] & 1) {
     jsvObjectSetChildAndUnLock(HEAP32[$3 + 24 >> 2], 134129, jsvNewFromBool(1));
    }
   }
   HEAP8[$3 + 23 | 0] = 0;
   if (!(jsiIsWatchingPin(HEAPU8[$3 + 71 | 0]) & 1)) {
    HEAP8[$3 + 23 | 0] = jshPinWatch(HEAPU8[$3 + 71 | 0], 1, HEAP8[$3 + 42 | 0] & 1);
   }
   label$32: {
    if (HEAPU8[$3 + 23 | 0]) {
     jshSetEventCallback(HEAPU8[$3 + 23 | 0], 0);
     if (jshIsPinValid(HEAPU8[$3 + 41 | 0]) & 1) {
      jshSetEventDataPin(HEAPU8[$3 + 23 | 0], HEAPU8[$3 + 41 | 0]);
     }
     if (HEAP8[$3 + 43 | 0] & 1) {
      label$36: {
       if (jsvIsNativeFunction(HEAP32[$3 + 72 >> 2]) & 1) {
        jshSetEventCallback(HEAPU8[$3 + 23 | 0], jsvGetNativeFunctionPtr(HEAP32[$3 + 72 >> 2]));
        break label$36;
       }
       label$38: {
        if (jshIsPinValid(HEAPU8[$3 + 41 | 0]) & 1) {
         jsExceptionHere(1, 131724, 0);
         break label$38;
        }
        jsExceptionHere(1, 128136, 0);
       }
      }
     }
     break label$32;
    }
    if (HEAP8[$3 + 43 | 0] & 1) {
     jsExceptionHere(1, 133624, 0);
    }
   }
   HEAP32[$3 + 16 >> 2] = jsvLock(HEAPU16[182205]);
   HEAP32[$3 + 28 >> 2] = jsvArrayAddToEnd(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 24 >> 2], 1) - 1;
   jsvUnLock2(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 24 >> 2]);
  }
  label$41: {
   if (HEAP32[$3 + 28 >> 2] >= 0) {
    $0 = jsvNewFromInteger(HEAP32[$3 + 28 >> 2]);
    break label$41;
   }
   $0 = 0;
  }
  HEAP32[$3 + 76 >> 2] = $0;
 }
 __stack_pointer = $3 + 80 | 0;
 return HEAP32[$3 + 76 >> 2];
}

function jspeClassDefinition($0) {
 var $1 = 0;
 $1 = __stack_pointer - 96 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 91 | 0] = $0;
 HEAP32[$1 + 84 >> 2] = 0;
 HEAP32[$1 + 80 >> 2] = 0;
 HEAP32[$1 + 76 >> 2] = 0;
 HEAP8[$1 + 75 | 0] = (HEAP32[91094] & 63) == 1;
 if (HEAP8[$1 + 75 | 0] & 1) {
  HEAP32[$1 + 84 >> 2] = jsvNewWithFlags(7);
  HEAP32[$1 + 76 >> 2] = jsvNewObject();
  HEAP32[$1 + 68 >> 2] = jspeiGetScopesAsVar();
  if (HEAP32[$1 + 68 >> 2]) {
   jsvAddNamedChildAndUnLock(HEAP32[$1 + 84 >> 2], HEAP32[$1 + 68 >> 2], 128047);
  }
 }
 if (!(!(HEAP8[$1 + 91 | 0] & 1) | HEAP16[HEAP32[49079] + 2 >> 1] != 128)) {
  if (HEAP32[$1 + 76 >> 2]) {
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 76 >> 2], 128707, jslGetTokenValueAsVar());
  }
  jslGetNextToken();
 }
 if (HEAP32[$1 + 84 >> 2]) {
  HEAP32[$1 + 64 >> 2] = jsvFindOrAddChildFromString(HEAP32[$1 + 84 >> 2], 132159);
  jspEnsureIsPrototype(HEAP32[$1 + 84 >> 2], HEAP32[$1 + 64 >> 2]);
  HEAP32[$1 + 80 >> 2] = jsvSkipName(HEAP32[$1 + 64 >> 2]);
  jsvUnLock(HEAP32[$1 + 64 >> 2]);
 }
 label$6: {
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 195) {
   jslGetNextToken();
   HEAP32[$1 + 60 >> 2] = 0;
   HEAP32[$1 + 56 >> 2] = 0;
   if (HEAP8[$1 + 75 | 0] & 1) {
    HEAP32[$1 + 60 >> 2] = jspGetNamedVariable(jslGetTokenValueAsString());
    HEAP32[$1 + 56 >> 2] = jsvSkipName(HEAP32[$1 + 60 >> 2]);
   }
   if (!(jslMatch(128) & 1)) {
    jsvUnLock4(HEAP32[$1 + 56 >> 2], HEAP32[$1 + 84 >> 2], HEAP32[$1 + 76 >> 2], HEAP32[$1 + 80 >> 2]);
    HEAP32[$1 + 92 >> 2] = 0;
    break label$6;
   }
   if (HEAP32[$1 + 80 >> 2]) {
    label$11: {
     if (jsvIsFunction(HEAP32[$1 + 56 >> 2]) & 1) {
      HEAP32[$1 + 52 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 56 >> 2], 132159);
      if (HEAP32[$1 + 52 >> 2]) {
       jsvObjectSetChild(HEAP32[$1 + 80 >> 2], 135865, HEAP32[$1 + 52 >> 2]);
       $0 = HEAP32[$1 + 84 >> 2];
       HEAP32[$1 >> 2] = HEAP32[$1 + 60 >> 2];
       jsvObjectSetChildAndUnLock($0, 133204, jsvVarPrintf(142748, $1));
       jsvUnLock(HEAP32[$1 + 52 >> 2]);
      }
      break label$11;
     }
     $0 = HEAP32[$1 + 60 >> 2];
     HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 56 >> 2];
     HEAP32[$1 + 16 >> 2] = $0;
     jsExceptionHere(2, 118827, $1 + 16 | 0);
    }
   }
   jsvUnLock2(HEAP32[$1 + 56 >> 2], HEAP32[$1 + 60 >> 2]);
  }
  if (!(jslMatch(123) & 1)) {
   jsvUnLock3(HEAP32[$1 + 84 >> 2], HEAP32[$1 + 76 >> 2], HEAP32[$1 + 80 >> 2]);
   HEAP32[$1 + 92 >> 2] = 0;
   break label$6;
  }
  while (1) {
   label$16: {
    if (HEAP16[HEAP32[49079] + 2 >> 1] != 128) {
     $0 = 0;
     if (HEAP16[HEAP32[49079] + 2 >> 1] != 197) {
      break label$16;
     }
    }
    $0 = jspIsInterrupted() ^ -1;
   }
   if ($0 & 1) {
    HEAP8[$1 + 51 | 0] = HEAP16[HEAP32[49079] + 2 >> 1] == 197;
    if (HEAP8[$1 + 51 | 0] & 1) {
     jslGetNextToken();
    }
    HEAP32[$1 + 44 >> 2] = jslGetTokenValueAsVar();
    HEAP8[$1 + 43 | 0] = jsvIsStringEqual(HEAP32[$1 + 44 >> 2], 120855) & 1;
    if (!(jslMatch(128) & 1)) {
     jsvUnLock4(HEAP32[$1 + 44 >> 2], HEAP32[$1 + 84 >> 2], HEAP32[$1 + 76 >> 2], HEAP32[$1 + 80 >> 2]);
     HEAP32[$1 + 92 >> 2] = 0;
     break label$6;
    }
    HEAP8[$1 + 42 | 0] = 0;
    HEAP8[$1 + 41 | 0] = 0;
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 128) {
     HEAP8[$1 + 42 | 0] = jsvIsStringEqual(HEAP32[$1 + 44 >> 2], 117892) & 1;
     HEAP8[$1 + 41 | 0] = jsvIsStringEqual(HEAP32[$1 + 44 >> 2], 117878) & 1;
     if (HEAP8[$1 + 41 | 0] & 1 ? 1 : HEAP8[$1 + 42 | 0] & 1) {
      jsvUnLock(HEAP32[$1 + 44 >> 2]);
      HEAP32[$1 + 44 >> 2] = jslGetTokenValueAsVar();
      jslGetNextToken();
     }
    }
    if (HEAP8[$1 + 51 | 0] & 1) {
     $0 = HEAP32[$1 + 76 >> 2];
    } else {
     $0 = HEAP32[$1 + 80 >> 2];
    }
    HEAP32[$1 + 36 >> 2] = $0;
    if (HEAP32[$1 + 36 >> 2]) {
     label$27: {
      label$28: {
       if (!(HEAP8[$1 + 43 | 0] & 1 | (HEAP8[$1 + 42 | 0] & 1 | HEAP8[$1 + 41 | 0] & 1))) {
        if (HEAP16[HEAP32[49079] + 2 >> 1] != 40) {
         break label$28;
        }
       }
       HEAP32[$1 + 32 >> 2] = jspeFunctionDefinition(0);
       label$30: {
        if (HEAP8[$1 + 43 | 0] & 1) {
         jswrap_function_replaceWith(HEAP32[$1 + 84 >> 2], HEAP32[$1 + 32 >> 2]);
         break label$30;
        }
        label$32: {
         if (HEAP8[$1 + 41 | 0] & 1 ? 1 : HEAP8[$1 + 42 | 0] & 1) {
          jsvAddGetterOrSetter(HEAP32[$1 + 36 >> 2], HEAP32[$1 + 44 >> 2], HEAP8[$1 + 42 | 0] & 1, HEAP32[$1 + 32 >> 2]);
          break label$32;
         }
         jsvObjectSetChildVar(HEAP32[$1 + 36 >> 2], HEAP32[$1 + 44 >> 2], HEAP32[$1 + 32 >> 2]);
        }
       }
       jsvUnLock(HEAP32[$1 + 32 >> 2]);
       break label$27;
      }
      if (!(jslMatch(61) & 1)) {
       jsvUnLock4(HEAP32[$1 + 44 >> 2], HEAP32[$1 + 84 >> 2], HEAP32[$1 + 76 >> 2], HEAP32[$1 + 80 >> 2]);
       HEAP32[$1 + 92 >> 2] = 0;
       break label$6;
      }
      HEAP32[$1 + 28 >> 2] = jsvSkipNameAndUnLock(jspeAssignmentExpression());
      jsvObjectSetChildVar(HEAP32[$1 + 36 >> 2], HEAP32[$1 + 44 >> 2], HEAP32[$1 + 28 >> 2]);
      jsvUnLock(HEAP32[$1 + 28 >> 2]);
     }
    }
    while (1) {
     if (HEAP16[HEAP32[49079] + 2 >> 1] == 59) {
      jslGetNextToken();
      continue;
     }
     break;
    }
    jsvUnLock(HEAP32[$1 + 44 >> 2]);
    continue;
   }
   break;
  }
  jsvUnLock(HEAP32[$1 + 80 >> 2]);
  jsvObjectAppendAll(HEAP32[$1 + 84 >> 2], HEAP32[$1 + 76 >> 2]);
  jsvUnLock(HEAP32[$1 + 76 >> 2]);
  if (!(jslMatch(125) & 1)) {
   jsvUnLock(HEAP32[$1 + 84 >> 2]);
   HEAP32[$1 + 92 >> 2] = 0;
   break label$6;
  }
  HEAP32[$1 + 92 >> 2] = HEAP32[$1 + 84 >> 2];
 }
 __stack_pointer = $1 + 96 | 0;
 return HEAP32[$1 + 92 >> 2];
}

function jswrap_crypto_AES_ccmCrypt($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $6 = __stack_pointer - 160 | 0;
 $5 = $6;
 __stack_pointer = $5;
 HEAP32[$5 + 152 >> 2] = $0;
 HEAP32[$5 + 148 >> 2] = $1;
 HEAP32[$5 + 144 >> 2] = $2;
 HEAP32[$5 + 140 >> 2] = $3;
 HEAP8[$5 + 139 | 0] = $4;
 $0 = $5 + 126 | 0;
 HEAP8[$0 | 0] = 0;
 HEAP8[$0 + 1 | 0] = 0;
 HEAP8[$0 + 2 | 0] = 0;
 HEAP8[$0 + 3 | 0] = 0;
 HEAP8[$0 + 4 | 0] = 0;
 HEAP8[$0 + 5 | 0] = 0;
 HEAP8[$0 + 6 | 0] = 0;
 HEAP8[$0 + 7 | 0] = 0;
 HEAP8[$0 + 5 | 0] = 0;
 HEAP8[$0 + 6 | 0] = 0;
 HEAP8[$0 + 7 | 0] = 0;
 HEAP8[$0 + 8 | 0] = 0;
 HEAP8[$0 + 9 | 0] = 0;
 HEAP8[$0 + 10 | 0] = 0;
 HEAP8[$0 + 11 | 0] = 0;
 HEAP8[$0 + 12 | 0] = 0;
 HEAP32[$5 + 120 >> 2] = 0;
 label$1: {
  label$2: {
   label$3: {
    if (!(jsvIsArray(HEAP32[$5 + 144 >> 2]) & 1)) {
     if (!(jsvIsArrayBuffer(HEAP32[$5 + 144 >> 2]) & 1)) {
      break label$3;
     }
    }
    jsvIterateCallbackToBytes(HEAP32[$5 + 144 >> 2], $5 + 126 | 0, 13);
    HEAP32[$5 + 120 >> 2] = jsvGetLength(HEAP32[$5 + 144 >> 2]);
    if (!(HEAPU32[$5 + 120 >> 2] <= 13 & HEAP32[$5 + 120 >> 2] >= 2)) {
     jswrap_crypto_error(-20736);
     HEAP32[$5 + 156 >> 2] = 0;
     break label$1;
    }
    break label$2;
   }
   jswrap_crypto_error(-20736);
   HEAP32[$5 + 156 >> 2] = 0;
   break label$1;
  }
  HEAP32[$5 + 116 >> 2] = 0;
  HEAP32[$5 + 112 >> 2] = jsvGetDataPointer(HEAP32[$5 + 152 >> 2], $5 + 116 | 0);
  if (!(HEAP32[$5 + 112 >> 2] | !HEAP32[$5 + 152 >> 2])) {
   HEAP32[$5 + 116 >> 2] = jsvIterateCallbackCount(HEAP32[$5 + 152 >> 2]);
   label$8: {
    if (HEAP32[$5 + 116 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
     jsExceptionHere(1, 135807, 0);
     break label$8;
    }
    $6 = $6 - (HEAP32[$5 + 116 >> 2] + 15 & -16) | 0;
    __stack_pointer = $6;
    HEAP32[$5 + 112 >> 2] = $6;
    jsvIterateCallbackToBytes(HEAP32[$5 + 152 >> 2], HEAP32[$5 + 112 >> 2], HEAP32[$5 + 116 >> 2]);
   }
  }
  if (!HEAP32[$5 + 112 >> 2]) {
   HEAP32[$5 + 156 >> 2] = 0;
   break label$1;
  }
  HEAP32[$5 + 108 >> 2] = 0;
  HEAP32[$5 + 104 >> 2] = jsvGetDataPointer(HEAP32[$5 + 148 >> 2], $5 + 108 | 0);
  if (!(HEAP32[$5 + 104 >> 2] | !HEAP32[$5 + 148 >> 2])) {
   HEAP32[$5 + 108 >> 2] = jsvIterateCallbackCount(HEAP32[$5 + 148 >> 2]);
   label$12: {
    if (HEAP32[$5 + 108 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
     jsExceptionHere(1, 135807, 0);
     break label$12;
    }
    $6 = $6 - (HEAP32[$5 + 108 >> 2] + 15 & -16) | 0;
    __stack_pointer = $6;
    HEAP32[$5 + 104 >> 2] = $6;
    jsvIterateCallbackToBytes(HEAP32[$5 + 148 >> 2], HEAP32[$5 + 104 >> 2], HEAP32[$5 + 108 >> 2]);
   }
  }
  if (!HEAP32[$5 + 104 >> 2]) {
   HEAP32[$5 + 156 >> 2] = 0;
   break label$1;
  }
  HEAP32[$5 + 100 >> 2] = 0;
  HEAP32[$5 + 96 >> 2] = jsvNewArrayBufferWithPtr(HEAP32[$5 + 116 >> 2], $5 + 100 | 0);
  if (!HEAP32[$5 + 100 >> 2]) {
   HEAP32[$5 + 156 >> 2] = 0;
   break label$1;
  }
  HEAP32[$5 + 92 >> 2] = 0;
  mbedtls_ccm_init($5 + 32 | 0);
  HEAP32[$5 + 92 >> 2] = mbedtls_ccm_setkey($5 + 32 | 0, 2, HEAP32[$5 + 104 >> 2], HEAP32[$5 + 108 >> 2] << 3);
  if (!HEAP32[$5 + 92 >> 2]) {
   label$17: {
    if (HEAP8[$5 + 139 | 0] & 1) {
     HEAP32[$5 + 28 >> 2] = 0;
     label$19: {
      if (jsvIsNumeric(HEAP32[$5 + 140 >> 2]) & 1) {
       HEAP32[$5 + 28 >> 2] = jsvGetInteger(HEAP32[$5 + 140 >> 2]);
       break label$19;
      }
      HEAP32[$5 + 92 >> 2] = -20736;
     }
     if (!HEAP32[$5 + 92 >> 2]) {
      if (HEAP32[$5 + 28 >> 2] & 1 ? 1 : HEAP32[$5 + 28 >> 2] < 4 | HEAP32[$5 + 28 >> 2] > 16) {
       HEAP32[$5 + 92 >> 2] = -20736;
      }
     }
     if (!HEAP32[$5 + 92 >> 2]) {
      $0 = HEAP32[$5 + 28 >> 2];
      HEAP32[$5 + 24 >> 2] = $6;
      $6 = $6 - ($0 + 15 & -16) | 0;
      __stack_pointer = $6;
      HEAP32[$5 + 20 >> 2] = $0;
      memset($6, 0, $0);
      HEAP32[$5 + 92 >> 2] = mbedtls_ccm_encrypt_and_tag($5 + 32 | 0, HEAP32[$5 + 116 >> 2], $5 + 126 | 0, HEAP32[$5 + 120 >> 2], 0, 0, HEAP32[$5 + 112 >> 2], HEAP32[$5 + 100 >> 2], $6, $0);
      if (!HEAP32[$5 + 92 >> 2]) {
       HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 96 >> 2];
       HEAP32[$5 + 96 >> 2] = jsvNewObject();
       jsvObjectSetChildAndUnLock(HEAP32[$5 + 96 >> 2], 135835, HEAP32[$5 + 16 >> 2]);
       jsvObjectSetChildAndUnLock(HEAP32[$5 + 96 >> 2], 130054, jsvNewArrayBufferWithData(HEAP32[$5 + 28 >> 2], $6));
      }
     }
     break label$17;
    }
    HEAP32[$5 + 12 >> 2] = 0;
    HEAP32[$5 + 8 >> 2] = jsvGetDataPointer(HEAP32[$5 + 140 >> 2], $5 + 12 | 0);
    if (!(HEAP32[$5 + 8 >> 2] | !HEAP32[$5 + 140 >> 2])) {
     HEAP32[$5 + 12 >> 2] = jsvIterateCallbackCount(HEAP32[$5 + 140 >> 2]);
     label$27: {
      if (HEAP32[$5 + 12 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
       jsExceptionHere(1, 135807, 0);
       break label$27;
      }
      $6 = $6 - (HEAP32[$5 + 12 >> 2] + 15 & -16) | 0;
      __stack_pointer = $6;
      HEAP32[$5 + 8 >> 2] = $6;
      jsvIterateCallbackToBytes(HEAP32[$5 + 140 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 12 >> 2]);
     }
    }
    if (!HEAP32[$5 + 8 >> 2]) {
     HEAP32[$5 + 92 >> 2] = -20736;
    }
    if (!HEAP32[$5 + 92 >> 2]) {
     HEAP32[$5 + 92 >> 2] = mbedtls_ccm_auth_decrypt($5 + 32 | 0, HEAP32[$5 + 116 >> 2], $5 + 126 | 0, HEAP32[$5 + 120 >> 2], 0, 0, HEAP32[$5 + 112 >> 2], HEAP32[$5 + 100 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 12 >> 2]);
    }
   }
  }
  mbedtls_ccm_free($5 + 32 | 0);
  if (!HEAP32[$5 + 92 >> 2]) {
   HEAP32[$5 + 156 >> 2] = HEAP32[$5 + 96 >> 2];
   break label$1;
  }
  jswrap_crypto_error(HEAP32[$5 + 92 >> 2]);
  jsvUnLock(HEAP32[$5 + 96 >> 2]);
  HEAP32[$5 + 156 >> 2] = 0;
 }
 __stack_pointer = $5 + 160 | 0;
 return HEAP32[$5 + 156 >> 2];
}

function jsvCopy($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP8[$2 + 55 | 0] = $1;
 label$1: {
  if (jsvIsFlatString(HEAP32[$2 + 56 >> 2]) & 1) {
   HEAP32[$2 + 60 >> 2] = jsvNewFromStringVarComplete(HEAP32[$2 + 56 >> 2]);
   break label$1;
  }
  $0 = HEAP32[$2 + 56 >> 2];
  HEAP32[$2 + 48 >> 2] = jsvNewWithFlags((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 255);
  if (!HEAP32[$2 + 48 >> 2]) {
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  label$4: {
   if (!(jsvIsStringExt(HEAP32[$2 + 56 >> 2]) & 1)) {
    $0 = 1;
    label$6: {
     if (jsvIsBasicString(HEAP32[$2 + 56 >> 2]) & 1) {
      break label$6;
     }
     $0 = 1;
     if (jsvIsNativeString(HEAP32[$2 + 56 >> 2]) & 1) {
      break label$6;
     }
     $0 = 1;
     if (jsvIsFlashString(HEAP32[$2 + 56 >> 2]) & 1) {
      break label$6;
     }
     $0 = jsvIsNativeFunction(HEAP32[$2 + 56 >> 2]);
    }
    HEAP8[$2 + 47 | 0] = $0 & 1;
    __memcpy(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 56 >> 2], HEAP8[$2 + 47 | 0] & 1 ? 9 : 4);
    if (jsvIsNativeFunction(HEAP32[$2 + 56 >> 2]) & 1) {
     jsvSetFirstChild(HEAP32[$2 + 48 >> 2], 0);
    }
    label$8: {
     if (HEAP8[$2 + 47 | 0] & 1) {
      break label$8;
     }
    }
    break label$4;
   }
   $3 = HEAP32[$2 + 56 >> 2];
   $1 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
   $4 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
   $0 = $1;
   $1 = HEAP32[$2 + 48 >> 2];
   HEAP8[$1 | 0] = $0;
   HEAP8[$1 + 1 | 0] = $0 >>> 8;
   HEAP8[$1 + 2 | 0] = $0 >>> 16;
   HEAP8[$1 + 3 | 0] = $0 >>> 24;
   HEAP8[$1 + 4 | 0] = $4;
   HEAP8[$1 + 5 | 0] = $4 >>> 8;
   HEAP8[$1 + 6 | 0] = $4 >>> 16;
   HEAP8[$1 + 7 | 0] = $4 >>> 24;
   $0 = HEAPU8[$3 + 8 | 0] | HEAPU8[$3 + 9 | 0] << 8;
   HEAP8[$1 + 8 | 0] = $0;
   HEAP8[$1 + 9 | 0] = $0 >>> 8;
  }
  label$9: {
   if (!(HEAP8[$2 + 55 | 0] & 1)) {
    break label$9;
   }
   if (!(jsvIsName(HEAP32[$2 + 56 >> 2]) & 1)) {
    break label$9;
   }
   if (jsvGetFirstChild(HEAP32[$2 + 56 >> 2]) & 65535) {
    label$11: {
     if (jsvIsNameWithValue(HEAP32[$2 + 56 >> 2]) & 1) {
      jsvSetFirstChild(HEAP32[$2 + 48 >> 2], jsvGetFirstChild(HEAP32[$2 + 56 >> 2]) & 65535);
      break label$11;
     }
     HEAP32[$2 + 40 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 56 >> 2]) & 65535);
     HEAP32[$2 + 36 >> 2] = jsvRef(jsvCopy(HEAP32[$2 + 40 >> 2], 1));
     jsvUnLock(HEAP32[$2 + 40 >> 2]);
     if (HEAP32[$2 + 36 >> 2]) {
      jsvSetFirstChild(HEAP32[$2 + 48 >> 2], jsvGetRef(HEAP32[$2 + 36 >> 2]) & 65535);
      jsvUnLock(HEAP32[$2 + 36 >> 2]);
     }
    }
   }
  }
  label$14: {
   if (jsvHasStringExt(HEAP32[$2 + 56 >> 2]) & 1) {
    HEAP32[$2 + 56 >> 2] = jsvLockAgain(HEAP32[$2 + 56 >> 2]);
    HEAP32[$2 + 32 >> 2] = jsvLockAgain(HEAP32[$2 + 48 >> 2]);
    while (1) {
     if (jsvGetLastChild(HEAP32[$2 + 56 >> 2]) & 65535) {
      HEAP32[$2 + 28 >> 2] = jsvLock(jsvGetLastChild(HEAP32[$2 + 56 >> 2]) & 65535);
      label$18: {
       if (jsvIsStringExt(HEAP32[$2 + 28 >> 2]) & 1) {
        $0 = HEAP32[$2 + 28 >> 2];
        HEAP32[$2 + 24 >> 2] = jsvNewWithFlags((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 255);
        if (HEAP32[$2 + 24 >> 2]) {
         $3 = HEAP32[$2 + 28 >> 2];
         $4 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
         $1 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
         $0 = $4;
         $4 = HEAP32[$2 + 24 >> 2];
         HEAP8[$4 | 0] = $0;
         HEAP8[$4 + 1 | 0] = $0 >>> 8;
         HEAP8[$4 + 2 | 0] = $0 >>> 16;
         HEAP8[$4 + 3 | 0] = $0 >>> 24;
         HEAP8[$4 + 4 | 0] = $1;
         HEAP8[$4 + 5 | 0] = $1 >>> 8;
         HEAP8[$4 + 6 | 0] = $1 >>> 16;
         HEAP8[$4 + 7 | 0] = $1 >>> 24;
         $0 = HEAPU8[$3 + 8 | 0] | HEAPU8[$3 + 9 | 0] << 8;
         HEAP8[$4 + 8 | 0] = $0;
         HEAP8[$4 + 9 | 0] = $0 >>> 8;
         jsvSetLastChild(HEAP32[$2 + 32 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
        }
        jsvUnLock2(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 32 >> 2]);
        HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 28 >> 2];
        HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 24 >> 2];
        break label$18;
       }
       HEAP32[$2 + 20 >> 2] = jsvCopy(HEAP32[$2 + 28 >> 2], 1);
       if (HEAP32[$2 + 20 >> 2]) {
        jsvSetLastChild(HEAP32[$2 + 32 >> 2], jsvGetRef(jsvRef(HEAP32[$2 + 20 >> 2])) & 65535);
        jsvUnLock(HEAP32[$2 + 20 >> 2]);
       }
       jsvUnLock3(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 28 >> 2]);
       HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
       break label$1;
      }
      continue;
     }
     break;
    }
    jsvUnLock2(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 32 >> 2]);
    break label$14;
   }
   if (jsvHasChildren(HEAP32[$2 + 56 >> 2]) & 1 & (HEAP8[$2 + 55 | 0] & 1)) {
    HEAP16[$2 + 18 >> 1] = jsvGetFirstChild(HEAP32[$2 + 56 >> 2]);
    while (1) {
     if (HEAPU16[$2 + 18 >> 1]) {
      HEAP32[$2 + 12 >> 2] = jsvLock(HEAPU16[$2 + 18 >> 1]);
      HEAP32[$2 + 8 >> 2] = jsvCopyNameOnly(HEAP32[$2 + 12 >> 2], 1, 1);
      if (HEAP32[$2 + 8 >> 2]) {
       jsvAddName(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 8 >> 2]);
       jsvUnLock(HEAP32[$2 + 8 >> 2]);
      }
      HEAP16[$2 + 18 >> 1] = jsvGetNextSibling(HEAP32[$2 + 12 >> 2]);
      jsvUnLock(HEAP32[$2 + 12 >> 2]);
      continue;
     }
     break;
    }
   }
  }
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
 }
 __stack_pointer = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}

function jsvMakeIntoVariableName($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 112 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 104 >> 2] = $0;
 HEAP32[$2 + 100 >> 2] = $1;
 label$1: {
  if (!HEAP32[$2 + 104 >> 2]) {
   HEAP32[$2 + 108 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$2 + 104 >> 2];
  HEAP16[$2 + 98 >> 1] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  label$3: {
   if (HEAPU16[$2 + 98 >> 1] == 10) {
    HEAP32[$2 + 92 >> 2] = 15;
    label$5: {
     if (!(jsvIsInt(HEAP32[$2 + 100 >> 2]) & 1)) {
      if (!(jsvIsBoolean(HEAP32[$2 + 100 >> 2]) & 1)) {
       break label$5;
      }
     }
     if (jsvIsPin(HEAP32[$2 + 100 >> 2]) & 1) {
      break label$5;
     }
     $0 = HEAP32[$2 + 100 >> 2];
     HEAP32[$2 + 88 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
     if (!(HEAP32[$2 + 88 >> 2] < -8192 | HEAP32[$2 + 88 >> 2] > 8191)) {
      HEAP32[$2 + 92 >> 2] = jsvIsInt(HEAP32[$2 + 100 >> 2]) & 1 ? 16 : 17;
      jsvSetFirstChild(HEAP32[$2 + 104 >> 2], HEAP32[$2 + 88 >> 2] & 65535);
      HEAP32[$2 + 100 >> 2] = 0;
     }
    }
    $0 = HEAP32[$2 + 104 >> 2];
    $1 = HEAP32[$2 + 104 >> 2];
    $1 = HEAP32[$2 + 92 >> 2] | (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64;
    HEAP8[$0 + 12 | 0] = $1;
    HEAP8[$0 + 13 | 0] = $1 >>> 8;
    break label$3;
   }
   if (!(HEAPU16[$2 + 98 >> 1] < 18 | HEAPU16[$2 + 98 >> 1] > 40)) {
    label$9: {
     if (!(!(HEAPU16[$2 + 98 >> 1] == 38 | HEAPU16[$2 + 98 >> 1] == 39) & HEAPU16[$2 + 98 >> 1] != 40)) {
      HEAP32[$2 + 84 >> 2] = jsvNewWithFlags(23);
      jsvAppendStringVarComplete(HEAP32[$2 + 84 >> 2], HEAP32[$2 + 104 >> 2]);
      jsvUnLock(HEAP32[$2 + 104 >> 2]);
      HEAP32[$2 + 104 >> 2] = HEAP32[$2 + 84 >> 2];
      break label$9;
     }
     if (jsvGetCharactersInVar(HEAP32[$2 + 104 >> 2]) >>> 0 > 4) {
      jsvStringIteratorNew($2 + 48 | 0, HEAP32[$2 + 104 >> 2], 4);
      HEAP32[$2 + 36 >> 2] = 0;
      while (1) {
       $0 = 0;
       if (HEAP32[$2 + 36 >> 2] < 5) {
        $0 = jsvStringIteratorHasChar_1($2 + 48 | 0);
       }
       if ($0 & 1) {
        $0 = jsvStringIteratorGetCharAndNext($2 + 48 | 0);
        HEAP8[HEAP32[$2 + 36 >> 2] + ($2 + 43 | 0) | 0] = $0;
        HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 36 >> 2] + 1;
        continue;
       }
       break;
      }
      jsvStringIteratorFree_1($2 + 48 | 0);
      HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 104 >> 2];
      while (1) {
       if (jsvGetLastChild(HEAP32[$2 + 32 >> 2]) & 65535) {
        HEAP32[$2 + 32 >> 2] = jsvGetAddressOf(jsvGetLastChild(HEAP32[$2 + 32 >> 2]) & 65535);
        continue;
       }
       break;
      }
      if (HEAP32[$2 + 32 >> 2] != HEAP32[$2 + 104 >> 2]) {
       HEAP32[$2 + 28 >> 2] = jsvGetCharactersInVar(HEAP32[$2 + 32 >> 2]) + HEAP32[$2 + 36 >> 2];
       label$19: {
        if (HEAP32[$2 + 28 >> 2] <= 10) {
         jsvSetCharactersInVar(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 28 >> 2]);
         HEAP32[$2 + 32 >> 2] = 0;
         break label$19;
        }
        HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 28 >> 2] - 10;
       }
      }
      if (HEAP32[$2 + 32 >> 2]) {
       jsvSetCharactersInVar(HEAP32[$2 + 32 >> 2], jsvGetMaxCharactersInVar(HEAP32[$2 + 32 >> 2]));
       HEAP32[$2 + 24 >> 2] = jsvNewWithFlags(41);
       if (HEAP32[$2 + 24 >> 2]) {
        jsvSetCharactersInVar(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 36 >> 2]);
        jsvSetLastChild(HEAP32[$2 + 32 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
        jsvUnLock(HEAP32[$2 + 24 >> 2]);
       }
      }
      jsvStringIteratorNew($2 + 48 | 0, HEAP32[$2 + 104 >> 2], 9);
      HEAP32[$2 + 36 >> 2] = 0;
      while (1) {
       if (jsvStringIteratorHasChar_1($2 + 48 | 0) & 1) {
        HEAP8[$2 + 23 | 0] = jsvStringIteratorGetChar_1($2 + 48 | 0);
        jsvStringIteratorSetChar($2 + 48 | 0, HEAP8[HEAP32[$2 + 36 >> 2] + ($2 + 43 | 0) | 0]);
        HEAP8[HEAP32[$2 + 36 >> 2] + ($2 + 43 | 0) | 0] = HEAPU8[$2 + 23 | 0];
        jsvStringIteratorNext($2 + 48 | 0);
        HEAP32[$2 + 36 >> 2] = (HEAP32[$2 + 36 >> 2] + 1 | 0) % 5;
        continue;
       }
       break;
      }
      jsvStringIteratorFree_1($2 + 48 | 0);
      jsvSetCharactersInVar(HEAP32[$2 + 104 >> 2], 4);
      jsvSetNextSibling(HEAP32[$2 + 104 >> 2], 0);
      jsvSetPrevSibling(HEAP32[$2 + 104 >> 2], 0);
      jsvSetFirstChild(HEAP32[$2 + 104 >> 2], 0);
     }
    }
    HEAP32[$2 + 16 >> 2] = 23;
    label$25: {
     label$26: {
      if (!(jsvIsInt(HEAP32[$2 + 100 >> 2]) & 1)) {
       break label$26;
      }
      if (jsvIsPin(HEAP32[$2 + 100 >> 2]) & 1) {
       break label$26;
      }
      $0 = HEAP32[$2 + 100 >> 2];
      HEAP32[$2 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
      if (!(HEAP32[$2 + 12 >> 2] < -8192 | HEAP32[$2 + 12 >> 2] > 8191)) {
       HEAP32[$2 + 16 >> 2] = 18;
       jsvSetFirstChild(HEAP32[$2 + 104 >> 2], HEAP32[$2 + 12 >> 2] & 65535);
       HEAP32[$2 + 100 >> 2] = 0;
      }
      break label$25;
     }
     jsvSetFirstChild(HEAP32[$2 + 104 >> 2], 0);
    }
    $0 = HEAP32[$2 + 104 >> 2];
    $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 65472;
    $3 = HEAP32[$2 + 16 >> 2] + jsvGetCharactersInVar(HEAP32[$2 + 104 >> 2]) | 0;
    $0 = HEAP32[$2 + 104 >> 2];
    $1 = $1 | $3;
    HEAP8[$0 + 12 | 0] = $1;
    HEAP8[$0 + 13 | 0] = $1 >>> 8;
   }
  }
  if (HEAP32[$2 + 100 >> 2]) {
   jsvSetFirstChild(HEAP32[$2 + 104 >> 2], jsvGetRef(jsvRef(HEAP32[$2 + 100 >> 2])) & 65535);
  }
  HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 104 >> 2];
 }
 __stack_pointer = $2 + 112 | 0;
 return HEAP32[$2 + 108 >> 2];
}

function tflite__reference_ops__AveragePool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 144 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 140 >> 2] = $0;
 HEAP32[$5 + 136 >> 2] = $1;
 HEAP32[$5 + 132 >> 2] = $2;
 HEAP32[$5 + 128 >> 2] = $3;
 HEAP32[$5 + 124 >> 2] = $4;
 label$1: {
  if (HEAP32[HEAP32[$5 + 140 >> 2] + 28 >> 2] > HEAP32[HEAP32[$5 + 140 >> 2] + 32 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 136 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 label$3: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 128 >> 2]) | 0) != 4) {
   break label$3;
  }
 }
 HEAP32[$5 + 120 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 0, HEAP32[$5 + 128 >> 2], 0);
 HEAP32[$5 + 116 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 3, HEAP32[$5 + 128 >> 2], 3);
 HEAP32[$5 + 112 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 1);
 HEAP32[$5 + 108 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 2);
 HEAP32[$5 + 104 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 1);
 HEAP32[$5 + 100 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 2);
 HEAP32[$5 + 96 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 12 >> 2];
 HEAP32[$5 + 92 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 16 >> 2];
 HEAP32[$5 + 88 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 88 >> 2] < HEAP32[$5 + 120 >> 2]) {
   HEAP32[$5 + 84 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 84 >> 2] < HEAP32[$5 + 104 >> 2]) {
     HEAP32[$5 + 80 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 80 >> 2] < HEAP32[$5 + 100 >> 2]) {
       HEAP32[$5 + 76 >> 2] = 0;
       while (1) {
        if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 116 >> 2]) {
         HEAP32[$5 + 72 >> 2] = Math_imul(HEAP32[$5 + 80 >> 2], HEAP32[$5 + 92 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 2 >> 1];
         HEAP32[$5 + 68 >> 2] = Math_imul(HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 4 >> 1];
         HEAP32[$5 + 60 >> 2] = 0;
         HEAP32[$5 + 56 >> 2] = 0 - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 64 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 60 | 0, $5 + 56 | 0) >> 2];
         $0 = HEAP32[$5 + 140 >> 2];
         HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 108 >> 2] - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 52 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0 + 24 | 0, $5 + 48 | 0) >> 2];
         HEAP32[$5 + 40 >> 2] = 0;
         HEAP32[$5 + 36 >> 2] = 0 - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 44 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 40 | 0, $5 + 36 | 0) >> 2];
         $0 = HEAP32[$5 + 140 >> 2];
         HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 112 >> 2] - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 32 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0 + 20 | 0, $5 + 28 | 0) >> 2];
         HEAP32[$5 + 24 >> 2] = 0;
         HEAP32[$5 + 20 >> 2] = 0;
         HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 44 >> 2];
         while (1) {
          if (HEAP32[$5 + 16 >> 2] < HEAP32[$5 + 32 >> 2]) {
           HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 64 >> 2];
           while (1) {
            if (HEAP32[$5 + 12 >> 2] < HEAP32[$5 + 52 >> 2]) {
             HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 72 >> 2] + HEAP32[$5 + 12 >> 2];
             HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 68 >> 2] + HEAP32[$5 + 16 >> 2];
             HEAP32[$5 + 24 >> 2] = HEAPU8[HEAP32[$5 + 132 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 4 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 76 >> 2]) | 0] + HEAP32[$5 + 24 >> 2];
             HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
             HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAP32[$5 + 24 >> 2] = (HEAP32[$5 + 24 >> 2] + (HEAP32[$5 + 20 >> 2] / 2 | 0) | 0) / HEAP32[$5 + 20 >> 2];
         HEAP32[$5 + 24 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 24 | 0, HEAP32[$5 + 140 >> 2] + 28 | 0) >> 2];
         HEAP32[$5 + 24 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($5 + 24 | 0, HEAP32[$5 + 140 >> 2] + 32 | 0) >> 2];
         $0 = HEAP32[$5 + 24 >> 2];
         HEAP8[HEAP32[$5 + 124 >> 2] + tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 128 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2]) | 0] = $0;
         HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 80 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 84 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 144 | 0;
}

function jswrap_storagefile_write($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 240 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 236 >> 2] = $0;
 HEAP32[$2 + 232 >> 2] = $1;
 HEAP8[$2 + 231 | 0] = jsvObjectGetIntegerChild(HEAP32[$2 + 236 >> 2], 132782);
 label$1: {
  if (!(HEAP8[$2 + 231 | 0] == 119 | HEAP8[$2 + 231 | 0] == 97)) {
   jsExceptionHere(1, 132721, 0);
   break label$1;
  }
  HEAP32[$2 + 224 >> 2] = jsvAsString(HEAP32[$2 + 232 >> 2]);
  if (!HEAP32[$2 + 224 >> 2]) {
   break label$1;
  }
  HEAP32[$2 + 220 >> 2] = jsvGetStringLength(HEAP32[$2 + 224 >> 2]);
  if (!HEAP32[$2 + 220 >> 2]) {
   jsvUnLock(HEAP32[$2 + 224 >> 2]);
   break label$1;
  }
  HEAP32[$2 + 216 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 236 >> 2], 117864);
  HEAP32[$2 + 212 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 236 >> 2], 129088);
  jsfNameFromVarAndUnLock($2 + 184 | 0, jsvObjectGetChildIfExists(HEAP32[$2 + 236 >> 2], 132398));
  HEAP32[$2 + 180 >> 2] = 27;
  while (1) {
   $0 = 0;
   $0 = HEAP32[$2 + 180 >> 2] ? !HEAP8[(HEAP32[$2 + 180 >> 2] + $2 | 0) + 183 | 0] : $0;
   if ($0) {
    HEAP32[$2 + 180 >> 2] = HEAP32[$2 + 180 >> 2] - 1;
    continue;
   }
   break;
  }
  HEAP8[HEAP32[$2 + 180 >> 2] + ($2 + 184 | 0) | 0] = HEAP32[$2 + 212 >> 2];
  HEAP32[$2 + 120 >> 2] = HEAP32[$2 + 208 >> 2];
  $0 = HEAP32[$2 + 204 >> 2];
  $1 = HEAP32[$2 + 200 >> 2];
  HEAP32[$2 + 112 >> 2] = $1;
  HEAP32[$2 + 116 >> 2] = $0;
  $1 = HEAP32[$2 + 196 >> 2];
  $0 = HEAP32[$2 + 192 >> 2];
  HEAP32[$2 + 104 >> 2] = $0;
  HEAP32[$2 + 108 >> 2] = $1;
  $0 = HEAP32[$2 + 188 >> 2];
  $1 = HEAP32[$2 + 184 >> 2];
  HEAP32[$2 + 96 >> 2] = $1;
  HEAP32[$2 + 100 >> 2] = $0;
  HEAP32[$2 + 140 >> 2] = jsfFindFile($2 + 96 | 0, $2 + 144 | 0);
  label$7: {
   if (HEAP32[$2 + 140 >> 2]) {
    $0 = jsfGetFileSize($2 + 144 | 0);
    break label$7;
   }
   $0 = 0;
  }
  HEAP32[$2 + 136 >> 2] = $0;
  if (!HEAP32[$2 + 140 >> 2]) {
   $3 = HEAP32[$2 + 224 >> 2];
   HEAP32[$2 + 88 >> 2] = HEAP32[$2 + 208 >> 2];
   $1 = HEAP32[$2 + 204 >> 2];
   $0 = HEAP32[$2 + 200 >> 2];
   HEAP32[$2 + 80 >> 2] = $0;
   HEAP32[$2 + 84 >> 2] = $1;
   $0 = HEAP32[$2 + 196 >> 2];
   $1 = HEAP32[$2 + 192 >> 2];
   HEAP32[$2 + 72 >> 2] = $1;
   HEAP32[$2 + 76 >> 2] = $0;
   $1 = HEAP32[$2 + 188 >> 2];
   $0 = HEAP32[$2 + 184 >> 2];
   HEAP32[$2 + 64 >> 2] = $0;
   HEAP32[$2 + 68 >> 2] = $1;
   label$10: {
    if (jsfWriteFile($2 - -64 | 0, $3, 64, 0, 40928) & 1) {
     HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 208 >> 2];
     $0 = HEAP32[$2 + 204 >> 2];
     $1 = HEAP32[$2 + 200 >> 2];
     HEAP32[$2 + 48 >> 2] = $1;
     HEAP32[$2 + 52 >> 2] = $0;
     $1 = HEAP32[$2 + 196 >> 2];
     $0 = HEAP32[$2 + 192 >> 2];
     HEAP32[$2 + 40 >> 2] = $0;
     HEAP32[$2 + 44 >> 2] = $1;
     $0 = HEAP32[$2 + 188 >> 2];
     $1 = HEAP32[$2 + 184 >> 2];
     HEAP32[$2 + 32 >> 2] = $1;
     HEAP32[$2 + 36 >> 2] = $0;
     HEAP32[$2 + 140 >> 2] = jsfFindFile($2 + 32 | 0, $2 + 144 | 0);
     HEAP32[$2 + 136 >> 2] = jsfGetFileSize($2 + 144 | 0);
     HEAP32[$2 + 216 >> 2] = HEAP32[$2 + 220 >> 2];
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 117864, jsvNewFromInteger(HEAP32[$2 + 216 >> 2]));
     break label$10;
    }
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 132782, jsvNewFromInteger(0));
   }
   jsvUnLock(HEAP32[$2 + 224 >> 2]);
   break label$1;
  }
  HEAP32[$2 + 132 >> 2] = HEAP32[$2 + 136 >> 2] - HEAP32[$2 + 216 >> 2];
  label$12: {
   if (HEAP32[$2 + 220 >> 2] < HEAP32[$2 + 132 >> 2]) {
    jswrap_flash_write(HEAP32[$2 + 224 >> 2], HEAP32[$2 + 140 >> 2] + HEAP32[$2 + 216 >> 2] | 0);
    HEAP32[$2 + 216 >> 2] = HEAP32[$2 + 220 >> 2] + HEAP32[$2 + 216 >> 2];
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 117864, jsvNewFromInteger(HEAP32[$2 + 216 >> 2]));
    break label$12;
   }
   HEAP32[$2 + 128 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 224 >> 2], 0, HEAP32[$2 + 132 >> 2]);
   jswrap_flash_write(HEAP32[$2 + 128 >> 2], HEAP32[$2 + 140 >> 2] + HEAP32[$2 + 216 >> 2] | 0);
   HEAP32[$2 + 216 >> 2] = HEAP32[$2 + 132 >> 2] + HEAP32[$2 + 216 >> 2];
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 117864, jsvNewFromInteger(HEAP32[$2 + 216 >> 2]));
   jsvUnLock(HEAP32[$2 + 128 >> 2]);
   if (HEAP32[$2 + 212 >> 2] == 255) {
    jsExceptionHere(1, 145750, 0);
    jsvUnLock(HEAP32[$2 + 224 >> 2]);
    break label$1;
   }
   HEAP32[$2 + 212 >> 2] = HEAP32[$2 + 212 >> 2] + 1;
   HEAP8[HEAP32[$2 + 180 >> 2] + ($2 + 184 | 0) | 0] = HEAP32[$2 + 212 >> 2];
   HEAP32[$2 + 128 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 224 >> 2], HEAP32[$2 + 132 >> 2], 2147483647);
   $3 = HEAP32[$2 + 128 >> 2];
   HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 208 >> 2];
   $1 = HEAP32[$2 + 204 >> 2];
   $0 = HEAP32[$2 + 200 >> 2];
   HEAP32[$2 + 16 >> 2] = $0;
   HEAP32[$2 + 20 >> 2] = $1;
   $0 = HEAP32[$2 + 196 >> 2];
   $1 = HEAP32[$2 + 192 >> 2];
   HEAP32[$2 + 8 >> 2] = $1;
   HEAP32[$2 + 12 >> 2] = $0;
   $1 = HEAP32[$2 + 188 >> 2];
   $0 = HEAP32[$2 + 184 >> 2];
   HEAP32[$2 >> 2] = $0;
   HEAP32[$2 + 4 >> 2] = $1;
   label$15: {
    if (jsfWriteFile($2, $3, 64, 0, 40928) & 1) {
     HEAP32[$2 + 216 >> 2] = jsvGetStringLength(HEAP32[$2 + 128 >> 2]);
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 129088, jsvNewFromInteger(HEAP32[$2 + 212 >> 2]));
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 117864, jsvNewFromInteger(HEAP32[$2 + 216 >> 2]));
     break label$15;
    }
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 132782, jsvNewFromInteger(0));
   }
   jsvUnLock(HEAP32[$2 + 128 >> 2]);
  }
  jsvUnLock(HEAP32[$2 + 224 >> 2]);
 }
 __stack_pointer = $2 + 240 | 0;
}

function jswrap_json_parse_internal($0) {
 var $1 = 0;
 $1 = __stack_pointer - 112 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 104 >> 2] = $0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        $0 = HEAP16[HEAP32[49079] + 2 >> 1];
        if (($0 | 0) != 45) {
         if (($0 | 0) == 91) {
          break label$4;
         }
         if (($0 | 0) == 123) {
          break label$3;
         }
         if (($0 | 0) == 129) {
          break label$7;
         }
         if (($0 | 0) == 130) {
          break label$6;
         }
         if (($0 | 0) == 131) {
          break label$5;
         }
         label$9: {
          label$10: {
           if (($0 | 0) != 180) {
            if (($0 | 0) == 181) {
             break label$10;
            }
            if (($0 | 0) == 182) {
             break label$9;
            }
            break label$2;
           }
           jslGetNextToken();
           HEAP32[$1 + 108 >> 2] = jsvNewFromBool(1);
           break label$1;
          }
          jslGetNextToken();
          HEAP32[$1 + 108 >> 2] = jsvNewFromBool(0);
          break label$1;
         }
         jslGetNextToken();
         HEAP32[$1 + 108 >> 2] = jsvNewWithFlags(2);
         break label$1;
        }
        jslGetNextToken();
        if (!(HEAP16[HEAP32[49079] + 2 >> 1] == 129 | HEAP16[HEAP32[49079] + 2 >> 1] == 130)) {
         HEAP32[$1 + 108 >> 2] = 0;
         break label$1;
        }
        HEAP32[$1 + 100 >> 2] = jswrap_json_parse_internal(HEAP32[$1 + 104 >> 2]);
        HEAP32[$1 + 96 >> 2] = jsvNewFromInteger(0);
        HEAP32[$1 + 92 >> 2] = jsvMathsOp(HEAP32[$1 + 96 >> 2], HEAP32[$1 + 100 >> 2], 45);
        jsvUnLock2(HEAP32[$1 + 100 >> 2], HEAP32[$1 + 96 >> 2]);
        HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 92 >> 2];
        break label$1;
       }
       HEAP32[$1 + 80 >> 2] = stringToInt(jslGetTokenValueAsString());
       HEAP32[$1 + 84 >> 2] = i64toi32_i32$HIGH_BITS;
       jslGetNextToken();
       HEAP32[$1 + 108 >> 2] = jsvNewFromLongInteger(HEAP32[$1 + 80 >> 2], HEAP32[$1 + 84 >> 2]);
       break label$1;
      }
      HEAPF64[$1 + 72 >> 3] = stringToFloat(jslGetTokenValueAsString());
      jslGetNextToken();
      HEAP32[$1 + 108 >> 2] = jsvNewFromFloat(HEAPF64[$1 + 72 >> 3]);
      break label$1;
     }
     HEAP32[$1 + 68 >> 2] = jslGetTokenValueAsVar();
     jslGetNextToken();
     HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 68 >> 2];
     break label$1;
    }
    HEAP32[$1 + 64 >> 2] = jsvNewEmptyArray();
    if (!HEAP32[$1 + 64 >> 2]) {
     HEAP32[$1 + 108 >> 2] = 0;
     break label$1;
    }
    jslGetNextToken();
    while (1) {
     $0 = 0;
     if (HEAP16[HEAP32[49079] + 2 >> 1] != 93) {
      $0 = jspHasError() ^ -1;
     }
     if ($0 & 1) {
      HEAP32[$1 + 60 >> 2] = jswrap_json_parse_internal(HEAP32[$1 + 104 >> 2]);
      label$17: {
       if (HEAP32[$1 + 60 >> 2]) {
        if (HEAP16[HEAP32[49079] + 2 >> 1] == 93) {
         break label$17;
        }
        if (jslMatch(44) & 1) {
         break label$17;
        }
       }
       jsvUnLock2(HEAP32[$1 + 60 >> 2], HEAP32[$1 + 64 >> 2]);
       HEAP32[$1 + 108 >> 2] = 0;
       break label$1;
      }
      jsvArrayPush(HEAP32[$1 + 64 >> 2], HEAP32[$1 + 60 >> 2]);
      jsvUnLock(HEAP32[$1 + 60 >> 2]);
      continue;
     }
     break;
    }
    if (!(jslMatch(93) & 1)) {
     jsvUnLock(HEAP32[$1 + 64 >> 2]);
     HEAP32[$1 + 108 >> 2] = 0;
     break label$1;
    }
    HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 64 >> 2];
    break label$1;
   }
   HEAP32[$1 + 56 >> 2] = jsvNewObject();
   if (!HEAP32[$1 + 56 >> 2]) {
    HEAP32[$1 + 108 >> 2] = 0;
    break label$1;
   }
   jslGetNextToken();
   while (1) {
    label$22: {
     if (!(HEAP16[HEAP32[49079] + 2 >> 1] == 131 | HEAP16[HEAP32[49079] + 2 >> 1] == 129)) {
      $0 = 0;
      if (!(jslIsIDOrReservedWord() & 1)) {
       break label$22;
      }
     }
     $0 = jspHasError() ^ -1;
    }
    if ($0 & 1) {
     label$25: {
      if (HEAP32[$1 + 104 >> 2] & 512) {
       break label$25;
      }
      if (!(jslIsIDOrReservedWord() & 1) & HEAP16[HEAP32[49079] + 2 >> 1] != 129) {
       break label$25;
      }
      jslMatch(131);
      HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 56 >> 2];
      break label$1;
     }
     HEAP32[$1 + 52 >> 2] = jsvAsArrayIndexAndUnLock(jslGetTokenValueAsVar());
     jslGetNextToken();
     HEAP32[$1 + 48 >> 2] = 0;
     label$27: {
      label$28: {
       if (!(jslMatch(58) & 1)) {
        break label$28;
       }
       $0 = jswrap_json_parse_internal(HEAP32[$1 + 104 >> 2]);
       HEAP32[$1 + 48 >> 2] = $0;
       if (!$0) {
        break label$28;
       }
       if (HEAP16[HEAP32[49079] + 2 >> 1] == 125) {
        break label$27;
       }
       if (jslMatch(44) & 1) {
        break label$27;
       }
      }
      jsvUnLock3(HEAP32[$1 + 52 >> 2], HEAP32[$1 + 48 >> 2], HEAP32[$1 + 56 >> 2]);
      HEAP32[$1 + 108 >> 2] = 0;
      break label$1;
     }
     jsvAddName(HEAP32[$1 + 56 >> 2], jsvMakeIntoVariableName(HEAP32[$1 + 52 >> 2], HEAP32[$1 + 48 >> 2]));
     jsvUnLock2(HEAP32[$1 + 48 >> 2], HEAP32[$1 + 52 >> 2]);
     continue;
    }
    break;
   }
   if (!(jslMatch(125) & 1)) {
    jsvUnLock(HEAP32[$1 + 56 >> 2]);
    HEAP32[$1 + 108 >> 2] = 0;
    break label$1;
   }
   HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 56 >> 2];
   break label$1;
  }
  jslTokenAsString(HEAP16[HEAP32[49079] + 2 >> 1], $1 + 16 | 0, 32);
  HEAP32[$1 >> 2] = $1 + 16;
  jsExceptionHere(2, 120512, $1);
  HEAP32[$1 + 108 >> 2] = 0;
 }
 __stack_pointer = $1 + 112 | 0;
 return HEAP32[$1 + 108 >> 2];
}

function tflite__GreedyMemoryPlanner__CalculateOffsetsIfNeeded_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 96 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 92 >> 2] = $0;
 label$1: {
  $0 = HEAP32[$1 + 92 >> 2];
  if (!(HEAP8[$0 + 40 | 0] & 1) | !HEAP32[$0 + 8 >> 2]) {
   break label$1;
  }
  HEAP8[$0 + 40 | 0] = 0;
  HEAP32[$1 + 88 >> 2] = HEAP32[$0 + 8 >> 2];
  HEAP32[$1 + 84 >> 2] = 0;
  HEAP32[$1 + 80 >> 2] = 0;
  while (1) {
   if (HEAP32[$1 + 80 >> 2] < HEAP32[$0 + 8 >> 2]) {
    label$5: {
     if (HEAP32[(HEAP32[$0 + 12 >> 2] + (HEAP32[$1 + 80 >> 2] << 4) | 0) + 4 >> 2] == -1) {
      HEAP32[$1 + 88 >> 2] = HEAP32[$1 + 88 >> 2] - 1;
      HEAP32[HEAP32[$0 + 16 >> 2] + (HEAP32[$1 + 88 >> 2] << 2) >> 2] = HEAP32[HEAP32[$0 + 12 >> 2] + (HEAP32[$1 + 80 >> 2] << 4) >> 2];
      HEAP32[HEAP32[$0 + 20 >> 2] + (HEAP32[$1 + 88 >> 2] << 2) >> 2] = HEAP32[$1 + 80 >> 2];
      HEAP32[HEAP32[$0 + 36 >> 2] + (HEAP32[$1 + 80 >> 2] << 2) >> 2] = -1;
      break label$5;
     }
     HEAP32[HEAP32[$0 + 16 >> 2] + (HEAP32[$1 + 84 >> 2] << 2) >> 2] = HEAP32[HEAP32[$0 + 12 >> 2] + (HEAP32[$1 + 80 >> 2] << 4) >> 2];
     HEAP32[HEAP32[$0 + 20 >> 2] + (HEAP32[$1 + 84 >> 2] << 2) >> 2] = HEAP32[$1 + 80 >> 2];
     HEAP32[HEAP32[$0 + 36 >> 2] + (HEAP32[$1 + 80 >> 2] << 2) >> 2] = HEAP32[(HEAP32[$0 + 12 >> 2] + (HEAP32[$1 + 80 >> 2] << 4) | 0) + 4 >> 2];
     HEAP32[$1 + 84 >> 2] = HEAP32[$1 + 84 >> 2] + 1;
    }
    HEAP32[$1 + 80 >> 2] = HEAP32[$1 + 80 >> 2] + 1;
    continue;
   }
   break;
  }
  tflite__ReverseSortInPlace_28int__2c_20int__2c_20int_29(HEAP32[$0 + 16 >> 2] + (HEAP32[$1 + 84 >> 2] << 2) | 0, HEAP32[$0 + 20 >> 2] + (HEAP32[$1 + 84 >> 2] << 2) | 0, HEAP32[$0 + 8 >> 2] - HEAP32[$1 + 84 >> 2] | 0);
  HEAP32[$0 + 32 >> 2] = 0;
  HEAP32[$0 + 28 >> 2] = 1;
  HEAP32[$1 + 76 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[$0 + 32 >> 2], 12);
  HEAP32[HEAP32[$1 + 76 >> 2] + 8 >> 2] = -1;
  HEAP32[$1 + 72 >> 2] = HEAP32[HEAP32[$0 + 20 >> 2] >> 2];
  HEAP32[HEAP32[$1 + 76 >> 2] + 4 >> 2] = HEAP32[$1 + 72 >> 2];
  if (HEAP32[(HEAP32[$0 + 12 >> 2] + (HEAP32[$1 + 72 >> 2] << 4) | 0) + 4 >> 2] == -1) {
   HEAP32[HEAP32[$0 + 36 >> 2] + (HEAP32[$1 + 72 >> 2] << 2) >> 2] = 0;
  }
  HEAP32[HEAP32[$1 + 76 >> 2] >> 2] = HEAP32[HEAP32[$0 + 36 >> 2] + (HEAP32[$1 + 72 >> 2] << 2) >> 2];
  HEAP32[$1 + 68 >> 2] = 1;
  while (1) {
   if (HEAP32[$1 + 68 >> 2] >= HEAP32[$0 + 8 >> 2]) {
    break label$1;
   }
   HEAP32[$1 + 72 >> 2] = HEAP32[HEAP32[$0 + 20 >> 2] + (HEAP32[$1 + 68 >> 2] << 2) >> 2];
   HEAP32[$1 + 64 >> 2] = HEAP32[$0 + 12 >> 2] + (HEAP32[$1 + 72 >> 2] << 4);
   HEAP32[$1 + 60 >> 2] = HEAP32[HEAP32[$1 + 64 >> 2] >> 2];
   HEAP32[$1 + 56 >> 2] = HEAP32[HEAP32[$1 + 64 >> 2] + 8 >> 2];
   HEAP32[$1 + 52 >> 2] = HEAP32[HEAP32[$1 + 64 >> 2] + 12 >> 2];
   HEAP32[$1 + 48 >> 2] = 0;
   label$9: {
    if (HEAP32[HEAP32[$1 + 64 >> 2] + 4 >> 2] == -1) {
     HEAP32[$1 + 44 >> 2] = 0;
     while (1) {
      HEAP32[$1 + 40 >> 2] = tflite__GreedyMemoryPlanner__NextSimultaneouslyActiveBuffer_28tflite__GreedyMemoryPlanner__ListEntry_20const__2c_20int_2c_20int_29($0, HEAP32[$1 + 44 >> 2], HEAP32[$1 + 56 >> 2], HEAP32[$1 + 52 >> 2]);
      if (HEAP32[$1 + 44 >> 2]) {
       HEAP32[$1 + 36 >> 2] = HEAP32[$0 + 12 >> 2] + (HEAP32[HEAP32[$1 + 44 >> 2] + 4 >> 2] << 4);
       HEAP32[$1 + 32 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] >> 2] + HEAP32[HEAP32[$1 + 36 >> 2] >> 2];
       if (HEAP32[$1 + 32 >> 2] > HEAP32[$1 + 48 >> 2]) {
        HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 32 >> 2];
       }
      }
      label$14: {
       if (!HEAP32[$1 + 40 >> 2]) {
        break label$14;
       }
       HEAP32[$1 + 28 >> 2] = HEAP32[HEAP32[$1 + 40 >> 2] >> 2] - HEAP32[$1 + 48 >> 2];
       if (HEAP32[$1 + 28 >> 2] >= HEAP32[$1 + 60 >> 2]) {
        break label$14;
       }
       HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 40 >> 2];
       continue;
      }
      break;
     }
     break label$9;
    }
    HEAP32[$1 + 48 >> 2] = HEAP32[HEAP32[$1 + 64 >> 2] + 4 >> 2];
   }
   HEAP32[HEAP32[$0 + 36 >> 2] + (HEAP32[$1 + 72 >> 2] << 2) >> 2] = HEAP32[$1 + 48 >> 2];
   HEAP32[$1 + 24 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[$0 + 28 >> 2], 12);
   HEAP32[HEAP32[$1 + 24 >> 2] >> 2] = HEAP32[$1 + 48 >> 2];
   HEAP32[HEAP32[$1 + 24 >> 2] + 4 >> 2] = HEAP32[$1 + 72 >> 2];
   HEAP32[$1 + 20 >> 2] = HEAP32[$0 + 28 >> 2];
   HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 28 >> 2] + 1;
   label$15: {
    if (HEAP32[HEAP32[$1 + 76 >> 2] >> 2] > HEAP32[$1 + 48 >> 2]) {
     HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 24 >> 2];
     HEAP32[HEAP32[$1 + 76 >> 2] + 8 >> 2] = HEAP32[$0 + 32 >> 2];
     HEAP32[$0 + 32 >> 2] = HEAP32[$1 + 20 >> 2];
     break label$15;
    }
    HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 76 >> 2];
    while (1) {
     label$18: {
      HEAP32[$1 + 12 >> 2] = HEAP32[HEAP32[$1 + 16 >> 2] + 8 >> 2];
      if (HEAP32[$1 + 12 >> 2] == -1) {
       HEAP32[HEAP32[$1 + 16 >> 2] + 8 >> 2] = HEAP32[$1 + 20 >> 2];
       HEAP32[HEAP32[$1 + 24 >> 2] + 8 >> 2] = -1;
       break label$18;
      }
      HEAP32[$1 + 8 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[$1 + 12 >> 2], 12);
      if (HEAP32[HEAP32[$1 + 8 >> 2] >> 2] > HEAP32[$1 + 48 >> 2]) {
       HEAP32[HEAP32[$1 + 24 >> 2] + 8 >> 2] = HEAP32[HEAP32[$1 + 16 >> 2] + 8 >> 2];
       HEAP32[HEAP32[$1 + 16 >> 2] + 8 >> 2] = HEAP32[$1 + 20 >> 2];
      } else {
       HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 8 >> 2];
       continue;
      }
     }
     break;
    }
   }
   HEAP32[$1 + 68 >> 2] = HEAP32[$1 + 68 >> 2] + 1;
   continue;
  }
 }
 __stack_pointer = $1 + 96 | 0;
}

function _jswrap_banglejs_setOptions($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 416 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 408 >> 2] = $0;
 HEAP8[$2 + 407 | 0] = $1;
 HEAP8[$2 + 406 | 0] = (HEAP32[97749] & 2) != 0;
 HEAP8[$2 + 405 | 0] = (HEAP32[97749] & 4) != 0;
 HEAP8[$2 + 404 | 0] = (HEAP32[97749] & 8) != 0;
 HEAP8[$2 + 403 | 0] = HEAP32[97749] & 1;
 HEAP8[$2 + 402 | 0] = (HEAP32[97749] & 16) != 0;
 HEAP8[$2 + 401 | 0] = (HEAP32[97749] & 32) != 0;
 HEAP8[$2 + 400 | 0] = (HEAP32[97749] & 64) != 0;
 HEAP8[$2 + 399 | 0] = (HEAP32[97749] & 2048) != 0;
 HEAP8[$2 + 398 | 0] = (HEAP32[97749] & 2097152) != 0;
 HEAP8[$2 + 397 | 0] = (HEAP32[97749] & 4194304) != 0;
 HEAP32[$2 + 384 >> 2] = Math_imul(HEAPU16[97841], HEAPU16[97841]);
 HEAP32[$2 + 380 >> 2] = Math_imul(HEAPU16[97842], HEAPU16[97842]);
 HEAP32[$2 + 376 >> 2] = HEAP16[195496];
 HEAP32[$2 + 372 >> 2] = HEAP16[195497];
 HEAP32[$2 + 368 >> 2] = HEAP16[97839];
 HEAP32[$2 + 364 >> 2] = HEAP16[97840];
 HEAP32[$2 + 360 >> 2] = lcdMemLCD_getRowPtr(0);
 HEAP8[$2 + 359 | 0] = (HEAP32[97749] & 1048576) != 0;
 HEAP32[$2 >> 2] = 129414;
 HEAP16[$2 + 4 >> 1] = 10;
 HEAP32[$2 + 8 >> 2] = $2 + 384;
 HEAP32[$2 + 12 >> 2] = 129433;
 HEAP16[$2 + 16 >> 1] = 10;
 HEAP32[$2 + 20 >> 2] = $2 + 380;
 HEAP32[$2 + 24 >> 2] = 117377;
 HEAP16[$2 + 28 >> 1] = 10;
 HEAP32[$2 + 32 >> 2] = 195688;
 HEAP32[$2 + 36 >> 2] = 129370;
 HEAP16[$2 + 40 >> 1] = 10;
 HEAP32[$2 + 44 >> 2] = 195692;
 HEAP32[$2 + 48 >> 2] = 116637;
 HEAP16[$2 + 52 >> 1] = 10;
 HEAP32[$2 + 56 >> 2] = $2 + 392;
 HEAP32[$2 + 60 >> 2] = 129481;
 HEAP16[$2 + 64 >> 1] = 10;
 HEAP32[$2 + 68 >> 2] = $2 + 388;
 HEAP32[$2 + 72 >> 2] = 133233;
 HEAP16[$2 + 76 >> 1] = 10;
 HEAP32[$2 + 80 >> 2] = 195696;
 HEAP32[$2 + 84 >> 2] = 117231;
 HEAP16[$2 + 88 >> 1] = 10;
 HEAP32[$2 + 92 >> 2] = 195704;
 HEAP32[$2 + 96 >> 2] = 136303;
 HEAP16[$2 + 100 >> 1] = 10;
 HEAP32[$2 + 104 >> 2] = 195700;
 HEAP32[$2 + 108 >> 2] = 139902;
 HEAP16[$2 + 112 >> 1] = 12;
 HEAP32[$2 + 116 >> 2] = $2 + 406;
 HEAP32[$2 + 120 >> 2] = 139620;
 HEAP16[$2 + 124 >> 1] = 12;
 HEAP32[$2 + 128 >> 2] = $2 + 405;
 HEAP32[$2 + 132 >> 2] = 139536;
 HEAP16[$2 + 136 >> 1] = 12;
 HEAP32[$2 + 140 >> 2] = $2 + 404;
 HEAP32[$2 + 144 >> 2] = 121889;
 HEAP16[$2 + 148 >> 1] = 12;
 HEAP32[$2 + 152 >> 2] = $2 + 403;
 HEAP32[$2 + 156 >> 2] = 129525;
 HEAP16[$2 + 160 >> 1] = 12;
 HEAP32[$2 + 164 >> 2] = $2 + 402;
 HEAP32[$2 + 168 >> 2] = 121863;
 HEAP16[$2 + 172 >> 1] = 12;
 HEAP32[$2 + 176 >> 2] = $2 + 401;
 HEAP32[$2 + 180 >> 2] = 117327;
 HEAP16[$2 + 184 >> 1] = 12;
 HEAP32[$2 + 188 >> 2] = $2 + 400;
 HEAP32[$2 + 192 >> 2] = 131714;
 HEAP16[$2 + 196 >> 1] = 12;
 HEAP32[$2 + 200 >> 2] = $2 + 399;
 HEAP32[$2 + 204 >> 2] = 129689;
 HEAP16[$2 + 208 >> 1] = 12;
 HEAP32[$2 + 212 >> 2] = $2 + 398;
 HEAP32[$2 + 216 >> 2] = 116405;
 HEAP16[$2 + 220 >> 1] = 12;
 HEAP32[$2 + 224 >> 2] = $2 + 397;
 HEAP32[$2 + 228 >> 2] = 117277;
 HEAP16[$2 + 232 >> 1] = 10;
 HEAP32[$2 + 236 >> 2] = 391016;
 HEAP32[$2 + 240 >> 2] = 117261;
 HEAP16[$2 + 244 >> 1] = 10;
 HEAP32[$2 + 248 >> 2] = 391004;
 HEAP32[$2 + 252 >> 2] = 117244;
 HEAP16[$2 + 256 >> 1] = 10;
 HEAP32[$2 + 260 >> 2] = 391012;
 HEAP32[$2 + 264 >> 2] = 117289;
 HEAP16[$2 + 268 >> 1] = 10;
 HEAP32[$2 + 272 >> 2] = 391064;
 HEAP32[$2 + 276 >> 2] = 139894;
 HEAP16[$2 + 280 >> 1] = 10;
 HEAP32[$2 + 284 >> 2] = $2 + 376;
 HEAP32[$2 + 288 >> 2] = 139886;
 HEAP16[$2 + 292 >> 1] = 10;
 HEAP32[$2 + 296 >> 2] = $2 + 372;
 HEAP32[$2 + 300 >> 2] = 139577;
 HEAP16[$2 + 304 >> 1] = 10;
 HEAP32[$2 + 308 >> 2] = $2 + 368;
 HEAP32[$2 + 312 >> 2] = 139569;
 HEAP16[$2 + 316 >> 1] = 10;
 HEAP32[$2 + 320 >> 2] = $2 + 364;
 HEAP32[$2 + 324 >> 2] = 120750;
 HEAP16[$2 + 328 >> 1] = 10;
 HEAP32[$2 + 332 >> 2] = $2 + 360;
 HEAP32[$2 + 336 >> 2] = 129450;
 HEAP16[$2 + 340 >> 1] = 12;
 HEAP32[$2 + 344 >> 2] = $2 + 359;
 label$1: {
  if (HEAP8[$2 + 407 | 0] & 1) {
   HEAP32[$2 + 412 >> 2] = jsvCreateConfigObject($2, 29);
   break label$1;
  }
  if (jsvReadConfigObject(HEAP32[$2 + 408 >> 2], $2, 29) & 1) {
   HEAP32[97749] = HEAP32[97749] & -3 | (HEAP8[$2 + 406 | 0] & 1 ? 2 : 0);
   HEAP32[97749] = HEAP32[97749] & -5 | (HEAP8[$2 + 405 | 0] & 1 ? 4 : 0);
   HEAP32[97749] = HEAP32[97749] & -9 | (HEAP8[$2 + 404 | 0] & 1 ? 8 : 0);
   HEAP32[97749] = HEAP32[97749] & -2 | HEAP8[$2 + 403 | 0] & 1;
   HEAP32[97749] = HEAP32[97749] & -17 | (HEAP8[$2 + 402 | 0] & 1 ? 16 : 0);
   HEAP32[97749] = HEAP32[97749] & -33 | (HEAP8[$2 + 401 | 0] & 1 ? 32 : 0);
   HEAP32[97749] = HEAP32[97749] & -65 | (HEAP8[$2 + 400 | 0] & 1 ? 64 : 0);
   HEAP32[97749] = HEAP32[97749] & -2049 | (HEAP8[$2 + 399 | 0] & 1 ? 2048 : 0);
   HEAP32[97749] = HEAP32[97749] & -2097153 | (HEAP8[$2 + 398 | 0] & 1 ? 2097152 : 0);
   HEAP32[97749] = HEAP32[97749] & -4194305 | (HEAP8[$2 + 397 | 0] & 1 ? 4194304 : 0);
   if (HEAP32[97754] < 0) {
    HEAP32[97754] = 0;
   }
   if (HEAP32[97751] < 0) {
    HEAP32[97751] = 0;
   }
   if (HEAP32[97753] < 0) {
    HEAP32[97753] = 0;
   }
   HEAP16[97841] = int_sqrt32(HEAP32[$2 + 384 >> 2]);
   HEAP16[97842] = int_sqrt32(HEAP32[$2 + 380 >> 2]);
   HEAP16[195496] = HEAP32[$2 + 376 >> 2];
   HEAP16[195497] = HEAP32[$2 + 372 >> 2];
   HEAP16[97839] = HEAP32[$2 + 368 >> 2];
   HEAP16[97840] = HEAP32[$2 + 364 >> 2];
   HEAP32[97749] = HEAP32[97749] & -1048577 | (HEAP8[$2 + 359 | 0] & 1 ? 1048576 : 0);
  }
  HEAP32[$2 + 412 >> 2] = 0;
 }
 __stack_pointer = $2 + 416 | 0;
 return HEAP32[$2 + 412 >> 2];
}

function tflite__reference_ops__AveragePool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = Math_fround(0);
 $5 = __stack_pointer - 144 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 140 >> 2] = $0;
 HEAP32[$5 + 136 >> 2] = $1;
 HEAP32[$5 + 132 >> 2] = $2;
 HEAP32[$5 + 128 >> 2] = $3;
 HEAP32[$5 + 124 >> 2] = $4;
 label$1: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 136 >> 2]) | 0) != 4) {
   break label$1;
  }
 }
 label$2: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 128 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 HEAP32[$5 + 120 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 0, HEAP32[$5 + 128 >> 2], 0);
 HEAP32[$5 + 116 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 3, HEAP32[$5 + 128 >> 2], 3);
 HEAP32[$5 + 112 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 1);
 HEAP32[$5 + 108 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 2);
 HEAP32[$5 + 104 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 1);
 HEAP32[$5 + 100 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 2);
 HEAP32[$5 + 96 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 12 >> 2];
 HEAP32[$5 + 92 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 16 >> 2];
 HEAP32[$5 + 88 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 88 >> 2] < HEAP32[$5 + 120 >> 2]) {
   HEAP32[$5 + 84 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 84 >> 2] < HEAP32[$5 + 104 >> 2]) {
     HEAP32[$5 + 80 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 80 >> 2] < HEAP32[$5 + 100 >> 2]) {
       HEAP32[$5 + 76 >> 2] = 0;
       while (1) {
        if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 116 >> 2]) {
         HEAP32[$5 + 72 >> 2] = Math_imul(HEAP32[$5 + 80 >> 2], HEAP32[$5 + 92 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 2 >> 1];
         HEAP32[$5 + 68 >> 2] = Math_imul(HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 4 >> 1];
         HEAP32[$5 + 60 >> 2] = 0;
         HEAP32[$5 + 56 >> 2] = 0 - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 64 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 60 | 0, $5 + 56 | 0) >> 2];
         $0 = HEAP32[$5 + 140 >> 2];
         HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 108 >> 2] - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 52 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0 + 24 | 0, $5 + 48 | 0) >> 2];
         HEAP32[$5 + 40 >> 2] = 0;
         HEAP32[$5 + 36 >> 2] = 0 - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 44 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 40 | 0, $5 + 36 | 0) >> 2];
         $0 = HEAP32[$5 + 140 >> 2];
         HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 112 >> 2] - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 32 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0 + 20 | 0, $5 + 28 | 0) >> 2];
         HEAPF32[$5 + 24 >> 2] = 0;
         HEAPF32[$5 + 20 >> 2] = 0;
         HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 44 >> 2];
         while (1) {
          if (HEAP32[$5 + 16 >> 2] < HEAP32[$5 + 32 >> 2]) {
           HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 64 >> 2];
           while (1) {
            if (HEAP32[$5 + 12 >> 2] < HEAP32[$5 + 52 >> 2]) {
             HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 72 >> 2] + HEAP32[$5 + 12 >> 2];
             HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 68 >> 2] + HEAP32[$5 + 16 >> 2];
             $0 = HEAP32[$5 + 132 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 4 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 76 >> 2]) << 2) | 0;
             HEAPF32[$5 + 24 >> 2] = HEAPF32[$5 + 24 >> 2] + HEAPF32[$0 >> 2];
             HEAPF32[$5 + 20 >> 2] = HEAPF32[$5 + 20 >> 2] + Math_fround(1);
             HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + 1;
           continue;
          }
          break;
         }
         HEAPF32[$5 >> 2] = HEAPF32[$5 + 24 >> 2] / HEAPF32[$5 + 20 >> 2];
         $6 = float_20tflite__ActivationFunctionWithMinMax_float__28float_2c_20float_2c_20float_29(HEAPF32[$5 >> 2], HEAPF32[HEAP32[$5 + 140 >> 2] + 36 >> 2], HEAPF32[HEAP32[$5 + 140 >> 2] + 40 >> 2]);
         HEAPF32[HEAP32[$5 + 124 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 128 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2]) << 2) >> 2] = $6;
         HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 80 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 84 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 144 | 0;
}

function jsiPacketProcess() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $0 = __stack_pointer - 144 | 0;
 __stack_pointer = $0;
 HEAP16[$0 + 142 >> 1] = HEAPU16[182240] & 57344;
 HEAP16[182240] = HEAPU16[182240] & 8191;
 label$1: {
  if (HEAPU16[$0 + 142 >> 1] == 8192) {
   HEAP32[$0 + 136 >> 2] = jspEvaluateExpressionVar(HEAP32[91104]);
   label$3: {
    if (jspHasError() & 1) {
     jsiConsolePrintChar(21);
     jsiCheckErrors();
     break label$3;
    }
    jsiConsolePrintChar(6);
    HEAP32[$0 + 132 >> 2] = jswrap_espruino_toJS(HEAP32[$0 + 136 >> 2]);
    jsiPacketReply(0, HEAP32[$0 + 132 >> 2]);
    jsvUnLock(HEAP32[$0 + 132 >> 2]);
   }
   jsvUnLock(HEAP32[$0 + 136 >> 2]);
   break label$1;
  }
  label$5: {
   if (HEAPU16[$0 + 142 >> 1] == 16384) {
    HEAP32[$0 + 128 >> 2] = jswrap_json_parse_liberal(HEAP32[91104], 1);
    HEAP8[$0 + 127 | 0] = jsvIsObject(HEAP32[$0 + 128 >> 2]) & 1;
    if (HEAP8[$0 + 127 | 0] & 1) {
     HEAP8[$0 + 127 | 0] = jsiExecuteEventCallbackOn(137917, 117882, 1, $0 + 128 | 0) & 1;
    }
    jsvUnLock(HEAP32[$0 + 128 >> 2]);
    jsiConsolePrintChar((HEAP8[$0 + 127 | 0] & 1 ? 6 : 21) << 24 >> 24);
    break label$5;
   }
   label$8: {
    if (HEAPU16[$0 + 142 >> 1] == 40960) {
     HEAP32[$0 + 120 >> 2] = jswrap_json_parse_liberal(HEAP32[91104], 1);
     HEAP8[$0 + 119 | 0] = jsvIsObject(HEAP32[$0 + 120 >> 2]) & 1;
     if (HEAP8[$0 + 119 | 0] & 1) {
      HEAP32[$0 + 112 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 120 >> 2], 128533);
      HEAP8[$0 + 119 | 0] = jsvIsString(HEAP32[$0 + 112 >> 2]) & 1;
      HEAP32[$0 + 108 >> 2] = jswrap_storage_read(HEAP32[$0 + 112 >> 2], 0, 0);
      label$11: {
       if (HEAP32[$0 + 108 >> 2]) {
        jsiConsolePrintChar(6);
        HEAP32[$0 + 104 >> 2] = jsvGetStringLength(HEAP32[$0 + 108 >> 2]);
        HEAP32[$0 + 100 >> 2] = 0;
        while (1) {
         if (HEAPU32[$0 + 100 >> 2] < HEAPU32[$0 + 104 >> 2]) {
          HEAP32[$0 + 96 >> 2] = jsvNewFromStringVar(HEAP32[$0 + 108 >> 2], HEAP32[$0 + 100 >> 2], 1024);
          jsiPacketReply(32768, HEAP32[$0 + 96 >> 2]);
          jsvUnLock(HEAP32[$0 + 96 >> 2]);
          HEAP32[$0 + 100 >> 2] = HEAP32[$0 + 100 >> 2] + 1024;
          continue;
         }
         break;
        }
        break label$11;
       }
       HEAP8[$0 + 119 | 0] = 0;
      }
      jsvUnLock(HEAP32[$0 + 112 >> 2]);
      if (HEAP8[$0 + 119 | 0] & 1) {
       jsiPacketReply(32768, 0);
      }
     }
     if (!(HEAP8[$0 + 119 | 0] & 1)) {
      jsiConsolePrintChar(21);
     }
     break label$8;
    }
    label$17: {
     if (HEAPU16[$0 + 142 >> 1] == 24576) {
      jsiPacketFileEnd();
      HEAP32[$0 + 92 >> 2] = jswrap_json_parse_liberal(HEAP32[91104], 1);
      HEAP8[$0 + 91 | 0] = jsvIsObject(HEAP32[$0 + 92 >> 2]) & 1;
      if (HEAP8[$0 + 91 | 0] & 1) {
       HEAP32[$0 + 84 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 92 >> 2], 128533);
       HEAP8[$0 + 91 | 0] = jsvIsString(HEAP32[$0 + 84 >> 2]) & 1;
       if (HEAP8[$0 + 91 | 0] & 1) {
        HEAP8[$0 + 91 | 0] = (jsvObjectGetIntegerChild(HEAP32[$0 + 92 >> 2], 120694) | 0) != 0;
       }
       jsvUnLock(HEAP32[$0 + 84 >> 2]);
      }
      if (HEAP8[$0 + 91 | 0] & 1) {
       jsvObjectSetChildAndUnLock(HEAP32[91087], 137821, HEAP32[$0 + 92 >> 2]);
       jsiPacketFileSetTimeout(1);
      }
      jsvUnLock(HEAP32[$0 + 92 >> 2]);
      jsiConsolePrintChar((HEAP8[$0 + 91 | 0] & 1 ? 6 : 21) << 24 >> 24);
      break label$17;
     }
     label$22: {
      if (HEAPU16[$0 + 142 >> 1] == 32768) {
       HEAP32[$0 + 80 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 137821);
       HEAP32[$0 + 76 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 80 >> 2], 128533);
       label$24: {
        if (!(!HEAP32[$0 + 80 >> 2] | !HEAP32[$0 + 76 >> 2])) {
         HEAP32[$0 + 68 >> 2] = jsvObjectGetIntegerChild(HEAP32[$0 + 80 >> 2], 120694);
         HEAP32[$0 + 64 >> 2] = jsvObjectGetIntegerChild(HEAP32[$0 + 80 >> 2], 120173);
         jsfNameFromVar($0 + 32 | 0, HEAP32[$0 + 76 >> 2]);
         $3 = HEAP32[91104];
         $4 = HEAP32[$0 + 64 >> 2];
         $5 = HEAP32[$0 + 68 >> 2];
         HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 56 >> 2];
         $1 = HEAP32[$0 + 52 >> 2];
         $2 = HEAP32[$0 + 48 >> 2];
         HEAP32[$0 + 16 >> 2] = $2;
         HEAP32[$0 + 20 >> 2] = $1;
         $2 = HEAP32[$0 + 44 >> 2];
         $1 = HEAP32[$0 + 40 >> 2];
         HEAP32[$0 + 8 >> 2] = $1;
         HEAP32[$0 + 12 >> 2] = $2;
         $1 = HEAP32[$0 + 36 >> 2];
         $2 = HEAP32[$0 + 32 >> 2];
         HEAP32[$0 >> 2] = $2;
         HEAP32[$0 + 4 >> 2] = $1;
         HEAP8[$0 + 75 | 0] = jsfWriteFile($0, $3, 0, $4, $5) & 1;
         HEAP32[$0 + 64 >> 2] = HEAPU16[182240] + HEAP32[$0 + 64 >> 2];
         jsvObjectSetChildAndUnLock(HEAP32[$0 + 80 >> 2], 120173, jsvNewFromInteger(HEAP32[$0 + 64 >> 2]));
         if (HEAP32[$0 + 64 >> 2] >= HEAP32[$0 + 68 >> 2]) {
          jsiPacketFileEnd();
         }
         break label$24;
        }
        HEAP8[$0 + 75 | 0] = 0;
       }
       jsvUnLock2(HEAP32[$0 + 76 >> 2], HEAP32[$0 + 80 >> 2]);
       jsiConsolePrintChar((HEAP8[$0 + 75 | 0] & 1 ? 6 : 21) << 24 >> 24);
       jsiPacketFileSetTimeout(1);
       break label$22;
      }
      jsiConsolePrintChar(21);
     }
    }
   }
  }
 }
 jsiPacketExit();
 __stack_pointer = $0 + 144 | 0;
}

function jsvIterateBufferCallback($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 256 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 248 >> 2] = $0;
 HEAP32[$3 + 244 >> 2] = $1;
 HEAP32[$3 + 240 >> 2] = $2;
 HEAP8[$3 + 239 | 0] = 1;
 label$1: {
  label$2: {
   if (jsvIsNumeric(HEAP32[$3 + 248 >> 2]) & 1) {
    HEAP8[$3 + 238 | 0] = jsvGetInteger(HEAP32[$3 + 248 >> 2]);
    FUNCTION_TABLE[HEAP32[$3 + 244 >> 2]]($3 + 238 | 0, 1, HEAP32[$3 + 240 >> 2]);
    break label$2;
   }
   label$4: {
    if (jsvIsObject(HEAP32[$3 + 248 >> 2]) & 1) {
     HEAP32[$3 + 232 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 248 >> 2], 129127);
     if (jsvIsFunction(HEAP32[$3 + 232 >> 2]) & 1) {
      HEAP32[$3 + 228 >> 2] = jspExecuteFunction(HEAP32[$3 + 232 >> 2], 0, 0, 0);
      jsvUnLock(HEAP32[$3 + 232 >> 2]);
      if (HEAP32[$3 + 228 >> 2]) {
       HEAP8[$3 + 227 | 0] = jsvIterateBufferCallback(HEAP32[$3 + 228 >> 2], HEAP32[$3 + 244 >> 2], HEAP32[$3 + 240 >> 2]) & 1;
       jsvUnLock(HEAP32[$3 + 228 >> 2]);
       HEAP8[$3 + 255 | 0] = HEAP8[$3 + 227 | 0] & 1;
       break label$1;
      }
      HEAP8[$3 + 255 | 0] = 1;
      break label$1;
     }
     jsvUnLock(HEAP32[$3 + 232 >> 2]);
     HEAP32[$3 + 220 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 248 >> 2], 117360);
     HEAP32[$3 + 216 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 248 >> 2], 135835);
     label$8: {
      label$9: {
       if (!HEAP32[$3 + 220 >> 2] | !HEAP32[$3 + 216 >> 2]) {
        break label$9;
       }
       if (!(jsvIsNumeric(HEAP32[$3 + 220 >> 2]) & 1)) {
        break label$9;
       }
       HEAP32[$3 + 212 >> 2] = jsvGetInteger(HEAP32[$3 + 220 >> 2]);
       while (1) {
        $0 = 0;
        if (HEAP8[$3 + 239 | 0] & 1) {
         $0 = HEAP32[$3 + 212 >> 2];
         HEAP32[$3 + 212 >> 2] = $0 - 1;
         $0 = ($0 | 0) > 0;
        }
        if ($0) {
         HEAP8[$3 + 239 | 0] = jsvIterateBufferCallback(HEAP32[$3 + 216 >> 2], HEAP32[$3 + 244 >> 2], HEAP32[$3 + 240 >> 2]) & 1;
         continue;
        }
        break;
       }
       break label$8;
      }
      HEAP32[$3 >> 2] = HEAP32[$3 + 248 >> 2];
      jsExceptionHere(3, 129158, $3);
      HEAP8[$3 + 239 | 0] = 0;
     }
     jsvUnLock2(HEAP32[$3 + 220 >> 2], HEAP32[$3 + 216 >> 2]);
     break label$4;
    }
    label$13: {
     if (jsvIsString(HEAP32[$3 + 248 >> 2]) & 1) {
      jsvStringIteratorNew($3 + 176 | 0, HEAP32[$3 + 248 >> 2], 0);
      while (1) {
       $0 = 0;
       if (jsvStringIteratorHasChar_2($3 + 176 | 0) & 1) {
        $0 = HEAPU8[$3 + 239 | 0];
       }
       if ($0 & 1) {
        jsvStringIteratorGetPtrAndNext($3 + 176 | 0, $3 + 172 | 0, $3 + 168 | 0);
        FUNCTION_TABLE[HEAP32[$3 + 244 >> 2]](HEAP32[$3 + 172 >> 2], HEAP32[$3 + 168 >> 2], HEAP32[$3 + 240 >> 2]);
        continue;
       }
       break;
      }
      jsvStringIteratorFree_2($3 + 176 | 0);
      break label$13;
     }
     label$18: {
      if (jsvIsArrayBuffer(HEAP32[$3 + 248 >> 2]) & 1) {
       jsvArrayBufferIteratorNew($3 + 112 | 0, HEAP32[$3 + 248 >> 2], 0);
       label$20: {
        if (!(HEAPU8[$3 + 148 | 0] & 16 | (HEAPU8[$3 + 148 | 0] & 15) != 1)) {
         HEAP32[$3 + 108 >> 2] = $3 + 112;
         HEAP32[$3 + 104 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 248 >> 2]);
         while (1) {
          if (HEAP32[$3 + 104 >> 2]) {
           jsvStringIteratorGetPtrAndNext(HEAP32[$3 + 108 >> 2], $3 + 100 | 0, $3 + 96 | 0);
           if (HEAPU32[$3 + 96 >> 2] > HEAPU32[$3 + 104 >> 2]) {
            HEAP32[$3 + 96 >> 2] = HEAP32[$3 + 104 >> 2];
           }
           FUNCTION_TABLE[HEAP32[$3 + 244 >> 2]](HEAP32[$3 + 100 >> 2], HEAP32[$3 + 96 >> 2], HEAP32[$3 + 240 >> 2]);
           HEAP32[$3 + 104 >> 2] = HEAP32[$3 + 104 >> 2] - HEAP32[$3 + 96 >> 2];
           continue;
          }
          break;
         }
         break label$20;
        }
        while (1) {
         if (jsvArrayBufferIteratorHasElement($3 + 112 | 0) & 1) {
          HEAP8[$3 + 95 | 0] = jsvArrayBufferIteratorGetIntegerValue($3 + 112 | 0);
          FUNCTION_TABLE[HEAP32[$3 + 244 >> 2]]($3 + 95 | 0, 1, HEAP32[$3 + 240 >> 2]);
          jsvArrayBufferIteratorNext($3 + 112 | 0);
          continue;
         }
         break;
        }
       }
       jsvArrayBufferIteratorFree($3 + 112 | 0);
       break label$18;
      }
      label$27: {
       if (jsvIsIterable(HEAP32[$3 + 248 >> 2]) & 1) {
        jsvIteratorNew($3 + 32 | 0, HEAP32[$3 + 248 >> 2], 1);
        while (1) {
         $0 = 0;
         if (jsvIteratorHasElement($3 + 32 | 0) & 1) {
          $0 = HEAPU8[$3 + 239 | 0];
         }
         if ($0 & 1) {
          HEAP32[$3 + 28 >> 2] = jsvIteratorGetValue($3 + 32 | 0);
          HEAP8[$3 + 239 | 0] = jsvIterateBufferCallback(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 244 >> 2], HEAP32[$3 + 240 >> 2]) & 1;
          jsvUnLock(HEAP32[$3 + 28 >> 2]);
          jsvIteratorNext($3 + 32 | 0);
          continue;
         }
         break;
        }
        jsvIteratorFree($3 + 32 | 0);
        break label$27;
       }
       HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 248 >> 2];
       jsExceptionHere(3, 118945, $3 + 16 | 0);
       HEAP8[$3 + 239 | 0] = 0;
      }
     }
    }
   }
  }
  HEAP8[$3 + 255 | 0] = HEAP8[$3 + 239 | 0] & 1;
 }
 __stack_pointer = $3 + 256 | 0;
 return HEAP8[$3 + 255 | 0] & 1;
}

function __rem_pio2($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = __stack_pointer - 48 | 0;
 __stack_pointer = $7;
 wasm2js_scratch_store_f64(+$0);
 $4 = wasm2js_scratch_load_i32(1) | 0;
 $11 = wasm2js_scratch_load_i32(0) | 0;
 label$1: {
  label$2: {
   $3 = $4;
   $8 = $4 & 2147483647;
   label$3: {
    if ($8 >>> 0 <= 1074752122) {
     if (($3 & 1048575) == 598523) {
      break label$3;
     }
     if ($8 >>> 0 <= 1073928572) {
      if (($4 | 0) > 0 | ($4 | 0) >= 0) {
       $0 = $0 + -1.5707963267341256;
       $2 = $0 + -6077100506506192e-26;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + -6077100506506192e-26;
       $3 = 1;
       break label$1;
      }
      $0 = $0 + 1.5707963267341256;
      $2 = $0 + 6077100506506192e-26;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + 6077100506506192e-26;
      $3 = -1;
      break label$1;
     }
     if (($4 | 0) > 0 | ($4 | 0) >= 0) {
      $0 = $0 + -3.1415926534682512;
      $2 = $0 + -1.2154201013012384e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + -1.2154201013012384e-10;
      $3 = 2;
      break label$1;
     }
     $0 = $0 + 3.1415926534682512;
     $2 = $0 + 1.2154201013012384e-10;
     HEAPF64[$1 >> 3] = $2;
     HEAPF64[$1 + 8 >> 3] = $0 - $2 + 1.2154201013012384e-10;
     $3 = -2;
     break label$1;
    }
    if ($8 >>> 0 <= 1075594811) {
     if ($8 >>> 0 <= 1075183036) {
      if (($8 | 0) == 1074977148) {
       break label$3;
      }
      if (($4 | 0) > 0 | ($4 | 0) >= 0) {
       $0 = $0 + -4.712388980202377;
       $2 = $0 + -1.8231301519518578e-10;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + -1.8231301519518578e-10;
       $3 = 3;
       break label$1;
      }
      $0 = $0 + 4.712388980202377;
      $2 = $0 + 1.8231301519518578e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + 1.8231301519518578e-10;
      $3 = -3;
      break label$1;
     }
     if (($8 | 0) == 1075388923) {
      break label$3;
     }
     if (($4 | 0) > 0 | ($4 | 0) >= 0) {
      $0 = $0 + -6.2831853069365025;
      $2 = $0 + -2.430840202602477e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + -2.430840202602477e-10;
      $3 = 4;
      break label$1;
     }
     $0 = $0 + 6.2831853069365025;
     $2 = $0 + 2.430840202602477e-10;
     HEAPF64[$1 >> 3] = $2;
     HEAPF64[$1 + 8 >> 3] = $0 - $2 + 2.430840202602477e-10;
     $3 = -4;
     break label$1;
    }
    if ($8 >>> 0 > 1094263290) {
     break label$2;
    }
   }
   $2 = $0 * .6366197723675814 + 6755399441055744 + -6755399441055744;
   $6 = $0 + $2 * -1.5707963267341256;
   $10 = $2 * 6077100506506192e-26;
   $12 = $6 - $10;
   $9 = $12 < -.7853981633974483;
   if (Math_abs($2) < 2147483648) {
    $3 = ~~$2;
   } else {
    $3 = -2147483648;
   }
   label$14: {
    if ($9) {
     $3 = $3 - 1 | 0;
     $2 = $2 + -1;
     $10 = $2 * 6077100506506192e-26;
     $6 = $0 + $2 * -1.5707963267341256;
     break label$14;
    }
    if (!($12 > .7853981633974483)) {
     break label$14;
    }
    $3 = $3 + 1 | 0;
    $2 = $2 + 1;
    $10 = $2 * 6077100506506192e-26;
    $6 = $0 + $2 * -1.5707963267341256;
   }
   $0 = $6 - $10;
   HEAPF64[$1 >> 3] = $0;
   wasm2js_scratch_store_f64(+$0);
   $5 = wasm2js_scratch_load_i32(1) | 0;
   wasm2js_scratch_load_i32(0) | 0;
   $9 = $8 >>> 20 | 0;
   label$16: {
    if (($9 - ($5 >>> 20 & 2047) | 0) < 17) {
     break label$16;
    }
    $0 = $2 * 6077100506303966e-26;
    $12 = $6 - $0;
    $10 = $2 * 20222662487959506e-37 - ($6 - $12 - $0);
    $0 = $12 - $10;
    HEAPF64[$1 >> 3] = $0;
    wasm2js_scratch_store_f64(+$0);
    $5 = wasm2js_scratch_load_i32(1) | 0;
    wasm2js_scratch_load_i32(0) | 0;
    if (($9 - ($5 >>> 20 & 2047) | 0) < 50) {
     $6 = $12;
     break label$16;
    }
    $0 = $2 * 20222662487111665e-37;
    $6 = $12 - $0;
    $10 = $2 * 84784276603689e-45 - ($12 - $6 - $0);
    $0 = $6 - $10;
    HEAPF64[$1 >> 3] = $0;
   }
   HEAPF64[$1 + 8 >> 3] = $6 - $0 - $10;
   break label$1;
  }
  if ($8 >>> 0 >= 2146435072) {
   $0 = $0 - $0;
   HEAPF64[$1 >> 3] = $0;
   HEAPF64[$1 + 8 >> 3] = $0;
   $3 = 0;
   break label$1;
  }
  $5 = $4 & 1048575;
  wasm2js_scratch_store_i32(0, $11 | 0);
  $5 = $5 | 1096810496;
  wasm2js_scratch_store_i32(1, $5 | 0);
  $0 = +wasm2js_scratch_load_f64();
  $3 = 0;
  $9 = 1;
  while (1) {
   $3 = ($7 + 16 | 0) + ($3 << 3) | 0;
   if (Math_abs($0) < 2147483648) {
    $5 = ~~$0;
   } else {
    $5 = -2147483648;
   }
   $2 = +($5 | 0);
   HEAPF64[$3 >> 3] = $2;
   $0 = ($0 - $2) * 16777216;
   $3 = 1;
   $5 = $9 & 1;
   $9 = 0;
   if ($5) {
    continue;
   }
   break;
  }
  HEAPF64[$7 + 32 >> 3] = $0;
  $3 = 2;
  while (1) {
   $9 = $3;
   $3 = $3 - 1 | 0;
   if (HEAPF64[($7 + 16 | 0) + ($9 << 3) >> 3] == 0) {
    continue;
   }
   break;
  }
  $3 = __rem_pio2_large($7 + 16 | 0, $7, ($8 >>> 20 | 0) - 1046 | 0, $9 + 1 | 0, 1);
  $0 = HEAPF64[$7 >> 3];
  if (($4 | 0) < 0) {
   HEAPF64[$1 >> 3] = -$0;
   HEAPF64[$1 + 8 >> 3] = -HEAPF64[$7 + 8 >> 3];
   $3 = 0 - $3 | 0;
   break label$1;
  }
  HEAPF64[$1 >> 3] = $0;
  HEAPF64[$1 + 8 >> 3] = HEAPF64[$7 + 8 >> 3];
 }
 __stack_pointer = $7 + 48 | 0;
 return $3;
}

function terminalSendChar($0) {
 var $1 = 0;
 $1 = __stack_pointer - 176 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 175 | 0] = $0;
 label$1: {
  if (!HEAP8[391324]) {
   if (HEAP8[$1 + 175 | 0] == 8) {
    if (HEAPU8[391322]) {
     HEAP8[391322] = HEAPU8[391322] - 1;
    }
    break label$1;
   }
   label$5: {
    if (HEAP8[$1 + 175 | 0] == 10) {
     HEAP8[391322] = 0;
     HEAP8[195720] = HEAPU8[195720] + 1;
     while (1) {
      if (HEAPU8[195720] >= 22) {
       terminalScroll();
       continue;
      }
      break;
     }
     break label$5;
    }
    label$9: {
     if (HEAP8[$1 + 175 | 0] == 13) {
      HEAP8[391322] = 0;
      break label$9;
     }
     label$11: {
      if (HEAP8[$1 + 175 | 0] == 27) {
       HEAP8[391324] = 27;
       break label$11;
      }
      if (!(HEAP8[$1 + 175 | 0] == 19 | HEAP8[$1 + 175 | 0] == 17)) {
       if (terminalGetGFX($1 + 96 | 0) & 1) {
        HEAP16[$1 + 94 >> 1] = Math_imul(HEAPU8[391322], 6);
        HEAP16[$1 + 92 >> 1] = ((HEAPU8[$1 + 110 | 0] | HEAPU8[$1 + 111 | 0] << 8) + (HEAPU8[195720] << 3) | 0) - 176;
        HEAP32[$1 + 88 >> 2] = HEAPU8[$1 + 113 | 0] | HEAPU8[$1 + 114 | 0] << 8 | (HEAPU8[$1 + 115 | 0] << 16 | HEAPU8[$1 + 116 | 0] << 24);
        HEAP32[$1 + 84 >> 2] = HEAPU8[$1 + 117 | 0] | HEAPU8[$1 + 118 | 0] << 8 | (HEAPU8[$1 + 119 | 0] << 16 | HEAPU8[$1 + 120 | 0] << 24);
        $0 = HEAPU8[366785] | HEAPU8[366786] << 8;
        HEAP8[$1 + 113 | 0] = $0;
        HEAP8[$1 + 114 | 0] = $0 >>> 8;
        HEAP8[$1 + 115 | 0] = $0 >>> 16;
        HEAP8[$1 + 116 | 0] = $0 >>> 24;
        $0 = HEAPU8[366787] | HEAPU8[366788] << 8;
        HEAP8[$1 + 117 | 0] = $0;
        HEAP8[$1 + 118 | 0] = $0 >>> 8;
        HEAP8[$1 + 119 | 0] = $0 >>> 16;
        HEAP8[$1 + 120 | 0] = $0 >>> 24;
        graphicsDrawChar6x8($1 + 96 | 0, HEAP16[$1 + 94 >> 1], HEAP16[$1 + 92 >> 1], HEAP8[$1 + 175 | 0], 1, 1, 1);
        $0 = HEAP32[$1 + 88 >> 2];
        HEAP8[$1 + 113 | 0] = $0;
        HEAP8[$1 + 114 | 0] = $0 >>> 8;
        HEAP8[$1 + 115 | 0] = $0 >>> 16;
        HEAP8[$1 + 116 | 0] = $0 >>> 24;
        $0 = HEAP32[$1 + 84 >> 2];
        HEAP8[$1 + 117 | 0] = $0;
        HEAP8[$1 + 118 | 0] = $0 >>> 8;
        HEAP8[$1 + 119 | 0] = $0 >>> 16;
        HEAP8[$1 + 120 | 0] = $0 >>> 24;
        terminalSetGFX($1 + 96 | 0);
       }
       if (HEAPU8[391322] < 255) {
        HEAP8[391322] = HEAPU8[391322] + 1;
       }
      }
     }
    }
   }
   break label$1;
  }
  label$17: {
   if (HEAP8[391324] == 27) {
    if (HEAP8[391325] == 91) {
     if (HEAP8[391326] == 63) {
      if (HEAP8[391327] == 55) {
       terminalControlCharsReset();
       break label$17;
      }
      label$22: {
       if (HEAP8[$1 + 175 | 0] == 55) {
        HEAP8[391327] = 55;
        break label$22;
       }
       terminalControlCharsReset();
      }
      break label$17;
     }
     label$24: {
      if (HEAP8[$1 + 175 | 0] == 63) {
       HEAP8[391326] = 63;
       break label$24;
      }
      terminalControlCharsReset();
      label$26: {
       label$27: {
        switch (HEAP8[$1 + 175 | 0] - 65 | 0) {
        case 0:
         if (HEAPU8[195720]) {
          HEAP8[195720] = HEAPU8[195720] - 1;
         }
         break label$26;

        case 1:
         HEAP8[195720] = HEAPU8[195720] + 1;
         while (1) {
          if (HEAPU8[195720] >= 22) {
           terminalScroll();
           continue;
          }
          break;
         }
         ;
         break label$26;

        case 2:
         if (HEAPU8[391322] < 255) {
          HEAP8[391322] = HEAPU8[391322] + 1;
         }
         break label$26;

        case 3:
         if (HEAPU8[391322]) {
          HEAP8[391322] = HEAPU8[391322] - 1;
         }
         break label$26;

        case 9:
         break label$27;

        default:
         break label$26;
        }
       }
       if (terminalGetGFX($1 + 8 | 0) & 1) {
        HEAP16[$1 + 6 >> 1] = Math_imul(HEAPU8[391322], 6);
        HEAP16[$1 + 4 >> 1] = ((HEAPU8[$1 + 22 | 0] | HEAPU8[$1 + 23 | 0] << 8) + (HEAPU8[195720] << 3) | 0) - 176;
        if ((HEAPU8[$1 + 16 | 0] | HEAPU8[$1 + 17 | 0] << 8 | (HEAPU8[$1 + 18 | 0] << 16 | HEAPU8[$1 + 19 | 0] << 24)) & 16) {
         $0 = HEAPU8[$1 + 22 | 0] | HEAPU8[$1 + 23 | 0] << 8;
        } else {
         $0 = HEAPU8[$1 + 20 | 0] | HEAPU8[$1 + 21 | 0] << 8;
        }
        HEAP16[$1 + 2 >> 1] = $0;
        if ((HEAPU8[$1 + 16 | 0] | HEAPU8[$1 + 17 | 0] << 8 | (HEAPU8[$1 + 18 | 0] << 16 | HEAPU8[$1 + 19 | 0] << 24)) & 16) {
         $0 = HEAPU8[$1 + 20 | 0] | HEAPU8[$1 + 21 | 0] << 8;
        } else {
         $0 = HEAPU8[$1 + 22 | 0] | HEAPU8[$1 + 23 | 0] << 8;
        }
        HEAP16[$1 >> 1] = $0;
        graphicsFillRect($1 + 8 | 0, HEAP16[$1 + 6 >> 1], HEAP16[$1 + 4 >> 1], HEAP16[$1 + 2 >> 1] - 1 | 0, HEAP16[$1 + 4 >> 1] + 7 | 0, 0);
        graphicsFillRect($1 + 8 | 0, 0, HEAP16[$1 + 4 >> 1] + 8 | 0, HEAP16[$1 + 2 >> 1] - 1 | 0, HEAP16[$1 >> 1] - 1 | 0, 0);
        terminalSetGFX($1 + 8 | 0);
       }
      }
     }
     break label$17;
    }
    label$42: {
     if (HEAP8[$1 + 175 | 0] == 91) {
      HEAP8[391325] = 91;
      break label$42;
     }
     terminalControlCharsReset();
    }
    break label$17;
   }
   terminalControlCharsReset();
  }
 }
 __stack_pointer = $1 + 176 | 0;
}

function jswrap_storage_open($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 256 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 248 >> 2] = $0;
 HEAP32[$2 + 244 >> 2] = $1;
 HEAP8[$2 + 243 | 0] = 0;
 label$1: {
  label$2: {
   if (jsvIsStringEqual(HEAP32[$2 + 244 >> 2], 121469) & 1) {
    HEAP8[$2 + 243 | 0] = 114;
    break label$2;
   }
   label$4: {
    if (jsvIsStringEqual(HEAP32[$2 + 244 >> 2], 116775) & 1) {
     HEAP8[$2 + 243 | 0] = 119;
     break label$4;
    }
    label$6: {
     if (jsvIsStringEqual(HEAP32[$2 + 244 >> 2], 135863) & 1) {
      HEAP8[$2 + 243 | 0] = 97;
      break label$6;
     }
     HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 244 >> 2];
     jsExceptionHere(1, 129296, $2 - -64 | 0);
     HEAP32[$2 + 252 >> 2] = 0;
     break label$1;
    }
   }
  }
  HEAP32[$2 + 236 >> 2] = jspNewObject(0, 132475);
  if (!HEAP32[$2 + 236 >> 2]) {
   HEAP32[$2 + 252 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 232 >> 2] = 1;
  HEAP32[$2 + 228 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 248 >> 2], 0, 28);
  jsfNameFromVar($2 + 200 | 0, HEAP32[$2 + 228 >> 2]);
  HEAP32[$2 + 196 >> 2] = 27;
  while (1) {
   $0 = 0;
   $0 = HEAP32[$2 + 196 >> 2] ? !HEAP8[(HEAP32[$2 + 196 >> 2] + $2 | 0) + 199 | 0] : $0;
   if ($0) {
    HEAP32[$2 + 196 >> 2] = HEAP32[$2 + 196 >> 2] - 1;
    continue;
   }
   break;
  }
  HEAP8[HEAP32[$2 + 196 >> 2] + ($2 + 200 | 0) | 0] = HEAP32[$2 + 232 >> 2];
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 132398, HEAP32[$2 + 228 >> 2]);
  HEAP32[$2 + 192 >> 2] = 0;
  HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 224 >> 2];
  $0 = HEAP32[$2 + 220 >> 2];
  $1 = HEAP32[$2 + 216 >> 2];
  HEAP32[$2 + 48 >> 2] = $1;
  HEAP32[$2 + 52 >> 2] = $0;
  $1 = HEAP32[$2 + 212 >> 2];
  $0 = HEAP32[$2 + 208 >> 2];
  HEAP32[$2 + 40 >> 2] = $0;
  HEAP32[$2 + 44 >> 2] = $1;
  $0 = HEAP32[$2 + 204 >> 2];
  $1 = HEAP32[$2 + 200 >> 2];
  HEAP32[$2 + 32 >> 2] = $1;
  HEAP32[$2 + 36 >> 2] = $0;
  HEAP32[$2 + 156 >> 2] = jsfFindFile($2 + 32 | 0, $2 + 160 | 0);
  if (HEAP32[$2 + 156 >> 2] ? HEAP8[$2 + 243 | 0] == 119 : 0) {
   jswrap_storagefile_erase(HEAP32[$2 + 236 >> 2]);
   HEAP32[$2 + 156 >> 2] = 0;
  }
  label$14: {
   if (HEAP32[$2 + 156 >> 2]) {
    $0 = jsfGetFileSize($2 + 160 | 0);
    break label$14;
   }
   $0 = 0;
  }
  HEAP32[$2 + 152 >> 2] = $0;
  if (HEAP8[$2 + 243 | 0] == 97) {
   HEAP8[$2 + 151 | 0] = 255;
   if (HEAP32[$2 + 156 >> 2]) {
    jshFlashRead($2 + 151 | 0, (HEAP32[$2 + 156 >> 2] + jsfGetFileSize($2 + 160 | 0) | 0) - 1 | 0, 1);
   }
   while (1) {
    $0 = 0;
    label$19: {
     if (!HEAP32[$2 + 156 >> 2]) {
      break label$19;
     }
     $0 = 0;
     if (HEAPU8[$2 + 151 | 0] == 255) {
      break label$19;
     }
     $0 = HEAP32[$2 + 232 >> 2] < 255;
    }
    if ($0) {
     HEAP32[$2 + 232 >> 2] = HEAP32[$2 + 232 >> 2] + 1;
     HEAP8[HEAP32[$2 + 196 >> 2] + ($2 + 200 | 0) | 0] = HEAP32[$2 + 232 >> 2];
     HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 224 >> 2];
     $1 = HEAP32[$2 + 220 >> 2];
     $0 = HEAP32[$2 + 216 >> 2];
     HEAP32[$2 + 16 >> 2] = $0;
     HEAP32[$2 + 20 >> 2] = $1;
     $0 = HEAP32[$2 + 212 >> 2];
     $1 = HEAP32[$2 + 208 >> 2];
     HEAP32[$2 + 8 >> 2] = $1;
     HEAP32[$2 + 12 >> 2] = $0;
     $1 = HEAP32[$2 + 204 >> 2];
     $0 = HEAP32[$2 + 200 >> 2];
     HEAP32[$2 >> 2] = $0;
     HEAP32[$2 + 4 >> 2] = $1;
     HEAP32[$2 + 156 >> 2] = jsfFindFile($2, $2 + 160 | 0);
     label$21: {
      if (HEAP32[$2 + 156 >> 2]) {
       HEAP32[$2 + 152 >> 2] = jsfGetFileSize($2 + 160 | 0);
       jshFlashRead($2 + 151 | 0, (HEAP32[$2 + 156 >> 2] + HEAP32[$2 + 152 >> 2] | 0) - 1 | 0, 1);
       break label$21;
      }
      HEAP32[$2 + 152 >> 2] = 0;
     }
     continue;
    }
    break;
   }
   if (HEAP32[$2 + 156 >> 2]) {
    HEAP8[$2 + 79 | 0] = 0;
    while (1) {
     label$25: {
      if (!((HEAPU8[$2 + 79 | 0] ^ -1) & 1)) {
       break label$25;
      }
      HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 152 >> 2] - HEAP32[$2 + 192 >> 2];
      if (HEAP32[$2 + 72 >> 2] <= 0) {
       HEAP8[$2 + 79 | 0] = 1;
       break label$25;
      }
      if (HEAP32[$2 + 72 >> 2] > 64) {
       HEAP32[$2 + 72 >> 2] = 64;
      }
      jshFlashRead($2 + 80 | 0, HEAP32[$2 + 156 >> 2] + HEAP32[$2 + 192 >> 2] | 0, HEAP32[$2 + 72 >> 2]);
      HEAP32[$2 + 68 >> 2] = 0;
      while (1) {
       if (HEAP32[$2 + 68 >> 2] < HEAP32[$2 + 72 >> 2]) {
        if (HEAP8[HEAP32[$2 + 68 >> 2] + ($2 + 80 | 0) | 0] == -1) {
         HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 68 >> 2];
         HEAP8[$2 + 79 | 0] = 1;
        } else {
         HEAP32[$2 + 68 >> 2] = HEAP32[$2 + 68 >> 2] + 1;
         continue;
        }
       }
       break;
      }
      HEAP32[$2 + 192 >> 2] = HEAP32[$2 + 72 >> 2] + HEAP32[$2 + 192 >> 2];
      continue;
     }
     break;
    }
   }
  }
  label$32: {
   if (HEAP8[$2 + 243 | 0] != 114) {
    break label$32;
   }
  }
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 129088, jsvNewFromInteger(HEAP32[$2 + 232 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 117864, jsvNewFromInteger(HEAP32[$2 + 192 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 236 >> 2], 132782, jsvNewFromInteger(HEAP8[$2 + 243 | 0]));
  HEAP32[$2 + 252 >> 2] = HEAP32[$2 + 236 >> 2];
 }
 __stack_pointer = $2 + 256 | 0;
 return HEAP32[$2 + 252 >> 2];
}

function tflite__reference_ops__MaxPool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = Math_fround(0);
 $5 = __stack_pointer - 144 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 140 >> 2] = $0;
 HEAP32[$5 + 136 >> 2] = $1;
 HEAP32[$5 + 132 >> 2] = $2;
 HEAP32[$5 + 128 >> 2] = $3;
 HEAP32[$5 + 124 >> 2] = $4;
 label$1: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 136 >> 2]) | 0) != 4) {
   break label$1;
  }
 }
 label$2: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 128 >> 2]) | 0) != 4) {
   break label$2;
  }
 }
 HEAP32[$5 + 120 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 0, HEAP32[$5 + 128 >> 2], 0);
 HEAP32[$5 + 116 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 136 >> 2], 3, HEAP32[$5 + 128 >> 2], 3);
 HEAP32[$5 + 112 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 1);
 HEAP32[$5 + 108 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 136 >> 2], 2);
 HEAP32[$5 + 104 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 1);
 HEAP32[$5 + 100 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$5 + 128 >> 2], 2);
 HEAP32[$5 + 96 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 12 >> 2];
 HEAP32[$5 + 92 >> 2] = HEAP32[HEAP32[$5 + 140 >> 2] + 16 >> 2];
 HEAP32[$5 + 88 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 88 >> 2] < HEAP32[$5 + 120 >> 2]) {
   HEAP32[$5 + 84 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 84 >> 2] < HEAP32[$5 + 104 >> 2]) {
     HEAP32[$5 + 80 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 80 >> 2] < HEAP32[$5 + 100 >> 2]) {
       HEAP32[$5 + 76 >> 2] = 0;
       while (1) {
        if (HEAP32[$5 + 76 >> 2] < HEAP32[$5 + 116 >> 2]) {
         HEAP32[$5 + 72 >> 2] = Math_imul(HEAP32[$5 + 80 >> 2], HEAP32[$5 + 92 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 2 >> 1];
         HEAP32[$5 + 68 >> 2] = Math_imul(HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2]) - HEAP16[HEAP32[$5 + 140 >> 2] + 4 >> 1];
         HEAP32[$5 + 60 >> 2] = 0;
         HEAP32[$5 + 56 >> 2] = 0 - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 64 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 60 | 0, $5 + 56 | 0) >> 2];
         $0 = HEAP32[$5 + 140 >> 2];
         HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 108 >> 2] - HEAP32[$5 + 72 >> 2];
         HEAP32[$5 + 52 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0 + 24 | 0, $5 + 48 | 0) >> 2];
         HEAP32[$5 + 40 >> 2] = 0;
         HEAP32[$5 + 36 >> 2] = 0 - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 44 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 40 | 0, $5 + 36 | 0) >> 2];
         $0 = HEAP32[$5 + 140 >> 2];
         HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 112 >> 2] - HEAP32[$5 + 68 >> 2];
         HEAP32[$5 + 32 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0 + 20 | 0, $5 + 28 | 0) >> 2];
         HEAPF32[$5 + 24 >> 2] = std____2__numeric_limits_float___lowest_28_29();
         HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 44 >> 2];
         while (1) {
          if (HEAP32[$5 + 20 >> 2] < HEAP32[$5 + 32 >> 2]) {
           HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 64 >> 2];
           while (1) {
            if (HEAP32[$5 + 16 >> 2] < HEAP32[$5 + 52 >> 2]) {
             HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 72 >> 2] + HEAP32[$5 + 16 >> 2];
             HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 68 >> 2] + HEAP32[$5 + 20 >> 2];
             HEAPF32[$5 + 24 >> 2] = HEAPF32[float_20const__20std____2__max_float__28float_20const__2c_20float_20const__29($5 + 24 | 0, HEAP32[$5 + 132 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 136 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 76 >> 2]) << 2) | 0) >> 2];
             HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + 1;
             continue;
            }
            break;
           }
           HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
           continue;
          }
          break;
         }
         $6 = float_20tflite__ActivationFunctionWithMinMax_float__28float_2c_20float_2c_20float_29(HEAPF32[$5 + 24 >> 2], HEAPF32[HEAP32[$5 + 140 >> 2] + 36 >> 2], HEAPF32[HEAP32[$5 + 140 >> 2] + 40 >> 2]);
         HEAPF32[HEAP32[$5 + 124 >> 2] + (tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$5 + 128 >> 2], HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2]) << 2) >> 2] = $6;
         HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 76 >> 2] + 1;
         continue;
        }
        break;
       }
       HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 80 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 84 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 144 | 0;
}

function jspeFactorFunctionCall() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 80 | 0;
 __stack_pointer = $0;
 HEAP8[$0 + 75 | 0] = 0;
 label$1: {
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 184) {
   jslGetNextToken();
   HEAP8[$0 + 75 | 0] = 1;
   if (HEAP16[HEAP32[49079] + 2 >> 1] == 184) {
    jsExceptionHere(1, 133324, 0);
    jspSetError(0);
    HEAP32[$0 + 76 >> 2] = 0;
    break label$1;
   }
  }
  HEAP32[$0 + 68 >> 2] = 0;
  HEAP32[$0 + 64 >> 2] = 0;
  HEAP8[$0 + 63 | 0] = 0;
  label$4: {
   if (HEAP16[HEAP32[49079] + 2 >> 1] == 196) {
    jslGetNextToken();
    label$6: {
     if (jsvIsObject(HEAP32[91092]) & 1) {
      label$8: {
       if (!(!HEAP32[91093] | HEAP16[HEAP32[49079] + 2 >> 1] != 40)) {
        HEAP32[$0 + 56 >> 2] = jsvObjectGetChildIfExists(HEAP32[91093], 132159);
        break label$8;
       }
       HEAP32[$0 + 56 >> 2] = jsvObjectGetChildIfExists(HEAP32[91092], 135865);
      }
      label$10: {
       if (jsvIsObject(HEAP32[$0 + 56 >> 2]) & 1) {
        $1 = jsvObjectGetChildIfExists(HEAP32[$0 + 56 >> 2], 135865);
        break label$10;
       }
       $1 = 0;
      }
      HEAP32[$0 + 52 >> 2] = $1;
      jsvUnLock(HEAP32[$0 + 56 >> 2]);
      if (!HEAP32[$0 + 52 >> 2]) {
       jsExceptionHere(2, 119882, 0);
       HEAP32[$0 + 76 >> 2] = 0;
       break label$1;
      }
      label$13: {
       if (HEAP16[HEAP32[49079] + 2 >> 1] == 40) {
        HEAP32[$0 + 48 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 52 >> 2], 120855);
        jsvUnLock(HEAP32[$0 + 52 >> 2]);
        HEAP32[91093] = HEAP32[$0 + 48 >> 2];
        HEAP8[$0 + 63 | 0] = 1;
        HEAP32[$0 + 64 >> 2] = HEAP32[$0 + 48 >> 2];
        break label$13;
       }
       HEAP32[$0 + 64 >> 2] = HEAP32[$0 + 52 >> 2];
      }
      break label$6;
     }
     label$15: {
      if (jsvIsFunction(HEAP32[91092]) & 1) {
       HEAP32[$0 + 44 >> 2] = jsvObjectGetChildIfExists(HEAP32[91092], 132159);
       label$17: {
        if (jsvIsObject(HEAP32[$0 + 44 >> 2]) & 1) {
         $1 = jsvObjectGetChildIfExists(HEAP32[$0 + 44 >> 2], 135865);
         break label$17;
        }
        $1 = 0;
       }
       HEAP32[$0 + 40 >> 2] = $1;
       jsvUnLock(HEAP32[$0 + 44 >> 2]);
       if (!HEAP32[$0 + 40 >> 2]) {
        jsExceptionHere(2, 119882, 0);
        HEAP32[$0 + 76 >> 2] = 0;
        break label$1;
       }
       HEAP32[$0 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 40 >> 2], 120855);
       jsvUnLock(HEAP32[$0 + 40 >> 2]);
       HEAP32[$0 + 64 >> 2] = HEAP32[$0 + 36 >> 2];
       break label$15;
      }
      jsExceptionHere(2, 119882, 0);
      HEAP32[$0 + 76 >> 2] = 0;
      break label$1;
     }
    }
    HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 64 >> 2];
    HEAP32[$0 + 64 >> 2] = jspeFactorMember(HEAP32[$0 + 64 >> 2], $0 + 68 | 0);
    if (!(HEAP32[$0 + 68 >> 2] != HEAP32[$0 + 32 >> 2] ? HEAP32[$0 + 68 >> 2] : 0)) {
     jsvUnLock(HEAP32[$0 + 68 >> 2]);
     HEAP32[$0 + 68 >> 2] = jsvLockAgain(HEAP32[91092]);
    }
    break label$4;
   }
   HEAP32[$0 + 64 >> 2] = jspeFactorMember(jspeFactor(), $0 + 68 | 0);
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 133) {
   jsExceptionHere(2, 133503, 0);
   jsvUnLock2(HEAP32[$0 + 64 >> 2], HEAP32[$0 + 68 >> 2]);
   HEAP32[$0 + 76 >> 2] = 0;
   break label$1;
  }
  while (1) {
   label$24: {
    if (HEAP16[HEAP32[49079] + 2 >> 1] != 40) {
     $1 = 0;
     if (!(HEAP8[$0 + 75 | 0] & 1)) {
      break label$24;
     }
     $1 = 0;
     if ((HEAP32[91094] & 63) != 1) {
      break label$24;
     }
    }
    $1 = jspIsInterrupted() ^ -1;
   }
   if ($1 & 1) {
    HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 64 >> 2];
    HEAP32[$0 + 24 >> 2] = jsvSkipName(HEAP32[$0 + 28 >> 2]);
    label$27: {
     if (!(!(HEAP8[$0 + 75 | 0] & 1) | (HEAP32[91094] & 63) != 1)) {
      HEAP8[$0 + 23 | 0] = HEAP16[HEAP32[49079] + 2 >> 1] == 40;
      HEAP32[$0 + 64 >> 2] = jspeConstruct(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 28 >> 2], HEAP8[$0 + 23 | 0] & 1);
      HEAP8[$0 + 75 | 0] = 0;
      break label$27;
     }
     HEAP32[$0 + 64 >> 2] = jspeFunctionCall(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 28 >> 2], HEAP32[$0 + 68 >> 2], 1, 0, 0);
    }
    jsvUnLock3(HEAP32[$0 + 28 >> 2], HEAP32[$0 + 24 >> 2], HEAP32[$0 + 68 >> 2]);
    HEAP32[$0 + 68 >> 2] = 0;
    HEAP32[$0 + 64 >> 2] = jspeFactorMember(HEAP32[$0 + 64 >> 2], $0 + 68 | 0);
    continue;
   }
   break;
  }
  if (HEAP8[$0 + 63 | 0] & 1) {
   HEAP32[91093] = 0;
  }
  label$30: {
   if (!HEAP32[$0 + 68 >> 2]) {
    break label$30;
   }
   if (!(jsvIsBasicName(HEAP32[$0 + 64 >> 2]) & 1)) {
    break label$30;
   }
   if (jsvIsNewChild(HEAP32[$0 + 64 >> 2]) & 1) {
    break label$30;
   }
   HEAP32[$0 + 16 >> 2] = jsvLockSafe(jsvGetFirstChild(HEAP32[$0 + 64 >> 2]) & 65535);
   if (jsvIsGetterOrSetter(HEAP32[$0 + 16 >> 2]) & 1) {
    HEAP32[$0 + 12 >> 2] = jsvCopyNameOnly(HEAP32[$0 + 64 >> 2], 0, 1);
    HEAP32[$0 + 8 >> 2] = jsvCreateNewChild(HEAP32[$0 + 68 >> 2], HEAP32[$0 + 12 >> 2], HEAP32[$0 + 16 >> 2]);
    jsvUnLock2(HEAP32[$0 + 12 >> 2], HEAP32[$0 + 64 >> 2]);
    HEAP32[$0 + 64 >> 2] = HEAP32[$0 + 8 >> 2];
   }
   jsvUnLock(HEAP32[$0 + 16 >> 2]);
  }
  jsvUnLock(HEAP32[$0 + 68 >> 2]);
  HEAP32[$0 + 76 >> 2] = HEAP32[$0 + 64 >> 2];
 }
 __stack_pointer = $0 + 80 | 0;
 return HEAP32[$0 + 76 >> 2];
}

function jsvGarbageCollect() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = __stack_pointer - 48 | 0;
 __stack_pointer = $0;
 label$1: {
  if (HEAPU8[196322]) {
   HEAP32[$0 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP8[196322] = 2;
  HEAP16[$0 + 42 >> 1] = 1;
  while (1) {
   if (HEAPU16[$0 + 42 >> 1] <= 12e3) {
    HEAP32[$0 + 36 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 42 >> 1]);
    $1 = HEAP32[$0 + 36 >> 2];
    if ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63) {
     $1 = HEAP32[$0 + 36 >> 2];
     $2 = HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8 | 256;
     HEAP8[$1 + 12 | 0] = $2;
     HEAP8[$1 + 13 | 0] = $2 >>> 8;
     if (jsvIsFlatString(HEAP32[$0 + 36 >> 2]) & 1) {
      HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + jsvGetFlatStringBlocks(HEAP32[$0 + 36 >> 2]);
     }
    }
    HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + 1;
    continue;
   }
   break;
  }
  HEAP16[$0 + 42 >> 1] = 1;
  while (1) {
   if (HEAPU16[$0 + 42 >> 1] <= 12e3) {
    HEAP32[$0 + 32 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 42 >> 1]);
    $1 = HEAP32[$0 + 32 >> 2];
    label$9: {
     if (!((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 256)) {
      break label$9;
     }
     if (!(jsvGetLocks(HEAP32[$0 + 32 >> 2]) & 255)) {
      break label$9;
     }
     if (!(jsvGarbageCollectMarkUsed(HEAP32[$0 + 32 >> 2]) & 1)) {
      HEAP8[196322] = 0;
      HEAP32[$0 + 44 >> 2] = 0;
      break label$1;
     }
    }
    if (jsvIsFlatString(HEAP32[$0 + 32 >> 2]) & 1) {
     HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + jsvGetFlatStringBlocks(HEAP32[$0 + 32 >> 2]);
    }
    HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + 1;
    continue;
   }
   break;
  }
  HEAP32[$0 + 28 >> 2] = 0;
  HEAP16[98162] = 0;
  HEAP32[$0 + 24 >> 2] = 0;
  HEAP16[$0 + 42 >> 1] = 1;
  while (1) {
   if (HEAPU16[$0 + 42 >> 1] <= 12e3) {
    HEAP32[$0 + 20 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 42 >> 1]);
    $1 = HEAP32[$0 + 20 >> 2];
    label$14: {
     if ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 256) {
      if (jsvIsFlatString(HEAP32[$0 + 20 >> 2]) & 1) {
       HEAP32[$0 + 16 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 20 >> 2]);
       HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 16 >> 2] + HEAP32[$0 + 28 >> 2];
       $1 = HEAP32[$0 + 20 >> 2];
       HEAP8[$1 + 12 | 0] = 0;
       HEAP8[$1 + 13 | 0] = 0;
       label$17: {
        if (HEAP32[$0 + 24 >> 2]) {
         jsvSetNextSibling(HEAP32[$0 + 24 >> 2], HEAPU16[$0 + 42 >> 1]);
         break label$17;
        }
        HEAP16[98162] = HEAPU16[$0 + 42 >> 1];
       }
       HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 20 >> 2];
       while (1) {
        $1 = HEAP32[$0 + 16 >> 2];
        HEAP32[$0 + 16 >> 2] = $1 - 1;
        if ($1) {
         HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + 1;
         HEAP32[$0 + 20 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 42 >> 1]);
         $1 = HEAP32[$0 + 20 >> 2];
         HEAP8[$1 + 12 | 0] = 0;
         HEAP8[$1 + 13 | 0] = 0;
         label$21: {
          if (HEAP32[$0 + 24 >> 2]) {
           jsvSetNextSibling(HEAP32[$0 + 24 >> 2], HEAPU16[$0 + 42 >> 1]);
           break label$21;
          }
          HEAP16[98162] = HEAPU16[$0 + 42 >> 1];
         }
         HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 20 >> 2];
         continue;
        }
        break;
       }
       break label$14;
      }
      if (jsvHasSingleChild(HEAP32[$0 + 20 >> 2]) & 1) {
       HEAP16[$0 + 14 >> 1] = jsvGetFirstChild(HEAP32[$0 + 20 >> 2]);
       if (HEAPU16[$0 + 14 >> 1]) {
        HEAP32[$0 + 8 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 14 >> 1]);
        $1 = HEAP32[$0 + 8 >> 2];
        label$25: {
         if (!(HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8)) {
          break label$25;
         }
         $1 = HEAP32[$0 + 8 >> 2];
         if ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 256) {
          break label$25;
         }
         jsvUnRef(HEAP32[$0 + 8 >> 2]);
        }
       }
      }
      $1 = HEAP32[$0 + 20 >> 2];
      HEAP8[$1 + 12 | 0] = 0;
      HEAP8[$1 + 13 | 0] = 0;
      label$26: {
       if (HEAP32[$0 + 24 >> 2]) {
        jsvSetNextSibling(HEAP32[$0 + 24 >> 2], HEAPU16[$0 + 42 >> 1]);
        break label$26;
       }
       HEAP16[98162] = HEAPU16[$0 + 42 >> 1];
      }
      HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 20 >> 2];
      HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 28 >> 2] + 1;
      break label$14;
     }
     label$28: {
      if (jsvIsFlatString(HEAP32[$0 + 20 >> 2]) & 1) {
       HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + jsvGetFlatStringBlocks(HEAP32[$0 + 20 >> 2]);
       break label$28;
      }
      $1 = HEAP32[$0 + 20 >> 2];
      if (!(HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8)) {
       label$31: {
        if (HEAP32[$0 + 24 >> 2]) {
         jsvSetNextSibling(HEAP32[$0 + 24 >> 2], HEAPU16[$0 + 42 >> 1]);
         break label$31;
        }
        HEAP16[98162] = HEAPU16[$0 + 42 >> 1];
       }
       HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 20 >> 2];
      }
     }
    }
    HEAP16[$0 + 42 >> 1] = HEAPU16[$0 + 42 >> 1] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[$0 + 24 >> 2]) {
   jsvSetNextSibling(HEAP32[$0 + 24 >> 2], 0);
  }
  HEAP8[196322] = 0;
  HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 28 >> 2];
 }
 __stack_pointer = $0 + 48 | 0;
 return HEAP32[$0 + 44 >> 2];
}

function tflite__ops__micro__depthwise_conv__Prepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 160 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 152 >> 2] = $0;
 HEAP32[$2 + 148 >> 2] = $1;
 label$1: {
  if (!HEAP32[HEAP32[$2 + 148 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (!HEAP32[HEAP32[$2 + 148 >> 2] + 12 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 144 >> 2] = HEAP32[HEAP32[$2 + 148 >> 2] + 12 >> 2];
 HEAP32[$2 + 140 >> 2] = HEAP32[HEAP32[$2 + 148 >> 2] + 8 >> 2];
 HEAP32[$2 + 136 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 152 >> 2], HEAP32[$2 + 148 >> 2], 0);
 HEAP32[$2 + 132 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 152 >> 2], HEAP32[$2 + 148 >> 2], 0);
 HEAP32[$2 + 128 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 152 >> 2], HEAP32[$2 + 148 >> 2], 1);
 HEAP32[$2 + 124 >> 2] = HEAP32[HEAP32[$2 + 132 >> 2] + 28 >> 2];
 HEAP32[$2 + 120 >> 2] = tflite__SizeOfDimension_28TfLiteTensor_20const__2c_20int_29(HEAP32[$2 + 132 >> 2], 2);
 HEAP32[$2 + 116 >> 2] = tflite__SizeOfDimension_28TfLiteTensor_20const__2c_20int_29(HEAP32[$2 + 132 >> 2], 1);
 HEAP32[$2 + 112 >> 2] = tflite__SizeOfDimension_28TfLiteTensor_20const__2c_20int_29(HEAP32[$2 + 128 >> 2], 2);
 HEAP32[$2 + 108 >> 2] = tflite__SizeOfDimension_28TfLiteTensor_20const__2c_20int_29(HEAP32[$2 + 128 >> 2], 1);
 HEAP32[$2 + 104 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 128 >> 2] + 20 >> 2] + 16 >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$2 + 152 >> 2] + 56 >> 2]](HEAP32[$2 + 152 >> 2], HEAP32[$2 + 104 >> 2] << 2) | 0;
 HEAP32[HEAP32[$2 + 140 >> 2] + 36 >> 2] = $0;
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$2 + 152 >> 2] + 56 >> 2]](HEAP32[$2 + 152 >> 2], HEAP32[$2 + 104 >> 2] << 2) | 0;
 HEAP32[HEAP32[$2 + 140 >> 2] + 40 >> 2] = $0;
 label$3: {
  if (HEAP32[HEAP32[$2 + 132 >> 2] + 28 >> 2] == 9) {
   if (HEAP32[HEAP32[$2 + 128 >> 2] >> 2] != 1) {
    $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 152 >> 2];
    $3 = HEAP32[HEAP32[$2 + 128 >> 2] >> 2];
    HEAP32[$2 + 12 >> 2] = 1;
    HEAP32[$2 + 8 >> 2] = $3;
    HEAP32[$2 + 4 >> 2] = 128383;
    HEAP32[$2 >> 2] = 132304;
    FUNCTION_TABLE[$0 | 0]($1, 143305, $2);
    HEAP32[$2 + 156 >> 2] = 1;
    break label$3;
   }
   HEAP32[$2 + 100 >> 2] = HEAP32[HEAP32[$2 + 128 >> 2] + 4 >> 2];
   if (!HEAP32[$2 + 100 >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 152 >> 2];
    HEAP32[$2 + 80 >> 2] = 128363;
    FUNCTION_TABLE[$0 | 0]($1, 140586, $2 + 80 | 0);
    HEAP32[$2 + 156 >> 2] = 1;
    break label$3;
   }
   if (!HEAP32[HEAP32[$2 + 100 >> 2] >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 152 >> 2];
    HEAP32[$2 + 64 >> 2] = 132598;
    FUNCTION_TABLE[$0 | 0]($1, 140586, $2 - -64 | 0);
    HEAP32[$2 + 156 >> 2] = 1;
    break label$3;
   }
   if (!HEAP32[HEAP32[$2 + 100 >> 2] + 4 >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 152 >> 2];
    HEAP32[$2 + 48 >> 2] = 117462;
    FUNCTION_TABLE[$0 | 0]($1, 140586, $2 + 48 | 0);
    HEAP32[$2 + 156 >> 2] = 1;
    break label$3;
   }
   if (!(HEAP32[HEAP32[HEAP32[$2 + 100 >> 2] >> 2] >> 2] == 1 | HEAP32[HEAP32[HEAP32[$2 + 100 >> 2] >> 2] >> 2] == HEAP32[HEAP32[HEAP32[$2 + 128 >> 2] + 20 >> 2] + 16 >> 2])) {
    $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 152 >> 2];
    HEAP32[$2 + 32 >> 2] = 136089;
    FUNCTION_TABLE[$0 | 0]($1, 140586, $2 + 32 | 0);
    HEAP32[$2 + 156 >> 2] = 1;
    break label$3;
   }
   if (HEAP32[HEAP32[HEAP32[$2 + 100 >> 2] >> 2] >> 2] != HEAP32[HEAP32[HEAP32[$2 + 100 >> 2] + 4 >> 2] >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 152 >> 2];
    $3 = HEAP32[HEAP32[HEAP32[$2 + 100 >> 2] >> 2] >> 2];
    HEAP32[$2 + 28 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 100 >> 2] + 4 >> 2] >> 2];
    HEAP32[$2 + 24 >> 2] = $3;
    HEAP32[$2 + 20 >> 2] = 131534;
    HEAP32[$2 + 16 >> 2] = 131592;
    FUNCTION_TABLE[$0 | 0]($1, 143305, $2 + 16 | 0);
    HEAP32[$2 + 156 >> 2] = 1;
    break label$3;
   }
  }
  HEAP32[$2 + 96 >> 2] = tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__CalculateOpData_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLiteType_2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData__29(HEAP32[$2 + 152 >> 2], HEAP32[$2 + 148 >> 2], HEAP32[$2 + 144 >> 2], HEAP32[$2 + 120 >> 2], HEAP32[$2 + 116 >> 2], HEAP32[$2 + 112 >> 2], HEAP32[$2 + 108 >> 2], HEAP32[$2 + 124 >> 2], HEAP32[$2 + 140 >> 2]);
  if (HEAP32[$2 + 96 >> 2]) {
   HEAP32[$2 + 156 >> 2] = HEAP32[$2 + 96 >> 2];
   break label$3;
  }
  HEAP32[HEAP32[$2 + 140 >> 2] + 16 >> 2] = HEAP32[HEAP32[$2 + 132 >> 2] + 12 >> 2];
  HEAP32[HEAP32[$2 + 140 >> 2] + 20 >> 2] = HEAP32[HEAP32[$2 + 128 >> 2] + 12 >> 2];
  HEAP32[HEAP32[$2 + 140 >> 2] + 24 >> 2] = HEAP32[HEAP32[$2 + 136 >> 2] + 12 >> 2];
  HEAP32[$2 + 156 >> 2] = 0;
 }
 __stack_pointer = $2 + 160 | 0;
 return HEAP32[$2 + 156 >> 2];
}

function graphicsDrawLineAA($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = __stack_pointer - 112 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 108 >> 2] = $0;
 HEAP32[$5 + 104 >> 2] = $1;
 HEAP32[$5 + 100 >> 2] = $2;
 HEAP32[$5 + 96 >> 2] = $3;
 HEAP32[$5 + 92 >> 2] = $4;
 graphicsToDeviceCoordinates16x(HEAP32[$5 + 108 >> 2], $5 + 104 | 0, $5 + 100 | 0);
 graphicsToDeviceCoordinates16x(HEAP32[$5 + 108 >> 2], $5 + 96 | 0, $5 + 92 | 0);
 HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 104 >> 2] << 4;
 HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 100 >> 2] << 4;
 HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 96 >> 2] << 4;
 HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 92 >> 2] << 4;
 HEAP8[$5 + 75 | 0] = (abs(HEAP32[$5 + 76 >> 2] - HEAP32[$5 + 84 >> 2] | 0) | 0) > (abs(HEAP32[$5 + 80 >> 2] - HEAP32[$5 + 88 >> 2] | 0) | 0);
 if (HEAP8[$5 + 75 | 0] & 1) {
  HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 88 >> 2];
  HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 84 >> 2];
  HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 68 >> 2];
  HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 80 >> 2];
  HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 76 >> 2];
  HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 68 >> 2];
 }
 if (HEAP32[$5 + 88 >> 2] > HEAP32[$5 + 80 >> 2]) {
  HEAP32[$5 + 64 >> 2] = HEAP32[$5 + 88 >> 2];
  HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 80 >> 2];
  HEAP32[$5 + 80 >> 2] = HEAP32[$5 + 64 >> 2];
  HEAP32[$5 + 64 >> 2] = HEAP32[$5 + 84 >> 2];
  HEAP32[$5 + 84 >> 2] = HEAP32[$5 + 76 >> 2];
  HEAP32[$5 + 76 >> 2] = HEAP32[$5 + 64 >> 2];
 }
 HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 80 >> 2] - HEAP32[$5 + 88 >> 2];
 HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 76 >> 2] - HEAP32[$5 + 84 >> 2];
 if (HEAP32[$5 + 60 >> 2]) {
  $0 = (HEAP32[$5 + 56 >> 2] << 8) / HEAP32[$5 + 60 >> 2] | 0;
 } else {
  $0 = 256;
 }
 HEAP32[$5 + 52 >> 2] = $0;
 HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 88 >> 2] & -256;
 HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 84 >> 2] + (Math_imul(HEAP32[$5 + 52 >> 2], HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 88 >> 2] | 0) >> 8);
 HEAP32[$5 + 40 >> 2] = 255 - (HEAP32[$5 + 88 >> 2] & 255);
 HEAP32[$5 + 36 >> 2] = HEAP32[$5 + 48 >> 2] >> 8;
 HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 44 >> 2] >> 8;
 HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 44 >> 2] & 255;
 label$5: {
  if (HEAP8[$5 + 75 | 0] & 1) {
   graphicsSetPixelDeviceBlended(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 32 >> 2], HEAP32[$5 + 36 >> 2], Math_imul(HEAP32[$5 + 40 >> 2], 256 - HEAP32[$5 + 28 >> 2] | 0) >> 8);
   graphicsSetPixelDeviceBlended(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 32 >> 2] + 1 | 0, HEAP32[$5 + 36 >> 2], Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 40 >> 2]) >> 8);
   break label$5;
  }
  graphicsSetPixelDeviceBlended(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 36 >> 2], HEAP32[$5 + 32 >> 2], Math_imul(HEAP32[$5 + 40 >> 2], 256 - HEAP32[$5 + 28 >> 2] | 0) >> 8);
  graphicsSetPixelDeviceBlended(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 36 >> 2], HEAP32[$5 + 32 >> 2] + 1 | 0, Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 40 >> 2]) >> 8);
 }
 HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 44 >> 2] + HEAP32[$5 + 52 >> 2];
 HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 80 >> 2] + 256 & -256;
 HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 76 >> 2] + (Math_imul(HEAP32[$5 + 52 >> 2], HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 80 >> 2] | 0) >> 8);
 HEAP32[$5 + 40 >> 2] = HEAP32[$5 + 80 >> 2] + 256 & 255;
 HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 48 >> 2] >> 8;
 HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 44 >> 2] >> 8;
 HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 44 >> 2] & 255;
 label$7: {
  if (HEAP8[$5 + 75 | 0] & 1) {
   graphicsSetPixelDeviceBlended(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 20 >> 2], Math_imul(HEAP32[$5 + 40 >> 2], 256 - HEAP32[$5 + 28 >> 2] | 0) >> 8);
   graphicsSetPixelDeviceBlended(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 16 >> 2] + 1 | 0, HEAP32[$5 + 20 >> 2], Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 40 >> 2]) >> 8);
   break label$7;
  }
  graphicsSetPixelDeviceBlended(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], Math_imul(HEAP32[$5 + 40 >> 2], 256 - HEAP32[$5 + 28 >> 2] | 0) >> 8);
  graphicsSetPixelDeviceBlended(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2] + 1 | 0, Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 40 >> 2]) >> 8);
 }
 HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 36 >> 2] + 1;
 while (1) {
  if (HEAP32[$5 + 12 >> 2] < HEAP32[$5 + 20 >> 2]) {
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 24 >> 2] >> 8;
   HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 24 >> 2] & 255;
   label$11: {
    if (HEAP8[$5 + 75 | 0] & 1) {
     graphicsSetPixelDeviceBlended(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 8 >> 2], HEAP32[$5 + 12 >> 2], 256 - HEAP32[$5 + 28 >> 2] | 0);
     graphicsSetPixelDeviceBlended(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 8 >> 2] + 1 | 0, HEAP32[$5 + 12 >> 2], HEAP32[$5 + 28 >> 2]);
     break label$11;
    }
    graphicsSetPixelDeviceBlended(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 8 >> 2], 256 - HEAP32[$5 + 28 >> 2] | 0);
    graphicsSetPixelDeviceBlended(HEAP32[$5 + 108 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 8 >> 2] + 1 | 0, HEAP32[$5 + 28 >> 2]);
   }
   HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 52 >> 2] + HEAP32[$5 + 24 >> 2];
   HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 112 | 0;
}

function tflite__ops__micro__conv__Prepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 160 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 152 >> 2] = $0;
 HEAP32[$2 + 148 >> 2] = $1;
 label$1: {
  if (!HEAP32[HEAP32[$2 + 148 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (!HEAP32[HEAP32[$2 + 148 >> 2] + 12 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 144 >> 2] = HEAP32[HEAP32[$2 + 148 >> 2] + 8 >> 2];
 HEAP32[$2 + 140 >> 2] = HEAP32[HEAP32[$2 + 148 >> 2] + 12 >> 2];
 HEAP32[$2 + 136 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 152 >> 2], HEAP32[$2 + 148 >> 2], 0);
 HEAP32[$2 + 132 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 152 >> 2], HEAP32[$2 + 148 >> 2], 0);
 HEAP32[$2 + 128 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 152 >> 2], HEAP32[$2 + 148 >> 2], 1);
 HEAP32[$2 + 124 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 132 >> 2] + 20 >> 2] + 12 >> 2];
 HEAP32[$2 + 120 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 132 >> 2] + 20 >> 2] + 8 >> 2];
 HEAP32[$2 + 116 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 128 >> 2] + 20 >> 2] + 12 >> 2];
 HEAP32[$2 + 112 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 128 >> 2] + 20 >> 2] + 8 >> 2];
 HEAP32[$2 + 108 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 136 >> 2] + 20 >> 2] + 12 >> 2];
 HEAP32[$2 + 104 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 136 >> 2] + 20 >> 2] + 8 >> 2];
 HEAP32[$2 + 100 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 128 >> 2] + 20 >> 2] + 4 >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$2 + 152 >> 2] + 56 >> 2]](HEAP32[$2 + 152 >> 2], HEAP32[$2 + 100 >> 2] << 2) | 0;
 HEAP32[HEAP32[$2 + 144 >> 2] + 36 >> 2] = $0;
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$2 + 152 >> 2] + 56 >> 2]](HEAP32[$2 + 152 >> 2], HEAP32[$2 + 100 >> 2] << 2) | 0;
 HEAP32[HEAP32[$2 + 144 >> 2] + 40 >> 2] = $0;
 label$3: {
  if (HEAP32[HEAP32[$2 + 132 >> 2] + 28 >> 2] == 9) {
   if (HEAP32[HEAP32[$2 + 128 >> 2] >> 2] != 1) {
    $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 152 >> 2];
    $3 = HEAP32[HEAP32[$2 + 128 >> 2] >> 2];
    HEAP32[$2 + 12 >> 2] = 1;
    HEAP32[$2 + 8 >> 2] = $3;
    HEAP32[$2 + 4 >> 2] = 128383;
    HEAP32[$2 >> 2] = 132304;
    FUNCTION_TABLE[$0 | 0]($1, 143305, $2);
    HEAP32[$2 + 156 >> 2] = 1;
    break label$3;
   }
   HEAP32[$2 + 96 >> 2] = HEAP32[HEAP32[$2 + 128 >> 2] + 4 >> 2];
   if (!HEAP32[$2 + 96 >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 152 >> 2];
    HEAP32[$2 + 80 >> 2] = 128363;
    FUNCTION_TABLE[$0 | 0]($1, 140586, $2 + 80 | 0);
    HEAP32[$2 + 156 >> 2] = 1;
    break label$3;
   }
   if (!HEAP32[HEAP32[$2 + 96 >> 2] >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 152 >> 2];
    HEAP32[$2 + 64 >> 2] = 132598;
    FUNCTION_TABLE[$0 | 0]($1, 140586, $2 - -64 | 0);
    HEAP32[$2 + 156 >> 2] = 1;
    break label$3;
   }
   if (!HEAP32[HEAP32[$2 + 96 >> 2] + 4 >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 152 >> 2];
    HEAP32[$2 + 48 >> 2] = 117462;
    FUNCTION_TABLE[$0 | 0]($1, 140586, $2 + 48 | 0);
    HEAP32[$2 + 156 >> 2] = 1;
    break label$3;
   }
   if (!(HEAP32[HEAP32[HEAP32[$2 + 96 >> 2] >> 2] >> 2] == 1 | HEAP32[HEAP32[HEAP32[$2 + 96 >> 2] >> 2] >> 2] == HEAP32[HEAP32[HEAP32[$2 + 128 >> 2] + 20 >> 2] + 4 >> 2])) {
    $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 152 >> 2];
    HEAP32[$2 + 32 >> 2] = 135968;
    FUNCTION_TABLE[$0 | 0]($1, 140586, $2 + 32 | 0);
    HEAP32[$2 + 156 >> 2] = 1;
    break label$3;
   }
   if (HEAP32[HEAP32[HEAP32[$2 + 96 >> 2] >> 2] >> 2] != HEAP32[HEAP32[HEAP32[$2 + 96 >> 2] + 4 >> 2] >> 2]) {
    $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
    $1 = HEAP32[$2 + 152 >> 2];
    $3 = HEAP32[HEAP32[HEAP32[$2 + 96 >> 2] >> 2] >> 2];
    HEAP32[$2 + 28 >> 2] = HEAP32[HEAP32[HEAP32[$2 + 96 >> 2] + 4 >> 2] >> 2];
    HEAP32[$2 + 24 >> 2] = $3;
    HEAP32[$2 + 20 >> 2] = 131534;
    HEAP32[$2 + 16 >> 2] = 131592;
    FUNCTION_TABLE[$0 | 0]($1, 143305, $2 + 16 | 0);
    HEAP32[$2 + 156 >> 2] = 1;
    break label$3;
   }
  }
  HEAP32[$2 + 92 >> 2] = tflite__ops__micro__conv__CalculateOpData_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLiteType_2c_20tflite__ops__micro__conv__OpData__29(HEAP32[$2 + 152 >> 2], HEAP32[$2 + 148 >> 2], HEAP32[$2 + 140 >> 2], HEAP32[$2 + 124 >> 2], HEAP32[$2 + 120 >> 2], HEAP32[$2 + 116 >> 2], HEAP32[$2 + 112 >> 2], HEAP32[$2 + 108 >> 2], HEAP32[$2 + 104 >> 2], HEAP32[HEAP32[$2 + 132 >> 2] + 28 >> 2], HEAP32[$2 + 144 >> 2]);
  if (HEAP32[$2 + 92 >> 2]) {
   HEAP32[$2 + 156 >> 2] = HEAP32[$2 + 92 >> 2];
   break label$3;
  }
  HEAP32[HEAP32[$2 + 144 >> 2] + 16 >> 2] = HEAP32[HEAP32[$2 + 132 >> 2] + 12 >> 2];
  HEAP32[HEAP32[$2 + 144 >> 2] + 20 >> 2] = HEAP32[HEAP32[$2 + 128 >> 2] + 12 >> 2];
  HEAP32[HEAP32[$2 + 144 >> 2] + 24 >> 2] = HEAP32[HEAP32[$2 + 136 >> 2] + 12 >> 2];
  HEAP32[$2 + 156 >> 2] = 0;
 }
 __stack_pointer = $2 + 160 | 0;
 return HEAP32[$2 + 156 >> 2];
}

function _jslNewTokenisedStringFromLexer($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 128 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 124 >> 2] = $0;
 HEAP32[$4 + 120 >> 2] = $1;
 HEAP32[$4 + 116 >> 2] = $2;
 HEAP32[$4 + 112 >> 2] = $3;
 jslSeekToP(HEAP32[$4 + 116 >> 2]);
 HEAP8[$4 + 71 | 0] = HEAPU8[HEAP32[$4 + 116 >> 2] + 36 | 0];
 if (HEAP32[$4 + 124 >> 2]) {
  jsvStringIteratorClone($4 + 72 | 0, HEAP32[$4 + 116 >> 2]);
 }
 HEAP32[$4 + 64 >> 2] = 0;
 HEAP32[$4 + 60 >> 2] = 0;
 HEAP32[$4 + 56 >> 2] = 0;
 while (1) {
  $0 = 0;
  if (HEAP16[HEAP32[49079] + 2 >> 1]) {
   $0 = jsvStringIteratorGetIndex(HEAP32[49079] + 88 | 0) >>> 0 <= HEAP32[$4 + 112 >> 2] + 1 >>> 0;
  }
  if ($0) {
   if (jslPreserveSpaceBetweenTokens(HEAP32[$4 + 60 >> 2], HEAP16[HEAP32[49079] + 2 >> 1]) & 1) {
    HEAP32[$4 + 64 >> 2] = HEAP32[$4 + 64 >> 2] + 1;
    if (HEAP32[$4 + 124 >> 2]) {
     jsvStringIteratorSetCharAndNext(HEAP32[$4 + 124 >> 2], 32);
    }
   }
   label$7: {
    label$8: {
     if (HEAP16[HEAP32[49079] + 2 >> 1] != 131) {
      break label$8;
     }
     $0 = jslGetTokenLength();
     HEAP32[$4 + 52 >> 2] = $0;
     if (!$0) {
      break label$8;
     }
     HEAP32[$4 + 48 >> 2] = 0;
     jslSkipWhiteSpace();
     if (!(HEAP32[$4 + 56 >> 2] != 2 | HEAP8[HEAP32[49079]] != 41)) {
      HEAP32[$4 + 44 >> 2] = jslGetTokenValueAsVar();
      HEAP32[$4 + 48 >> 2] = jswrap_atob(HEAP32[$4 + 44 >> 2]);
      jsvUnLock(HEAP32[$4 + 44 >> 2]);
      HEAP32[$4 + 52 >> 2] = jsvGetStringLength(HEAP32[$4 + 48 >> 2]);
      HEAP32[$4 + 64 >> 2] = HEAP32[$4 + 64 >> 2] - 5;
      if (HEAP32[$4 + 124 >> 2]) {
       jsvStringIteratorGoto(HEAP32[$4 + 124 >> 2], HEAP32[$4 + 120 >> 2], HEAP32[$4 + 64 >> 2]);
      }
      HEAP8[$4 + 71 | 0] = HEAPU8[HEAP32[49079]];
      jslGetNextToken();
     }
     HEAP32[$4 + 56 >> 2] = 0;
     if (HEAP32[$4 + 124 >> 2]) {
      jsvStringIteratorSetCharAndNext(HEAP32[$4 + 124 >> 2], (HEAPU32[$4 + 52 >> 2] < 256 ? 209 : 210) << 24 >> 24);
      jsvStringIteratorSetCharAndNext(HEAP32[$4 + 124 >> 2], (HEAP32[$4 + 52 >> 2] & 255) << 24 >> 24);
      if (HEAPU32[$4 + 52 >> 2] >= 256) {
       jsvStringIteratorSetCharAndNext(HEAP32[$4 + 124 >> 2], HEAP32[$4 + 52 >> 2] >>> 8 << 24 >> 24);
      }
      if (!HEAP32[$4 + 48 >> 2]) {
       HEAP32[$4 + 48 >> 2] = jslGetTokenValueAsVar();
      }
      jsvStringIteratorNew($4 + 8 | 0, HEAP32[$4 + 48 >> 2], 0);
      while (1) {
       if (jsvStringIteratorHasChar($4 + 8 | 0) & 1) {
        jsvStringIteratorSetCharAndNext(HEAP32[$4 + 124 >> 2], jsvStringIteratorGetCharAndNext($4 + 8 | 0) << 24 >> 24);
        continue;
       }
       break;
      }
      jsvStringIteratorFree($4 + 8 | 0);
     }
     jsvUnLock(HEAP32[$4 + 48 >> 2]);
     HEAP32[$4 + 64 >> 2] = HEAP32[$4 + 64 >> 2] + (HEAP32[$4 + 52 >> 2] + (HEAPU32[$4 + 52 >> 2] < 256 ? 2 : 3) | 0);
     break label$7;
    }
    label$16: {
     label$17: {
      label$18: {
       if (HEAP16[HEAP32[49079] + 2 >> 1] == 128 | HEAP16[HEAP32[49079] + 2 >> 1] == 129 | (HEAP16[HEAP32[49079] + 2 >> 1] == 130 | HEAP16[HEAP32[49079] + 2 >> 1] == 131)) {
        break label$18;
       }
       if (HEAP16[HEAP32[49079] + 2 >> 1] == 133) {
        break label$18;
       }
       if (HEAP16[HEAP32[49079] + 2 >> 1] != 135) {
        break label$17;
       }
      }
      label$19: {
       label$20: {
        if (HEAP16[HEAP32[49079] + 2 >> 1] != 128) {
         break label$20;
        }
        if (strcmp(jslGetTokenValueAsString(), 135701)) {
         break label$20;
        }
        HEAP32[$4 + 56 >> 2] = 1;
        break label$19;
       }
       HEAP32[$4 + 56 >> 2] = 0;
      }
      HEAP32[$4 + 64 >> 2] = (jsvStringIteratorGetIndex(HEAP32[49079] + 88 | 0) - (HEAP32[HEAP32[49079] + 4 >> 2] + 1 | 0) | 0) + HEAP32[$4 + 64 >> 2];
      if (HEAP32[$4 + 124 >> 2]) {
       jsvStringIteratorSetCharAndNext(HEAP32[$4 + 124 >> 2], HEAP8[$4 + 71 | 0]);
       while (1) {
        if (jsvStringIteratorGetIndex($4 + 72 | 0) + 1 >>> 0 < jsvStringIteratorGetIndex(HEAP32[49079] + 88 | 0) >>> 0) {
         jsvStringIteratorSetCharAndNext(HEAP32[$4 + 124 >> 2], jsvStringIteratorGetCharAndNext($4 + 72 | 0) << 24 >> 24);
         continue;
        }
        break;
       }
      }
      break label$16;
     }
     label$24: {
      if (!(HEAP32[$4 + 56 >> 2] != 1 | HEAP16[HEAP32[49079] + 2 >> 1] != 40)) {
       HEAP32[$4 + 56 >> 2] = 2;
       break label$24;
      }
      HEAP32[$4 + 56 >> 2] = 0;
     }
     if (HEAP32[$4 + 124 >> 2]) {
      jsvStringIteratorSetCharAndNext(HEAP32[$4 + 124 >> 2], HEAPU16[HEAP32[49079] + 2 >> 1] << 24 >> 24);
     }
     HEAP32[$4 + 64 >> 2] = HEAP32[$4 + 64 >> 2] + 1;
    }
   }
   HEAP32[$4 + 60 >> 2] = HEAP16[HEAP32[49079] + 2 >> 1];
   jslSkipWhiteSpace();
   if (HEAP32[$4 + 124 >> 2]) {
    jsvStringIteratorFree($4 + 72 | 0);
    jsvStringIteratorClone($4 + 72 | 0, HEAP32[49079] + 88 | 0);
   }
   HEAP8[$4 + 71 | 0] = HEAPU8[HEAP32[49079]];
   jslGetNextToken();
   continue;
  }
  break;
 }
 if (HEAP32[$4 + 124 >> 2]) {
  jsvStringIteratorFree($4 + 72 | 0);
 }
 __stack_pointer = $4 + 128 | 0;
 return HEAP32[$4 + 64 >> 2];
}

function jsvDefragment() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $0 = __stack_pointer - 560 | 0;
 __stack_pointer = $0;
 jsvGarbageCollect();
 jshInterruptOff();
 HEAP32[$0 + 556 >> 2] = 256;
 HEAP32[$0 + 552 >> 2] = $0;
 memset($0, 0, 512);
 HEAP32[$0 + 548 >> 2] = 0;
 HEAP32[$0 + 544 >> 2] = 0;
 while (1) {
  if (HEAPU32[$0 + 544 >> 2] < jsvGetMemoryTotal() >>> 0) {
   HEAP16[$0 + 542 >> 1] = HEAP32[$0 + 544 >> 2] + 1;
   HEAP32[$0 + 536 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 542 >> 1]);
   $1 = HEAP32[$0 + 536 >> 2];
   if ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63) {
    label$4: {
     if (jsvIsFlatString(HEAP32[$0 + 536 >> 2]) & 1) {
      HEAP32[$0 + 544 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 536 >> 2]) + HEAP32[$0 + 544 >> 2];
      break label$4;
     }
     if (!(jsvGetLocks(HEAP32[$0 + 536 >> 2]) & 255)) {
      HEAP16[(HEAP32[$0 + 548 >> 2] << 1) + $0 >> 1] = HEAPU16[$0 + 542 >> 1];
      HEAP32[$0 + 548 >> 2] = HEAP32[$0 + 548 >> 2] + 1 & 255;
     }
    }
   }
   HEAP32[$0 + 544 >> 2] = HEAP32[$0 + 544 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$0 + 548 >> 2] = HEAP32[$0 + 548 >> 2] - 1;
 if (HEAP32[$0 + 548 >> 2] < 0) {
  HEAP32[$0 + 548 >> 2] = HEAP32[$0 + 548 >> 2] + 256;
 }
 while (1) {
  label$9: {
   if (!HEAPU16[(HEAP32[$0 + 548 >> 2] << 1) + $0 >> 1]) {
    break label$9;
   }
   HEAP16[$0 + 534 >> 1] = HEAPU16[(HEAP32[$0 + 548 >> 2] << 1) + $0 >> 1];
   HEAP16[$0 + 532 >> 1] = HEAPU16[98162];
   if (!HEAPU16[$0 + 532 >> 1] | HEAPU16[$0 + 534 >> 1] < HEAPU16[$0 + 532 >> 1]) {
    break label$9;
   }
   HEAP32[$0 + 528 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 534 >> 1]);
   HEAP32[$0 + 524 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 532 >> 1]);
   HEAP16[98162] = jsvGetNextSibling(HEAP32[$0 + 524 >> 2]);
   $2 = HEAP32[$0 + 528 >> 2];
   $1 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
   $3 = HEAP32[$0 + 524 >> 2];
   $4 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
   HEAP8[$3 | 0] = $4;
   HEAP8[$3 + 1 | 0] = $4 >>> 8;
   HEAP8[$3 + 2 | 0] = $4 >>> 16;
   HEAP8[$3 + 3 | 0] = $4 >>> 24;
   HEAP8[$3 + 4 | 0] = $1;
   HEAP8[$3 + 5 | 0] = $1 >>> 8;
   HEAP8[$3 + 6 | 0] = $1 >>> 16;
   HEAP8[$3 + 7 | 0] = $1 >>> 24;
   $1 = HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8;
   HEAP8[$3 + 12 | 0] = $1;
   HEAP8[$3 + 13 | 0] = $1 >>> 8;
   $1 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
   HEAP8[$3 + 8 | 0] = $1;
   HEAP8[$3 + 9 | 0] = $1 >>> 8;
   HEAP8[$3 + 10 | 0] = $1 >>> 16;
   HEAP8[$3 + 11 | 0] = $1 >>> 24;
   $1 = HEAP32[$0 + 528 >> 2];
   HEAP8[$1 + 12 | 0] = 0;
   HEAP8[$1 + 13 | 0] = 0;
   HEAP32[$0 + 520 >> 2] = 0;
   while (1) {
    if (HEAPU32[$0 + 520 >> 2] < jsvGetMemoryTotal() >>> 0) {
     HEAP16[$0 + 518 >> 1] = HEAP32[$0 + 520 >> 2] + 1;
     HEAP32[$0 + 512 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 518 >> 1]);
     $1 = HEAP32[$0 + 512 >> 2];
     if ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63) {
      label$14: {
       if (jsvIsFlatString(HEAP32[$0 + 512 >> 2]) & 1) {
        HEAP32[$0 + 520 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 512 >> 2]) + HEAP32[$0 + 520 >> 2];
        break label$14;
       }
       if (jsvHasSingleChild(HEAP32[$0 + 512 >> 2]) & 1) {
        if ((jsvGetFirstChild(HEAP32[$0 + 512 >> 2]) & 65535) == HEAPU16[$0 + 534 >> 1]) {
         jsvSetFirstChild(HEAP32[$0 + 512 >> 2], HEAPU16[$0 + 532 >> 1]);
        }
       }
       if (jsvHasStringExt(HEAP32[$0 + 512 >> 2]) & 1) {
        if ((jsvGetLastChild(HEAP32[$0 + 512 >> 2]) & 65535) == HEAPU16[$0 + 534 >> 1]) {
         jsvSetLastChild(HEAP32[$0 + 512 >> 2], HEAPU16[$0 + 532 >> 1]);
        }
       }
       if (jsvHasChildren(HEAP32[$0 + 512 >> 2]) & 1) {
        if ((jsvGetFirstChild(HEAP32[$0 + 512 >> 2]) & 65535) == HEAPU16[$0 + 534 >> 1]) {
         jsvSetFirstChild(HEAP32[$0 + 512 >> 2], HEAPU16[$0 + 532 >> 1]);
        }
        if ((jsvGetLastChild(HEAP32[$0 + 512 >> 2]) & 65535) == HEAPU16[$0 + 534 >> 1]) {
         jsvSetLastChild(HEAP32[$0 + 512 >> 2], HEAPU16[$0 + 532 >> 1]);
        }
       }
       if (jsvIsName(HEAP32[$0 + 512 >> 2]) & 1) {
        if ((jsvGetNextSibling(HEAP32[$0 + 512 >> 2]) & 65535) == HEAPU16[$0 + 534 >> 1]) {
         jsvSetNextSibling(HEAP32[$0 + 512 >> 2], HEAPU16[$0 + 532 >> 1]);
        }
        if ((jsvGetPrevSibling(HEAP32[$0 + 512 >> 2]) & 65535) == HEAPU16[$0 + 534 >> 1]) {
         jsvSetPrevSibling(HEAP32[$0 + 512 >> 2], HEAPU16[$0 + 532 >> 1]);
        }
       }
      }
     }
     HEAP32[$0 + 520 >> 2] = HEAP32[$0 + 520 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP16[(HEAP32[$0 + 548 >> 2] << 1) + $0 >> 1] = 0;
   HEAP32[$0 + 548 >> 2] = HEAP32[$0 + 548 >> 2] - 1;
   if (HEAP32[$0 + 548 >> 2] < 0) {
    HEAP32[$0 + 548 >> 2] = HEAP32[$0 + 548 >> 2] + 256;
   }
   jshKickWatchDog();
   jshKickSoftWatchDog();
   continue;
  }
  break;
 }
 jsvCreateEmptyVarList();
 jshInterruptOn();
 $0 = HEAP32[$0 + 552 >> 2];
 __stack_pointer = $0 + 560 | 0;
}

function jslLexString() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = __stack_pointer - 80 | 0;
 __stack_pointer = $0;
 HEAP8[$0 + 79 | 0] = HEAPU8[HEAP32[49079]];
 HEAP32[$0 + 52 >> 2] = 0;
 label$1: {
  if ((HEAP32[91094] & 63) == 1) {
   $1 = jsvNewFromEmptyString();
   HEAP32[HEAP32[49079] + 76 >> 2] = $1;
   if (!HEAP32[HEAP32[49079] + 76 >> 2]) {
    HEAP16[HEAP32[49079] + 2 >> 1] = 0;
    break label$1;
   }
   jsvStringIteratorNew($0 + 40 | 0, HEAP32[HEAP32[49079] + 76 >> 2], 0);
  }
  jslGetNextCh();
  HEAP8[$0 + 39 | 0] = HEAPU8[$0 + 79 | 0];
  HEAP32[$0 + 32 >> 2] = 0;
  while (1) {
   $1 = 0;
   if (HEAP8[HEAP32[49079]]) {
    $1 = 1;
    $1 = HEAP8[HEAP32[49079]] == HEAP8[$0 + 79 | 0] ? HEAP32[$0 + 32 >> 2] != 0 : $1;
   }
   label$7: {
    if (!($1 & 1)) {
     break label$7;
    }
    if (HEAP8[$0 + 79 | 0] == 96) {
     if (!(HEAP8[HEAP32[49079]] != 123 | (HEAP32[$0 + 32 >> 2] ? 0 : HEAP8[$0 + 39 | 0] != 36))) {
      HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 32 >> 2] + 1;
     }
     if (!(!HEAP32[$0 + 32 >> 2] | HEAP8[HEAP32[49079]] != 125)) {
      HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 32 >> 2] - 1;
     }
    }
    label$12: {
     if (HEAP8[HEAP32[49079]] == 92) {
      jslGetNextCh();
      HEAP8[$0 + 31 | 0] = HEAPU8[HEAP32[49079]];
      label$14: {
       label$15: {
        switch (HEAP8[HEAP32[49079]] - 98 | 0) {
        case 12:
         HEAP8[$0 + 31 | 0] = 10;
         jslGetNextCh();
         break label$14;

        case 0:
         HEAP8[$0 + 31 | 0] = 8;
         jslGetNextCh();
         break label$14;

        case 4:
         HEAP8[$0 + 31 | 0] = 12;
         jslGetNextCh();
         break label$14;

        case 16:
         HEAP8[$0 + 31 | 0] = 13;
         jslGetNextCh();
         break label$14;

        case 18:
         HEAP8[$0 + 31 | 0] = 9;
         jslGetNextCh();
         break label$14;

        case 20:
         HEAP8[$0 + 31 | 0] = 11;
         jslGetNextCh();
         break label$14;

        case 19:
        case 22:
         HEAP8[$0 + 25 | 0] = HEAP8[HEAP32[49079]] == 117;
         jslGetNextCh();
         HEAP32[$0 + 20 >> 2] = HEAP8[$0 + 25 | 0] & 1 ? 4 : 2;
         HEAP32[$0 + 16 >> 2] = 0;
         while (1) {
          label$24: {
           $1 = HEAP32[$0 + 20 >> 2];
           HEAP32[$0 + 20 >> 2] = $1 - 1;
           if (!$1) {
            break label$24;
           }
           label$25: {
            if (HEAPU8[HEAP32[49079]]) {
             if (isHexadecimal(HEAP8[HEAP32[49079]]) & 1) {
              break label$25;
             }
            }
            jsExceptionHere(1, 132818, 0);
            break label$24;
           }
           $2 = HEAPU8[HEAP32[49079]];
           $1 = HEAP32[$0 + 16 >> 2];
           HEAP32[$0 + 16 >> 2] = $1 + 1;
           HEAP8[($0 + 26 | 0) + $1 | 0] = $2;
           jslGetNextCh();
           continue;
          }
          break;
         }
         ;
         HEAP8[HEAP32[$0 + 16 >> 2] + ($0 + 26 | 0) | 0] = 0;
         $1 = stringToIntWithRadix($0 + 26 | 0, 16, 0, 0);
         HEAP32[$0 + 12 >> 2] = $1;
         HEAP8[$0 + 31 | 0] = HEAP32[$0 + 12 >> 2];
         break label$14;

        default:
         break label$15;
        }
       }
       label$27: {
        if (!(HEAP8[HEAP32[49079]] < 48 | HEAP8[HEAP32[49079]] > 55)) {
         HEAP8[$0 + 8 | 0] = HEAPU8[148588];
         HEAP32[$0 + 4 >> 2] = HEAPU8[148584] | HEAPU8[148585] << 8 | (HEAPU8[148586] << 16 | HEAPU8[148587] << 24);
         HEAP8[$0 + 5 | 0] = HEAPU8[HEAP32[49079]];
         HEAP32[$0 >> 2] = 2;
         jslGetNextCh();
         if (!(HEAP8[HEAP32[49079]] < 48 | HEAP8[HEAP32[49079]] > 55)) {
          $2 = HEAPU8[HEAP32[49079]];
          $1 = HEAP32[$0 >> 2];
          HEAP32[$0 >> 2] = $1 + 1;
          HEAP8[($0 + 4 | 0) + $1 | 0] = $2;
          jslGetNextCh();
          if (!(HEAP8[HEAP32[49079]] < 48 | HEAP8[HEAP32[49079]] > 55)) {
           $2 = HEAPU8[HEAP32[49079]];
           $1 = HEAP32[$0 >> 2];
           HEAP32[$0 >> 2] = $1 + 1;
           HEAP8[($0 + 4 | 0) + $1 | 0] = $2;
           jslGetNextCh();
          }
         }
         HEAP8[HEAP32[$0 >> 2] + ($0 + 4 | 0) | 0] = 0;
         $1 = stringToInt($0 + 4 | 0);
         HEAP8[$0 + 31 | 0] = $1;
         break label$27;
        }
        jslGetNextCh();
       }
      }
      HEAP8[$0 + 39 | 0] = HEAPU8[$0 + 31 | 0];
      jsvStringIteratorAppend($0 + 40 | 0, HEAP8[$0 + 31 | 0]);
      break label$12;
     }
     if (!(HEAP8[$0 + 79 | 0] == 96 | HEAP8[HEAP32[49079]] != 10)) {
      break label$7;
     }
     jsvStringIteratorAppend($0 + 40 | 0, HEAP8[HEAP32[49079]]);
     HEAP8[$0 + 39 | 0] = HEAPU8[HEAP32[49079]];
     jslGetNextCh();
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree($0 + 40 | 0);
  label$32: {
   if (HEAP8[$0 + 79 | 0] == 96) {
    HEAP16[HEAP32[49079] + 2 >> 1] = 133;
    break label$32;
   }
   HEAP16[HEAP32[49079] + 2 >> 1] = 131;
  }
  if (HEAP8[HEAP32[49079]] != HEAP8[$0 + 79 | 0]) {
   $1 = HEAP32[49079];
   HEAP16[$1 + 2 >> 1] = HEAPU16[$1 + 2 >> 1] + 1;
  }
  jslGetNextCh();
 }
 __stack_pointer = $0 + 80 | 0;
}

function matchhere($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 1040 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 1032 >> 2] = $0;
 HEAP32[$3 + 1028 >> 2] = $1;
 label$1: {
  if (jspIsInterrupted() & 1) {
   HEAP32[$3 + 1036 >> 2] = 0;
   break label$1;
  }
  if (!(HEAP8[HEAP32[$3 + 1032 >> 2]] != 124 ? HEAP8[HEAP32[$3 + 1032 >> 2]] : 0)) {
   $0 = HEAP32[$3 + 1028 >> 2];
   __memcpy($3, $2, 88);
   HEAP32[$3 + 1036 >> 2] = matchfound($0, $3);
   break label$1;
  }
  if (HEAP8[HEAP32[$3 + 1032 >> 2]] == 94) {
   if (jsvStringIteratorGetIndex_4(HEAP32[$3 + 1028 >> 2])) {
    HEAP32[$3 + 1036 >> 2] = 0;
    break label$1;
   }
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$3 + 1036 >> 2] = 0;
    break label$1;
   }
   $0 = HEAP32[$3 + 1032 >> 2];
   $1 = HEAP32[$3 + 1028 >> 2];
   __memcpy($3 + 88 | 0, $2, 88);
   HEAP32[$3 + 1036 >> 2] = matchhere($0 + 1 | 0, $1, $3 + 88 | 0);
   break label$1;
  }
  if (HEAP8[HEAP32[$3 + 1032 >> 2]] == 36) {
   if (!(jsvStringIteratorHasChar_7(HEAP32[$3 + 1028 >> 2]) & 1)) {
    $0 = HEAP32[$3 + 1032 >> 2];
    $1 = HEAP32[$3 + 1028 >> 2];
    __memcpy($3 + 264 | 0, $2, 88);
    HEAP32[$3 + 1036 >> 2] = matchhere($0 + 1 | 0, $1, $3 + 264 | 0);
    break label$1;
   }
   $0 = HEAP32[$3 + 1032 >> 2];
   __memcpy($3 + 176 | 0, $2, 88);
   HEAP32[$3 + 1036 >> 2] = nomatchfound($0 + 1 | 0, $3 + 176 | 0);
   break label$1;
  }
  if (HEAP8[HEAP32[$3 + 1032 >> 2]] == 40) {
   $0 = jsvStringIteratorGetIndex_4(HEAP32[$3 + 1028 >> 2]);
   HEAP32[($2 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] = $0;
   HEAP32[($2 + 52 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] = HEAP32[($2 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2];
   if (HEAP32[$2 + 12 >> 2] < 9) {
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
   }
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$3 + 1036 >> 2] = 0;
    break label$1;
   }
   $0 = HEAP32[$3 + 1032 >> 2];
   $1 = HEAP32[$3 + 1028 >> 2];
   __memcpy($3 + 352 | 0, $2, 88);
   HEAP32[$3 + 1036 >> 2] = matchhere($0 + 1 | 0, $1, $3 + 352 | 0);
   break label$1;
  }
  if (HEAP8[HEAP32[$3 + 1032 >> 2]] == 41) {
   if (HEAP32[$2 + 12 >> 2] > 0) {
    $0 = jsvStringIteratorGetIndex_4(HEAP32[$3 + 1028 >> 2]);
    HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 48 >> 2] = $0;
   }
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$3 + 1036 >> 2] = 0;
    break label$1;
   }
   $0 = HEAP32[$3 + 1032 >> 2];
   $1 = HEAP32[$3 + 1028 >> 2];
   __memcpy($3 + 440 | 0, $2, 88);
   HEAP32[$3 + 1036 >> 2] = matchhere($0 + 1 | 0, $1, $3 + 440 | 0);
   break label$1;
  }
  HEAP8[$3 + 1023 | 0] = matchcharacter(HEAP32[$3 + 1032 >> 2], HEAP32[$3 + 1028 >> 2], $3 + 1024 | 0, $2) & 1;
  if (!(HEAP8[HEAP32[$3 + 1032 >> 2] + HEAP32[$3 + 1024 >> 2] | 0] != 42 & HEAP8[HEAP32[$3 + 1032 >> 2] + HEAP32[$3 + 1024 >> 2] | 0] != 43)) {
   HEAP8[$3 + 1022 | 0] = HEAPU8[HEAP32[$3 + 1032 >> 2] + HEAP32[$3 + 1024 >> 2] | 0];
   if (!(HEAP8[$3 + 1023 | 0] & 1 | HEAP8[$3 + 1022 | 0] != 43)) {
    $0 = HEAP32[$3 + 1032 >> 2];
    $1 = HEAP32[$3 + 1024 >> 2] + 1 | 0;
    __memcpy($3 + 704 | 0, $2, 88);
    HEAP32[$3 + 1036 >> 2] = nomatchfound($0 + $1 | 0, $3 + 704 | 0);
    break label$1;
   }
   HEAP32[$3 + 1016 >> 2] = (HEAP32[$3 + 1032 >> 2] + HEAP32[$3 + 1024 >> 2] | 0) + 1;
   jsvStringIteratorClone($3 + 976 | 0, HEAP32[$3 + 1028 >> 2]);
   $0 = HEAP32[$3 + 1016 >> 2];
   __memcpy($3 + 616 | 0, $2, 88);
   HEAP32[$3 + 972 >> 2] = matchhere($0, $3 + 976 | 0, $3 + 616 | 0);
   jsvStringIteratorFree_9($3 + 976 | 0);
   while (1) {
    $0 = 0;
    if (jsvStringIteratorHasChar_7(HEAP32[$3 + 1028 >> 2]) & 1) {
     $0 = HEAPU8[$3 + 1023 | 0];
    }
    if ($0 & 1) {
     jsvStringIteratorNext(HEAP32[$3 + 1028 >> 2]);
     HEAP8[$3 + 1023 | 0] = matchcharacter(HEAP32[$3 + 1032 >> 2], HEAP32[$3 + 1028 >> 2], $3 + 1024 | 0, $2) & 1;
     jsvStringIteratorClone($3 + 976 | 0, HEAP32[$3 + 1028 >> 2]);
     $0 = HEAP32[$3 + 1016 >> 2];
     __memcpy($3 + 528 | 0, $2, 88);
     HEAP32[$3 + 968 >> 2] = matchhere($0, $3 + 976 | 0, $3 + 528 | 0);
     jsvStringIteratorFree_9($3 + 976 | 0);
     if (HEAP32[$3 + 968 >> 2]) {
      jsvUnLock(HEAP32[$3 + 972 >> 2]);
      HEAP32[$3 + 972 >> 2] = HEAP32[$3 + 968 >> 2];
     }
     continue;
    }
    break;
   }
   HEAP32[$3 + 1036 >> 2] = HEAP32[$3 + 972 >> 2];
   break label$1;
  }
  if (!(!(jsvStringIteratorHasChar_7(HEAP32[$3 + 1028 >> 2]) & 1) | !(HEAP8[$3 + 1023 | 0] & 1))) {
   jsvStringIteratorNext(HEAP32[$3 + 1028 >> 2]);
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$3 + 1036 >> 2] = 0;
    break label$1;
   }
   $0 = HEAP32[$3 + 1032 >> 2];
   $1 = HEAP32[$3 + 1024 >> 2];
   $4 = HEAP32[$3 + 1028 >> 2];
   __memcpy($3 + 792 | 0, $2, 88);
   HEAP32[$3 + 1036 >> 2] = matchhere($0 + $1 | 0, $4, $3 + 792 | 0);
   break label$1;
  }
  $0 = HEAP32[$3 + 1032 >> 2];
  $1 = HEAP32[$3 + 1024 >> 2];
  __memcpy($3 + 880 | 0, $2, 88);
  HEAP32[$3 + 1036 >> 2] = nomatchfound($0 + $1 | 0, $3 + 880 | 0);
 }
 __stack_pointer = $3 + 1040 | 0;
 return HEAP32[$3 + 1036 >> 2];
}

function jsvIterateCallback($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 240 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 232 >> 2] = $0;
 HEAP32[$3 + 228 >> 2] = $1;
 HEAP32[$3 + 224 >> 2] = $2;
 HEAP8[$3 + 223 | 0] = 1;
 label$1: {
  label$2: {
   if (jsvIsNumeric(HEAP32[$3 + 232 >> 2]) & 1) {
    $0 = HEAP32[$3 + 228 >> 2];
    FUNCTION_TABLE[$0 | 0](jsvGetInteger(HEAP32[$3 + 232 >> 2]), HEAP32[$3 + 224 >> 2]);
    break label$2;
   }
   label$4: {
    if (jsvIsObject(HEAP32[$3 + 232 >> 2]) & 1) {
     HEAP32[$3 + 216 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 232 >> 2], 129127);
     if (jsvIsFunction(HEAP32[$3 + 216 >> 2]) & 1) {
      HEAP32[$3 + 212 >> 2] = jspExecuteFunction(HEAP32[$3 + 216 >> 2], 0, 0, 0);
      jsvUnLock(HEAP32[$3 + 216 >> 2]);
      if (HEAP32[$3 + 212 >> 2]) {
       HEAP8[$3 + 211 | 0] = jsvIterateCallback(HEAP32[$3 + 212 >> 2], HEAP32[$3 + 228 >> 2], HEAP32[$3 + 224 >> 2]) & 1;
       jsvUnLock(HEAP32[$3 + 212 >> 2]);
       HEAP8[$3 + 239 | 0] = HEAP8[$3 + 211 | 0] & 1;
       break label$1;
      }
      HEAP8[$3 + 239 | 0] = 1;
      break label$1;
     }
     jsvUnLock(HEAP32[$3 + 216 >> 2]);
     HEAP32[$3 + 204 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 232 >> 2], 117360);
     HEAP32[$3 + 200 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 232 >> 2], 135835);
     label$8: {
      label$9: {
       if (!HEAP32[$3 + 204 >> 2] | !HEAP32[$3 + 200 >> 2]) {
        break label$9;
       }
       if (!(jsvIsNumeric(HEAP32[$3 + 204 >> 2]) & 1)) {
        break label$9;
       }
       HEAP32[$3 + 196 >> 2] = jsvGetInteger(HEAP32[$3 + 204 >> 2]);
       while (1) {
        $0 = 0;
        if (HEAP8[$3 + 223 | 0] & 1) {
         $0 = HEAP32[$3 + 196 >> 2];
         HEAP32[$3 + 196 >> 2] = $0 - 1;
         $0 = ($0 | 0) > 0;
        }
        if ($0) {
         HEAP8[$3 + 223 | 0] = jsvIterateCallback(HEAP32[$3 + 200 >> 2], HEAP32[$3 + 228 >> 2], HEAP32[$3 + 224 >> 2]) & 1;
         continue;
        }
        break;
       }
       break label$8;
      }
      HEAP32[$3 >> 2] = HEAP32[$3 + 232 >> 2];
      jsExceptionHere(3, 129158, $3);
      HEAP8[$3 + 223 | 0] = 0;
     }
     jsvUnLock2(HEAP32[$3 + 204 >> 2], HEAP32[$3 + 200 >> 2]);
     break label$4;
    }
    label$13: {
     if (jsvIsString(HEAP32[$3 + 232 >> 2]) & 1) {
      jsvStringIteratorNew($3 + 160 | 0, HEAP32[$3 + 232 >> 2], 0);
      while (1) {
       $0 = 0;
       if (jsvStringIteratorHasChar_2($3 + 160 | 0) & 1) {
        $0 = HEAPU8[$3 + 223 | 0];
       }
       if ($0 & 1) {
        HEAP8[$3 + 159 | 0] = jsvStringIteratorGetCharAndNext($3 + 160 | 0);
        FUNCTION_TABLE[HEAP32[$3 + 228 >> 2]](HEAP8[$3 + 159 | 0], HEAP32[$3 + 224 >> 2]);
        continue;
       }
       break;
      }
      jsvStringIteratorFree_2($3 + 160 | 0);
      break label$13;
     }
     label$18: {
      if (jsvIsArrayBuffer(HEAP32[$3 + 232 >> 2]) & 1) {
       jsvArrayBufferIteratorNew($3 + 96 | 0, HEAP32[$3 + 232 >> 2], 0);
       label$20: {
        if (!(HEAPU8[$3 + 132 | 0] & 16 | (HEAPU8[$3 + 132 | 0] & 15) != 1)) {
         HEAP32[$3 + 92 >> 2] = $3 + 96;
         HEAP32[$3 + 88 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 232 >> 2]);
         while (1) {
          $0 = HEAP32[$3 + 88 >> 2];
          HEAP32[$3 + 88 >> 2] = $0 - 1;
          if ($0) {
           $0 = HEAP32[$3 + 228 >> 2];
           FUNCTION_TABLE[$0 | 0](jsvStringIteratorGetChar_2(HEAP32[$3 + 92 >> 2]) & 255, HEAP32[$3 + 224 >> 2]);
           jsvStringIteratorNextInline(HEAP32[$3 + 92 >> 2]);
           continue;
          }
          break;
         }
         break label$20;
        }
        while (1) {
         if (jsvArrayBufferIteratorHasElement($3 + 96 | 0) & 1) {
          $0 = HEAP32[$3 + 228 >> 2];
          FUNCTION_TABLE[$0 | 0](jsvArrayBufferIteratorGetIntegerValue($3 + 96 | 0), HEAP32[$3 + 224 >> 2]);
          jsvArrayBufferIteratorNext($3 + 96 | 0);
          continue;
         }
         break;
        }
       }
       jsvArrayBufferIteratorFree($3 + 96 | 0);
       break label$18;
      }
      label$26: {
       if (jsvIsIterable(HEAP32[$3 + 232 >> 2]) & 1) {
        jsvIteratorNew($3 + 24 | 0, HEAP32[$3 + 232 >> 2], 1);
        while (1) {
         $0 = 0;
         if (jsvIteratorHasElement($3 + 24 | 0) & 1) {
          $0 = HEAPU8[$3 + 223 | 0];
         }
         if ($0 & 1) {
          HEAP32[$3 + 20 >> 2] = jsvIteratorGetValue($3 + 24 | 0);
          HEAP8[$3 + 223 | 0] = jsvIterateCallback(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 228 >> 2], HEAP32[$3 + 224 >> 2]) & 1;
          jsvUnLock(HEAP32[$3 + 20 >> 2]);
          jsvIteratorNext($3 + 24 | 0);
          continue;
         }
         break;
        }
        jsvIteratorFree($3 + 24 | 0);
        break label$26;
       }
       HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 232 >> 2];
       jsExceptionHere(3, 118945, $3 + 16 | 0);
       HEAP8[$3 + 223 | 0] = 0;
      }
     }
    }
   }
  }
  HEAP8[$3 + 239 | 0] = HEAP8[$3 + 223 | 0] & 1;
 }
 __stack_pointer = $3 + 240 | 0;
 return HEAP8[$3 + 239 | 0] & 1;
}

function jswrap_storagefile_read_internal($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 224 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 216 >> 2] = $0;
 HEAP32[$2 + 212 >> 2] = $1;
 HEAP8[$2 + 211 | 0] = HEAP32[$2 + 212 >> 2] < 0;
 HEAP8[$2 + 210 | 0] = jsvObjectGetIntegerChild(HEAP32[$2 + 216 >> 2], 132782);
 label$1: {
  if (HEAP8[$2 + 210 | 0] != 114) {
   jsExceptionHere(1, 132746, 0);
   HEAP32[$2 + 220 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 204 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 216 >> 2], 129088);
  jsfNameFromVarAndUnLock($2 + 176 | 0, jsvObjectGetChildIfExists(HEAP32[$2 + 216 >> 2], 132398));
  HEAP32[$2 + 172 >> 2] = 27;
  while (1) {
   $0 = 0;
   $0 = HEAP32[$2 + 172 >> 2] ? !HEAP8[(HEAP32[$2 + 172 >> 2] + $2 | 0) + 175 | 0] : $0;
   if ($0) {
    HEAP32[$2 + 172 >> 2] = HEAP32[$2 + 172 >> 2] - 1;
    continue;
   }
   break;
  }
  HEAP8[HEAP32[$2 + 172 >> 2] + ($2 + 176 | 0) | 0] = HEAP32[$2 + 204 >> 2];
  HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 200 >> 2];
  $0 = HEAP32[$2 + 196 >> 2];
  $1 = HEAP32[$2 + 192 >> 2];
  HEAP32[$2 + 56 >> 2] = $1;
  HEAP32[$2 + 60 >> 2] = $0;
  $1 = HEAP32[$2 + 188 >> 2];
  $0 = HEAP32[$2 + 184 >> 2];
  HEAP32[$2 + 48 >> 2] = $0;
  HEAP32[$2 + 52 >> 2] = $1;
  $0 = HEAP32[$2 + 180 >> 2];
  $1 = HEAP32[$2 + 176 >> 2];
  HEAP32[$2 + 40 >> 2] = $1;
  HEAP32[$2 + 44 >> 2] = $0;
  HEAP32[$2 + 132 >> 2] = jsfFindFile($2 + 40 | 0, $2 + 136 | 0);
  if (!HEAP32[$2 + 132 >> 2]) {
   HEAP32[$2 + 220 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 128 >> 2] = jsfGetFileSize($2 + 136 | 0);
  HEAP32[$2 + 124 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 216 >> 2], 117864);
  HEAP32[$2 + 120 >> 2] = 0;
  if (HEAP8[$2 + 211 | 0] & 1) {
   HEAP32[$2 + 212 >> 2] = 32;
  }
  while (1) {
   label$9: {
    if (!HEAP32[$2 + 212 >> 2]) {
     break label$9;
    }
    HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 128 >> 2] - HEAP32[$2 + 124 >> 2];
    if (HEAP32[$2 + 76 >> 2] <= 0) {
     HEAP32[$2 + 124 >> 2] = 0;
     label$11: {
      if (HEAP32[$2 + 204 >> 2] == 255) {
       HEAP32[$2 + 132 >> 2] = 0;
       break label$11;
      }
      HEAP32[$2 + 204 >> 2] = HEAP32[$2 + 204 >> 2] + 1;
      HEAP8[HEAP32[$2 + 172 >> 2] + ($2 + 176 | 0) | 0] = HEAP32[$2 + 204 >> 2];
      HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 200 >> 2];
      $1 = HEAP32[$2 + 196 >> 2];
      $0 = HEAP32[$2 + 192 >> 2];
      HEAP32[$2 + 24 >> 2] = $0;
      HEAP32[$2 + 28 >> 2] = $1;
      $0 = HEAP32[$2 + 188 >> 2];
      $1 = HEAP32[$2 + 184 >> 2];
      HEAP32[$2 + 16 >> 2] = $1;
      HEAP32[$2 + 20 >> 2] = $0;
      $1 = HEAP32[$2 + 180 >> 2];
      $0 = HEAP32[$2 + 176 >> 2];
      HEAP32[$2 + 8 >> 2] = $0;
      HEAP32[$2 + 12 >> 2] = $1;
      HEAP32[$2 + 132 >> 2] = jsfFindFile($2 + 8 | 0, $2 + 136 | 0);
      HEAP32[$2 + 128 >> 2] = jsfGetFileSize($2 + 136 | 0);
     }
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 216 >> 2], 117864, jsvNewFromInteger(HEAP32[$2 + 124 >> 2]));
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 216 >> 2], 129088, jsvNewFromInteger(HEAP32[$2 + 204 >> 2]));
     HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 128 >> 2];
     if (!HEAP32[$2 + 132 >> 2]) {
      HEAP32[$2 + 220 >> 2] = HEAP32[$2 + 120 >> 2];
      break label$1;
     }
    }
    HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 212 >> 2];
    if (HEAP32[$2 + 72 >> 2] > 32) {
     HEAP32[$2 + 72 >> 2] = 32;
    }
    if (HEAP32[$2 + 72 >> 2] > HEAP32[$2 + 76 >> 2]) {
     HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 76 >> 2];
    }
    jshFlashRead($2 + 80 | 0, HEAP32[$2 + 132 >> 2] + HEAP32[$2 + 124 >> 2] | 0, HEAP32[$2 + 72 >> 2]);
    HEAP32[$2 + 68 >> 2] = 0;
    while (1) {
     label$17: {
      if (HEAP32[$2 + 68 >> 2] >= HEAP32[$2 + 72 >> 2]) {
       break label$17;
      }
      if (HEAP8[HEAP32[$2 + 68 >> 2] + ($2 + 80 | 0) | 0] == -1) {
       HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 68 >> 2];
       HEAP32[$2 + 212 >> 2] = HEAP32[$2 + 72 >> 2];
       break label$17;
      }
      if (!(HEAP8[$2 + 211 | 0] & 1) | HEAP8[HEAP32[$2 + 68 >> 2] + ($2 + 80 | 0) | 0] != 10) {
       HEAP32[$2 + 68 >> 2] = HEAP32[$2 + 68 >> 2] + 1;
       continue;
      } else {
       HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 68 >> 2] + 1;
       HEAP32[$2 + 212 >> 2] = HEAP32[$2 + 72 >> 2];
       HEAP8[$2 + 211 | 0] = 0;
      }
     }
     break;
    }
    if (!HEAP32[$2 + 72 >> 2]) {
     break label$9;
    }
    if (!HEAP32[$2 + 120 >> 2]) {
     HEAP32[$2 + 120 >> 2] = jsvNewFromEmptyString_11();
    }
    if (HEAP32[$2 + 120 >> 2]) {
     jsvAppendStringBuf(HEAP32[$2 + 120 >> 2], $2 + 80 | 0, HEAP32[$2 + 72 >> 2]);
    }
    HEAP32[$2 + 212 >> 2] = HEAP32[$2 + 212 >> 2] - HEAP32[$2 + 72 >> 2];
    HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 72 >> 2] + HEAP32[$2 + 124 >> 2];
    if (HEAP8[$2 + 211 | 0] & 1) {
     HEAP32[$2 + 212 >> 2] = 32;
    }
    continue;
   }
   break;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 216 >> 2], 117864, jsvNewFromInteger(HEAP32[$2 + 124 >> 2]));
  HEAP32[$2 + 220 >> 2] = HEAP32[$2 + 120 >> 2];
 }
 __stack_pointer = $2 + 224 | 0;
 return HEAP32[$2 + 220 >> 2];
}

function jspeFunctionDefinitionInternal($0, $1) {
 var $2 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $2 = __stack_pointer - 112 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 104 >> 2] = $0;
 HEAP8[$2 + 103 | 0] = $1;
 HEAP8[$2 + 55 | 0] = 0;
 label$1: {
  label$2: {
   if (HEAP8[$2 + 103 | 0] & 1) {
    if (HEAP32[$2 + 104 >> 2]) {
     $0 = HEAP32[$2 + 104 >> 2];
     $1 = HEAP32[$2 + 104 >> 2];
     $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64 | 9;
     HEAP8[$0 + 12 | 0] = $1;
     HEAP8[$0 + 13 | 0] = $1 >>> 8;
    }
    break label$2;
   }
   HEAP32[$2 + 48 >> 2] = HEAP32[91094];
   HEAP32[91094] = 1;
   if (!(jslMatch(123) & 1)) {
    HEAP8[$2 + 111 | 0] = 0;
    break label$1;
   }
   HEAP32[91094] = HEAP32[$2 + 48 >> 2];
   if (HEAP16[HEAP32[49079] + 2 >> 1] == 131) {
    HEAP32[$2 + 44 >> 2] = jslGetTokenValueAsVar();
    label$7: {
     if (jsvIsStringEqual(HEAP32[$2 + 44 >> 2], 133996) & 1) {
      jsWarn(128609, 0);
      break label$7;
     }
     if (jsvIsStringEqual(HEAP32[$2 + 44 >> 2], 128703) & 1) {
      jslGetNextToken();
      if (HEAP16[HEAP32[49079] + 2 >> 1] == 59) {
       jslGetNextToken();
      }
      HEAP8[$2 + 55 | 0] = 1;
     }
    }
    jsvUnLock(HEAP32[$2 + 44 >> 2]);
   }
   if (!(!HEAP32[$2 + 104 >> 2] | HEAP16[HEAP32[49079] + 2 >> 1] != 171)) {
    $0 = HEAP32[$2 + 104 >> 2];
    $1 = HEAP32[$2 + 104 >> 2];
    $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64 | 9;
    HEAP8[$0 + 12 | 0] = $1;
    HEAP8[$0 + 13 | 0] = $1 >>> 8;
    jslGetNextToken();
   }
  }
  jslSkipWhiteSpace();
  jslCharPosNew($2 + 56 | 0, HEAP32[HEAP32[49079] + 84 >> 2], HEAP32[HEAP32[49079] + 4 >> 2]);
  HEAP32[$2 + 40 >> 2] = -1;
  HEAP8[HEAP32[49079] + 81 | 0] = HEAP16[HEAP32[49079] + 2 >> 1] == 175;
  label$12: {
   if (!(HEAP8[$2 + 103 | 0] & 1)) {
    HEAP32[$2 + 36 >> 2] = 0;
    HEAP32[$2 + 32 >> 2] = HEAP32[91094];
    HEAP32[91094] = 0;
    while (1) {
     $0 = 0;
     if (HEAP16[HEAP32[49079] + 2 >> 1]) {
      $0 = 1;
      $0 = HEAP32[$2 + 36 >> 2] ? $0 : HEAP16[HEAP32[49079] + 2 >> 1] != 125;
     }
     if ($0 & 1) {
      if (HEAP16[HEAP32[49079] + 2 >> 1] == 123) {
       HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 36 >> 2] + 1;
      }
      if (HEAP16[HEAP32[49079] + 2 >> 1] == 125) {
       HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 36 >> 2] - 1;
      }
      HEAP32[$2 + 40 >> 2] = jsvStringIteratorGetIndex_3(HEAP32[49079] + 88 | 0) - 1;
      jslGetNextToken();
      continue;
     }
     break;
    }
    HEAP32[91094] = HEAP32[$2 + 32 >> 2];
    break label$12;
   }
   HEAP32[$2 + 28 >> 2] = HEAP32[91094];
   HEAP32[91094] = 0;
   jsvUnLock(jspeAssignmentExpression());
   HEAP32[91094] = HEAP32[$2 + 28 >> 2];
   HEAP32[$2 + 40 >> 2] = HEAP32[HEAP32[49079] + 4 >> 2];
  }
  HEAP8[$2 + 27 | 0] = HEAP8[HEAP32[49079] + 81 | 0] & 1;
  if (!(!HEAP32[$2 + 104 >> 2] | HEAP32[$2 + 40 >> 2] <= 0)) {
   label$21: {
    label$22: {
     if (HEAP8[$2 + 55 | 0] & 1) {
      break label$22;
     }
     if (!(jsvIsNativeString(HEAP32[HEAP32[49079] + 84 >> 2]) & 1)) {
      break label$22;
     }
     HEAP32[$2 + 16 >> 2] = jsvStringIteratorGetIndex_3($2 + 56 | 0) - 1;
     $0 = HEAP32[HEAP32[49079] + 84 >> 2];
     HEAP32[$2 + 20 >> 2] = jsvNewNativeString(HEAP32[$2 + 16 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0, HEAP32[$2 + 40 >> 2] - HEAP32[$2 + 16 >> 2] | 0);
     break label$21;
    }
    label$23: {
     label$24: {
      if (HEAP8[$2 + 55 | 0] & 1) {
       break label$24;
      }
      if (!(jsvIsFlashString(HEAP32[HEAP32[49079] + 84 >> 2]) & 1)) {
       break label$24;
      }
      HEAP32[$2 + 12 >> 2] = jsvStringIteratorGetIndex_3($2 + 56 | 0) - 1;
      $0 = HEAP32[HEAP32[49079] + 84 >> 2];
      HEAP32[$2 + 20 >> 2] = jsvNewFlashString(HEAP32[$2 + 12 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0, HEAP32[$2 + 40 >> 2] - HEAP32[$2 + 12 >> 2] | 0);
      break label$23;
     }
     label$25: {
      if (wasm2js_i32$0 = 1, wasm2js_i32$1 = jsfGetFlag(8) & 1, wasm2js_i32$2 = HEAP8[$2 + 55 | 0] & 1, 
      wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1) {
       HEAP32[$2 + 20 >> 2] = jslNewTokenisedStringFromLexer($2 + 56 | 0, HEAP32[$2 + 40 >> 2]);
       break label$25;
      }
      HEAP32[$2 + 20 >> 2] = jslNewStringFromLexer($2 + 56 | 0, HEAP32[$2 + 40 >> 2]);
     }
    }
   }
   jsvAddNamedChildAndUnLock(HEAP32[$2 + 104 >> 2], HEAP32[$2 + 20 >> 2], 133204);
   HEAP32[$2 + 8 >> 2] = jspeiGetScopesAsVar();
   if (HEAP32[$2 + 8 >> 2]) {
    jsvAddNamedChildAndUnLock(HEAP32[$2 + 104 >> 2], HEAP32[$2 + 8 >> 2], 128047);
   }
  }
  jslCharPosFree($2 + 56 | 0);
  if (!(HEAP8[$2 + 103 | 0] & 1)) {
   if (!(jslMatch(125) & 1)) {
    HEAP8[$2 + 111 | 0] = 0;
    break label$1;
   }
  }
  HEAP8[$2 + 111 | 0] = HEAP8[$2 + 27 | 0] & 1;
 }
 __stack_pointer = $2 + 112 | 0;
 return HEAP8[$2 + 111 | 0] & 1;
}

function tflite__ops__micro__fully_connected__EvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20tflite__ops__micro__fully_connected___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = __stack_pointer - 288 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 280 >> 2] = $0;
 HEAP32[$7 + 276 >> 2] = $1;
 HEAP32[$7 + 272 >> 2] = $2;
 HEAP32[$7 + 268 >> 2] = $3;
 HEAP32[$7 + 264 >> 2] = $4;
 HEAP32[$7 + 260 >> 2] = $5;
 HEAP32[$7 + 256 >> 2] = $6;
 HEAP32[$7 + 252 >> 2] = 0 - HEAP32[HEAP32[$7 + 272 >> 2] + 20 >> 2];
 HEAP32[$7 + 248 >> 2] = 0 - HEAP32[HEAP32[$7 + 272 >> 2] + 24 >> 2];
 HEAP32[$7 + 244 >> 2] = HEAP32[HEAP32[$7 + 272 >> 2] + 28 >> 2];
 HEAP32[$7 + 200 >> 2] = HEAP32[$7 + 252 >> 2];
 HEAP32[$7 + 204 >> 2] = HEAP32[$7 + 248 >> 2];
 HEAP32[$7 + 208 >> 2] = HEAP32[$7 + 244 >> 2];
 HEAP32[$7 + 212 >> 2] = HEAP32[HEAP32[$7 + 272 >> 2] >> 2];
 HEAP32[$7 + 216 >> 2] = 0 - HEAP32[HEAP32[$7 + 272 >> 2] + 4 >> 2];
 HEAP32[$7 + 220 >> 2] = HEAP32[HEAP32[$7 + 272 >> 2] + 8 >> 2];
 HEAP32[$7 + 224 >> 2] = HEAP32[HEAP32[$7 + 272 >> 2] + 12 >> 2];
 label$1: {
  label$2: {
   label$3: {
    switch (HEAP32[HEAP32[$7 + 256 >> 2] + 8 >> 2] - 3 | 0) {
    case 0:
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 176 | 0, HEAP32[$7 + 268 >> 2]);
     $0 = unsigned_20char_20const__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 268 >> 2]);
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 152 | 0, HEAP32[$7 + 264 >> 2]);
     $1 = unsigned_20char_20const__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 264 >> 2]);
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 128 | 0, HEAP32[$7 + 260 >> 2]);
     $2 = int_20const__20tflite__micro__GetTensorData_int__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 260 >> 2]);
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 104 | 0, HEAP32[$7 + 256 >> 2]);
     tflite__reference_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($7 + 200 | 0, $7 + 176 | 0, $0, $7 + 152 | 0, $1, $7 + 128 | 0, $2, $7 + 104 | 0, unsigned_20char__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor__29(HEAP32[$7 + 256 >> 2]));
     tflite__RuntimeShape___RuntimeShape_28_29($7 + 104 | 0);
     tflite__RuntimeShape___RuntimeShape_28_29($7 + 128 | 0);
     tflite__RuntimeShape___RuntimeShape_28_29($7 + 152 | 0);
     tflite__RuntimeShape___RuntimeShape_28_29($7 + 176 | 0);
     break label$2;

    case 4:
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 80 | 0, HEAP32[$7 + 268 >> 2]);
     $0 = unsigned_20char_20const__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 268 >> 2]);
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 56 | 0, HEAP32[$7 + 264 >> 2]);
     $1 = unsigned_20char_20const__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 264 >> 2]);
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 32 | 0, HEAP32[$7 + 260 >> 2]);
     $2 = int_20const__20tflite__micro__GetTensorData_int__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 260 >> 2]);
     tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 8 | 0, HEAP32[$7 + 256 >> 2]);
     tflite__reference_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20short__29($7 + 200 | 0, $7 + 80 | 0, $0, $7 + 56 | 0, $1, $7 + 32 | 0, $2, $7 + 8 | 0, short__20tflite__micro__GetTensorData_short__28TfLiteEvalTensor__29(HEAP32[$7 + 256 >> 2]));
     tflite__RuntimeShape___RuntimeShape_28_29($7 + 8 | 0);
     tflite__RuntimeShape___RuntimeShape_28_29($7 + 32 | 0);
     tflite__RuntimeShape___RuntimeShape_28_29($7 + 56 | 0);
     tflite__RuntimeShape___RuntimeShape_28_29($7 + 80 | 0);
     break label$2;

    default:
     break label$3;
    }
   }
   $0 = HEAP32[HEAP32[$7 + 280 >> 2] + 20 >> 2];
   $1 = HEAP32[$7 + 280 >> 2];
   $2 = TfLiteTypeGetName(HEAP32[HEAP32[$7 + 256 >> 2] + 8 >> 2]);
   HEAP32[$7 + 4 >> 2] = HEAP32[HEAP32[$7 + 256 >> 2] + 8 >> 2];
   HEAP32[$7 >> 2] = $2;
   FUNCTION_TABLE[$0 | 0]($1, 140819, $7);
   HEAP32[$7 + 284 >> 2] = 1;
   break label$1;
  }
  HEAP32[$7 + 284 >> 2] = 0;
 }
 __stack_pointer = $7 + 288 | 0;
 return HEAP32[$7 + 284 >> 2];
}

function jswrap_graphics_floodFill($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 128 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 120 >> 2] = $0;
 HEAP32[$4 + 116 >> 2] = $1;
 HEAP32[$4 + 112 >> 2] = $2;
 HEAP32[$4 + 108 >> 2] = $3;
 label$1: {
  if (!(graphicsGetFromVar($4 + 32 | 0, HEAP32[$4 + 120 >> 2]) & 1)) {
   HEAP32[$4 + 124 >> 2] = 0;
   break label$1;
  }
  if ((HEAPU8[$4 + 92 | 0] | HEAPU8[$4 + 93 | 0] << 8 | (HEAPU8[$4 + 94 | 0] << 16 | HEAPU8[$4 + 95 | 0] << 24)) == 577) {
   jsExceptionHere(1, 128751, 0);
   HEAP32[$4 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 28 >> 2] = HEAPU8[$4 + 49 | 0] | HEAPU8[$4 + 50 | 0] << 8 | (HEAPU8[$4 + 51 | 0] << 16 | HEAPU8[$4 + 52 | 0] << 24);
  if (HEAP32[$4 + 108 >> 2]) {
   HEAP32[$4 + 28 >> 2] = jswrap_graphics_toColor(HEAP32[$4 + 120 >> 2], HEAP32[$4 + 108 >> 2], 0, 0);
  }
  HEAP32[$4 + 24 >> 2] = graphicsGetPixel($4 + 32 | 0, HEAP32[$4 + 116 >> 2], HEAP32[$4 + 112 >> 2]);
  HEAP32[$4 + 20 >> 2] = 64;
  HEAP32[$4 + 16 >> 2] = $4;
  $0 = $4 - 128 | 0;
  __stack_pointer = $0;
  HEAP32[$4 + 12 >> 2] = 0;
  label$5: {
   if (HEAP32[$4 + 12 >> 2] < 64) {
    $2 = HEAP32[$4 + 116 >> 2];
    $1 = HEAP32[$4 + 12 >> 2];
    HEAP32[$4 + 12 >> 2] = $1 + 1;
    HEAP16[($1 << 1) + $0 >> 1] = $2;
    $2 = HEAP32[$4 + 112 >> 2];
    $1 = HEAP32[$4 + 12 >> 2];
    HEAP32[$4 + 12 >> 2] = $1 + 1;
    HEAP16[($1 << 1) + $0 >> 1] = $2;
    break label$5;
   }
   HEAP32[$4 + 12 >> 2] = 65;
  }
  while (1) {
   $1 = 0;
   $1 = HEAP32[$4 + 12 >> 2] > 0 ? HEAP32[$4 + 12 >> 2] <= 64 : $1;
   if ($1) {
    $1 = HEAP32[$4 + 12 >> 2] - 1 | 0;
    HEAP32[$4 + 12 >> 2] = $1;
    HEAP16[$4 + 10 >> 1] = HEAPU16[($1 << 1) + $0 >> 1];
    $1 = HEAP32[$4 + 12 >> 2] - 1 | 0;
    HEAP32[$4 + 12 >> 2] = $1;
    HEAP16[$4 + 8 >> 1] = HEAPU16[($1 << 1) + $0 >> 1];
    HEAP16[$4 + 6 >> 1] = HEAPU16[$4 + 8 >> 1];
    while (1) {
     if (_jswrap_graphics_floodFill_inside($4 + 32 | 0, HEAP16[$4 + 6 >> 1] - 1 | 0, HEAP16[$4 + 10 >> 1], HEAP32[$4 + 24 >> 2]) & 1) {
      $1 = HEAPU16[$4 + 6 >> 1] - 1 | 0;
      HEAP16[$4 + 6 >> 1] = $1;
      graphicsSetPixel($4 + 32 | 0, $1 << 16 >> 16, HEAP16[$4 + 10 >> 1], HEAP32[$4 + 28 >> 2]);
      continue;
     }
     break;
    }
    while (1) {
     if (_jswrap_graphics_floodFill_inside($4 + 32 | 0, HEAP16[$4 + 8 >> 1], HEAP16[$4 + 10 >> 1], HEAP32[$4 + 24 >> 2]) & 1) {
      $1 = HEAPU16[$4 + 8 >> 1];
      HEAP16[$4 + 8 >> 1] = $1 + 1;
      graphicsSetPixel($4 + 32 | 0, $1 << 16 >> 16, HEAP16[$4 + 10 >> 1], HEAP32[$4 + 28 >> 2]);
      continue;
     }
     break;
    }
    HEAP8[$4 + 5 | 0] = 0;
    HEAP16[$4 + 2 >> 1] = HEAPU16[$4 + 6 >> 1];
    while (1) {
     if (HEAP16[$4 + 2 >> 1] < HEAP16[$4 + 8 >> 1]) {
      label$16: {
       if (!(_jswrap_graphics_floodFill_inside($4 + 32 | 0, HEAP16[$4 + 2 >> 1], HEAP16[$4 + 10 >> 1] + 1 | 0, HEAP32[$4 + 24 >> 2]) & 1)) {
        HEAP8[$4 + 5 | 0] = 0;
        break label$16;
       }
       if (!(HEAP8[$4 + 5 | 0] & 1)) {
        label$19: {
         if (HEAP32[$4 + 12 >> 2] < 64) {
          $2 = HEAPU16[$4 + 2 >> 1];
          $1 = HEAP32[$4 + 12 >> 2];
          HEAP32[$4 + 12 >> 2] = $1 + 1;
          HEAP16[($1 << 1) + $0 >> 1] = $2;
          $2 = HEAP16[$4 + 10 >> 1];
          $1 = HEAP32[$4 + 12 >> 2];
          HEAP32[$4 + 12 >> 2] = $1 + 1;
          HEAP16[($1 << 1) + $0 >> 1] = $2 + 1;
          break label$19;
         }
         HEAP32[$4 + 12 >> 2] = 65;
        }
        HEAP8[$4 + 5 | 0] = 1;
       }
      }
      HEAP16[$4 + 2 >> 1] = HEAPU16[$4 + 2 >> 1] + 1;
      continue;
     }
     break;
    }
    HEAP8[$4 + 5 | 0] = 0;
    HEAP16[$4 >> 1] = HEAPU16[$4 + 6 >> 1];
    while (1) {
     if (HEAP16[$4 >> 1] < HEAP16[$4 + 8 >> 1]) {
      label$23: {
       if (!(_jswrap_graphics_floodFill_inside($4 + 32 | 0, HEAP16[$4 >> 1], HEAP16[$4 + 10 >> 1] - 1 | 0, HEAP32[$4 + 24 >> 2]) & 1)) {
        HEAP8[$4 + 5 | 0] = 0;
        break label$23;
       }
       if (!(HEAP8[$4 + 5 | 0] & 1)) {
        label$26: {
         if (HEAP32[$4 + 12 >> 2] < 64) {
          $2 = HEAPU16[$4 >> 1];
          $1 = HEAP32[$4 + 12 >> 2];
          HEAP32[$4 + 12 >> 2] = $1 + 1;
          HEAP16[($1 << 1) + $0 >> 1] = $2;
          $2 = HEAP16[$4 + 10 >> 1];
          $1 = HEAP32[$4 + 12 >> 2];
          HEAP32[$4 + 12 >> 2] = $1 + 1;
          HEAP16[($1 << 1) + $0 >> 1] = $2 - 1;
          break label$26;
         }
         HEAP32[$4 + 12 >> 2] = 65;
        }
        HEAP8[$4 + 5 | 0] = 1;
       }
      }
      HEAP16[$4 >> 1] = HEAPU16[$4 >> 1] + 1;
      continue;
     }
     break;
    }
    continue;
   }
   break;
  }
  if (HEAP32[$4 + 12 >> 2]) {
   jsiConsolePrintf(146439, 0);
  }
  graphicsSetVar($4 + 32 | 0);
  HEAP32[$4 + 124 >> 2] = jsvLockAgain(HEAP32[$4 + 120 >> 2]);
 }
 __stack_pointer = $4 + 128 | 0;
 return HEAP32[$4 + 124 >> 2];
}

function FFT($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 128 | 0;
 __stack_pointer = $4;
 HEAP16[$4 + 126 >> 1] = $0;
 HEAP32[$4 + 120 >> 2] = $1;
 HEAP32[$4 + 116 >> 2] = $2;
 HEAP32[$4 + 112 >> 2] = $3;
 HEAP32[$4 + 108 >> 2] = 1;
 HEAP32[$4 + 104 >> 2] = 0;
 while (1) {
  if (HEAP32[$4 + 104 >> 2] < HEAP32[$4 + 120 >> 2]) {
   HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 108 >> 2] << 1;
   HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 104 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$4 + 88 >> 2] = HEAP32[$4 + 108 >> 2] >> 1;
 HEAP32[$4 + 96 >> 2] = 0;
 HEAP32[$4 + 104 >> 2] = 0;
 while (1) {
  if (HEAP32[$4 + 104 >> 2] < (HEAP32[$4 + 108 >> 2] - 1 | 0)) {
   if (HEAP32[$4 + 104 >> 2] < HEAP32[$4 + 96 >> 2]) {
    HEAPF64[$4 + 48 >> 3] = HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3];
    HEAPF64[$4 + 40 >> 3] = HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3];
    HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3] = HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 96 >> 2] << 3) >> 3];
    HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3] = HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 96 >> 2] << 3) >> 3];
    HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 96 >> 2] << 3) >> 3] = HEAPF64[$4 + 48 >> 3];
    HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 96 >> 2] << 3) >> 3] = HEAPF64[$4 + 40 >> 3];
   }
   HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 88 >> 2];
   while (1) {
    if (HEAP32[$4 + 92 >> 2] <= HEAP32[$4 + 96 >> 2]) {
     HEAP32[$4 + 96 >> 2] = HEAP32[$4 + 96 >> 2] - HEAP32[$4 + 92 >> 2];
     HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 92 >> 2] >> 1;
     continue;
    }
    break;
   }
   HEAP32[$4 + 96 >> 2] = HEAP32[$4 + 92 >> 2] + HEAP32[$4 + 96 >> 2];
   HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 104 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAPF64[$4 + 64 >> 3] = -1;
 HEAPF64[$4 + 56 >> 3] = 0;
 HEAP32[$4 + 76 >> 2] = 1;
 HEAP32[$4 + 84 >> 2] = 0;
 while (1) {
  if (HEAP32[$4 + 84 >> 2] < HEAP32[$4 + 120 >> 2]) {
   HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 76 >> 2];
   HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 76 >> 2] << 1;
   HEAPF64[$4 + 16 >> 3] = 1;
   HEAPF64[$4 + 8 >> 3] = 0;
   HEAP32[$4 + 96 >> 2] = 0;
   while (1) {
    if (HEAP32[$4 + 96 >> 2] < HEAP32[$4 + 80 >> 2]) {
     HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 96 >> 2];
     while (1) {
      if (HEAP32[$4 + 104 >> 2] < HEAP32[$4 + 108 >> 2]) {
       HEAP32[$4 + 100 >> 2] = HEAP32[$4 + 104 >> 2] + HEAP32[$4 + 80 >> 2];
       HEAPF64[$4 + 32 >> 3] = HEAPF64[$4 + 16 >> 3] * HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3] + -(HEAPF64[$4 + 8 >> 3] * HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3]);
       HEAPF64[$4 + 24 >> 3] = HEAPF64[$4 + 16 >> 3] * HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3] + HEAPF64[$4 + 8 >> 3] * HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3];
       HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3] = HEAPF64[HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3] - HEAPF64[$4 + 32 >> 3];
       HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 100 >> 2] << 3) >> 3] = HEAPF64[HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) >> 3] - HEAPF64[$4 + 24 >> 3];
       $0 = HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) | 0;
       HEAPF64[$0 >> 3] = HEAPF64[$0 >> 3] + HEAPF64[$4 + 32 >> 3];
       $0 = HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) | 0;
       HEAPF64[$0 >> 3] = HEAPF64[$0 >> 3] + HEAPF64[$4 + 24 >> 3];
       HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 76 >> 2] + HEAP32[$4 + 104 >> 2];
       continue;
      }
      break;
     }
     HEAPF64[$4 >> 3] = HEAPF64[$4 + 16 >> 3] * HEAPF64[$4 + 64 >> 3] + -(HEAPF64[$4 + 8 >> 3] * HEAPF64[$4 + 56 >> 3]);
     HEAPF64[$4 + 8 >> 3] = HEAPF64[$4 + 16 >> 3] * HEAPF64[$4 + 56 >> 3] + HEAPF64[$4 + 8 >> 3] * HEAPF64[$4 + 64 >> 3];
     HEAPF64[$4 + 16 >> 3] = HEAPF64[$4 >> 3];
     HEAP32[$4 + 96 >> 2] = HEAP32[$4 + 96 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAPF64[$4 + 56 >> 3] = jswrap_math_sqrt((1 - HEAPF64[$4 + 64 >> 3]) * .5);
   if (HEAP16[$4 + 126 >> 1] == 1) {
    HEAPF64[$4 + 56 >> 3] = -HEAPF64[$4 + 56 >> 3];
   }
   HEAPF64[$4 + 64 >> 3] = jswrap_math_sqrt((HEAPF64[$4 + 64 >> 3] + 1) * .5);
   HEAP32[$4 + 84 >> 2] = HEAP32[$4 + 84 >> 2] + 1;
   continue;
  }
  break;
 }
 if (HEAP16[$4 + 126 >> 1] == 1) {
  HEAP32[$4 + 104 >> 2] = 0;
  while (1) {
   if (HEAP32[$4 + 104 >> 2] < HEAP32[$4 + 108 >> 2]) {
    $0 = HEAP32[$4 + 116 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) | 0;
    HEAPF64[$0 >> 3] = HEAPF64[$0 >> 3] / +HEAP32[$4 + 108 >> 2];
    $0 = HEAP32[$4 + 112 >> 2] + (HEAP32[$4 + 104 >> 2] << 3) | 0;
    HEAPF64[$0 >> 3] = HEAPF64[$0 >> 3] / +HEAP32[$4 + 108 >> 2];
    HEAP32[$4 + 104 >> 2] = HEAP32[$4 + 104 >> 2] + 1;
    continue;
   }
   break;
  }
 }
 __stack_pointer = $4 + 128 | 0;
 return 1;
}

function lcdMemLCD_flip($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 336 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 332 >> 2] = $0;
 $0 = HEAP32[$1 + 332 >> 2];
 $2 = HEAP32[$1 + 332 >> 2];
 if ((HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16 <= (HEAPU8[$2 + 46 | 0] | HEAPU8[$2 + 47 | 0] << 8) << 16 >> 16) {
  HEAP8[366872] = 1;
  lcdMemLCD_waitForSendComplete();
  $0 = HEAP32[$1 + 332 >> 2];
  HEAP32[$1 + 328 >> 2] = (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16;
  $0 = HEAP32[$1 + 332 >> 2];
  HEAP32[$1 + 324 >> 2] = (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16;
  HEAP32[$1 + 320 >> 2] = (HEAP32[$1 + 324 >> 2] + 1 | 0) - HEAP32[$1 + 328 >> 2];
  HEAP8[$1 + 319 | 0] = 0;
  if (HEAP32[97739]) {
   HEAP8[$1 + 319 | 0] = _jswrap_graphics_parseImage(HEAP32[$1 + 332 >> 2], HEAP32[97739], 0, $1 + 232 | 0) & 1;
  }
  jshPinSetValue(5, 1);
  label$3: {
   if (HEAP8[$1 + 319 | 0] & 1) {
    HEAP8[$1 + 231 | 0] = ((HEAPU8[366808] | HEAPU8[366809] << 8 | (HEAPU8[366810] << 16 | HEAPU8[366811] << 24)) & 112) == 96;
    if (HEAP8[$1 + 231 | 0] & 1) {
     $0 = 176 - (HEAP16[195480] + HEAP32[$1 + 236 >> 2] | 0) | 0;
    } else {
     $0 = HEAP16[195480];
    }
    HEAP32[$1 + 224 >> 2] = $0;
    $0 = HEAP32[$1 + 332 >> 2];
    HEAP32[$1 + 220 >> 2] = HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24);
    $0 = HEAP32[$1 + 332 >> 2];
    HEAP32[$1 + 216 >> 2] = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
    $0 = HEAP32[$1 + 332 >> 2];
    $2 = HEAPU8[366785] | HEAPU8[366786] << 8;
    HEAP8[$0 + 17 | 0] = $2;
    HEAP8[$0 + 18 | 0] = $2 >>> 8;
    HEAP8[$0 + 19 | 0] = $2 >>> 16;
    HEAP8[$0 + 20 | 0] = $2 >>> 24;
    $0 = HEAP32[$1 + 332 >> 2];
    $2 = HEAPU8[366787] | HEAPU8[366788] << 8;
    HEAP8[$0 + 21 | 0] = $2;
    HEAP8[$0 + 22 | 0] = $2 >>> 8;
    HEAP8[$0 + 23 | 0] = $2 >>> 16;
    HEAP8[$0 + 24 | 0] = $2 >>> 24;
    HEAP32[$1 + 24 >> 2] = 0;
    HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 224 >> 2] << 8;
    __memcpy($1 + 60 | 0, $1 + 232 | 0, 84);
    HEAPF64[$1 + 40 >> 3] = HEAP8[$1 + 231 | 0] & 1 ? 3.141592 : 0;
    HEAPF64[$1 + 48 >> 3] = 1;
    HEAP8[$1 + 56 | 0] = 0;
    HEAP8[$1 + 57 | 0] = 0;
    jsvStringIteratorNew($1 + 144 | 0, HEAP32[$1 + 80 >> 2], HEAP32[$1 + 84 >> 2]);
    _jswrap_drawImageLayerInit($1 + 24 | 0);
    _jswrap_drawImageLayerSetStart($1 + 24 | 0, 0, HEAP32[$1 + 328 >> 2]);
    HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 328 >> 2];
    while (1) {
     if (HEAP32[$1 + 20 >> 2] <= HEAP32[$1 + 324 >> 2]) {
      HEAP32[$1 + 16 >> 2] = (HEAP32[$1 + 20 >> 2] & 1) + 176;
      HEAP32[$1 + 12 >> 2] = Math_imul(HEAP32[$1 + 16 >> 2], 68) + 378848;
      __memcpy(HEAP32[$1 + 12 >> 2], Math_imul(HEAP32[$1 + 20 >> 2], 68) + 378848 | 0, 68);
      if (!(HEAP32[$1 + 20 >> 2] < HEAP32[$1 + 224 >> 2] | HEAP32[$1 + 20 >> 2] >= (HEAP32[$1 + 224 >> 2] + HEAP32[$1 + 236 >> 2] | 0))) {
       _jswrap_drawImageLayerStartX($1 + 24 | 0);
       HEAP32[$1 + 8 >> 2] = 0;
       while (1) {
        if (HEAP32[$1 + 8 >> 2] < HEAP32[$1 + 232 >> 2]) {
         HEAP32[$1 >> 2] = HEAP32[$1 + 8 >> 2] + HEAP16[195481];
         if (!(!(_jswrap_drawImageLayerGetPixel($1 + 24 | 0, $1 + 4 | 0) & 1) | HEAP32[$1 >> 2] >= 176 | HEAP32[$1 >> 2] < 0)) {
          lcdMemLCD_setPixel(0, HEAP32[$1 >> 2], HEAP32[$1 + 16 >> 2], HEAP32[$1 + 4 >> 2]);
         }
         _jswrap_drawImageLayerNextX($1 + 24 | 0);
         HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
         continue;
        }
        break;
       }
      }
      _jswrap_drawImageLayerNextY($1 + 24 | 0);
      __memcpy(Math_imul(HEAP32[$1 + 20 >> 2], 68) + 366880 | 0, HEAP32[$1 + 12 >> 2], 68);
      HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 20 >> 2] + 1;
      continue;
     }
     break;
    }
    jsvStringIteratorFree_6($1 + 144 | 0);
    _jswrap_graphics_freeImageInfo($1 + 232 | 0);
    $0 = HEAP32[$1 + 332 >> 2];
    $2 = HEAP32[$1 + 220 >> 2];
    HEAP8[$0 + 17 | 0] = $2;
    HEAP8[$0 + 18 | 0] = $2 >>> 8;
    HEAP8[$0 + 19 | 0] = $2 >>> 16;
    HEAP8[$0 + 20 | 0] = $2 >>> 24;
    $0 = HEAP32[$1 + 332 >> 2];
    $2 = HEAP32[$1 + 216 >> 2];
    HEAP8[$0 + 21 | 0] = $2;
    HEAP8[$0 + 22 | 0] = $2 >>> 8;
    HEAP8[$0 + 23 | 0] = $2 >>> 16;
    HEAP8[$0 + 24 | 0] = $2 >>> 24;
    break label$3;
   }
   __memcpy(366880, 378848, 11968);
  }
  $0 = HEAP32[$1 + 332 >> 2];
  HEAP8[$0 + 44 | 0] = 0;
  HEAP8[$0 + 45 | 0] = 128;
  $0 = HEAP32[$1 + 332 >> 2];
  HEAP8[$0 + 46 | 0] = 0;
  HEAP8[$0 + 47 | 0] = 128;
  $0 = HEAP32[$1 + 332 >> 2];
  HEAP8[$0 + 40 | 0] = 255;
  HEAP8[$0 + 41 | 0] = 127;
  $0 = HEAP32[$1 + 332 >> 2];
  HEAP8[$0 + 42 | 0] = 255;
  HEAP8[$0 + 43 | 0] = 127;
 }
 __stack_pointer = $1 + 336 | 0;
}

function lcdSetPixels_ArrayBuffer($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 128 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 124 >> 2] = $0;
 HEAP32[$5 + 120 >> 2] = $1;
 HEAP32[$5 + 116 >> 2] = $2;
 HEAP32[$5 + 112 >> 2] = $3;
 HEAP32[$5 + 108 >> 2] = $4;
 $0 = HEAP32[$5 + 124 >> 2];
 HEAP32[$5 + 104 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
 HEAP32[$5 + 100 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$5 + 124 >> 2], HEAP32[$5 + 120 >> 2], HEAP32[$5 + 116 >> 2], HEAP32[$5 + 112 >> 2]);
 jsvArrayBufferIteratorNew($5 + 40 | 0, HEAP32[$5 + 104 >> 2], HEAP32[$5 + 100 >> 2] >>> 3 | 0);
 HEAP32[$5 + 36 >> 2] = (1 << HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0]) - 1;
 label$1: {
  if (HEAP32[$5 + 108 >> 2]) {
   $0 = 0;
   if (HEAP32[$5 + 36 >> 2] != (HEAP32[$5 + 108 >> 2] & HEAP32[$5 + 36 >> 2])) {
    break label$1;
   }
  }
  $0 = HEAP32[$5 + 124 >> 2];
  $0 = ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 2) != 0 ^ -1;
 }
 HEAP8[$5 + 35 | 0] = $0 & 1;
 HEAP32[$5 + 28 >> 2] = HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0];
 $0 = HEAP32[$5 + 124 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 8) {
  HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 28 >> 2] << 1;
  HEAP8[$5 + 35 | 0] = 0;
 }
 while (1) {
  label$5: {
   $0 = HEAP32[$5 + 112 >> 2];
   HEAP32[$5 + 112 >> 2] = $0 - 1;
   if (!$0) {
    break label$5;
   }
   label$6: {
    if (HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0] & 7) {
     HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 100 >> 2] & 7;
     if (!(HEAP32[$5 + 100 >> 2] | !(HEAP8[$5 + 35 | 0] & 1))) {
      HEAP32[$5 + 24 >> 2] = Math_imul(HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0], HEAP32[$5 + 112 >> 2] + 1 | 0) >> 3;
      if (HEAP32[$5 + 24 >> 2]) {
       HEAP8[$5 + 23 | 0] = HEAP32[$5 + 108 >> 2] ? 255 : 0;
       HEAP32[$5 + 112 >> 2] = (HEAP32[$5 + 112 >> 2] + 1 | 0) - ((HEAP32[$5 + 24 >> 2] << 3) / HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0] | 0);
       while (1) {
        $0 = HEAP32[$5 + 24 >> 2];
        HEAP32[$5 + 24 >> 2] = $0 - 1;
        if ($0) {
         jsvArrayBufferIteratorSetByteValue($5 + 40 | 0, HEAP8[$5 + 23 | 0]);
         jsvArrayBufferIteratorNext($5 + 40 | 0);
         continue;
        }
        break;
       }
       continue;
      }
     }
     HEAP32[$5 + 16 >> 2] = (1 << HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0]) - 1;
     HEAP32[$5 + 12 >> 2] = jsvArrayBufferIteratorGetIntegerValue($5 + 40 | 0);
     $0 = HEAP32[$5 + 124 >> 2];
     if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
      $0 = 8 - (HEAP32[$5 + 100 >> 2] + HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0] | 0) | 0;
     } else {
      $0 = HEAP32[$5 + 100 >> 2];
     }
     HEAP32[$5 + 8 >> 2] = $0;
     jsvArrayBufferIteratorSetByteValue($5 + 40 | 0, (HEAP32[$5 + 12 >> 2] & (HEAP32[$5 + 16 >> 2] << HEAP32[$5 + 8 >> 2] ^ -1) | (HEAP32[$5 + 108 >> 2] & HEAP32[$5 + 16 >> 2]) << HEAP32[$5 + 8 >> 2]) << 24 >> 24);
     $0 = HEAP32[$5 + 124 >> 2];
     label$14: {
      if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 2) {
       jsvArrayBufferIteratorNext($5 + 40 | 0);
       break label$14;
      }
      HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 28 >> 2] + HEAP32[$5 + 100 >> 2];
      if (HEAPU32[$5 + 100 >> 2] >= 8) {
       jsvArrayBufferIteratorNext($5 + 40 | 0);
      }
     }
     break label$6;
    }
    $0 = HEAP32[$5 + 124 >> 2];
    label$17: {
     if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
      HEAP32[$5 + 4 >> 2] = HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0] - 8;
      while (1) {
       if (HEAP32[$5 + 4 >> 2] >= 0) {
        jsvArrayBufferIteratorSetByteValue($5 + 40 | 0, HEAP32[$5 + 108 >> 2] >>> HEAP32[$5 + 4 >> 2] << 24 >> 24);
        jsvArrayBufferIteratorNext($5 + 40 | 0);
        HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] - 8;
        continue;
       }
       break;
      }
      break label$17;
     }
     HEAP32[$5 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 >> 2] < HEAPU8[HEAP32[$5 + 124 >> 2] + 16 | 0]) {
       jsvArrayBufferIteratorSetByteValue($5 + 40 | 0, HEAP32[$5 + 108 >> 2] >>> HEAP32[$5 >> 2] << 24 >> 24);
       jsvArrayBufferIteratorNext($5 + 40 | 0);
       HEAP32[$5 >> 2] = HEAP32[$5 >> 2] + 8;
       continue;
      }
      break;
     }
    }
   }
   continue;
  }
  break;
 }
 jsvArrayBufferIteratorFree($5 + 40 | 0);
 __stack_pointer = $5 + 128 | 0;
}

function tflite__ops__micro__quantize__Prepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 160 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 152 >> 2] = $0;
 HEAP32[$2 + 148 >> 2] = $1;
 label$1: {
  if (!HEAP32[HEAP32[$2 + 148 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 144 >> 2] = HEAP32[HEAP32[$2 + 148 >> 2] + 8 >> 2];
 label$2: {
  if ((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 148 >> 2]) | 0) != 1) {
   $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 152 >> 2];
   $3 = tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 148 >> 2]);
   HEAP32[$2 + 12 >> 2] = 1;
   HEAP32[$2 + 8 >> 2] = $3;
   HEAP32[$2 + 4 >> 2] = 139997;
   HEAP32[$2 >> 2] = 143050;
   FUNCTION_TABLE[$0 | 0]($1, 143305, $2);
   HEAP32[$2 + 156 >> 2] = 1;
   break label$2;
  }
  if ((tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 148 >> 2]) | 0) != 1) {
   $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 152 >> 2];
   $3 = tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 148 >> 2]);
   HEAP32[$2 + 28 >> 2] = 1;
   HEAP32[$2 + 24 >> 2] = $3;
   HEAP32[$2 + 20 >> 2] = 139997;
   HEAP32[$2 + 16 >> 2] = 143033;
   FUNCTION_TABLE[$0 | 0]($1, 143305, $2 + 16 | 0);
   HEAP32[$2 + 156 >> 2] = 1;
   break label$2;
  }
  HEAP32[$2 + 140 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 152 >> 2], HEAP32[$2 + 148 >> 2], 0);
  HEAP32[$2 + 136 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 152 >> 2], HEAP32[$2 + 148 >> 2], 0);
  if (HEAP32[HEAP32[$2 + 136 >> 2] >> 2] != 1) {
   $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 152 >> 2];
   $3 = HEAP32[HEAP32[$2 + 136 >> 2] >> 2];
   HEAP32[$2 + 44 >> 2] = 1;
   HEAP32[$2 + 40 >> 2] = $3;
   HEAP32[$2 + 36 >> 2] = 128383;
   HEAP32[$2 + 32 >> 2] = 132253;
   FUNCTION_TABLE[$0 | 0]($1, 143305, $2 + 32 | 0);
   HEAP32[$2 + 156 >> 2] = 1;
   break label$2;
  }
  HEAP32[$2 + 132 >> 2] = HEAP32[HEAP32[$2 + 136 >> 2] + 4 >> 2];
  if (!HEAP32[$2 + 132 >> 2]) {
   $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 152 >> 2];
   HEAP32[$2 + 112 >> 2] = 128363;
   FUNCTION_TABLE[$0 | 0]($1, 140586, $2 + 112 | 0);
   HEAP32[$2 + 156 >> 2] = 1;
   break label$2;
  }
  if (!HEAP32[HEAP32[$2 + 132 >> 2] >> 2]) {
   $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 152 >> 2];
   HEAP32[$2 + 96 >> 2] = 132598;
   FUNCTION_TABLE[$0 | 0]($1, 140586, $2 + 96 | 0);
   HEAP32[$2 + 156 >> 2] = 1;
   break label$2;
  }
  if (HEAP32[HEAP32[HEAP32[$2 + 132 >> 2] >> 2] >> 2] != 1) {
   $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 152 >> 2];
   HEAP32[$2 + 80 >> 2] = 139961;
   FUNCTION_TABLE[$0 | 0]($1, 140586, $2 + 80 | 0);
   HEAP32[$2 + 156 >> 2] = 1;
   break label$2;
  }
  if (!(HEAP32[HEAP32[$2 + 140 >> 2] + 28 >> 2] == 1 | HEAP32[HEAP32[$2 + 140 >> 2] + 28 >> 2] == 7 | HEAP32[HEAP32[$2 + 140 >> 2] + 28 >> 2] == 9)) {
   $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 152 >> 2];
   HEAP32[$2 + 64 >> 2] = 139041;
   FUNCTION_TABLE[$0 | 0]($1, 140586, $2 - -64 | 0);
   HEAP32[$2 + 156 >> 2] = 1;
   break label$2;
  }
  if (!(HEAP32[HEAP32[$2 + 136 >> 2] + 28 >> 2] == 3 | HEAP32[HEAP32[$2 + 136 >> 2] + 28 >> 2] == 9 | HEAP32[HEAP32[$2 + 136 >> 2] + 28 >> 2] == 7)) {
   $0 = HEAP32[HEAP32[$2 + 152 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 152 >> 2];
   HEAP32[$2 + 48 >> 2] = 139218;
   FUNCTION_TABLE[$0 | 0]($1, 140586, $2 + 48 | 0);
   HEAP32[$2 + 156 >> 2] = 1;
   break label$2;
  }
  label$11: {
   if (!(!(HEAP32[HEAP32[$2 + 140 >> 2] + 28 >> 2] != 7 & HEAP32[HEAP32[$2 + 140 >> 2] + 28 >> 2] != 9) & HEAP32[HEAP32[$2 + 136 >> 2] + 28 >> 2] == 9)) {
    if (HEAP32[HEAP32[$2 + 140 >> 2] + 28 >> 2] != 7 | HEAP32[HEAP32[$2 + 136 >> 2] + 28 >> 2] != 7) {
     break label$11;
    }
   }
   HEAPF64[$2 + 120 >> 3] = Math_fround(HEAPF32[HEAP32[$2 + 140 >> 2] + 8 >> 2] / HEAPF32[HEAP32[$2 + 136 >> 2] + 8 >> 2]);
   tflite__QuantizeMultiplier_28double_2c_20int__2c_20int__29(HEAPF64[$2 + 120 >> 3], HEAP32[$2 + 144 >> 2] + 16 | 0, HEAP32[$2 + 144 >> 2] + 20 | 0);
  }
  HEAP32[HEAP32[$2 + 144 >> 2] >> 2] = HEAP32[HEAP32[$2 + 136 >> 2] + 12 >> 2];
  HEAPF64[HEAP32[$2 + 144 >> 2] + 8 >> 3] = HEAPF32[HEAP32[$2 + 136 >> 2] + 8 >> 2];
  HEAP32[HEAP32[$2 + 144 >> 2] + 24 >> 2] = HEAP32[HEAP32[$2 + 140 >> 2] + 12 >> 2];
  HEAP32[$2 + 156 >> 2] = 0;
 }
 __stack_pointer = $2 + 160 | 0;
 return HEAP32[$2 + 156 >> 2];
}

function jspeFactorObject() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 112 | 0;
 __stack_pointer = $0;
 label$1: {
  if ((HEAP32[91094] & 63) == 1) {
   HEAP32[$0 + 104 >> 2] = jsvNewObject();
   if (!HEAP32[$0 + 104 >> 2]) {
    jspSetError(0);
    HEAP32[$0 + 108 >> 2] = 0;
    break label$1;
   }
   if (!(jslMatch(123) & 1)) {
    HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 104 >> 2];
    break label$1;
   }
   while (1) {
    $1 = 0;
    $1 = HEAP32[91094] & 80 ? $1 : HEAP16[HEAP32[49079] + 2 >> 1] != 125;
    if ($1) {
     HEAP32[$0 + 100 >> 2] = 0;
     HEAP8[$0 + 99 | 0] = 0;
     label$8: {
      if (jslIsIDOrReservedWord() & 1) {
       HEAP8[$0 + 99 | 0] = HEAP16[HEAP32[49079] + 2 >> 1] == 128;
       if ((HEAP32[91094] & 63) == 1) {
        HEAP32[$0 + 100 >> 2] = jslGetTokenValueAsVar();
       }
       jslGetNextToken();
       break label$8;
      }
      label$11: {
       if (!(!(HEAP16[HEAP32[49079] + 2 >> 1] == 131 | HEAP16[HEAP32[49079] + 2 >> 1] == 130) & HEAP16[HEAP32[49079] + 2 >> 1] != 129)) {
        HEAP32[$0 + 100 >> 2] = jspeFactor();
        break label$11;
       }
       if (!(jslMatch(128) & 1)) {
        HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 104 >> 2];
        break label$1;
       }
      }
     }
     label$15: {
      label$16: {
       if (HEAP16[HEAP32[49079] + 2 >> 1] != 128) {
        break label$16;
       }
       if (!(jsvIsString(HEAP32[$0 + 100 >> 2]) & 1)) {
        break label$16;
       }
       HEAP8[$0 + 98 | 0] = jsvIsStringEqual(HEAP32[$0 + 100 >> 2], 117892) & 1;
       HEAP8[$0 + 97 | 0] = jsvIsStringEqual(HEAP32[$0 + 100 >> 2], 117878) & 1;
       if (HEAP8[$0 + 97 | 0] & 1 ? 1 : HEAP8[$0 + 98 | 0] & 1) {
        jsvUnLock(HEAP32[$0 + 100 >> 2]);
        HEAP32[$0 + 100 >> 2] = jslGetTokenValueAsVar();
        jslGetNextToken();
        HEAP32[$0 + 92 >> 2] = jspeFunctionDefinition(0);
        jsvAddGetterOrSetter(HEAP32[$0 + 104 >> 2], HEAP32[$0 + 100 >> 2], HEAP8[$0 + 98 | 0] & 1, HEAP32[$0 + 92 >> 2]);
        jsvUnLock(HEAP32[$0 + 92 >> 2]);
       }
       break label$15;
      }
      label$19: {
       if (HEAP16[HEAP32[49079] + 2 >> 1] == 40) {
        HEAP32[$0 + 88 >> 2] = jsvFindChildFromVar(HEAP32[$0 + 104 >> 2], HEAP32[$0 + 100 >> 2], 1);
        if (HEAP32[$0 + 88 >> 2]) {
         HEAP32[$0 + 84 >> 2] = jspeFunctionDefinition(0);
         jsvUnLock2(jsvSetValueOfName(HEAP32[$0 + 88 >> 2], HEAP32[$0 + 84 >> 2]), HEAP32[$0 + 84 >> 2]);
        }
        break label$19;
       }
       label$22: {
        label$23: {
         if (!(HEAP8[$0 + 99 | 0] & 1) | HEAP16[HEAP32[49079] + 2 >> 1] != 44 & HEAP16[HEAP32[49079] + 2 >> 1] != 125) {
          break label$23;
         }
         if (!(jsvIsString(HEAP32[$0 + 100 >> 2]) & 1)) {
          break label$23;
         }
         if ((HEAP32[91094] & 63) == 1) {
          HEAP32[$0 + 100 >> 2] = jsvAsArrayIndexAndUnLock(HEAP32[$0 + 100 >> 2]);
          HEAP32[$0 + 80 >> 2] = jsvFindChildFromVar(HEAP32[$0 + 104 >> 2], HEAP32[$0 + 100 >> 2], 1);
          if (HEAP32[$0 + 80 >> 2]) {
           jsvGetString(HEAP32[$0 + 100 >> 2], $0 + 16 | 0, 64);
           HEAP32[$0 + 12 >> 2] = jsvSkipNameAndUnLock(jspGetNamedVariable($0 + 16 | 0));
           jsvUnLock2(jsvSetValueOfName(HEAP32[$0 + 80 >> 2], HEAP32[$0 + 12 >> 2]), HEAP32[$0 + 12 >> 2]);
          }
         }
         break label$22;
        }
        if (!(jslMatch(58) & 1)) {
         jsvUnLock(HEAP32[$0 + 100 >> 2]);
         HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 104 >> 2];
         break label$1;
        }
        if ((HEAP32[91094] & 63) == 1) {
         HEAP32[$0 + 100 >> 2] = jsvAsArrayIndexAndUnLock(HEAP32[$0 + 100 >> 2]);
         HEAP32[$0 + 8 >> 2] = jsvFindChildFromVar(HEAP32[$0 + 104 >> 2], HEAP32[$0 + 100 >> 2], 1);
         if (HEAP32[$0 + 8 >> 2]) {
          HEAP32[$0 + 4 >> 2] = jsvSkipNameAndUnLock(jspeAssignmentExpression());
          jsvUnLock2(jsvSetValueOfName(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2]), HEAP32[$0 + 4 >> 2]);
         }
        }
       }
      }
     }
     jsvUnLock(HEAP32[$0 + 100 >> 2]);
     if (HEAP16[HEAP32[49079] + 2 >> 1] != 125) {
      if (!(jslMatch(44) & 1)) {
       HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 104 >> 2];
       break label$1;
      }
     }
     continue;
    }
    break;
   }
   if (!(jslMatch(125) & 1)) {
    HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 104 >> 2];
    break label$1;
   }
   HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 104 >> 2];
   break label$1;
  }
  jspeBlock();
  HEAP32[$0 + 108 >> 2] = 0;
 }
 __stack_pointer = $0 + 112 | 0;
 return HEAP32[$0 + 108 >> 2];
}

function tflite__ParseDepthwiseConv2D_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 tflite___28anonymous_20namespace_29__CheckParsePointerParams_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29(HEAP32[$4 + 40 >> 2], HEAP32[$4 + 36 >> 2], HEAP32[$4 + 32 >> 2], HEAP32[$4 + 28 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($4 + 24 | 0, HEAP32[$4 + 32 >> 2]);
 std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteDepthwiseConvParams__28_29($4 + 16 | 0, $4 + 24 | 0);
 label$1: {
  if (!(bool_20std____2__operator___TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($4 + 16 | 0, 0) & 1)) {
   $0 = HEAP32[$4 + 36 >> 2];
   $1 = HEAP32[$4 + 36 >> 2];
   HEAP32[$4 >> 2] = 120702;
   tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($0, $1, 140586, $4);
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 8 >> 2] = tflite__Operator__builtin_options_as_DepthwiseConv2DOptions_28_29_20const(HEAP32[$4 + 40 >> 2]);
  if (HEAP32[$4 + 8 >> 2]) {
   $0 = tflite___28anonymous_20namespace_29__ConvertPadding_28tflite__Padding_29(tflite__DepthwiseConv2DOptions__padding_28_29_20const(HEAP32[$4 + 8 >> 2]));
   HEAP32[std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) >> 2] = $0;
   $0 = tflite__DepthwiseConv2DOptions__stride_w_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 4 >> 2] = $0;
   $0 = tflite__DepthwiseConv2DOptions__stride_h_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 8 >> 2] = $0;
   $0 = tflite__DepthwiseConv2DOptions__depth_multiplier_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 12 >> 2] = $0;
   $0 = tflite___28anonymous_20namespace_29__ConvertActivation_28tflite__ActivationFunctionType_29(tflite__DepthwiseConv2DOptions__fused_activation_function_28_29_20const(HEAP32[$4 + 8 >> 2]));
   HEAP32[std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 16 >> 2] = $0;
   $0 = tflite__DepthwiseConv2DOptions__dilation_w_factor_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 20 >> 2] = $0;
   $0 = tflite__DepthwiseConv2DOptions__dilation_h_factor_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 24 >> 2] = $0;
  }
  $0 = std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($4 + 16 | 0);
  HEAP32[HEAP32[$4 + 28 >> 2] >> 2] = $0;
  HEAP32[$4 + 44 >> 2] = 0;
 }
 HEAP32[$4 + 12 >> 2] = 1;
 std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($4 + 16 | 0);
 __stack_pointer = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}

function lcdSetPixels_ArrayBuffer_flat($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 80 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 76 >> 2] = $0;
 HEAP32[$5 + 72 >> 2] = $1;
 HEAP32[$5 + 68 >> 2] = $2;
 HEAP32[$5 + 64 >> 2] = $3;
 HEAP32[$5 + 60 >> 2] = $4;
 $0 = HEAP32[$5 + 76 >> 2];
 HEAP32[$5 + 56 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
 HEAP32[$5 + 52 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$5 + 76 >> 2], HEAP32[$5 + 72 >> 2], HEAP32[$5 + 68 >> 2], HEAP32[$5 + 64 >> 2]);
 HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 56 >> 2] + (HEAP32[$5 + 52 >> 2] >>> 3 | 0);
 HEAP32[$5 + 48 >> 2] = (1 << HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0]) - 1;
 label$1: {
  if (HEAP32[$5 + 60 >> 2]) {
   $0 = 0;
   if (HEAP32[$5 + 48 >> 2] != (HEAP32[$5 + 60 >> 2] & HEAP32[$5 + 48 >> 2])) {
    break label$1;
   }
  }
  $0 = HEAP32[$5 + 76 >> 2];
  $0 = ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 2) != 0 ^ -1;
 }
 HEAP8[$5 + 47 | 0] = $0 & 1;
 HEAP32[$5 + 40 >> 2] = HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0];
 $0 = HEAP32[$5 + 76 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 8) {
  HEAP32[$5 + 40 >> 2] = HEAP32[$5 + 40 >> 2] << 1;
  HEAP8[$5 + 47 | 0] = 0;
 }
 while (1) {
  label$5: {
   $0 = HEAP32[$5 + 64 >> 2];
   HEAP32[$5 + 64 >> 2] = $0 - 1;
   if (!$0) {
    break label$5;
   }
   label$6: {
    if (HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0] & 7) {
     HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 52 >> 2] & 7;
     if (!(HEAP32[$5 + 52 >> 2] | !(HEAP8[$5 + 47 | 0] & 1))) {
      HEAP32[$5 + 36 >> 2] = Math_imul(HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0], HEAP32[$5 + 64 >> 2] + 1 | 0) >> 3;
      if (HEAP32[$5 + 36 >> 2]) {
       HEAP8[$5 + 35 | 0] = HEAP32[$5 + 60 >> 2] ? 255 : 0;
       HEAP32[$5 + 64 >> 2] = (HEAP32[$5 + 64 >> 2] + 1 | 0) - ((HEAP32[$5 + 36 >> 2] << 3) / HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0] | 0);
       while (1) {
        $0 = HEAP32[$5 + 36 >> 2];
        HEAP32[$5 + 36 >> 2] = $0 - 1;
        if ($0) {
         HEAP8[HEAP32[$5 + 56 >> 2]] = HEAPU8[$5 + 35 | 0];
         HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 56 >> 2] + 1;
         continue;
        }
        break;
       }
       continue;
      }
     }
     HEAP32[$5 + 28 >> 2] = (1 << HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0]) - 1;
     HEAP32[$5 + 24 >> 2] = HEAPU8[HEAP32[$5 + 56 >> 2]];
     $0 = HEAP32[$5 + 76 >> 2];
     if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
      $0 = 8 - (HEAP32[$5 + 52 >> 2] + HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0] | 0) | 0;
     } else {
      $0 = HEAP32[$5 + 52 >> 2];
     }
     HEAP32[$5 + 20 >> 2] = $0;
     HEAP8[HEAP32[$5 + 56 >> 2]] = HEAP32[$5 + 24 >> 2] & (HEAP32[$5 + 28 >> 2] << HEAP32[$5 + 20 >> 2] ^ -1) | (HEAP32[$5 + 60 >> 2] & HEAP32[$5 + 28 >> 2]) << HEAP32[$5 + 20 >> 2];
     $0 = HEAP32[$5 + 76 >> 2];
     label$14: {
      if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 2) {
       HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 56 >> 2] + 1;
       break label$14;
      }
      HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 40 >> 2] + HEAP32[$5 + 52 >> 2];
      if (HEAPU32[$5 + 52 >> 2] >= 8) {
       HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 56 >> 2] + 1;
      }
     }
     break label$6;
    }
    $0 = HEAP32[$5 + 76 >> 2];
    label$17: {
     if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
      HEAP32[$5 + 16 >> 2] = HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0] - 8;
      while (1) {
       if (HEAP32[$5 + 16 >> 2] >= 0) {
        $1 = HEAP32[$5 + 60 >> 2];
        $2 = HEAP32[$5 + 16 >> 2];
        $0 = HEAP32[$5 + 56 >> 2];
        HEAP32[$5 + 56 >> 2] = $0 + 1;
        HEAP8[$0 | 0] = $1 >>> $2;
        HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] - 8;
        continue;
       }
       break;
      }
      break label$17;
     }
     HEAP32[$5 + 12 >> 2] = 0;
     while (1) {
      if (HEAP32[$5 + 12 >> 2] < HEAPU8[HEAP32[$5 + 76 >> 2] + 16 | 0]) {
       $1 = HEAP32[$5 + 60 >> 2];
       $2 = HEAP32[$5 + 12 >> 2];
       $0 = HEAP32[$5 + 56 >> 2];
       HEAP32[$5 + 56 >> 2] = $0 + 1;
       HEAP8[$0 | 0] = $1 >>> $2;
       HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 8;
       continue;
      }
      break;
     }
    }
   }
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 80 | 0;
}

function jswFindBuiltInFunction($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1: {
  label$2: {
   label$3: {
    if (!HEAP32[$2 + 40 >> 2]) {
     break label$3;
    }
    if (jsvIsRoot(HEAP32[$2 + 40 >> 2]) & 1) {
     break label$3;
    }
    if (jsvIsNativeFunction(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 28 >> 2] = jswGetSymbolListForObject(HEAP32[$2 + 40 >> 2]);
     if (HEAP32[$2 + 28 >> 2]) {
      HEAP32[$2 + 32 >> 2] = jswBinarySearch(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
      if (HEAP32[$2 + 32 >> 2]) {
       HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
       break label$1;
      }
     }
    }
    if (jsvIsPin(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 32 >> 2] = jswBinarySearch(159049, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
     if (HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
      break label$1;
     }
    }
    if (jsvIsArray(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 32 >> 2] = jswBinarySearch(159112, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
     if (HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
      break label$1;
     }
    }
    if (!(!(jsvIsArrayBuffer(HEAP32[$2 + 40 >> 2]) & 1) | HEAPU8[HEAP32[$2 + 40 >> 2] + 5 | 0] != 129)) {
     HEAP32[$2 + 32 >> 2] = jswBinarySearch(159130, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
     if (HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
      break label$1;
     }
    }
    if (!(!(jsvIsArrayBuffer(HEAP32[$2 + 40 >> 2]) & 1) | HEAPU8[HEAP32[$2 + 40 >> 2] + 5 | 0] == 129)) {
     HEAP32[$2 + 32 >> 2] = jswBinarySearch(159139, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
     if (HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
      break label$1;
     }
    }
    if (jsvIsNumeric(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 32 >> 2] = jswBinarySearch(159247, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
     if (HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
      break label$1;
     }
    }
    if (jsvIsFunction(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 32 >> 2] = jswBinarySearch(159274, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
     if (HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
      break label$1;
     }
    }
    if (jsvIsString(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 32 >> 2] = jswBinarySearch(159292, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
     if (HEAP32[$2 + 32 >> 2]) {
      HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
      break label$1;
     }
    }
    label$21: {
     if (jsvIsObject(HEAP32[$2 + 40 >> 2]) & 1) {
      $0 = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAP32[$2 + 40 >> 2], 135865));
      break label$21;
     }
     $0 = 0;
    }
    HEAP32[$2 + 24 >> 2] = $0;
    label$23: {
     if (jsvIsObject(HEAP32[$2 + 24 >> 2]) & 1) {
      $0 = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAP32[$2 + 24 >> 2], 120855));
      break label$23;
     }
     $0 = 0;
    }
    HEAP32[$2 + 20 >> 2] = $0;
    jsvUnLock(HEAP32[$2 + 24 >> 2]);
    label$25: {
     label$26: {
      if (!HEAP32[$2 + 20 >> 2]) {
       break label$26;
      }
      if (!(jsvIsNativeFunction(HEAP32[$2 + 20 >> 2]) & 1)) {
       break label$26;
      }
      HEAP32[$2 + 16 >> 2] = jswGetSymbolListForConstructorProto(HEAP32[$2 + 20 >> 2]);
      jsvUnLock(HEAP32[$2 + 20 >> 2]);
      if (HEAP32[$2 + 16 >> 2]) {
       HEAP32[$2 + 32 >> 2] = jswBinarySearch(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
       if (HEAP32[$2 + 32 >> 2]) {
        HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
        break label$1;
       }
      }
      break label$25;
     }
     jsvUnLock(HEAP32[$2 + 20 >> 2]);
    }
    HEAP32[$2 + 32 >> 2] = jswBinarySearch(159256, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
    if (HEAP32[$2 + 32 >> 2]) {
     HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
     break label$1;
    }
    break label$2;
   }
   HEAP8[$2 + 15 | 0] = jshGetPinFromString(HEAP32[$2 + 36 >> 2]);
   if (HEAPU8[$2 + 15 | 0] != 255) {
    HEAP32[$2 + 44 >> 2] = jsvNewFromPin(HEAPU8[$2 + 15 | 0]);
    break label$1;
   }
   HEAP32[$2 + 44 >> 2] = jswBinarySearch(159058, HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
   break label$1;
  }
  HEAP32[$2 + 44 >> 2] = 0;
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function _jswrap_graphics_fillRect_col($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 176 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 168 >> 2] = $0;
 HEAP32[$6 + 164 >> 2] = $1;
 HEAP32[$6 + 160 >> 2] = $2;
 HEAP32[$6 + 156 >> 2] = $3;
 HEAP32[$6 + 152 >> 2] = $4;
 HEAP8[$6 + 151 | 0] = $5;
 _jswrap_graphics_getRect(HEAP32[$6 + 164 >> 2], $6 + 144 | 0, $6 + 160 | 0, $6 + 156 | 0, $6 + 152 | 0, $6 + 140 | 0);
 label$1: {
  if (!(graphicsGetFromVar($6 - -64 | 0, HEAP32[$6 + 168 >> 2]) & 1)) {
   HEAP32[$6 + 172 >> 2] = 0;
   break label$1;
  }
  if (HEAP8[$6 + 151 | 0] & 1) {
   $0 = HEAPU8[$6 + 81 | 0] | HEAPU8[$6 + 82 | 0] << 8 | (HEAPU8[$6 + 83 | 0] << 16 | HEAPU8[$6 + 84 | 0] << 24);
  } else {
   $0 = HEAPU8[$6 + 85 | 0] | HEAPU8[$6 + 86 | 0] << 8 | (HEAPU8[$6 + 87 | 0] << 16 | HEAPU8[$6 + 88 | 0] << 24);
  }
  HEAP32[$6 + 60 >> 2] = $0;
  label$5: {
   if (HEAP32[$6 + 140 >> 2] > 0) {
    graphicsToDeviceCoordinates($6 - -64 | 0, $6 + 144 | 0, $6 + 160 | 0);
    graphicsToDeviceCoordinates($6 - -64 | 0, $6 + 156 | 0, $6 + 152 | 0);
    if (HEAP32[$6 + 144 >> 2] > HEAP32[$6 + 156 >> 2]) {
     HEAP32[$6 + 56 >> 2] = HEAP32[$6 + 144 >> 2];
     HEAP32[$6 + 144 >> 2] = HEAP32[$6 + 156 >> 2];
     HEAP32[$6 + 156 >> 2] = HEAP32[$6 + 56 >> 2];
    }
    if (HEAP32[$6 + 160 >> 2] > HEAP32[$6 + 152 >> 2]) {
     HEAP32[$6 + 52 >> 2] = HEAP32[$6 + 160 >> 2];
     HEAP32[$6 + 160 >> 2] = HEAP32[$6 + 152 >> 2];
     HEAP32[$6 + 152 >> 2] = HEAP32[$6 + 52 >> 2];
    }
    HEAP32[$6 + 56 >> 2] = (HEAP32[$6 + 156 >> 2] - HEAP32[$6 + 144 >> 2] | 0) / 2;
    HEAP32[$6 + 52 >> 2] = (HEAP32[$6 + 152 >> 2] - HEAP32[$6 + 160 >> 2] | 0) / 2;
    if (HEAP32[$6 + 56 >> 2] < HEAP32[$6 + 140 >> 2]) {
     HEAP32[$6 + 140 >> 2] = HEAP32[$6 + 56 >> 2];
    }
    if (HEAP32[$6 + 52 >> 2] < HEAP32[$6 + 140 >> 2]) {
     HEAP32[$6 + 140 >> 2] = HEAP32[$6 + 52 >> 2];
    }
    HEAP32[$6 + 48 >> 2] = HEAP32[$6 + 144 >> 2] + HEAP32[$6 + 140 >> 2];
    HEAP32[$6 + 44 >> 2] = HEAP32[$6 + 156 >> 2] - HEAP32[$6 + 140 >> 2];
    HEAP32[$6 + 40 >> 2] = HEAP32[$6 + 160 >> 2] + HEAP32[$6 + 140 >> 2];
    HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 152 >> 2] - HEAP32[$6 + 140 >> 2];
    graphicsFillRectDevice($6 - -64 | 0, HEAP32[$6 + 144 >> 2], HEAP32[$6 + 40 >> 2], HEAP32[$6 + 156 >> 2], HEAP32[$6 + 36 >> 2], HEAP32[$6 + 60 >> 2]);
    HEAP32[$6 + 32 >> 2] = 0;
    HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 140 >> 2];
    HEAP32[$6 + 24 >> 2] = Math_imul(HEAP32[$6 + 140 >> 2], HEAP32[$6 + 140 >> 2]);
    HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 24 >> 2] - Math_imul(HEAP32[$6 + 24 >> 2], (HEAP32[$6 + 140 >> 2] << 1) - 1 | 0);
    HEAP8[$6 + 15 | 0] = 0;
    while (1) {
     HEAP8[$6 + 15 | 0] = 0;
     HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 20 >> 2] << 1;
     if (HEAP32[$6 + 16 >> 2] < (Math_imul(HEAP32[$6 + 24 >> 2], (HEAP32[$6 + 32 >> 2] << 1) + 1 | 0) | 0)) {
      HEAP32[$6 + 32 >> 2] = HEAP32[$6 + 32 >> 2] + 1;
      HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 20 >> 2] + Math_imul(HEAP32[$6 + 24 >> 2], (HEAP32[$6 + 32 >> 2] << 1) + 1 | 0);
      HEAP8[$6 + 15 | 0] = 1;
     }
     if (HEAP32[$6 + 16 >> 2] > (Math_imul(HEAP32[$6 + 24 >> 2], 1 - (HEAP32[$6 + 28 >> 2] << 1) | 0) | 0)) {
      graphicsFillRectDevice($6 - -64 | 0, HEAP32[$6 + 48 >> 2] - HEAP32[$6 + 32 >> 2] | 0, HEAP32[$6 + 36 >> 2] + HEAP32[$6 + 28 >> 2] | 0, HEAP32[$6 + 44 >> 2] + HEAP32[$6 + 32 >> 2] | 0, HEAP32[$6 + 36 >> 2] + HEAP32[$6 + 28 >> 2] | 0, HEAP32[$6 + 60 >> 2]);
      graphicsFillRectDevice($6 - -64 | 0, HEAP32[$6 + 48 >> 2] - HEAP32[$6 + 32 >> 2] | 0, HEAP32[$6 + 40 >> 2] - HEAP32[$6 + 28 >> 2] | 0, HEAP32[$6 + 44 >> 2] + HEAP32[$6 + 32 >> 2] | 0, HEAP32[$6 + 40 >> 2] - HEAP32[$6 + 28 >> 2] | 0, HEAP32[$6 + 60 >> 2]);
      HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 28 >> 2] - 1;
      HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 20 >> 2] - Math_imul(HEAP32[$6 + 24 >> 2], (HEAP32[$6 + 28 >> 2] << 1) - 1 | 0);
      HEAP8[$6 + 15 | 0] = 1;
     }
     $0 = 0;
     $0 = HEAP8[$6 + 15 | 0] & 1 ? HEAP32[$6 + 28 >> 2] >= 0 : $0;
     if ($0) {
      continue;
     }
     break;
    }
    break label$5;
   }
   graphicsFillRect($6 - -64 | 0, HEAP32[$6 + 144 >> 2], HEAP32[$6 + 160 >> 2], HEAP32[$6 + 156 >> 2], HEAP32[$6 + 152 >> 2], HEAP32[$6 + 60 >> 2]);
  }
  graphicsSetVar($6 - -64 | 0);
  HEAP32[$6 + 172 >> 2] = jsvLockAgain(HEAP32[$6 + 168 >> 2]);
 }
 __stack_pointer = $6 + 176 | 0;
 return HEAP32[$6 + 172 >> 2];
}

function graphicsScroll($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 HEAP32[$3 + 32 >> 2] = 0;
 HEAP32[$3 + 28 >> 2] = 0;
 HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 40 >> 2];
 HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 36 >> 2];
 graphicsToDeviceCoordinates(HEAP32[$3 + 44 >> 2], $3 + 32 | 0, $3 + 28 | 0);
 graphicsToDeviceCoordinates(HEAP32[$3 + 44 >> 2], $3 + 24 | 0, $3 + 20 | 0);
 HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 24 >> 2] - HEAP32[$3 + 32 >> 2];
 HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 28 >> 2];
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 32 >> 2] = HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 28 >> 2] = HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 24 >> 2] = HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 20 >> 2] = HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8;
 HEAP8[$3 + 19 | 0] = 1;
 HEAP32[$3 + 12 >> 2] = (HEAP32[$3 + 24 >> 2] + 1 | 0) - HEAP32[$3 + 32 >> 2];
 HEAP32[$3 + 8 >> 2] = (HEAP32[$3 + 20 >> 2] + 1 | 0) - HEAP32[$3 + 28 >> 2];
 if (HEAP32[$3 + 40 >> 2] >= HEAP32[$3 + 12 >> 2]) {
  HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 12 >> 2];
  HEAP8[$3 + 19 | 0] = 0;
 }
 if (HEAP32[$3 + 40 >> 2] <= (0 - HEAP32[$3 + 12 >> 2] | 0)) {
  HEAP32[$3 + 40 >> 2] = 0 - HEAP32[$3 + 12 >> 2];
  HEAP8[$3 + 19 | 0] = 0;
 }
 if (HEAP32[$3 + 36 >> 2] >= HEAP32[$3 + 8 >> 2]) {
  HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 8 >> 2];
  HEAP8[$3 + 19 | 0] = 0;
 }
 if (HEAP32[$3 + 36 >> 2] <= (0 - HEAP32[$3 + 8 >> 2] | 0)) {
  HEAP32[$3 + 36 >> 2] = 0 - HEAP32[$3 + 8 >> 2];
  HEAP8[$3 + 19 | 0] = 0;
 }
 if (HEAP8[$3 + 19 | 0] & 1) {
  $0 = HEAP32[$3 + 44 >> 2];
  FUNCTION_TABLE[HEAPU8[$0 + 68 | 0] | HEAPU8[$0 + 69 | 0] << 8 | (HEAPU8[$0 + 70 | 0] << 16 | HEAPU8[$0 + 71 | 0] << 24)](HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2], HEAP32[$3 + 36 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
 }
 graphicsSetModified(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
 label$6: {
  if (HEAP32[$3 + 40 >> 2] > 0) {
   $0 = HEAP32[$3 + 44 >> 2];
   $1 = HEAP32[$3 + 44 >> 2];
   FUNCTION_TABLE[HEAPU8[$1 + 56 | 0] | HEAPU8[$1 + 57 | 0] << 8 | (HEAPU8[$1 + 58 | 0] << 16 | HEAPU8[$1 + 59 | 0] << 24)](HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2], (HEAP32[$3 + 32 >> 2] + HEAP32[$3 + 40 >> 2] | 0) - 1 | 0, HEAP32[$3 + 20 >> 2], HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
   break label$6;
  }
  if (HEAP32[$3 + 40 >> 2] < 0) {
   $0 = HEAP32[$3 + 44 >> 2];
   $1 = HEAP32[$3 + 44 >> 2];
   FUNCTION_TABLE[HEAPU8[$1 + 56 | 0] | HEAPU8[$1 + 57 | 0] << 8 | (HEAPU8[$1 + 58 | 0] << 16 | HEAPU8[$1 + 59 | 0] << 24)](HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2] + (HEAP32[$3 + 24 >> 2] + 1 | 0) | 0, HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
  }
 }
 label$9: {
  if (HEAP32[$3 + 36 >> 2] > 0) {
   $0 = HEAP32[$3 + 44 >> 2];
   $1 = HEAP32[$3 + 44 >> 2];
   FUNCTION_TABLE[HEAPU8[$1 + 56 | 0] | HEAPU8[$1 + 57 | 0] << 8 | (HEAPU8[$1 + 58 | 0] << 16 | HEAPU8[$1 + 59 | 0] << 24)](HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], (HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 36 >> 2] | 0) - 1 | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
   break label$9;
  }
  if (HEAP32[$3 + 36 >> 2] < 0) {
   $0 = HEAP32[$3 + 44 >> 2];
   $1 = HEAP32[$3 + 44 >> 2];
   FUNCTION_TABLE[HEAPU8[$1 + 56 | 0] | HEAPU8[$1 + 57 | 0] << 8 | (HEAPU8[$1 + 58 | 0] << 16 | HEAPU8[$1 + 59 | 0] << 24)](HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 36 >> 2] + (HEAP32[$3 + 20 >> 2] + 1 | 0) | 0, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
  }
 }
 __stack_pointer = $3 + 48 | 0;
}

function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__exp_on_interval_between_negative_one_quarter_and_0_excl_int__28gemmlowp__FixedPoint_int_2c_200__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 256 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 240 >> 2] = $0;
 HEAP32[$1 + 232 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200___28int_29(1895147668));
 HEAP32[$1 + 224 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200___28int_29(715827883));
 HEAP32[$1 + 208 >> 2] = HEAP32[$1 + 240 >> 2];
 HEAP32[$1 + 200 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__FixedPoint_int_2c_200___ConstantPOT__3__28_29();
 HEAP32[$1 + 216 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__operator__int_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 208 >> 2], HEAP32[$1 + 200 >> 2]);
 HEAP32[$1 + 184 >> 2] = HEAP32[$1 + 216 >> 2];
 HEAP32[$1 + 176 >> 2] = HEAP32[$1 + 216 >> 2];
 HEAP32[$1 + 192 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 184 >> 2], HEAP32[$1 + 176 >> 2]);
 HEAP32[$1 + 160 >> 2] = HEAP32[$1 + 192 >> 2];
 HEAP32[$1 + 152 >> 2] = HEAP32[$1 + 216 >> 2];
 HEAP32[$1 + 168 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 160 >> 2], HEAP32[$1 + 152 >> 2]);
 HEAP32[$1 + 136 >> 2] = HEAP32[$1 + 192 >> 2];
 HEAP32[$1 + 128 >> 2] = HEAP32[$1 + 192 >> 2];
 HEAP32[$1 + 144 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 136 >> 2], HEAP32[$1 + 128 >> 2]);
 HEAP32[$1 + 112 >> 2] = HEAP32[$1 + 144 >> 2];
 HEAP32[$1 + 120 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SaturatingRoundingMultiplyByPOT__2_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 112 >> 2]);
 HEAP32[$1 + 72 >> 2] = HEAP32[$1 + 120 >> 2];
 HEAP32[$1 + 64 >> 2] = HEAP32[$1 + 168 >> 2];
 HEAP32[$1 + 80 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__operator__int_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 72 >> 2], HEAP32[$1 + 64 >> 2]);
 HEAP32[$1 + 56 >> 2] = HEAP32[$1 + 224 >> 2];
 HEAP32[$1 + 88 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 80 >> 2], HEAP32[$1 + 56 >> 2]);
 HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 192 >> 2];
 HEAP32[$1 + 96 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__operator__int_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 88 >> 2], HEAP32[$1 + 48 >> 2]);
 HEAP32[$1 + 104 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SaturatingRoundingMultiplyByPOT__1_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 96 >> 2]);
 HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 232 >> 2];
 HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 232 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 216 >> 2];
 HEAP32[$1 >> 2] = HEAP32[$1 + 104 >> 2];
 HEAP32[$1 + 16 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__operator__int_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 8 >> 2], HEAP32[$1 >> 2]);
 HEAP32[$1 + 32 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 16 >> 2]);
 HEAP32[$1 + 248 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__AddSaturatingIf16Bit_int_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 40 >> 2], HEAP32[$1 + 32 >> 2]);
 __stack_pointer = $1 + 256 | 0;
 return HEAP32[$1 + 248 >> 2];
}

function tflite__MicroInterpreter__AllocateTensors_28_29($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer + -64 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 $0 = HEAP32[$1 + 56 >> 2];
 label$1: {
  if (tflite__MicroAllocator__StartModelAllocation_28tflite__Model_20const__2c_20tflite__MicroOpResolver_20const__2c_20tflite__NodeAndRegistration___2c_20TfLiteEvalTensor___29(HEAP32[$0 + 104 >> 2], HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2], $0, $0 + 120 | 0)) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 12 >> 2], 147622, 0);
   HEAP32[$0 + 112 >> 2] = 1;
   HEAP32[$1 + 60 >> 2] = 1;
   break label$1;
  }
  tflite__internal__ContextHelper__SetTfLiteEvalTensors_28TfLiteEvalTensor__29($0 + 124 | 0, HEAP32[$0 + 120 >> 2]);
  HEAP32[$0 + 72 >> 2] = 678;
  HEAP32[$0 + 80 >> 2] = 0;
  HEAP32[$0 + 84 >> 2] = 0;
  HEAP32[$1 + 52 >> 2] = 0;
  while (1) {
   if (HEAPU32[$1 + 52 >> 2] < flatbuffers__Vector_flatbuffers__Offset_tflite__Operator____size_28_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$0 + 116 >> 2])) >>> 0) {
    tflite__internal__ContextHelper__SetNodeIndex_28int_29($0 + 124 | 0, HEAP32[$1 + 52 >> 2]);
    HEAP32[$1 + 48 >> 2] = HEAP32[$0 >> 2] + Math_imul(HEAP32[$1 + 52 >> 2], 28);
    HEAP32[$1 + 44 >> 2] = HEAP32[(HEAP32[$0 >> 2] + Math_imul(HEAP32[$1 + 52 >> 2], 28) | 0) + 24 >> 2];
    label$5: {
     if (HEAP32[HEAP32[$1 + 44 >> 2] + 20 >> 2] == 32) {
      HEAP32[$1 + 36 >> 2] = HEAP32[HEAP32[$1 + 48 >> 2] + 16 >> 2];
      HEAP32[$1 + 40 >> 2] = HEAP32[HEAP32[$1 + 48 >> 2] + 20 >> 2];
      break label$5;
     }
     HEAP32[$1 + 36 >> 2] = HEAP32[HEAP32[$1 + 48 >> 2] + 12 >> 2];
     HEAP32[$1 + 40 >> 2] = 0;
    }
    if (HEAP32[HEAP32[$1 + 44 >> 2] >> 2]) {
     $2 = FUNCTION_TABLE[HEAP32[HEAP32[$1 + 44 >> 2] >> 2]]($0 + 16 | 0, HEAP32[$1 + 36 >> 2], HEAP32[$1 + 40 >> 2]) | 0;
     HEAP32[HEAP32[$1 + 48 >> 2] + 8 >> 2] = $2;
    }
    HEAP32[$1 + 52 >> 2] = HEAP32[$1 + 52 >> 2] + 1;
    continue;
   }
   break;
  }
  tflite__internal__ContextHelper__SetNodeIndex_28int_29($0 + 124 | 0, -1);
  HEAP32[$0 + 80 >> 2] = 679;
  HEAP32[$1 + 32 >> 2] = 0;
  while (1) {
   if (HEAPU32[$1 + 32 >> 2] < flatbuffers__Vector_flatbuffers__Offset_tflite__Operator____size_28_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$0 + 116 >> 2])) >>> 0) {
    tflite__internal__ContextHelper__SetNodeIndex_28int_29($0 + 124 | 0, HEAP32[$1 + 32 >> 2]);
    HEAP32[$1 + 28 >> 2] = HEAP32[$0 >> 2] + Math_imul(HEAP32[$1 + 32 >> 2], 28);
    HEAP32[$1 + 24 >> 2] = HEAP32[(HEAP32[$0 >> 2] + Math_imul(HEAP32[$1 + 32 >> 2], 28) | 0) + 24 >> 2];
    if (HEAP32[HEAP32[$1 + 24 >> 2] + 8 >> 2]) {
     HEAP32[$1 + 20 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$1 + 24 >> 2] + 8 >> 2]]($0 + 16 | 0, HEAP32[$1 + 28 >> 2]);
     if (HEAP32[$1 + 20 >> 2]) {
      $0 = HEAP32[$0 + 12 >> 2];
      $2 = tflite___28anonymous_20namespace_29__OpNameFromRegistration_28TfLiteRegistration_20const__29(HEAP32[$1 + 24 >> 2]);
      $3 = HEAP32[$1 + 32 >> 2];
      HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 20 >> 2];
      HEAP32[$1 + 4 >> 2] = $3;
      HEAP32[$1 >> 2] = $2;
      tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 134673, $1);
      HEAP32[$1 + 60 >> 2] = 1;
      break label$1;
     }
    }
    $2 = HEAP32[$0 + 104 >> 2];
    FUNCTION_TABLE[HEAP32[HEAP32[$2 >> 2] + 8 >> 2]]($2);
    HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 32 >> 2] + 1;
    continue;
   }
   break;
  }
  tflite__internal__ContextHelper__SetNodeIndex_28int_29($0 + 124 | 0, -1);
  HEAP32[$0 + 72 >> 2] = 0;
  HEAP32[$0 + 80 >> 2] = 0;
  HEAP32[$0 + 84 >> 2] = 680;
  HEAP32[$1 + 16 >> 2] = tflite__MicroAllocator__FinishModelAllocation_28tflite__Model_20const__2c_20TfLiteEvalTensor__29(HEAP32[$0 + 104 >> 2], HEAP32[$0 + 4 >> 2], HEAP32[$0 + 120 >> 2]);
  if (HEAP32[$1 + 16 >> 2]) {
   HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 16 >> 2];
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = tflite__MicroInterpreter__ResetVariableTensors_28_29($0);
  if (HEAP32[$1 + 12 >> 2]) {
   HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 12 >> 2];
   break label$1;
  }
  HEAP8[$0 + 108 | 0] = 1;
  HEAP32[$1 + 60 >> 2] = 0;
 }
 __stack_pointer = $1 - -64 | 0;
 return HEAP32[$1 + 60 >> 2];
}

function jswrap_object_keys_or_property_names_cb($0, $1, $2, $3) {
 var $4 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $4 = __stack_pointer - 144 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 140 >> 2] = $0;
 HEAP32[$4 + 136 >> 2] = $1;
 HEAP32[$4 + 132 >> 2] = $2;
 HEAP32[$4 + 128 >> 2] = $3;
 label$1: {
  if (!(jsvIsIterable(HEAP32[$4 + 140 >> 2]) & 1)) {
   break label$1;
  }
  if (wasm2js_i32$0 = jsvIsArrayBuffer(HEAP32[$4 + 140 >> 2]) & 1, wasm2js_i32$1 = 0, 
  wasm2js_i32$2 = HEAP32[$4 + 136 >> 2] & 4, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1) {
   break label$1;
  }
  HEAP32[$4 + 124 >> 2] = jsvGetInternalFunctionCheckerFor(HEAP32[$4 + 140 >> 2]);
  jsvIteratorNew($4 - -64 | 0, HEAP32[$4 + 140 >> 2], 0);
  while (1) {
   if (jsvIteratorHasElement($4 - -64 | 0) & 1) {
    HEAP32[$4 + 60 >> 2] = jsvIteratorGetKey($4 - -64 | 0);
    label$5: {
     label$6: {
      if (!HEAP32[$4 + 124 >> 2]) {
       break label$6;
      }
      if (!(FUNCTION_TABLE[HEAP32[$4 + 124 >> 2]](HEAP32[$4 + 60 >> 2]) & 1)) {
       break label$6;
      }
      if (!(jsvIsStringEqual(HEAP32[$4 + 60 >> 2], 120855) & 1)) {
       break label$5;
      }
     }
     HEAP32[$4 + 56 >> 2] = jsvAsStringAndUnLock(jsvCopyNameOnly(HEAP32[$4 + 60 >> 2], 0, 0));
     if (HEAP32[$4 + 56 >> 2]) {
      FUNCTION_TABLE[HEAP32[$4 + 132 >> 2]](HEAP32[$4 + 128 >> 2], HEAP32[$4 + 56 >> 2]);
      jsvUnLock(HEAP32[$4 + 56 >> 2]);
     }
    }
    jsvUnLock(HEAP32[$4 + 60 >> 2]);
    jsvIteratorNext($4 - -64 | 0);
    continue;
   }
   break;
  }
  jsvIteratorFree($4 - -64 | 0);
 }
 if (HEAP32[$4 + 136 >> 2] & 1) {
  HEAP32[$4 + 52 >> 2] = jswGetSymbolListForObjectProto(0);
  HEAP32[$4 + 48 >> 2] = jspGetPrototypeOwner(HEAP32[$4 + 140 >> 2]);
  label$9: {
   if (HEAP32[$4 + 48 >> 2]) {
    HEAP32[$4 + 44 >> 2] = jswGetSymbolListForObjectProto(HEAP32[$4 + 48 >> 2]);
    jsvUnLock(HEAP32[$4 + 48 >> 2]);
    _jswrap_object_keys_or_property_names_iterator(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 132 >> 2], HEAP32[$4 + 128 >> 2]);
    break label$9;
   }
   label$11: {
    if (jsvIsObject(HEAP32[$4 + 140 >> 2]) & 1) {
     if (!(jsvIsRoot(HEAP32[$4 + 140 >> 2]) & 1)) {
      break label$11;
     }
    }
    HEAP32[$4 + 40 >> 2] = jswGetSymbolListForObject(HEAP32[$4 + 140 >> 2]);
    _jswrap_object_keys_or_property_names_iterator(HEAP32[$4 + 40 >> 2], HEAP32[$4 + 132 >> 2], HEAP32[$4 + 128 >> 2]);
   }
  }
  if (HEAP32[$4 + 136 >> 2] & 2) {
   HEAP32[$4 + 36 >> 2] = 0;
   label$14: {
    if (!(jsvIsObject(HEAP32[$4 + 140 >> 2]) & 1)) {
     if (!(jsvIsFunction(HEAP32[$4 + 140 >> 2]) & 1)) {
      break label$14;
     }
    }
    HEAP32[$4 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 140 >> 2], 135865);
   }
   label$16: {
    if (jsvIsObject(HEAP32[$4 + 36 >> 2]) & 1) {
     jswrap_object_keys_or_property_names_cb(HEAP32[$4 + 36 >> 2], HEAP32[$4 + 136 >> 2], HEAP32[$4 + 132 >> 2], HEAP32[$4 + 128 >> 2]);
     break label$16;
    }
    HEAP32[$4 + 32 >> 2] = jswGetSymbolListForObjectProto(HEAP32[$4 + 140 >> 2]);
    _jswrap_object_keys_or_property_names_iterator(HEAP32[$4 + 32 >> 2], HEAP32[$4 + 132 >> 2], HEAP32[$4 + 128 >> 2]);
    if (HEAP32[$4 + 52 >> 2] != HEAP32[$4 + 32 >> 2]) {
     _jswrap_object_keys_or_property_names_iterator(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 132 >> 2], HEAP32[$4 + 128 >> 2]);
    }
   }
   jsvUnLock(HEAP32[$4 + 36 >> 2]);
  }
  label$19: {
   if (!(jsvIsArray(HEAP32[$4 + 140 >> 2]) & 1)) {
    if (!(jsvIsString(HEAP32[$4 + 140 >> 2]) & 1)) {
     break label$19;
    }
   }
   HEAP32[$4 + 28 >> 2] = jsvNewFromString(129363);
   FUNCTION_TABLE[HEAP32[$4 + 132 >> 2]](HEAP32[$4 + 128 >> 2], HEAP32[$4 + 28 >> 2]);
   jsvUnLock(HEAP32[$4 + 28 >> 2]);
  }
 }
 if (jsvIsRoot(HEAP32[$4 + 140 >> 2]) & 1) {
  HEAP32[$4 + 24 >> 2] = 0;
  while (1) {
   if (HEAP32[$4 + 24 >> 2] < 48) {
    jshGetPinString($4 + 14 | 0, HEAP32[$4 + 24 >> 2] & 255);
    HEAP32[$4 + 8 >> 2] = jsvNewFromString($4 + 14 | 0);
    FUNCTION_TABLE[HEAP32[$4 + 132 >> 2]](HEAP32[$4 + 128 >> 2], HEAP32[$4 + 8 >> 2]);
    jsvUnLock(HEAP32[$4 + 8 >> 2]);
    HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] + 1;
    continue;
   }
   break;
  }
 }
 __stack_pointer = $4 + 144 | 0;
}

function jsfWriteFile($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $6 = __stack_pointer - 128 | 0;
 $5 = $6;
 __stack_pointer = $5;
 HEAP32[$5 + 120 >> 2] = $1;
 HEAP32[$5 + 116 >> 2] = $2;
 HEAP32[$5 + 112 >> 2] = $3;
 HEAP32[$5 + 108 >> 2] = $4;
 label$1: {
  if ((HEAP32[$5 + 112 >> 2] | HEAP32[$5 + 108 >> 2]) < 0) {
   HEAP8[$5 + 127 | 0] = 0;
   break label$1;
  }
  HEAP32[$5 + 104 >> 2] = HEAP32[$5 + 108 >> 2];
  HEAP32[$5 + 100 >> 2] = 0;
  HEAP32[$5 + 96 >> 2] = jsvGetDataPointer(HEAP32[$5 + 120 >> 2], $5 + 100 | 0);
  if (!(HEAP32[$5 + 96 >> 2] | !HEAP32[$5 + 120 >> 2])) {
   HEAP32[$5 + 100 >> 2] = jsvIterateCallbackCount(HEAP32[$5 + 120 >> 2]);
   label$5: {
    if (HEAP32[$5 + 100 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
     jsExceptionHere(1, 135807, 0);
     break label$5;
    }
    $6 = $6 - (HEAP32[$5 + 100 >> 2] + 15 & -16) | 0;
    __stack_pointer = $6;
    HEAP32[$5 + 96 >> 2] = $6;
    jsvIterateCallbackToBytes(HEAP32[$5 + 120 >> 2], HEAP32[$5 + 96 >> 2], HEAP32[$5 + 100 >> 2]);
   }
  }
  if (!HEAP32[$5 + 96 >> 2]) {
   jsExceptionHere(1, 131940, 0);
   HEAP8[$5 + 127 | 0] = 0;
   break label$1;
  }
  if (!HEAP32[$5 + 104 >> 2]) {
   HEAP32[$5 + 104 >> 2] = HEAP32[$5 + 100 >> 2];
  }
  if (!HEAP32[$5 + 104 >> 2]) {
   jsExceptionHere(1, 132415, 0);
   HEAP8[$5 + 127 | 0] = 0;
   break label$1;
  }
  HEAP32[$5 + 56 >> 2] = HEAP32[$0 + 24 >> 2];
  $1 = HEAP32[$0 + 16 >> 2];
  $2 = HEAP32[$0 + 20 >> 2];
  HEAP32[$5 + 48 >> 2] = $1;
  HEAP32[$5 + 52 >> 2] = $2;
  $1 = HEAP32[$0 + 12 >> 2];
  $2 = HEAP32[$0 + 8 >> 2];
  HEAP32[$5 + 40 >> 2] = $2;
  HEAP32[$5 + 44 >> 2] = $1;
  $2 = HEAP32[$0 + 4 >> 2];
  $1 = HEAP32[$0 >> 2];
  HEAP32[$5 + 32 >> 2] = $1;
  HEAP32[$5 + 36 >> 2] = $2;
  HEAP32[$5 + 60 >> 2] = jsfFindFile($5 + 32 | 0, $5 - -64 | 0);
  label$10: {
   label$11: {
    if (!(HEAP32[$5 + 112 >> 2] ? 1 : HEAP32[$5 + 60 >> 2])) {
     break label$11;
    }
    if (HEAP32[$5 + 112 >> 2] | !HEAP32[$5 + 60 >> 2]) {
     break label$10;
    }
    if (HEAP32[$5 + 116 >> 2] != (jsfGetFileFlags($5 - -64 | 0) | 0)) {
     break label$11;
    }
    if (HEAP32[$5 + 104 >> 2] != (jsfGetFileSize($5 - -64 | 0) | 0)) {
     break label$11;
    }
    if (jsfIsErased(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 104 >> 2]) & 1) {
     break label$10;
    }
   }
   label$13: {
    if (HEAP32[$5 + 112 >> 2] | !HEAP32[$5 + 60 >> 2]) {
     break label$13;
    }
    if (HEAP32[$5 + 104 >> 2] != (jsfGetFileSize($5 - -64 | 0) | 0)) {
     break label$13;
    }
    if (HEAP32[$5 + 116 >> 2] != (jsfGetFileFlags($5 - -64 | 0) | 0) | HEAP32[$5 + 100 >> 2] != HEAP32[$5 + 104 >> 2]) {
     break label$13;
    }
    if (!(jsfIsEqual(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 96 >> 2], HEAP32[$5 + 100 >> 2]) & 1)) {
     break label$13;
    }
    HEAP8[$5 + 127 | 0] = 1;
    break label$1;
   }
   if (HEAP32[$5 + 60 >> 2]) {
    jsfEraseFileInternal(HEAP32[$5 + 60 >> 2], $5 - -64 | 0, 1);
   }
   $3 = HEAP32[$5 + 104 >> 2];
   $4 = HEAP32[$5 + 116 >> 2];
   HEAP32[$5 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
   $2 = HEAP32[$0 + 16 >> 2];
   $1 = HEAP32[$0 + 20 >> 2];
   HEAP32[$5 + 16 >> 2] = $2;
   HEAP32[$5 + 20 >> 2] = $1;
   $2 = HEAP32[$0 + 12 >> 2];
   $1 = HEAP32[$0 + 8 >> 2];
   HEAP32[$5 + 8 >> 2] = $1;
   HEAP32[$5 + 12 >> 2] = $2;
   $1 = HEAP32[$0 + 4 >> 2];
   $2 = HEAP32[$0 >> 2];
   HEAP32[$5 >> 2] = $2;
   HEAP32[$5 + 4 >> 2] = $1;
   HEAP32[$5 + 60 >> 2] = jsfCreateFile($5, $3, $4, $5 - -64 | 0);
  }
  if (!HEAP32[$5 + 60 >> 2]) {
   jsExceptionHere(1, 132445, 0);
   HEAP8[$5 + 127 | 0] = 0;
   break label$1;
  }
  if (HEAP32[$5 + 112 >> 2] + HEAP32[$5 + 100 >> 2] >>> 0 > jsfGetFileSize($5 - -64 | 0) >>> 0) {
   jsExceptionHere(1, 131625, 0);
   HEAP8[$5 + 127 | 0] = 0;
   break label$1;
  }
  HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 112 >> 2] + HEAP32[$5 + 60 >> 2];
  if (!(jsfIsErased(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 100 >> 2]) & 1)) {
   jsExceptionHere(1, 135766, 0);
   HEAP8[$5 + 127 | 0] = 0;
   break label$1;
  }
  jshFlashWriteAligned(HEAP32[$5 + 96 >> 2], HEAP32[$5 + 60 >> 2], HEAP32[$5 + 100 >> 2]);
  HEAP8[$5 + 127 | 0] = 1;
 }
 __stack_pointer = $5 + 128 | 0;
 return HEAP8[$5 + 127 | 0] & 1;
}

function jswrap_espruino_mapInPlace($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 176 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 172 >> 2] = $0;
 HEAP32[$4 + 168 >> 2] = $1;
 HEAP32[$4 + 164 >> 2] = $2;
 HEAP32[$4 + 160 >> 2] = $3;
 label$1: {
  label$2: {
   if (jsvIsArrayBuffer(HEAP32[$4 + 172 >> 2]) & 1) {
    if (jsvIsArrayBuffer(HEAP32[$4 + 168 >> 2]) & 1) {
     break label$2;
    }
   }
   jsExceptionHere(1, 119962, 0);
   break label$1;
  }
  label$4: {
   if (!HEAP32[$4 + 164 >> 2]) {
    break label$4;
   }
   if (jsvIsArray(HEAP32[$4 + 164 >> 2]) & 1) {
    break label$4;
   }
   if (jsvIsArrayBuffer(HEAP32[$4 + 164 >> 2]) & 1) {
    break label$4;
   }
   if (jsvIsFunction(HEAP32[$4 + 164 >> 2]) & 1) {
    break label$4;
   }
   jsExceptionHere(1, 116227, 0);
   break label$1;
  }
  HEAP8[$4 + 159 | 0] = jsvIsFunction(HEAP32[$4 + 164 >> 2]) & 1;
  HEAP32[$4 + 152 >> 2] = (HEAPU8[HEAP32[$4 + 172 >> 2] + 5 | 0] & 15) << 3;
  HEAP8[$4 + 151 | 0] = 1;
  if (HEAP32[$4 + 160 >> 2] < 0) {
   HEAP32[$4 + 160 >> 2] = 0 - HEAP32[$4 + 160 >> 2];
   HEAP8[$4 + 151 | 0] = 0;
  }
  if (!HEAP32[$4 + 160 >> 2]) {
   HEAP32[$4 + 160 >> 2] = HEAP32[$4 + 152 >> 2];
  }
  jsvArrayBufferIteratorNew($4 + 88 | 0, HEAP32[$4 + 172 >> 2], 0);
  HEAP32[$4 + 28 >> 2] = 0;
  HEAP32[$4 + 24 >> 2] = 0;
  jsvArrayBufferIteratorNew($4 + 32 | 0, HEAP32[$4 + 168 >> 2], 0);
  while (1) {
   label$8: {
    if (!(jsvArrayBufferIteratorHasElement($4 + 88 | 0) & 1)) {
     $0 = 0;
     if (HEAP32[$4 + 24 >> 2] < HEAP32[$4 + 160 >> 2]) {
      break label$8;
     }
    }
    $0 = jsvArrayBufferIteratorHasElement($4 + 32 | 0);
   }
   if ($0 & 1) {
    label$11: {
     if (HEAP8[$4 + 159 | 0] & 1) {
      $0 = jsvArrayBufferIteratorGetIndex($4 + 88 | 0);
      break label$11;
     }
     $0 = 0;
    }
    HEAP32[$4 + 20 >> 2] = $0;
    while (1) {
     if (HEAP32[$4 + 24 >> 2] < HEAP32[$4 + 160 >> 2]) {
      label$15: {
       if (HEAP8[$4 + 151 | 0] & 1) {
        HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 28 >> 2] << HEAP32[$4 + 152 >> 2] | jsvArrayBufferIteratorGetIntegerValue($4 + 88 | 0);
        break label$15;
       }
       HEAP32[$4 + 28 >> 2] = jsvArrayBufferIteratorGetIntegerValue($4 + 88 | 0) << HEAP32[$4 + 24 >> 2] | HEAP32[$4 + 28 >> 2];
      }
      jsvArrayBufferIteratorNext($4 + 88 | 0);
      HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 152 >> 2] + HEAP32[$4 + 24 >> 2];
      continue;
     }
     break;
    }
    label$17: {
     if (HEAP8[$4 + 151 | 0] & 1) {
      HEAP32[$4 + 16 >> 2] = (1 << HEAP32[$4 + 160 >> 2]) - 1 & HEAP32[$4 + 28 >> 2] >> HEAP32[$4 + 24 >> 2] - HEAP32[$4 + 160 >> 2];
      break label$17;
     }
     HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 28 >> 2] & (1 << HEAP32[$4 + 160 >> 2]) - 1;
     HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 28 >> 2] >> HEAP32[$4 + 160 >> 2];
    }
    HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] - HEAP32[$4 + 160 >> 2];
    label$19: {
     if (HEAP32[$4 + 164 >> 2]) {
      HEAP32[$4 + 12 >> 2] = 0;
      label$21: {
       if (HEAP8[$4 + 159 | 0] & 1) {
        HEAP32[$4 + 4 >> 2] = jsvNewFromInteger(HEAP32[$4 + 16 >> 2]);
        HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 20 >> 2];
        HEAP32[$4 + 12 >> 2] = jspeFunctionCall(HEAP32[$4 + 164 >> 2], 0, 0, 0, 2, $4 + 4 | 0);
        jsvUnLock(HEAP32[$4 + 4 >> 2]);
        break label$21;
       }
       label$23: {
        if (jsvIsArray(HEAP32[$4 + 164 >> 2]) & 1) {
         HEAP32[$4 + 12 >> 2] = jsvGetArrayItem(HEAP32[$4 + 164 >> 2], HEAP32[$4 + 16 >> 2]);
         break label$23;
        }
        HEAP32[$4 + 12 >> 2] = jsvArrayBufferGet(HEAP32[$4 + 164 >> 2], HEAP32[$4 + 16 >> 2]);
       }
      }
      jsvArrayBufferIteratorSetValue($4 + 32 | 0, HEAP32[$4 + 12 >> 2], 0);
      jsvUnLock(HEAP32[$4 + 12 >> 2]);
      break label$19;
     }
     jsvArrayBufferIteratorSetIntegerValue($4 + 32 | 0, HEAP32[$4 + 16 >> 2]);
    }
    jsvUnLock(HEAP32[$4 + 20 >> 2]);
    jsvArrayBufferIteratorNext($4 + 32 | 0);
    continue;
   }
   break;
  }
  jsvArrayBufferIteratorFree($4 + 88 | 0);
  jsvArrayBufferIteratorFree($4 + 32 | 0);
 }
 __stack_pointer = $4 + 176 | 0;
}

function jspeStatement() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 label$1: {
  label$2: {
   label$3: {
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 128 | HEAP16[HEAP32[49079] + 2 >> 1] == 129 | (HEAP16[HEAP32[49079] + 2 >> 1] == 130 | HEAP16[HEAP32[49079] + 2 >> 1] == 131)) {
     break label$3;
    }
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 133 | HEAP16[HEAP32[49079] + 2 >> 1] == 135 | (HEAP16[HEAP32[49079] + 2 >> 1] == 184 | HEAP16[HEAP32[49079] + 2 >> 1] == 182)) {
     break label$3;
    }
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 183 | HEAP16[HEAP32[49079] + 2 >> 1] == 180 | (HEAP16[HEAP32[49079] + 2 >> 1] == 181 | HEAP16[HEAP32[49079] + 2 >> 1] == 175)) {
     break label$3;
    }
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 190 | HEAP16[HEAP32[49079] + 2 >> 1] == 191 | (HEAP16[HEAP32[49079] + 2 >> 1] == 192 | HEAP16[HEAP32[49079] + 2 >> 1] == 196)) {
     break label$3;
    }
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 152 | HEAP16[HEAP32[49079] + 2 >> 1] == 153 | (HEAP16[HEAP32[49079] + 2 >> 1] == 33 | HEAP16[HEAP32[49079] + 2 >> 1] == 45)) {
     break label$3;
    }
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 43 | HEAP16[HEAP32[49079] + 2 >> 1] == 126 | HEAP16[HEAP32[49079] + 2 >> 1] == 91) {
     break label$3;
    }
    if (HEAP16[HEAP32[49079] + 2 >> 1] != 40) {
     break label$2;
    }
   }
   HEAP32[$0 + 12 >> 2] = jspeExpression();
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 123) {
   if (!(jspCheckStackPosition() & 1)) {
    HEAP32[$0 + 12 >> 2] = 0;
    break label$1;
   }
   jspeBlock();
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 59) {
   jslGetNextToken();
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  if (!(!(HEAP16[HEAP32[49079] + 2 >> 1] == 172 | HEAP16[HEAP32[49079] + 2 >> 1] == 173) & HEAP16[HEAP32[49079] + 2 >> 1] != 174)) {
   HEAP32[$0 + 12 >> 2] = jspeStatementVar();
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 163) {
   HEAP32[$0 + 12 >> 2] = jspeStatementIf();
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 165) {
   HEAP32[$0 + 12 >> 2] = jspeStatementDoOrWhile(0);
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 166) {
   HEAP32[$0 + 12 >> 2] = jspeStatementDoOrWhile(1);
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 167) {
   HEAP32[$0 + 12 >> 2] = jspeStatementFor();
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 177) {
   HEAP32[$0 + 12 >> 2] = jspeStatementTry();
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 171) {
   HEAP32[$0 + 12 >> 2] = jspeStatementReturn();
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 176) {
   HEAP32[$0 + 12 >> 2] = jspeStatementThrow();
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 170) {
   HEAP32[$0 + 12 >> 2] = jspeStatementFunctionDecl(0);
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 194) {
   HEAP32[$0 + 12 >> 2] = jspeStatementFunctionDecl(1);
   break label$1;
  }
  label$18: {
   if (HEAP16[HEAP32[49079] + 2 >> 1] == 169) {
    jslGetNextToken();
    if ((HEAP32[91094] & 63) == 1) {
     label$21: {
      if (!(HEAP32[91094] & 512)) {
       jsExceptionHere(2, 121723, 0);
       break label$21;
      }
      HEAP32[91094] = HEAP32[91094] & -64 | 4;
     }
    }
    break label$18;
   }
   label$23: {
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 168) {
     jslGetNextToken();
     if ((HEAP32[91094] & 63) == 1) {
      label$26: {
       if (!(HEAP32[91094] & 1536)) {
        jsExceptionHere(2, 121771, 0);
        break label$26;
       }
       HEAP32[91094] = HEAP32[91094] & -64 | 2;
      }
     }
     break label$23;
    }
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 187) {
     HEAP32[$0 + 12 >> 2] = jspeStatementSwitch();
     break label$1;
    }
    label$29: {
     if (HEAP16[HEAP32[49079] + 2 >> 1] == 193) {
      jslGetNextToken();
      break label$29;
     }
     if (!(jslMatch(0) & 1)) {
      HEAP32[$0 + 12 >> 2] = 0;
      break label$1;
     }
    }
   }
  }
  HEAP32[$0 + 12 >> 2] = 0;
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function graphicsDrawEllipse($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 80 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 76 >> 2] = $0;
 HEAP32[$5 + 72 >> 2] = $1;
 HEAP32[$5 + 68 >> 2] = $2;
 HEAP32[$5 + 64 >> 2] = $3;
 HEAP32[$5 + 60 >> 2] = $4;
 graphicsToDeviceCoordinates(HEAP32[$5 + 76 >> 2], $5 + 72 | 0, $5 + 68 | 0);
 graphicsToDeviceCoordinates(HEAP32[$5 + 76 >> 2], $5 - -64 | 0, $5 + 60 | 0);
 if (HEAP32[$5 + 72 >> 2] > HEAP32[$5 + 64 >> 2]) {
  HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 72 >> 2];
  HEAP32[$5 + 72 >> 2] = HEAP32[$5 + 64 >> 2];
  HEAP32[$5 + 64 >> 2] = HEAP32[$5 + 56 >> 2];
 }
 if (HEAP32[$5 + 68 >> 2] > HEAP32[$5 + 60 >> 2]) {
  HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 68 >> 2];
  HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 60 >> 2];
  HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 52 >> 2];
 }
 HEAP32[$5 + 48 >> 2] = (HEAP32[$5 + 72 >> 2] + HEAP32[$5 + 64 >> 2] | 0) / 2;
 HEAP32[$5 + 44 >> 2] = (HEAP32[$5 + 68 >> 2] + HEAP32[$5 + 60 >> 2] | 0) / 2;
 HEAP32[$5 + 40 >> 2] = (HEAP32[$5 + 64 >> 2] - HEAP32[$5 + 72 >> 2] | 0) / 2;
 HEAP32[$5 + 36 >> 2] = (HEAP32[$5 + 60 >> 2] - HEAP32[$5 + 68 >> 2] | 0) / 2;
 HEAP32[$5 + 32 >> 2] = 0;
 HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 36 >> 2];
 HEAP32[$5 + 24 >> 2] = Math_imul(HEAP32[$5 + 40 >> 2], HEAP32[$5 + 40 >> 2]);
 HEAP32[$5 + 20 >> 2] = Math_imul(HEAP32[$5 + 36 >> 2], HEAP32[$5 + 36 >> 2]);
 HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 20 >> 2] - Math_imul(HEAP32[$5 + 24 >> 2], (HEAP32[$5 + 36 >> 2] << 1) - 1 | 0);
 HEAP8[$5 + 11 | 0] = 0;
 while (1) {
  HEAP8[$5 + 11 | 0] = 0;
  $0 = HEAP32[$5 + 76 >> 2];
  graphicsSetPixelDevice(HEAP32[$5 + 76 >> 2], HEAP32[$5 + 48 >> 2] + HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2] + HEAP32[$5 + 28 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
  $0 = HEAP32[$5 + 76 >> 2];
  graphicsSetPixelDevice(HEAP32[$5 + 76 >> 2], HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2] + HEAP32[$5 + 28 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
  $0 = HEAP32[$5 + 76 >> 2];
  graphicsSetPixelDevice(HEAP32[$5 + 76 >> 2], HEAP32[$5 + 48 >> 2] + HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2] - HEAP32[$5 + 28 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
  $0 = HEAP32[$5 + 76 >> 2];
  graphicsSetPixelDevice(HEAP32[$5 + 76 >> 2], HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2] - HEAP32[$5 + 28 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
  HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 16 >> 2] << 1;
  if (HEAP32[$5 + 12 >> 2] < (Math_imul(HEAP32[$5 + 20 >> 2], (HEAP32[$5 + 32 >> 2] << 1) + 1 | 0) | 0)) {
   HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 32 >> 2] + 1;
   HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + Math_imul(HEAP32[$5 + 20 >> 2], (HEAP32[$5 + 32 >> 2] << 1) + 1 | 0);
   HEAP8[$5 + 11 | 0] = 1;
  }
  if (HEAP32[$5 + 12 >> 2] > (Math_imul(HEAP32[$5 + 24 >> 2], 1 - (HEAP32[$5 + 28 >> 2] << 1) | 0) | 0)) {
   HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 28 >> 2] - 1;
   HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] - Math_imul(HEAP32[$5 + 24 >> 2], (HEAP32[$5 + 28 >> 2] << 1) - 1 | 0);
   HEAP8[$5 + 11 | 0] = 1;
  }
  $0 = 0;
  $0 = HEAP8[$5 + 11 | 0] & 1 ? HEAP32[$5 + 28 >> 2] >= 0 : $0;
  if ($0) {
   continue;
  }
  break;
 }
 while (1) {
  $0 = HEAP32[$5 + 32 >> 2];
  HEAP32[$5 + 32 >> 2] = $0 + 1;
  if (($0 | 0) < HEAP32[$5 + 40 >> 2]) {
   $0 = HEAP32[$5 + 76 >> 2];
   graphicsSetPixelDevice(HEAP32[$5 + 76 >> 2], HEAP32[$5 + 48 >> 2] + HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
   $0 = HEAP32[$5 + 76 >> 2];
   graphicsSetPixelDevice(HEAP32[$5 + 76 >> 2], HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 80 | 0;
}

function jswrap_onewire_search($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 96 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP32[$2 + 84 >> 2] = $1;
 HEAP8[$2 + 83 | 0] = onewire_getpin(HEAP32[$2 + 88 >> 2]);
 label$1: {
  if (!(jshIsPinValid(HEAPU8[$2 + 83 | 0]) & 1)) {
   HEAP32[$2 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 76 >> 2] = jsvNewEmptyArray();
  if (!HEAP32[$2 + 76 >> 2]) {
   HEAP32[$2 + 92 >> 2] = 0;
   break label$1;
  }
  if (!(HEAP32[$2 + 84 >> 2] <= 255 & HEAP32[$2 + 84 >> 2] > 0)) {
   HEAP32[$2 + 84 >> 2] = 240;
  }
  HEAP32[$2 + 64 >> 2] = 0;
  HEAP32[$2 + 56 >> 2] = 0;
  HEAP32[$2 + 60 >> 2] = 0;
  HEAP32[$2 + 52 >> 2] = 1;
  while (1) {
   if (HEAP32[$2 + 52 >> 2]) {
    HEAP32[$2 + 48 >> 2] = 1;
    HEAP32[$2 + 44 >> 2] = 0;
    HEAP32[$2 + 40 >> 2] = 0;
    HEAP8[$2 + 37 | 0] = 1;
    HEAP32[$2 + 52 >> 2] = 0;
    if (!HEAP32[$2 + 56 >> 2]) {
     if (!(OneWireReset(HEAPU8[$2 + 83 | 0]) & 1)) {
      HEAP32[$2 + 64 >> 2] = 0;
      HEAP32[$2 + 56 >> 2] = 0;
      HEAP32[$2 + 60 >> 2] = 0;
      HEAP32[$2 + 92 >> 2] = HEAP32[$2 + 76 >> 2];
      break label$1;
     }
     $0 = HEAP32[$2 + 84 >> 2];
     $1 = $0 >> 31;
     OneWireWrite(HEAPU8[$2 + 83 | 0], 8, $0, $1);
     while (1) {
      label$11: {
       HEAP8[$2 + 39 | 0] = OneWireRead(HEAPU8[$2 + 83 | 0], 1);
       HEAP8[$2 + 38 | 0] = OneWireRead(HEAPU8[$2 + 83 | 0], 1);
       if (!(HEAPU8[$2 + 39 | 0] != 1 | HEAPU8[$2 + 38 | 0] != 1)) {
        break label$11;
       }
       label$13: {
        if (HEAPU8[$2 + 39 | 0] != HEAPU8[$2 + 38 | 0]) {
         HEAP8[$2 + 36 | 0] = HEAPU8[$2 + 39 | 0];
         break label$13;
        }
        label$15: {
         if (HEAP32[$2 + 48 >> 2] < HEAP32[$2 + 64 >> 2]) {
          HEAP8[$2 + 36 | 0] = (HEAPU8[HEAP32[$2 + 40 >> 2] + ($2 + 68 | 0) | 0] & HEAPU8[$2 + 37 | 0]) != 0;
          break label$15;
         }
         HEAP8[$2 + 36 | 0] = HEAP32[$2 + 48 >> 2] == HEAP32[$2 + 64 >> 2];
        }
        if (!HEAPU8[$2 + 36 | 0]) {
         HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 48 >> 2];
         if (HEAP32[$2 + 44 >> 2] < 9) {
          HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 44 >> 2];
         }
        }
       }
       label$19: {
        if (HEAPU8[$2 + 36 | 0] == 1) {
         $0 = HEAP32[$2 + 40 >> 2] + ($2 + 68 | 0) | 0;
         HEAP8[$0 | 0] = HEAPU8[$2 + 37 | 0] | HEAPU8[$0 | 0];
         break label$19;
        }
        $0 = HEAP32[$2 + 40 >> 2] + ($2 + 68 | 0) | 0;
        HEAP8[$0 | 0] = HEAPU8[$0 | 0] & ((HEAPU8[$2 + 37 | 0] ^ -1) & 255);
       }
       $1 = HEAPU8[$2 + 36 | 0];
       OneWireWrite(HEAPU8[$2 + 83 | 0], 1, $1, 0);
       HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 48 >> 2] + 1;
       HEAP8[$2 + 37 | 0] = HEAPU8[$2 + 37 | 0] << 1;
       if (!HEAPU8[$2 + 37 | 0]) {
        HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 40 >> 2] + 1;
        HEAP8[$2 + 37 | 0] = 1;
       }
       if (HEAP32[$2 + 40 >> 2] < 8) {
        continue;
       }
      }
      break;
     }
     if (HEAP32[$2 + 48 >> 2] >= 65) {
      HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 44 >> 2];
      if (!HEAP32[$2 + 64 >> 2]) {
       HEAP32[$2 + 56 >> 2] = 1;
      }
      HEAP32[$2 + 52 >> 2] = 1;
     }
    }
    if (!(HEAPU8[$2 + 68 | 0] ? HEAP32[$2 + 52 >> 2] : 0)) {
     HEAP32[$2 + 64 >> 2] = 0;
     HEAP32[$2 + 56 >> 2] = 0;
     HEAP32[$2 + 60 >> 2] = 0;
     HEAP32[$2 + 52 >> 2] = 0;
    }
    if (HEAP32[$2 + 52 >> 2]) {
     HEAP32[$2 + 32 >> 2] = 0;
     while (1) {
      if (HEAP32[$2 + 32 >> 2] < 8) {
       $0 = itoch(HEAPU8[HEAP32[$2 + 32 >> 2] + ($2 + 68 | 0) | 0] >>> 4 | 0);
       HEAP8[(HEAP32[$2 + 32 >> 2] << 1) + $2 | 0] = $0;
       $0 = itoch(HEAPU8[HEAP32[$2 + 32 >> 2] + ($2 + 68 | 0) | 0] & 15);
       HEAP8[((HEAP32[$2 + 32 >> 2] << 1) + 1 | 0) + $2 | 0] = $0;
       HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 32 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP8[$2 + 16 | 0] = 0;
     jsvArrayPushString(HEAP32[$2 + 76 >> 2], $2);
    }
    continue;
   }
   break;
  }
  HEAP32[$2 + 92 >> 2] = HEAP32[$2 + 76 >> 2];
 }
 __stack_pointer = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}

function tflite__ParseFullyConnected_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 tflite___28anonymous_20namespace_29__CheckParsePointerParams_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29(HEAP32[$4 + 40 >> 2], HEAP32[$4 + 36 >> 2], HEAP32[$4 + 32 >> 2], HEAP32[$4 + 28 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($4 + 24 | 0, HEAP32[$4 + 32 >> 2]);
 std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteFullyConnectedParams__28_29($4 + 16 | 0, $4 + 24 | 0);
 label$1: {
  if (!(bool_20std____2__operator___TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($4 + 16 | 0, 0) & 1)) {
   $0 = HEAP32[$4 + 36 >> 2];
   $1 = HEAP32[$4 + 36 >> 2];
   HEAP32[$4 >> 2] = 120702;
   tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($0, $1, 140586, $4);
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 8 >> 2] = tflite__Operator__builtin_options_as_FullyConnectedOptions_28_29_20const(HEAP32[$4 + 40 >> 2]);
  if (HEAP32[$4 + 8 >> 2]) {
   $0 = tflite___28anonymous_20namespace_29__ConvertActivation_28tflite__ActivationFunctionType_29(tflite__FullyConnectedOptions__fused_activation_function_28_29_20const(HEAP32[$4 + 8 >> 2]));
   HEAP32[std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) >> 2] = $0;
   $0 = tflite__FullyConnectedOptions__keep_num_dims_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAP8[std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 8 | 0] = $0;
   $0 = tflite__FullyConnectedOptions__asymmetric_quantize_inputs_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAP8[std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 9 | 0] = $0;
   label$4: {
    label$5: {
     switch (tflite__FullyConnectedOptions__weights_format_28_29_20const(HEAP32[$4 + 8 >> 2]) | 0) {
     case 0:
      HEAP32[std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 4 >> 2] = 0;
      break label$4;

     case 1:
      HEAP32[std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 4 >> 2] = 1;
      break label$4;

     default:
      break label$5;
     }
    }
    tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$4 + 36 >> 2], 140233, 0);
    HEAP32[$4 + 44 >> 2] = 1;
    break label$1;
   }
  }
  $0 = std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($4 + 16 | 0);
  HEAP32[HEAP32[$4 + 28 >> 2] >> 2] = $0;
  HEAP32[$4 + 44 >> 2] = 0;
 }
 HEAP32[$4 + 12 >> 2] = 1;
 std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($4 + 16 | 0);
 __stack_pointer = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}

function jsiDumpHardwareInitialisation($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 96 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 92 >> 2] = $0;
 HEAP32[$3 + 88 >> 2] = $1;
 HEAP8[$3 + 87 | 0] = $2;
 if (HEAP16[182206] & 1) {
  FUNCTION_TABLE[HEAP32[$3 + 92 >> 2]](138694, HEAP32[$3 + 88 >> 2]);
 }
 if (HEAPU8[195665] != 255) {
  $0 = HEAP32[$3 + 92 >> 2];
  $1 = HEAP32[$3 + 88 >> 2];
  HEAP32[$3 + 64 >> 2] = HEAPU8[195665];
  cbprintf($0, $1, 147351, $3 - -64 | 0);
 }
 if (HEAPU8[195666] != 255) {
  $0 = HEAP32[$3 + 92 >> 2];
  $1 = HEAP32[$3 + 88 >> 2];
  HEAP32[$3 + 48 >> 2] = HEAPU8[195666];
  cbprintf($0, $1, 147374, $3 + 48 | 0);
 }
 if (!(!(HEAP8[$3 + 87 | 0] & 1) | !HEAPU8[196320])) {
  HEAP32[$3 + 80 >> 2] = jsfGetFlags();
  $0 = HEAP32[$3 + 92 >> 2];
  $1 = HEAP32[$3 + 88 >> 2];
  HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 80 >> 2];
  cbprintf($0, $1, 147398, $3 + 32 | 0);
  jsvUnLock(HEAP32[$3 + 80 >> 2]);
 }
 jsiDumpSerialInitialisation(HEAP32[$3 + 92 >> 2], HEAP32[$3 + 88 >> 2], 138161, HEAP8[$3 + 87 | 0] & 1);
 HEAP32[$3 + 76 >> 2] = 0;
 while (1) {
  if (HEAP32[$3 + 76 >> 2] <= 0) {
   jsiDumpSerialInitialisation(HEAP32[$3 + 92 >> 2], HEAP32[$3 + 88 >> 2], jshGetDeviceString(HEAP32[$3 + 76 >> 2] + 22 & 255), HEAP8[$3 + 87 | 0] & 1);
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$3 + 76 >> 2] = 0;
 while (1) {
  if (HEAP32[$3 + 76 >> 2] <= 0) {
   jsiDumpDeviceInitialisation(HEAP32[$3 + 92 >> 2], HEAP32[$3 + 88 >> 2], jshGetDeviceString(HEAP32[$3 + 76 >> 2] + 26 & 255));
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$3 + 76 >> 2] = 0;
 while (1) {
  if (HEAP32[$3 + 76 >> 2] <= 0) {
   jsiDumpDeviceInitialisation(HEAP32[$3 + 92 >> 2], HEAP32[$3 + 88 >> 2], jshGetDeviceString(HEAP32[$3 + 76 >> 2] + 27 & 255));
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP8[$3 + 75 | 0] = 0;
 while (1) {
  $0 = 0;
  if (jshIsPinValid(HEAPU8[$3 + 75 | 0]) & 1) {
   $0 = HEAPU8[$3 + 75 | 0] < 48;
  }
  if ($0) {
   label$14: {
    if (HEAPU8[$3 + 75 | 0] == 5 | HEAPU8[$3 + 75 | 0] == 6 | (HEAPU8[$3 + 75 | 0] == 7 | HEAPU8[$3 + 75 | 0] == 26)) {
     break label$14;
    }
    if (HEAPU8[$3 + 75 | 0] == 27 | HEAPU8[$3 + 75 | 0] == 8 | (HEAPU8[$3 + 75 | 0] == 23 | HEAPU8[$3 + 75 | 0] == 3)) {
     break label$14;
    }
    if (HEAPU8[$3 + 75 | 0] == 33 | HEAPU8[$3 + 75 | 0] == 34 | (HEAPU8[$3 + 75 | 0] == 35 | HEAPU8[$3 + 75 | 0] == 36)) {
     break label$14;
    }
    if (HEAPU8[$3 + 75 | 0] == 19) {
     break label$14;
    }
    HEAP8[$3 + 74 | 0] = jshPinGetState(HEAPU8[$3 + 75 | 0]);
    HEAP8[$3 + 73 | 0] = HEAPU8[$3 + 74 | 0] & 15;
    label$16: {
     label$17: {
      if (HEAPU8[$3 + 73 | 0] != 1) {
       break label$17;
      }
      if (jshGetPinStateIsManual(HEAPU8[$3 + 75 | 0]) & 1) {
       break label$17;
      }
      HEAP8[$3 + 72 | 0] = (HEAPU8[$3 + 74 | 0] & 16) != 0;
      if (!(HEAP8[$3 + 72 | 0] & 1 | HEAPU8[$3 + 75 | 0] != 8)) {
       break label$14;
      }
      $0 = HEAP32[$3 + 92 >> 2];
      $1 = HEAP32[$3 + 88 >> 2];
      $2 = HEAPU8[$3 + 75 | 0];
      HEAP32[$3 + 20 >> 2] = HEAP8[$3 + 72 | 0] & 1;
      HEAP32[$3 + 16 >> 2] = $2;
      cbprintf($0, $1, 147415, $3 + 16 | 0);
      break label$16;
     }
     if (!(HEAPU8[$3 + 75 | 0] != 17 | HEAPU8[$3 + 73 | 0] != 6)) {
      break label$14;
     }
     if (!(jshIsPinStateDefault(HEAPU8[$3 + 75 | 0], HEAPU8[$3 + 73 | 0]) & 1)) {
      HEAP32[$3 + 68 >> 2] = jswrap_io_getPinMode(HEAPU8[$3 + 75 | 0]);
      if (HEAP32[$3 + 68 >> 2]) {
       $0 = HEAP32[$3 + 92 >> 2];
       $1 = HEAP32[$3 + 88 >> 2];
       $2 = HEAPU8[$3 + 75 | 0];
       $4 = HEAP32[$3 + 68 >> 2];
       HEAP32[$3 + 8 >> 2] = jshGetPinStateIsManual(HEAPU8[$3 + 75 | 0]) & 1 ? 148267 : 131759;
       HEAP32[$3 + 4 >> 2] = $4;
       HEAP32[$3 >> 2] = $2;
       cbprintf($0, $1, 147331, $3);
      }
      jsvUnLock(HEAP32[$3 + 68 >> 2]);
     }
    }
   }
   HEAP8[$3 + 75 | 0] = HEAPU8[$3 + 75 | 0] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $3 + 96 | 0;
}

function tflite__reference_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0;
 $9 = __stack_pointer - 112 | 0;
 __stack_pointer = $9;
 HEAP32[$9 + 108 >> 2] = $0;
 HEAP32[$9 + 104 >> 2] = $1;
 HEAP32[$9 + 100 >> 2] = $2;
 HEAP32[$9 + 96 >> 2] = $3;
 HEAP32[$9 + 92 >> 2] = $4;
 HEAP32[$9 + 88 >> 2] = $5;
 HEAP32[$9 + 84 >> 2] = $6;
 HEAP32[$9 + 80 >> 2] = $7;
 HEAP32[$9 + 76 >> 2] = $8;
 HEAP32[$9 + 72 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] >> 2];
 HEAP32[$9 + 68 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 4 >> 2];
 HEAP32[$9 + 64 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 8 >> 2];
 HEAP32[$9 + 60 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 12 >> 2];
 HEAP32[$9 + 56 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 16 >> 2];
 HEAP32[$9 + 52 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 20 >> 2];
 HEAP32[$9 + 48 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 24 >> 2];
 label$1: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 96 >> 2]) | 0) < 2) {
   break label$1;
  }
 }
 label$2: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 80 >> 2]) | 0) <= 0) {
   break label$2;
  }
 }
 label$3: {
  if (HEAP32[$9 + 52 >> 2] > HEAP32[$9 + 48 >> 2]) {
   break label$3;
  }
 }
 HEAP32[$9 + 44 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 80 >> 2]);
 HEAP32[$9 + 40 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 96 >> 2]);
 HEAP32[$9 + 36 >> 2] = tflite__FlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 80 >> 2], HEAP32[$9 + 44 >> 2] - 1 | 0);
 HEAP32[$9 + 32 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 96 >> 2], HEAP32[$9 + 40 >> 2] - 2 | 0, HEAP32[$9 + 80 >> 2], HEAP32[$9 + 44 >> 2] - 1 | 0);
 HEAP32[$9 + 28 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 96 >> 2], HEAP32[$9 + 40 >> 2] - 1 | 0);
 HEAP32[$9 + 24 >> 2] = 0;
 while (1) {
  if (HEAP32[$9 + 24 >> 2] < HEAP32[$9 + 36 >> 2]) {
   HEAP32[$9 + 20 >> 2] = 0;
   while (1) {
    if (HEAP32[$9 + 20 >> 2] < HEAP32[$9 + 32 >> 2]) {
     HEAP32[$9 + 16 >> 2] = 0;
     HEAP32[$9 + 12 >> 2] = 0;
     while (1) {
      if (HEAP32[$9 + 12 >> 2] < HEAP32[$9 + 28 >> 2]) {
       HEAP32[$9 + 8 >> 2] = HEAPU8[HEAP32[$9 + 100 >> 2] + (HEAP32[$9 + 12 >> 2] + Math_imul(HEAP32[$9 + 24 >> 2], HEAP32[$9 + 28 >> 2]) | 0) | 0];
       HEAP32[$9 + 4 >> 2] = HEAPU8[HEAP32[$9 + 92 >> 2] + (HEAP32[$9 + 12 >> 2] + Math_imul(HEAP32[$9 + 20 >> 2], HEAP32[$9 + 28 >> 2]) | 0) | 0];
       HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 16 >> 2] + Math_imul(HEAP32[$9 + 4 >> 2] + HEAP32[$9 + 68 >> 2] | 0, HEAP32[$9 + 8 >> 2] + HEAP32[$9 + 72 >> 2] | 0);
       HEAP32[$9 + 12 >> 2] = HEAP32[$9 + 12 >> 2] + 1;
       continue;
      }
      break;
     }
     if (HEAP32[$9 + 84 >> 2]) {
      HEAP32[$9 + 16 >> 2] = HEAP32[HEAP32[$9 + 84 >> 2] + (HEAP32[$9 + 20 >> 2] << 2) >> 2] + HEAP32[$9 + 16 >> 2];
     }
     HEAP32[$9 + 16 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$9 + 16 >> 2], HEAP32[$9 + 60 >> 2], HEAP32[$9 + 56 >> 2]);
     HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 64 >> 2] + HEAP32[$9 + 16 >> 2];
     HEAP32[$9 + 16 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($9 + 16 | 0, $9 + 52 | 0) >> 2];
     HEAP32[$9 + 16 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($9 + 16 | 0, $9 + 48 | 0) >> 2];
     HEAP8[HEAP32[$9 + 76 >> 2] + (HEAP32[$9 + 20 >> 2] + Math_imul(HEAP32[$9 + 32 >> 2], HEAP32[$9 + 24 >> 2]) | 0) | 0] = HEAP32[$9 + 16 >> 2];
     HEAP32[$9 + 20 >> 2] = HEAP32[$9 + 20 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$9 + 24 >> 2] = HEAP32[$9 + 24 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $9 + 112 | 0;
}

function jswrap_graphics_blit($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 224 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 216 >> 2] = $0;
 HEAP32[$2 + 212 >> 2] = $1;
 label$1: {
  if (!(graphicsGetFromVar($2 + 136 | 0, HEAP32[$2 + 216 >> 2]) & 1)) {
   HEAP32[$2 + 220 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 132 >> 2] = HEAPU8[$2 + 148 | 0] | HEAPU8[$2 + 149 | 0] << 8;
  HEAP32[$2 + 128 >> 2] = HEAPU8[$2 + 150 | 0] | HEAPU8[$2 + 151 | 0] << 8;
  HEAP32[$2 + 124 >> 2] = 0;
  HEAP32[$2 + 120 >> 2] = 0;
  HEAP32[$2 + 116 >> 2] = 0;
  HEAP32[$2 + 112 >> 2] = 0;
  HEAP32[$2 + 108 >> 2] = 0;
  HEAP32[$2 + 104 >> 2] = 0;
  HEAP8[$2 + 103 | 0] = 0;
  HEAP32[$2 + 16 >> 2] = 139857;
  HEAP16[$2 + 20 >> 1] = 10;
  HEAP32[$2 + 24 >> 2] = $2 + 124;
  HEAP32[$2 + 28 >> 2] = 139854;
  HEAP16[$2 + 32 >> 1] = 10;
  HEAP32[$2 + 36 >> 2] = $2 + 120;
  HEAP32[$2 + 40 >> 2] = 116775;
  HEAP16[$2 + 44 >> 1] = 10;
  HEAP32[$2 + 48 >> 2] = $2 + 116;
  HEAP32[$2 + 52 >> 2] = 129676;
  HEAP16[$2 + 56 >> 1] = 10;
  HEAP32[$2 + 60 >> 2] = $2 + 112;
  HEAP32[$2 + 64 >> 2] = 139550;
  HEAP16[$2 + 68 >> 1] = 10;
  HEAP32[$2 + 72 >> 2] = $2 + 108;
  HEAP32[$2 + 76 >> 2] = 139547;
  HEAP16[$2 + 80 >> 1] = 10;
  HEAP32[$2 + 84 >> 2] = $2 + 104;
  HEAP32[$2 + 88 >> 2] = 134117;
  HEAP16[$2 + 92 >> 1] = 12;
  HEAP32[$2 + 96 >> 2] = $2 + 103;
  label$3: {
   if (jsvIsObject(HEAP32[$2 + 212 >> 2]) & 1) {
    if (jsvReadConfigObject(HEAP32[$2 + 212 >> 2], $2 + 16 | 0, 7) & 1) {
     break label$3;
    }
   }
   jsExceptionHere(1, 120084, 0);
   HEAP32[$2 + 220 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$2 + 124 >> 2] < 0) {
   HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 108 >> 2] - HEAP32[$2 + 124 >> 2];
   HEAP32[$2 + 116 >> 2] = HEAP32[$2 + 124 >> 2] + HEAP32[$2 + 116 >> 2];
   HEAP32[$2 + 124 >> 2] = 0;
  }
  if (HEAP32[$2 + 120 >> 2] < 0) {
   HEAP32[$2 + 104 >> 2] = HEAP32[$2 + 104 >> 2] - HEAP32[$2 + 120 >> 2];
   HEAP32[$2 + 112 >> 2] = HEAP32[$2 + 120 >> 2] + HEAP32[$2 + 112 >> 2];
   HEAP32[$2 + 120 >> 2] = 0;
  }
  HEAP32[$2 + 12 >> 2] = (HEAP32[$2 + 124 >> 2] + HEAP32[$2 + 116 >> 2] | 0) - HEAP32[$2 + 132 >> 2];
  if (HEAP32[$2 + 12 >> 2] > 0) {
   HEAP32[$2 + 116 >> 2] = HEAP32[$2 + 116 >> 2] - HEAP32[$2 + 12 >> 2];
  }
  HEAP32[$2 + 12 >> 2] = (HEAP32[$2 + 120 >> 2] + HEAP32[$2 + 112 >> 2] | 0) - HEAP32[$2 + 128 >> 2];
  if (HEAP32[$2 + 12 >> 2] > 0) {
   HEAP32[$2 + 112 >> 2] = HEAP32[$2 + 112 >> 2] - HEAP32[$2 + 12 >> 2];
  }
  if (HEAP32[$2 + 108 >> 2] < 0) {
   HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 124 >> 2] - HEAP32[$2 + 108 >> 2];
   HEAP32[$2 + 116 >> 2] = HEAP32[$2 + 108 >> 2] + HEAP32[$2 + 116 >> 2];
   HEAP32[$2 + 108 >> 2] = 0;
  }
  if (HEAP32[$2 + 104 >> 2] < 0) {
   HEAP32[$2 + 120 >> 2] = HEAP32[$2 + 120 >> 2] - HEAP32[$2 + 104 >> 2];
   HEAP32[$2 + 112 >> 2] = HEAP32[$2 + 104 >> 2] + HEAP32[$2 + 112 >> 2];
   HEAP32[$2 + 104 >> 2] = 0;
  }
  HEAP32[$2 + 12 >> 2] = (HEAP32[$2 + 108 >> 2] + HEAP32[$2 + 116 >> 2] | 0) - HEAP32[$2 + 132 >> 2];
  if (HEAP32[$2 + 12 >> 2] > 0) {
   HEAP32[$2 + 116 >> 2] = HEAP32[$2 + 116 >> 2] - HEAP32[$2 + 12 >> 2];
  }
  HEAP32[$2 + 12 >> 2] = (HEAP32[$2 + 104 >> 2] + HEAP32[$2 + 112 >> 2] | 0) - HEAP32[$2 + 128 >> 2];
  if (HEAP32[$2 + 12 >> 2] > 0) {
   HEAP32[$2 + 112 >> 2] = HEAP32[$2 + 112 >> 2] - HEAP32[$2 + 12 >> 2];
  }
  if (!(HEAP32[$2 + 116 >> 2] <= 0 & HEAP32[$2 + 112 >> 2] <= 0)) {
   FUNCTION_TABLE[HEAPU8[$2 + 200 | 0] | HEAPU8[$2 + 201 | 0] << 8 | (HEAPU8[$2 + 202 | 0] << 16 | HEAPU8[$2 + 203 | 0] << 24)]($2 + 136 | 0, HEAP32[$2 + 124 >> 2], HEAP32[$2 + 120 >> 2], HEAP32[$2 + 116 >> 2], HEAP32[$2 + 112 >> 2], HEAP32[$2 + 108 >> 2], HEAP32[$2 + 104 >> 2]);
   if (HEAP8[$2 + 103 | 0] & 1) {
    graphicsSetModified($2 + 136 | 0, HEAP32[$2 + 108 >> 2], HEAP32[$2 + 104 >> 2], HEAP32[$2 + 108 >> 2] + HEAP32[$2 + 116 >> 2] | 0, HEAP32[$2 + 104 >> 2] + HEAP32[$2 + 112 >> 2] | 0);
    graphicsSetVar($2 + 136 | 0);
   }
  }
  HEAP32[$2 + 220 >> 2] = jsvLockAgain(HEAP32[$2 + 216 >> 2]);
 }
 __stack_pointer = $2 + 224 | 0;
 return HEAP32[$2 + 220 >> 2];
}

function tflite__ParseConv2D_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 tflite___28anonymous_20namespace_29__CheckParsePointerParams_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29(HEAP32[$4 + 40 >> 2], HEAP32[$4 + 36 >> 2], HEAP32[$4 + 32 >> 2], HEAP32[$4 + 28 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($4 + 24 | 0, HEAP32[$4 + 32 >> 2]);
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteConvParams__28_29($4 + 16 | 0, $4 + 24 | 0);
 label$1: {
  if (!(bool_20std____2__operator___TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($4 + 16 | 0, 0) & 1)) {
   $0 = HEAP32[$4 + 36 >> 2];
   $1 = HEAP32[$4 + 36 >> 2];
   HEAP32[$4 >> 2] = 120702;
   tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($0, $1, 140586, $4);
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 8 >> 2] = tflite__Operator__builtin_options_as_Conv2DOptions_28_29_20const(HEAP32[$4 + 40 >> 2]);
  if (HEAP32[$4 + 8 >> 2]) {
   $0 = tflite___28anonymous_20namespace_29__ConvertPadding_28tflite__Padding_29(tflite__Conv2DOptions__padding_28_29_20const(HEAP32[$4 + 8 >> 2]));
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) >> 2] = $0;
   $0 = tflite__Conv2DOptions__stride_w_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 4 >> 2] = $0;
   $0 = tflite__Conv2DOptions__stride_h_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 8 >> 2] = $0;
   $0 = tflite___28anonymous_20namespace_29__ConvertActivation_28tflite__ActivationFunctionType_29(tflite__Conv2DOptions__fused_activation_function_28_29_20const(HEAP32[$4 + 8 >> 2]));
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 12 >> 2] = $0;
   $0 = tflite__Conv2DOptions__dilation_w_factor_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 16 >> 2] = $0;
   $0 = tflite__Conv2DOptions__dilation_h_factor_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAP32[std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 20 >> 2] = $0;
  }
  $0 = std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($4 + 16 | 0);
  HEAP32[HEAP32[$4 + 28 >> 2] >> 2] = $0;
  HEAP32[$4 + 44 >> 2] = 0;
 }
 HEAP32[$4 + 12 >> 2] = 1;
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($4 + 16 | 0);
 __stack_pointer = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}

function tflite__ParsePool_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 tflite___28anonymous_20namespace_29__CheckParsePointerParams_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29(HEAP32[$4 + 40 >> 2], HEAP32[$4 + 36 >> 2], HEAP32[$4 + 32 >> 2], HEAP32[$4 + 28 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($4 + 24 | 0, HEAP32[$4 + 32 >> 2]);
 std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLitePoolParams__28_29($4 + 16 | 0, $4 + 24 | 0);
 label$1: {
  if (!(bool_20std____2__operator___TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($4 + 16 | 0, 0) & 1)) {
   $0 = HEAP32[$4 + 36 >> 2];
   $1 = HEAP32[$4 + 36 >> 2];
   HEAP32[$4 >> 2] = 120702;
   tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($0, $1, 140586, $4);
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 8 >> 2] = tflite__Operator__builtin_options_as_Pool2DOptions_28_29_20const(HEAP32[$4 + 40 >> 2]);
  if (HEAP32[$4 + 8 >> 2]) {
   $0 = tflite___28anonymous_20namespace_29__ConvertPadding_28tflite__Padding_29(tflite__Pool2DOptions__padding_28_29_20const(HEAP32[$4 + 8 >> 2]));
   HEAP32[std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) >> 2] = $0;
   $0 = tflite__Pool2DOptions__stride_w_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAP32[std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 4 >> 2] = $0;
   $0 = tflite__Pool2DOptions__stride_h_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAP32[std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 8 >> 2] = $0;
   $0 = tflite__Pool2DOptions__filter_width_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAP32[std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 12 >> 2] = $0;
   $0 = tflite__Pool2DOptions__filter_height_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAP32[std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 16 >> 2] = $0;
   $0 = tflite___28anonymous_20namespace_29__ConvertActivation_28tflite__ActivationFunctionType_29(tflite__Pool2DOptions__fused_activation_function_28_29_20const(HEAP32[$4 + 8 >> 2]));
   HEAP32[std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) + 20 >> 2] = $0;
  }
  $0 = std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($4 + 16 | 0);
  HEAP32[HEAP32[$4 + 28 >> 2] >> 2] = $0;
  HEAP32[$4 + 44 >> 2] = 0;
 }
 HEAP32[$4 + 12 >> 2] = 1;
 std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($4 + 16 | 0);
 __stack_pointer = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}

function jswrap_e_dumpVariables() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0;
 $0 = __stack_pointer - 128 | 0;
 __stack_pointer = $0;
 jsiConsolePrintf(147869, 0);
 HEAP32[$0 + 124 >> 2] = 0;
 while (1) {
  if (HEAPU32[$0 + 124 >> 2] < jsvGetMemoryTotal() >>> 0) {
   HEAP16[$0 + 122 >> 1] = HEAP32[$0 + 124 >> 2] + 1;
   HEAP32[$0 + 116 >> 2] = _jsvGetAddressOf(HEAPU16[$0 + 122 >> 1]);
   $1 = HEAP32[$0 + 116 >> 2];
   label$3: {
    if (!((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63)) {
     break label$3;
    }
    if (jsvIsStringExt(HEAP32[$0 + 116 >> 2]) & 1) {
     break label$3;
    }
    HEAP32[$0 + 112 >> 2] = 1;
    label$4: {
     if (jsvIsFlatString(HEAP32[$0 + 116 >> 2]) & 1) {
      HEAP32[$0 + 108 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 116 >> 2]);
      HEAP32[$0 + 124 >> 2] = HEAP32[$0 + 108 >> 2] + HEAP32[$0 + 124 >> 2];
      HEAP32[$0 + 112 >> 2] = HEAP32[$0 + 108 >> 2] + HEAP32[$0 + 112 >> 2];
      break label$4;
     }
     if (jsvHasCharacterData(HEAP32[$0 + 116 >> 2]) & 1) {
      HEAP16[$0 + 106 >> 1] = jsvGetLastChild(HEAP32[$0 + 116 >> 2]);
      while (1) {
       if (HEAPU16[$0 + 106 >> 1]) {
        HEAP32[$0 + 100 >> 2] = jsvLock(HEAPU16[$0 + 106 >> 1]);
        HEAP32[$0 + 112 >> 2] = HEAP32[$0 + 112 >> 2] + 1;
        HEAP16[$0 + 106 >> 1] = jsvGetLastChild(HEAP32[$0 + 100 >> 2]);
        jsvUnLock(HEAP32[$0 + 100 >> 2]);
        continue;
       }
       break;
      }
     }
    }
    $2 = HEAPU16[$0 + 122 >> 1];
    $3 = HEAP32[$0 + 112 >> 2];
    $1 = HEAP32[$0 + 116 >> 2];
    HEAP32[$0 + 72 >> 2] = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63;
    HEAP32[$0 + 68 >> 2] = $3;
    HEAP32[$0 + 64 >> 2] = $2;
    jsiConsolePrintf(141313, $0 - -64 | 0);
    label$9: {
     if (jsvIsName(HEAP32[$0 + 116 >> 2]) & 1) {
      HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 116 >> 2];
      jsiConsolePrintf(141280, $0 + 16 | 0);
      break label$9;
     }
     label$11: {
      if (jsvIsNumeric(HEAP32[$0 + 116 >> 2]) & 1) {
       HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 116 >> 2];
       jsiConsolePrintf(141284, $0 + 32 | 0);
       break label$11;
      }
      label$13: {
       if (jsvIsString(HEAP32[$0 + 116 >> 2]) & 1) {
        label$15: {
         if (jsvGetStringLength(HEAP32[$0 + 116 >> 2]) >>> 0 > 20) {
          HEAP32[$0 + 96 >> 2] = jsvNewWritableStringFromStringVar(HEAP32[$0 + 116 >> 2], 0, 17);
          jsvAppendString(HEAP32[$0 + 96 >> 2], 141032);
          break label$15;
         }
         HEAP32[$0 + 96 >> 2] = jsvLockAgain(HEAP32[$0 + 116 >> 2]);
        }
        HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 96 >> 2];
        jsiConsolePrintf(141295, $0 + 48 | 0);
        jsvUnLock(HEAP32[$0 + 96 >> 2]);
        break label$13;
       }
       label$17: {
        if (jsvIsObject(HEAP32[$0 + 116 >> 2]) & 1) {
         jsiConsolePrintf(141272, 0);
         break label$17;
        }
        label$19: {
         if (jsvIsArray(HEAP32[$0 + 116 >> 2]) & 1) {
          jsiConsolePrintf(141265, 0);
          break label$19;
         }
         jsiConsolePrintf(141344, 0);
        }
       }
      }
     }
    }
    label$21: {
     if (!(jsvHasSingleChild(HEAP32[$0 + 116 >> 2]) & 1)) {
      if (!(jsvHasChildren(HEAP32[$0 + 116 >> 2]) & 1)) {
       break label$21;
      }
     }
     HEAP16[$0 + 94 >> 1] = jsvGetFirstChild(HEAP32[$0 + 116 >> 2]);
     while (1) {
      if (HEAPU16[$0 + 94 >> 1]) {
       HEAP32[$0 + 88 >> 2] = jsvLock(HEAPU16[$0 + 94 >> 1]);
       HEAP32[$0 >> 2] = HEAPU16[$0 + 94 >> 1];
       jsiConsolePrintf(141319, $0);
       label$25: {
        if (jsvHasChildren(HEAP32[$0 + 116 >> 2]) & 1) {
         HEAP16[$0 + 94 >> 1] = jsvGetNextSibling(HEAP32[$0 + 88 >> 2]);
         break label$25;
        }
        HEAP16[$0 + 94 >> 1] = 0;
       }
       jsvUnLock(HEAP32[$0 + 88 >> 2]);
       continue;
      }
      break;
     }
    }
    jsiConsolePrintString(148266);
   }
   HEAP32[$0 + 124 >> 2] = HEAP32[$0 + 124 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $0 + 128 | 0;
}

function tflite__ops__micro__conv__CalculateOpData_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLiteType_2c_20tflite__ops__micro__conv__OpData__29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0;
 $11 = __stack_pointer - 128 | 0;
 __stack_pointer = $11;
 HEAP32[$11 + 120 >> 2] = $0;
 HEAP32[$11 + 116 >> 2] = $1;
 HEAP32[$11 + 112 >> 2] = $2;
 HEAP32[$11 + 108 >> 2] = $3;
 HEAP32[$11 + 104 >> 2] = $4;
 HEAP32[$11 + 100 >> 2] = $5;
 HEAP32[$11 + 96 >> 2] = $6;
 HEAP32[$11 + 92 >> 2] = $7;
 HEAP32[$11 + 88 >> 2] = $8;
 HEAP32[$11 + 84 >> 2] = $9;
 HEAP32[$11 + 80 >> 2] = $10;
 HEAP8[$11 + 79 | 0] = HEAP32[HEAP32[HEAP32[$11 + 116 >> 2] >> 2] >> 2] == 3;
 label$1: {
  if (!(HEAP8[$11 + 79 | 0] & 1 | HEAP32[HEAP32[HEAP32[$11 + 116 >> 2] >> 2] >> 2] == 2)) {
   $0 = HEAP32[HEAP32[$11 + 120 >> 2] + 20 >> 2];
   $1 = HEAP32[$11 + 120 >> 2];
   HEAP32[$11 + 16 >> 2] = 139773;
   FUNCTION_TABLE[$0 | 0]($1, 140586, $11 + 16 | 0);
   HEAP32[$11 + 124 >> 2] = 1;
   break label$1;
  }
  if (HEAP32[HEAP32[HEAP32[$11 + 116 >> 2] + 4 >> 2] >> 2] != 1) {
   $0 = HEAP32[HEAP32[$11 + 120 >> 2] + 20 >> 2];
   $1 = HEAP32[$11 + 120 >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$11 + 116 >> 2] + 4 >> 2] >> 2];
   HEAP32[$11 + 12 >> 2] = 1;
   HEAP32[$11 + 8 >> 2] = $2;
   HEAP32[$11 + 4 >> 2] = 139997;
   HEAP32[$11 >> 2] = 131572;
   FUNCTION_TABLE[$0 | 0]($1, 143305, $11);
   HEAP32[$11 + 124 >> 2] = 1;
   break label$1;
  }
  HEAP32[$11 + 72 >> 2] = HEAP32[HEAP32[$11 + 112 >> 2] >> 2];
  tflite__ComputePaddingHeightWidth_28int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLitePadding_2c_20int__2c_20int__29($11 + 56 | 0, HEAP32[HEAP32[$11 + 112 >> 2] + 8 >> 2], HEAP32[HEAP32[$11 + 112 >> 2] + 4 >> 2], HEAP32[HEAP32[$11 + 112 >> 2] + 20 >> 2], HEAP32[HEAP32[$11 + 112 >> 2] + 16 >> 2], HEAP32[$11 + 104 >> 2], HEAP32[$11 + 108 >> 2], HEAP32[$11 + 96 >> 2], HEAP32[$11 + 100 >> 2], HEAP32[$11 + 72 >> 2], $11 + 88 | 0, $11 + 92 | 0);
  $0 = HEAP32[$11 + 60 >> 2];
  $1 = HEAP32[$11 + 56 >> 2];
  $3 = $1;
  $2 = HEAP32[$11 + 80 >> 2];
  $1 = $2;
  HEAP32[$1 >> 2] = $3;
  HEAP32[$1 + 4 >> 2] = $0;
  $1 = HEAP32[$11 + 68 >> 2];
  $0 = HEAP32[$11 + 64 >> 2];
  $3 = $0;
  $0 = $2;
  HEAP32[$0 + 8 >> 2] = $3;
  HEAP32[$0 + 12 >> 2] = $1;
  if (HEAP32[$11 + 84 >> 2] != 1) {
   HEAP32[$11 + 52 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$11 + 120 >> 2], HEAP32[$11 + 116 >> 2], 0);
   HEAP32[$11 + 48 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$11 + 120 >> 2], HEAP32[$11 + 116 >> 2], 1);
   HEAP32[$11 + 44 >> 2] = tflite__GetOptionalInputTensor_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$11 + 120 >> 2], HEAP32[$11 + 116 >> 2], 2);
   HEAP32[$11 + 40 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$11 + 120 >> 2], HEAP32[$11 + 116 >> 2], 0);
   HEAP32[$11 + 36 >> 2] = HEAP32[HEAP32[HEAP32[$11 + 48 >> 2] + 20 >> 2] + 4 >> 2];
   HEAP32[$11 + 32 >> 2] = tflite__PopulateConvolutionQuantizationParams_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20TfLiteFusedActivation_20const__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int_29(HEAP32[$11 + 120 >> 2], HEAP32[$11 + 52 >> 2], HEAP32[$11 + 48 >> 2], HEAP32[$11 + 44 >> 2], HEAP32[$11 + 40 >> 2], HEAP32[$11 + 112 >> 2] + 12 | 0, HEAP32[$11 + 80 >> 2] + 28 | 0, HEAP32[$11 + 80 >> 2] + 32 | 0, HEAP32[$11 + 80 >> 2] + 44 | 0, HEAP32[$11 + 80 >> 2] + 48 | 0, HEAP32[HEAP32[$11 + 80 >> 2] + 36 >> 2], HEAP32[HEAP32[$11 + 80 >> 2] + 40 >> 2], HEAP32[$11 + 36 >> 2]);
   if (HEAP32[$11 + 32 >> 2]) {
    HEAP32[$11 + 124 >> 2] = HEAP32[$11 + 32 >> 2];
    break label$1;
   }
  }
  HEAP32[$11 + 124 >> 2] = 0;
 }
 __stack_pointer = $11 + 128 | 0;
 return HEAP32[$11 + 124 >> 2];
}

function __jspeAssignmentExpression($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 label$1: {
  label$2: {
   if (HEAP16[HEAP32[49079] + 2 >> 1] == 61 | HEAP16[HEAP32[49079] + 2 >> 1] == 150 | (HEAP16[HEAP32[49079] + 2 >> 1] == 151 | HEAP16[HEAP32[49079] + 2 >> 1] == 154)) {
    break label$2;
   }
   if (HEAP16[HEAP32[49079] + 2 >> 1] == 155 | HEAP16[HEAP32[49079] + 2 >> 1] == 156 | (HEAP16[HEAP32[49079] + 2 >> 1] == 157 | HEAP16[HEAP32[49079] + 2 >> 1] == 159)) {
    break label$2;
   }
   if (HEAP16[HEAP32[49079] + 2 >> 1] == 161 | HEAP16[HEAP32[49079] + 2 >> 1] == 148 | HEAP16[HEAP32[49079] + 2 >> 1] == 144) {
    break label$2;
   }
   if (HEAP16[HEAP32[49079] + 2 >> 1] != 149) {
    break label$1;
   }
  }
  HEAP32[$1 + 20 >> 2] = HEAP16[HEAP32[49079] + 2 >> 1];
  jslGetNextToken();
  HEAP32[$1 + 24 >> 2] = jspeAssignmentExpression();
  HEAP32[$1 + 24 >> 2] = jsvSkipNameAndUnLock(HEAP32[$1 + 24 >> 2]);
  if (!(!HEAP32[$1 + 28 >> 2] | (HEAP32[91094] & 63) != 1)) {
   label$4: {
    if (HEAP32[$1 + 20 >> 2] == 61) {
     jsvReplaceWithOrAddToRoot(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 24 >> 2]);
     break label$4;
    }
    label$6: {
     if (HEAP32[$1 + 20 >> 2] == 150) {
      HEAP32[$1 + 20 >> 2] = 43;
      break label$6;
     }
     label$8: {
      if (HEAP32[$1 + 20 >> 2] == 151) {
       HEAP32[$1 + 20 >> 2] = 45;
       break label$8;
      }
      label$10: {
       if (HEAP32[$1 + 20 >> 2] == 154) {
        HEAP32[$1 + 20 >> 2] = 42;
        break label$10;
       }
       label$12: {
        if (HEAP32[$1 + 20 >> 2] == 155) {
         HEAP32[$1 + 20 >> 2] = 47;
         break label$12;
        }
        label$14: {
         if (HEAP32[$1 + 20 >> 2] == 156) {
          HEAP32[$1 + 20 >> 2] = 37;
          break label$14;
         }
         label$16: {
          if (HEAP32[$1 + 20 >> 2] == 157) {
           HEAP32[$1 + 20 >> 2] = 38;
           break label$16;
          }
          label$18: {
           if (HEAP32[$1 + 20 >> 2] == 159) {
            HEAP32[$1 + 20 >> 2] = 124;
            break label$18;
           }
           label$20: {
            if (HEAP32[$1 + 20 >> 2] == 161) {
             HEAP32[$1 + 20 >> 2] = 94;
             break label$20;
            }
            label$22: {
             if (HEAP32[$1 + 20 >> 2] == 148) {
              HEAP32[$1 + 20 >> 2] = 146;
              break label$22;
             }
             label$24: {
              if (HEAP32[$1 + 20 >> 2] == 144) {
               HEAP32[$1 + 20 >> 2] = 143;
               break label$24;
              }
              if (HEAP32[$1 + 20 >> 2] == 149) {
               HEAP32[$1 + 20 >> 2] = 147;
              }
             }
            }
           }
          }
         }
        }
       }
      }
     }
    }
    label$27: {
     if (HEAP32[$1 + 20 >> 2] != 43) {
      break label$27;
     }
     if (!(jsvIsName(HEAP32[$1 + 28 >> 2]) & 1)) {
      break label$27;
     }
     HEAP32[$1 + 16 >> 2] = jsvSkipName(HEAP32[$1 + 28 >> 2]);
     label$28: {
      if (!(jsvIsBasicString(HEAP32[$1 + 16 >> 2]) & 1)) {
       break label$28;
      }
      if ((jsvGetRefs(HEAP32[$1 + 16 >> 2]) & 65535) != 1 | HEAP32[$1 + 24 >> 2] == HEAP32[$1 + 16 >> 2]) {
       break label$28;
      }
      HEAP32[$1 + 12 >> 2] = jsvAsString(HEAP32[$1 + 24 >> 2]);
      jsvAppendStringVarComplete(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2]);
      jsvUnLock(HEAP32[$1 + 12 >> 2]);
      HEAP32[$1 + 20 >> 2] = 0;
     }
     jsvUnLock(HEAP32[$1 + 16 >> 2]);
    }
    if (HEAP32[$1 + 20 >> 2]) {
     HEAP32[$1 + 8 >> 2] = jsvMathsOpSkipNames(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 24 >> 2], HEAP32[$1 + 20 >> 2]);
     jsvReplaceWith(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 8 >> 2]);
     jsvUnLock(HEAP32[$1 + 8 >> 2]);
    }
   }
  }
  jsvUnLock(HEAP32[$1 + 24 >> 2]);
  HEAP32[$1 + 28 >> 2] = jsvSkipNameAndUnLock(HEAP32[$1 + 28 >> 2]);
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function tflite__reference_integer_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0;
 $9 = __stack_pointer - 112 | 0;
 __stack_pointer = $9;
 HEAP32[$9 + 108 >> 2] = $0;
 HEAP32[$9 + 104 >> 2] = $1;
 HEAP32[$9 + 100 >> 2] = $2;
 HEAP32[$9 + 96 >> 2] = $3;
 HEAP32[$9 + 92 >> 2] = $4;
 HEAP32[$9 + 88 >> 2] = $5;
 HEAP32[$9 + 84 >> 2] = $6;
 HEAP32[$9 + 80 >> 2] = $7;
 HEAP32[$9 + 76 >> 2] = $8;
 HEAP32[$9 + 72 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] >> 2];
 HEAP32[$9 + 68 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 4 >> 2];
 HEAP32[$9 + 64 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 8 >> 2];
 HEAP32[$9 + 60 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 12 >> 2];
 HEAP32[$9 + 56 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 16 >> 2];
 HEAP32[$9 + 52 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 20 >> 2];
 HEAP32[$9 + 48 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 24 >> 2];
 label$1: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 96 >> 2]) | 0) < 2) {
   break label$1;
  }
 }
 label$2: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 80 >> 2]) | 0) != 2) {
   break label$2;
  }
 }
 label$3: {
  if (HEAP32[$9 + 52 >> 2] > HEAP32[$9 + 48 >> 2]) {
   break label$3;
  }
 }
 HEAP32[$9 + 44 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 96 >> 2]);
 HEAP32[$9 + 40 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 80 >> 2], 0);
 HEAP32[$9 + 36 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 80 >> 2], 1);
 label$4: {
  if (HEAP32[$9 + 36 >> 2] > (tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 96 >> 2], HEAP32[$9 + 44 >> 2] - 2 | 0) | 0)) {
   break label$4;
  }
 }
 HEAP32[$9 + 32 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 96 >> 2], HEAP32[$9 + 44 >> 2] - 1 | 0);
 HEAP32[$9 + 28 >> 2] = 0;
 while (1) {
  if (HEAP32[$9 + 28 >> 2] < HEAP32[$9 + 40 >> 2]) {
   HEAP32[$9 + 24 >> 2] = 0;
   while (1) {
    if (HEAP32[$9 + 24 >> 2] < HEAP32[$9 + 36 >> 2]) {
     HEAP32[$9 + 20 >> 2] = 0;
     HEAP32[$9 + 16 >> 2] = 0;
     while (1) {
      if (HEAP32[$9 + 16 >> 2] < HEAP32[$9 + 32 >> 2]) {
       HEAP32[$9 + 12 >> 2] = HEAP8[HEAP32[$9 + 100 >> 2] + (HEAP32[$9 + 16 >> 2] + Math_imul(HEAP32[$9 + 28 >> 2], HEAP32[$9 + 32 >> 2]) | 0) | 0];
       HEAP32[$9 + 8 >> 2] = HEAP8[HEAP32[$9 + 92 >> 2] + (HEAP32[$9 + 16 >> 2] + Math_imul(HEAP32[$9 + 24 >> 2], HEAP32[$9 + 32 >> 2]) | 0) | 0];
       HEAP32[$9 + 20 >> 2] = HEAP32[$9 + 20 >> 2] + Math_imul(HEAP32[$9 + 8 >> 2] + HEAP32[$9 + 68 >> 2] | 0, HEAP32[$9 + 12 >> 2] + HEAP32[$9 + 72 >> 2] | 0);
       HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 16 >> 2] + 1;
       continue;
      }
      break;
     }
     if (HEAP32[$9 + 84 >> 2]) {
      HEAP32[$9 + 20 >> 2] = HEAP32[HEAP32[$9 + 84 >> 2] + (HEAP32[$9 + 24 >> 2] << 2) >> 2] + HEAP32[$9 + 20 >> 2];
     }
     HEAP32[$9 + 20 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$9 + 20 >> 2], HEAP32[$9 + 60 >> 2], HEAP32[$9 + 56 >> 2]);
     HEAP32[$9 + 20 >> 2] = HEAP32[$9 + 64 >> 2] + HEAP32[$9 + 20 >> 2];
     HEAP32[$9 + 20 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($9 + 20 | 0, $9 + 52 | 0) >> 2];
     HEAP32[$9 + 20 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($9 + 20 | 0, $9 + 48 | 0) >> 2];
     HEAP8[HEAP32[$9 + 76 >> 2] + (HEAP32[$9 + 24 >> 2] + Math_imul(HEAP32[$9 + 36 >> 2], HEAP32[$9 + 28 >> 2]) | 0) | 0] = HEAP32[$9 + 20 >> 2];
     HEAP32[$9 + 24 >> 2] = HEAP32[$9 + 24 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$9 + 28 >> 2] = HEAP32[$9 + 28 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $9 + 112 | 0;
}

function _jswrap_array_iterate_with_callback($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 144 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 136 >> 2] = $0;
 HEAP32[$6 + 132 >> 2] = $1;
 HEAP32[$6 + 128 >> 2] = $2;
 HEAP32[$6 + 124 >> 2] = $3;
 HEAP8[$6 + 123 | 0] = $4;
 HEAP8[$6 + 122 | 0] = $5;
 label$1: {
  if (!(jsvIsIterable(HEAP32[$6 + 136 >> 2]) & 1)) {
   jsExceptionHere(1, 132530, 0);
   HEAP32[$6 + 140 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsFunction(HEAP32[$6 + 132 >> 2]) & 1)) {
   jsExceptionHere(1, 128290, 0);
   HEAP32[$6 + 140 >> 2] = 0;
   break label$1;
  }
  label$4: {
   if (jsvIsUndefined(HEAP32[$6 + 128 >> 2]) & 1) {
    break label$4;
   }
   if (jsvIsObject(HEAP32[$6 + 128 >> 2]) & 1) {
    break label$4;
   }
   jsExceptionHere(1, 133829, 0);
   HEAP32[$6 + 140 >> 2] = 0;
   break label$1;
  }
  HEAP32[$6 + 116 >> 2] = 0;
  if (HEAP32[$6 + 124 >> 2] == 1) {
   HEAP32[$6 + 116 >> 2] = jsvNewEmptyArray();
  }
  HEAP8[$6 + 115 | 0] = 0;
  if (!(!HEAP32[$6 + 116 >> 2] & HEAP32[$6 + 124 >> 2] == 1)) {
   jsvIteratorNew($6 + 48 | 0, HEAP32[$6 + 136 >> 2], 0);
   while (1) {
    $0 = 0;
    if (jsvIteratorHasElement($6 + 48 | 0) & 1) {
     $0 = HEAPU8[$6 + 115 | 0] ^ -1;
    }
    if ($0 & 1) {
     HEAP32[$6 + 44 >> 2] = jsvIteratorGetKey($6 + 48 | 0);
     label$11: {
      if (jsvIsInt(HEAP32[$6 + 44 >> 2]) & 1) {
       HEAP32[$6 + 40 >> 2] = jsvGetInteger(HEAP32[$6 + 44 >> 2]);
       HEAP32[$6 + 36 >> 2] = jsvIteratorGetValue($6 + 48 | 0);
       HEAP32[$6 + 24 >> 2] = HEAP32[$6 + 36 >> 2];
       HEAP32[$6 + 28 >> 2] = jsvNewFromInteger(HEAP32[$6 + 40 >> 2]);
       HEAP32[$6 + 32 >> 2] = HEAP32[$6 + 136 >> 2];
       jsvIteratorNext($6 + 48 | 0);
       HEAP32[$6 + 20 >> 2] = jspeFunctionCall(HEAP32[$6 + 132 >> 2], 0, HEAP32[$6 + 128 >> 2], 0, 3, $6 + 24 | 0);
       jsvUnLock(HEAP32[$6 + 28 >> 2]);
       if (HEAP32[$6 + 20 >> 2]) {
        if (HEAP8[$6 + 123 | 0] & 1) {
         HEAP8[$6 + 19 | 0] = (jsvGetBool(HEAP32[$6 + 20 >> 2]) & 1) == (HEAP8[$6 + 122 | 0] & 1);
        }
        label$15: {
         if (HEAP32[$6 + 124 >> 2] == 1) {
          if (HEAP8[$6 + 123 | 0] & 1) {
           if (HEAP8[$6 + 19 | 0] & 1) {
            jsvArrayPush(HEAP32[$6 + 116 >> 2], HEAP32[$6 + 36 >> 2]);
           }
           break label$15;
          }
          HEAP32[$6 + 12 >> 2] = jsvNewFromInteger(HEAP32[$6 + 40 >> 2]);
          if (HEAP32[$6 + 12 >> 2]) {
           HEAP32[$6 + 12 >> 2] = jsvMakeIntoVariableName(HEAP32[$6 + 12 >> 2], HEAP32[$6 + 20 >> 2]);
           jsvAddName(HEAP32[$6 + 116 >> 2], HEAP32[$6 + 12 >> 2]);
           jsvUnLock(HEAP32[$6 + 12 >> 2]);
          }
          break label$15;
         }
         if (HEAP8[$6 + 123 | 0] & 1) {
          label$21: {
           if (!(HEAP32[$6 + 124 >> 2] != 2 & HEAP32[$6 + 124 >> 2] != 3)) {
            if (HEAP8[$6 + 19 | 0] & 1) {
             label$25: {
              if (HEAP32[$6 + 124 >> 2] == 2) {
               $0 = jsvLockAgain(HEAP32[$6 + 36 >> 2]);
               break label$25;
              }
              $0 = jsvNewFromInteger(jsvGetInteger(HEAP32[$6 + 44 >> 2]));
             }
             HEAP32[$6 + 116 >> 2] = $0;
             HEAP8[$6 + 115 | 0] = 1;
            }
            break label$21;
           }
           if (!(HEAP8[$6 + 19 | 0] & 1)) {
            HEAP8[$6 + 115 | 0] = 1;
           }
          }
         }
        }
        jsvUnLock(HEAP32[$6 + 20 >> 2]);
       }
       jsvUnLock(HEAP32[$6 + 36 >> 2]);
       break label$11;
      }
      jsvIteratorNext($6 + 48 | 0);
     }
     jsvUnLock(HEAP32[$6 + 44 >> 2]);
     continue;
    }
    break;
   }
   jsvIteratorFree($6 + 48 | 0);
  }
  if (!(HEAP32[$6 + 124 >> 2] | !(HEAP8[$6 + 123 | 0] & 1))) {
   HEAP32[$6 + 116 >> 2] = jsvNewFromBool((HEAP8[$6 + 115 | 0] & 1) != (HEAP8[$6 + 122 | 0] & 1));
  }
  HEAP32[$6 + 140 >> 2] = HEAP32[$6 + 116 >> 2];
 }
 __stack_pointer = $6 + 144 | 0;
 return HEAP32[$6 + 140 >> 2];
}

function jswrap_graphics_setFont($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 160 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 152 >> 2] = $0;
 HEAP32[$3 + 148 >> 2] = $1;
 HEAP32[$3 + 144 >> 2] = $2;
 label$1: {
  if (!(jsvIsString(HEAP32[$3 + 148 >> 2]) & 1)) {
   HEAP32[$3 + 156 >> 2] = 0;
   break label$1;
  }
  HEAP8[$3 + 143 | 0] = 0;
  HEAP32[$3 + 136 >> 2] = -1;
  if (jsvIsStringEqualOrStartsWith(HEAP32[$3 + 148 >> 2], 120867, 1) & 1) {
   if (jsvGetStringLength(HEAP32[$3 + 148 >> 2]) >>> 0 > 6) {
    HEAP32[$3 + 136 >> 2] = 6;
   }
   HEAP8[$3 + 143 | 0] = 1;
  }
  HEAP32[$3 + 132 >> 2] = jsvGetStringIndexOf(HEAP32[$3 + 148 >> 2], 58);
  if (HEAP32[$3 + 132 >> 2] >= 0) {
   HEAP32[$3 + 136 >> 2] = HEAP32[$3 + 132 >> 2] + 1;
  }
  label$6: {
   if (HEAP32[$3 + 136 >> 2] >= 0) {
    HEAP32[$3 + 124 >> 2] = jsvNewFromStringVar(HEAP32[$3 + 148 >> 2], HEAP32[$3 + 136 >> 2], 2147483647);
    HEAP32[$3 + 120 >> 2] = jsvGetStringIndexOf(HEAP32[$3 + 124 >> 2], 120);
    label$8: {
     if (HEAP32[$3 + 120 >> 2] >= 0) {
      HEAP32[$3 + 116 >> 2] = jsvGetIntegerAndUnLock(jsvNewFromStringVar(HEAP32[$3 + 124 >> 2], 0, HEAP32[$3 + 120 >> 2]));
      HEAP32[$3 + 112 >> 2] = jsvGetIntegerAndUnLock(jsvNewFromStringVar(HEAP32[$3 + 124 >> 2], HEAP32[$3 + 120 >> 2] + 1 | 0, 2147483647));
      if (HEAP32[$3 + 116 >> 2] < 0) {
       HEAP32[$3 + 116 >> 2] = 0;
      }
      if (HEAP32[$3 + 112 >> 2] < 0) {
       HEAP32[$3 + 112 >> 2] = 0;
      }
      if (HEAP32[$3 + 116 >> 2] > 63) {
       HEAP32[$3 + 116 >> 2] = 63;
      }
      if (HEAP32[$3 + 112 >> 2] > 63) {
       HEAP32[$3 + 112 >> 2] = 63;
      }
      HEAP32[$3 + 144 >> 2] = HEAP32[$3 + 116 >> 2] | HEAP32[$3 + 112 >> 2] << 6 | 4096;
      break label$8;
     }
     HEAP32[$3 + 144 >> 2] = jsvGetInteger(HEAP32[$3 + 124 >> 2]);
    }
    jsvUnLock(HEAP32[$3 + 124 >> 2]);
    $1 = HEAP32[$3 + 148 >> 2];
    if (HEAP32[$3 + 136 >> 2] > 0) {
     $0 = HEAP32[$3 + 136 >> 2] - 1 | 0;
    } else {
     $0 = 0;
    }
    HEAP32[$3 + 128 >> 2] = jsvNewFromStringVar($1, 0, $0);
    break label$6;
   }
   HEAP32[$3 + 128 >> 2] = jsvLockAgain(HEAP32[$3 + 148 >> 2]);
  }
  if (HEAP32[$3 + 144 >> 2] <= 0) {
   HEAP32[$3 + 144 >> 2] = 1;
  }
  if (HEAP32[$3 + 144 >> 2] > 8191) {
   HEAP32[$3 + 144 >> 2] = 8191;
  }
  HEAP16[$3 + 110 >> 1] = 65535;
  label$18: {
   if (HEAP8[$3 + 143 | 0] & 1) {
    HEAP16[$3 + 110 >> 1] = HEAP32[$3 + 144 >> 2];
    break label$18;
   }
   label$20: {
    label$21: {
     if (jsvIsUndefined(HEAP32[$3 + 128 >> 2]) & 1) {
      break label$21;
     }
     if (!jsvGetStringLength(HEAP32[$3 + 128 >> 2])) {
      break label$21;
     }
     if (!(jsvIsStringEqual(HEAP32[$3 + 128 >> 2], 139174) & 1)) {
      break label$20;
     }
    }
    HEAP16[$3 + 110 >> 1] = HEAP32[$3 + 144 >> 2] - -8192;
   }
  }
  if (jsvIsStringEqual(HEAP32[$3 + 128 >> 2], 139037) & 1) {
   HEAP16[$3 + 110 >> 1] = HEAP32[$3 + 144 >> 2] + 16384;
  }
  if (HEAPU16[$3 + 110 >> 1] == 65535) {
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 128 >> 2];
   HEAP32[$3 + 104 >> 2] = jsvVarPrintf(116791, $3 + 16 | 0);
   HEAP32[$3 + 100 >> 2] = jspGetVarNamedField(HEAP32[$3 + 152 >> 2], HEAP32[$3 + 104 >> 2], 0);
   if (HEAP32[$3 + 100 >> 2]) {
    jsvUnLock(jspExecuteFunction(HEAP32[$3 + 100 >> 2], HEAP32[$3 + 152 >> 2], 0, 0));
    graphicsGetFromVar($3 + 24 | 0, HEAP32[$3 + 152 >> 2]);
    HEAP16[$3 + 110 >> 1] = HEAP32[$3 + 144 >> 2] | (HEAPU8[$3 + 49 | 0] | HEAPU8[$3 + 50 | 0] << 8) & 57344;
   }
   jsvUnLock2(HEAP32[$3 + 100 >> 2], HEAP32[$3 + 104 >> 2]);
  }
  if (HEAPU16[$3 + 110 >> 1] == 65535) {
   HEAP32[$3 >> 2] = HEAP32[$3 + 128 >> 2];
   jsExceptionHere(1, 129258, $3);
  }
  jsvUnLock(HEAP32[$3 + 128 >> 2]);
  HEAP32[$3 + 156 >> 2] = jswrap_graphics_setFontSizeX(HEAP32[$3 + 152 >> 2], HEAPU16[$3 + 110 >> 1], HEAP8[$3 + 143 | 0] & 1);
 }
 __stack_pointer = $3 + 160 | 0;
 return HEAP32[$3 + 156 >> 2];
}

function jsvIsBasicVarEqual($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 96 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP32[$2 + 84 >> 2] = $1;
 label$1: {
  if (HEAP32[$2 + 88 >> 2] == HEAP32[$2 + 84 >> 2]) {
   HEAP8[$2 + 95 | 0] = 1;
   break label$1;
  }
  if (!(HEAP32[$2 + 84 >> 2] ? HEAP32[$2 + 88 >> 2] : 0)) {
   HEAP8[$2 + 95 | 0] = 0;
   break label$1;
  }
  label$5: {
   if (!(jsvIsNumeric(HEAP32[$2 + 88 >> 2]) & 1)) {
    break label$5;
   }
   if (!(jsvIsNumeric(HEAP32[$2 + 84 >> 2]) & 1)) {
    break label$5;
   }
   if (jsvIsIntegerish(HEAP32[$2 + 88 >> 2]) & 1) {
    if (jsvIsIntegerish(HEAP32[$2 + 84 >> 2]) & 1) {
     $0 = HEAP32[$2 + 88 >> 2];
     $1 = HEAP32[$2 + 84 >> 2];
     HEAP8[$2 + 95 | 0] = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == (HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24));
     break label$1;
    }
    $0 = HEAP32[$2 + 84 >> 2];
    $1 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
    $3 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
    wasm2js_scratch_store_i32(0, $1 | 0);
    wasm2js_scratch_store_i32(1, $3 | 0);
    $4 = +wasm2js_scratch_load_f64();
    $0 = HEAP32[$2 + 88 >> 2];
    HEAP8[$2 + 95 | 0] = $4 == +(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
    break label$1;
   }
   if (jsvIsIntegerish(HEAP32[$2 + 84 >> 2]) & 1) {
    $0 = HEAP32[$2 + 88 >> 2];
    $3 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
    $1 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
    wasm2js_scratch_store_i32(0, $3 | 0);
    wasm2js_scratch_store_i32(1, $1 | 0);
    $4 = +wasm2js_scratch_load_f64();
    $0 = HEAP32[$2 + 84 >> 2];
    HEAP8[$2 + 95 | 0] = $4 == +(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
    break label$1;
   }
   $0 = HEAP32[$2 + 88 >> 2];
   $1 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   $3 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
   wasm2js_scratch_store_i32(0, $1 | 0);
   wasm2js_scratch_store_i32(1, $3 | 0);
   $4 = +wasm2js_scratch_load_f64();
   $0 = HEAP32[$2 + 84 >> 2];
   $3 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   $1 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
   wasm2js_scratch_store_i32(0, $3 | 0);
   wasm2js_scratch_store_i32(1, $1 | 0);
   HEAP8[$2 + 95 | 0] = $4 == +wasm2js_scratch_load_f64();
   break label$1;
  }
  label$9: {
   if (!(jsvIsString(HEAP32[$2 + 88 >> 2]) & 1)) {
    break label$9;
   }
   if (!(jsvIsString(HEAP32[$2 + 84 >> 2]) & 1)) {
    break label$9;
   }
   jsvStringIteratorNew($2 + 48 | 0, HEAP32[$2 + 88 >> 2], 0);
   jsvStringIteratorNew($2 + 8 | 0, HEAP32[$2 + 84 >> 2], 0);
   while (1) {
    HEAP32[$2 + 4 >> 2] = jsvStringIteratorGetCharOrMinusOne($2 + 48 | 0);
    jsvStringIteratorNext($2 + 48 | 0);
    HEAP32[$2 >> 2] = jsvStringIteratorGetCharOrMinusOne($2 + 8 | 0);
    jsvStringIteratorNext($2 + 8 | 0);
    if (HEAP32[$2 + 4 >> 2] != HEAP32[$2 >> 2]) {
     jsvStringIteratorFree_1($2 + 48 | 0);
     jsvStringIteratorFree_1($2 + 8 | 0);
     HEAP8[$2 + 95 | 0] = 0;
     break label$1;
    }
    if (HEAP32[$2 + 4 >> 2] >= 0) {
     continue;
    }
    break;
   }
   jsvStringIteratorFree_1($2 + 48 | 0);
   jsvStringIteratorFree_1($2 + 8 | 0);
   HEAP8[$2 + 95 | 0] = 1;
   break label$1;
  }
  HEAP8[$2 + 95 | 0] = 0;
 }
 __stack_pointer = $2 + 96 | 0;
 return HEAP8[$2 + 95 | 0] & 1;
}

function jswrap_io_digitalPulse($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 176 | 0;
 __stack_pointer = $3;
 HEAP8[$3 + 175 | 0] = $0;
 HEAP8[$3 + 174 | 0] = $1;
 HEAP32[$3 + 168 >> 2] = $2;
 label$1: {
  if (!(jshIsPinValid(HEAPU8[$3 + 175 | 0]) & 1)) {
   jsExceptionHere(1, 128480, 0);
   break label$1;
  }
  HEAP32[$3 + 132 >> 2] = jstGetUtilTimerOffset();
  HEAP8[$3 + 131 | 0] = jstGetLastPinTimerTask(HEAPU8[$3 + 175 | 0], $3 + 136 | 0) & 1;
  if (!(HEAP8[$3 + 131 | 0] & 1)) {
   HEAP8[$3 + 136 | 0] = 0;
   HEAP8[$3 + 137 | 0] = 0;
   HEAP8[$3 + 138 | 0] = 0;
   HEAP8[$3 + 139 | 0] = 0;
  }
  if (jsvIsNumeric(HEAP32[$3 + 168 >> 2]) & 1) {
   HEAPF64[$3 + 120 >> 3] = jsvGetFloat(HEAP32[$3 + 168 >> 2]);
   label$5: {
    label$6: {
     label$7: {
      if (HEAPF64[$3 + 120 >> 3] < 0) {
       break label$7;
      }
      $4 = __DOUBLE_BITS_9(HEAPF64[$3 + 120 >> 3]);
      $1 = $4;
      $0 = i64toi32_i32$HIGH_BITS;
      $4 = $0 & 2147483647;
      $0 = $1;
      if (($4 | 0) == 2146435072 & ($0 | 0) != 0 | $4 >>> 0 > 2146435072) {
       break label$7;
      }
      break label$6;
     }
     jsExceptionHere(1, 121404, 0);
     break label$5;
    }
    label$8: {
     if (HEAPF64[$3 + 120 >> 3] > 0) {
      if (!(HEAP8[$3 + 131 | 0] & 1)) {
       jshPinOutput(HEAPU8[$3 + 175 | 0], HEAP8[$3 + 174 | 0] & 1);
      }
      $0 = jshGetTimeFromMilliseconds(HEAPF64[$3 + 120 >> 3]);
      $2 = $0;
      $4 = i64toi32_i32$HIGH_BITS;
      $1 = $4;
      $4 = HEAPU8[$3 + 136 | 0] | HEAPU8[$3 + 137 | 0] << 8 | (HEAPU8[$3 + 138 | 0] << 16 | HEAPU8[$3 + 139 | 0] << 24);
      $0 = $4 >> 31;
      $2 = $4 + $2 | 0;
      $4 = $0;
      $0 = $1;
      HEAP8[$3 + 136 | 0] = $2;
      HEAP8[$3 + 137 | 0] = $2 >>> 8;
      HEAP8[$3 + 138 | 0] = $2 >>> 16;
      HEAP8[$3 + 139 | 0] = $2 >>> 24;
      $1 = HEAPU8[$3 + 136 | 0] | HEAPU8[$3 + 137 | 0] << 8 | (HEAPU8[$3 + 138 | 0] << 16 | HEAPU8[$3 + 139 | 0] << 24);
      $2 = $1 >> 31;
      jstPinOutputAtTime($1, $2, $3 + 132 | 0, $3 + 175 | 0, 1, (HEAPU8[$3 + 174 | 0] ^ -1) & 1);
      break label$8;
     }
     jstUtilTimerWaitEmpty();
    }
   }
   break label$1;
  }
  label$11: {
   if (jsvIsIterable(HEAP32[$3 + 168 >> 2]) & 1) {
    if (!(HEAP8[$3 + 131 | 0] & 1)) {
     jshPinOutput(HEAPU8[$3 + 175 | 0], HEAP8[$3 + 174 | 0] & 1);
    }
    jsvIteratorNew($3 + 56 | 0, HEAP32[$3 + 168 >> 2], 1);
    while (1) {
     if (jsvIteratorHasElement($3 + 56 | 0) & 1) {
      HEAPF64[$3 + 48 >> 3] = jsvIteratorGetFloatValue($3 + 56 | 0);
      $2 = __DOUBLE_BITS_9(HEAPF64[$3 + 48 >> 3]);
      $0 = $2;
      $1 = i64toi32_i32$HIGH_BITS;
      $2 = $1 & 2147483647;
      $1 = $0;
      if ((!$1 & ($2 | 0) == 2146435072 | $2 >>> 0 < 2146435072) & HEAPF64[$3 + 48 >> 3] > 0) {
       $1 = jshGetTimeFromMilliseconds(HEAPF64[$3 + 48 >> 3]);
       $5 = $1;
       $2 = i64toi32_i32$HIGH_BITS;
       $4 = $2;
       $2 = HEAPU8[$3 + 136 | 0] | HEAPU8[$3 + 137 | 0] << 8 | (HEAPU8[$3 + 138 | 0] << 16 | HEAPU8[$3 + 139 | 0] << 24);
       $1 = $2 >> 31;
       $0 = $2;
       $2 = $1;
       $1 = $4;
       $2 = $2 + $1 | 0;
       $1 = $5;
       $4 = $0 + $1 | 0;
       HEAP8[$3 + 136 | 0] = $4;
       HEAP8[$3 + 137 | 0] = $4 >>> 8;
       HEAP8[$3 + 138 | 0] = $4 >>> 16;
       HEAP8[$3 + 139 | 0] = $4 >>> 24;
       $2 = HEAPU8[$3 + 136 | 0] | HEAPU8[$3 + 137 | 0] << 8 | (HEAPU8[$3 + 138 | 0] << 16 | HEAPU8[$3 + 139 | 0] << 24);
       $1 = $2 >> 31;
       jstPinOutputAtTime($2, $1, $3 + 132 | 0, $3 + 175 | 0, 1, (HEAPU8[$3 + 174 | 0] ^ -1) & 1);
      }
      HEAP8[$3 + 174 | 0] = (HEAPU8[$3 + 174 | 0] ^ -1) & 1;
      jsvIteratorNext($3 + 56 | 0);
      continue;
     }
     break;
    }
    jsvIteratorFree($3 + 56 | 0);
    break label$11;
   }
   HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 168 >> 2];
   jsExceptionHere(1, 118252, $3 + 32 | 0);
  }
 }
 __stack_pointer = $3 + 176 | 0;
}

function jswrap_string_split($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP32[$2 + 52 >> 2] = $1;
 label$1: {
  if (!(jsvIsString(HEAP32[$2 + 56 >> 2]) & 1)) {
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 48 >> 2] = jsvNewEmptyArray();
  if (!HEAP32[$2 + 48 >> 2]) {
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  if (jsvIsUndefined(HEAP32[$2 + 52 >> 2]) & 1) {
   jsvArrayPush(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 56 >> 2]);
   HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
   break label$1;
  }
  if (jsvIsInstanceOf(HEAP32[$2 + 52 >> 2], 121677) & 1) {
   HEAP32[$2 + 44 >> 2] = 0;
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 52 >> 2], 116445, jsvNewFromInteger(0));
   HEAP32[$2 + 40 >> 2] = jswrap_regexp_exec(HEAP32[$2 + 52 >> 2], HEAP32[$2 + 56 >> 2]);
   while (1) {
    $0 = 0;
    if (HEAP32[$2 + 40 >> 2]) {
     $0 = jsvIsNull(HEAP32[$2 + 40 >> 2]) ^ -1;
    }
    if ($0 & 1) {
     HEAP32[$2 + 36 >> 2] = jsvGetArrayItem(HEAP32[$2 + 40 >> 2], 0);
     HEAP32[$2 + 32 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 40 >> 2], 116439);
     HEAP32[$2 + 28 >> 2] = jsvGetStringLength(HEAP32[$2 + 36 >> 2]);
     jsvUnLock(HEAP32[$2 + 36 >> 2]);
     jsvArrayPushAndUnLock(HEAP32[$2 + 48 >> 2], jsvNewFromStringVar(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 44 >> 2], HEAP32[$2 + 32 >> 2] - HEAP32[$2 + 44 >> 2] | 0));
     HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2] + HEAP32[$2 + 28 >> 2];
     jsvUnLock(HEAP32[$2 + 40 >> 2]);
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 52 >> 2], 116445, jsvNewFromInteger(HEAP32[$2 + 44 >> 2]));
     HEAP32[$2 + 40 >> 2] = jswrap_regexp_exec(HEAP32[$2 + 52 >> 2], HEAP32[$2 + 56 >> 2]);
     continue;
    }
    break;
   }
   jsvUnLock(HEAP32[$2 + 40 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 52 >> 2], 116445, jsvNewFromInteger(0));
   if (HEAP32[$2 + 44 >> 2] <= (jsvGetStringLength(HEAP32[$2 + 56 >> 2]) | 0)) {
    jsvArrayPushAndUnLock(HEAP32[$2 + 48 >> 2], jsvNewFromStringVar(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 44 >> 2], 2147483647));
   }
   HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
   break label$1;
  }
  HEAP32[$2 + 52 >> 2] = jsvAsString(HEAP32[$2 + 52 >> 2]);
  HEAP32[$2 + 20 >> 2] = 0;
  if (jsvIsUndefined(HEAP32[$2 + 52 >> 2]) & 1) {
   $0 = 0;
  } else {
   $0 = jsvGetStringLength(HEAP32[$2 + 52 >> 2]);
  }
  HEAP32[$2 + 16 >> 2] = $0;
  HEAP32[$2 + 12 >> 2] = (jsvGetStringLength(HEAP32[$2 + 56 >> 2]) + 1 | 0) - HEAP32[$2 + 16 >> 2];
  HEAP32[$2 + 24 >> 2] = 0;
  while (1) {
   label$13: {
    if (HEAP32[$2 + 24 >> 2] > HEAP32[$2 + 12 >> 2]) {
     break label$13;
    }
    if (HEAP32[$2 + 16 >> 2] | HEAP32[$2 + 24 >> 2]) {
     label$16: {
      if (!(!HEAP32[$2 + 16 >> 2] | HEAP32[$2 + 24 >> 2] == HEAP32[$2 + 12 >> 2])) {
       if (jsvCompareString(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2], HEAP32[$2 + 24 >> 2], 0, 1)) {
        break label$16;
       }
      }
      if (HEAP32[$2 + 24 >> 2] == HEAP32[$2 + 12 >> 2]) {
       HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 16 >> 2];
       if (!HEAP32[$2 + 16 >> 2]) {
        break label$13;
       }
      }
      HEAP32[$2 + 8 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 56 >> 2], jsvConvertFromUTF8Index(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 20 >> 2]), jsvConvertFromUTF8Index(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 24 >> 2]) - jsvConvertFromUTF8Index(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 20 >> 2]) | 0);
      if (!HEAP32[$2 + 8 >> 2]) {
       break label$13;
      }
      jsvArrayPush(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 8 >> 2]);
      jsvUnLock(HEAP32[$2 + 8 >> 2]);
      HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 24 >> 2] + HEAP32[$2 + 16 >> 2];
     }
    }
    HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 24 >> 2] + 1;
    continue;
   }
   break;
  }
  jsvUnLock(HEAP32[$2 + 52 >> 2]);
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
 }
 __stack_pointer = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}

function jswrap_array_splice($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 96 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 88 >> 2] = $0;
 HEAP32[$4 + 84 >> 2] = $1;
 HEAP32[$4 + 80 >> 2] = $2;
 HEAP32[$4 + 76 >> 2] = $3;
 label$1: {
  if (!(jsvIsArray(HEAP32[$4 + 88 >> 2]) & 1)) {
   HEAP32[$4 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 72 >> 2] = jsvGetArrayLength(HEAP32[$4 + 88 >> 2]);
  if (HEAP32[$4 + 84 >> 2] < 0) {
   HEAP32[$4 + 84 >> 2] = HEAP32[$4 + 72 >> 2] + HEAP32[$4 + 84 >> 2];
  }
  if (HEAP32[$4 + 84 >> 2] < 0) {
   HEAP32[$4 + 84 >> 2] = 0;
  }
  if (HEAP32[$4 + 84 >> 2] > HEAP32[$4 + 72 >> 2]) {
   HEAP32[$4 + 84 >> 2] = HEAP32[$4 + 72 >> 2];
  }
  HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 72 >> 2];
  if (jsvIsNumeric(HEAP32[$4 + 80 >> 2]) & 1) {
   HEAP32[$4 + 68 >> 2] = jsvGetInteger(HEAP32[$4 + 80 >> 2]);
  }
  if (HEAP32[$4 + 68 >> 2] > (HEAP32[$4 + 72 >> 2] - HEAP32[$4 + 84 >> 2] | 0)) {
   HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 72 >> 2] - HEAP32[$4 + 84 >> 2];
  }
  HEAP32[$4 + 64 >> 2] = jsvGetArrayLength(HEAP32[$4 + 76 >> 2]);
  HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 64 >> 2] - HEAP32[$4 + 68 >> 2];
  HEAP8[$4 + 59 | 0] = 0;
  HEAP32[$4 + 52 >> 2] = jsvNewEmptyArray();
  jsvObjectIteratorNew($4 + 48 | 0, HEAP32[$4 + 88 >> 2]);
  while (1) {
   $0 = 0;
   if (jsvObjectIteratorHasValue_6($4 + 48 | 0) & 1) {
    $0 = HEAPU8[$4 + 59 | 0] ^ -1;
   }
   if ($0 & 1) {
    HEAP8[$4 + 47 | 0] = 1;
    HEAP32[$4 + 40 >> 2] = jsvObjectIteratorGetKey_4($4 + 48 | 0);
    label$11: {
     if (!HEAP32[$4 + 40 >> 2]) {
      break label$11;
     }
     if (!(jsvIsInt(HEAP32[$4 + 40 >> 2]) & 1)) {
      break label$11;
     }
     HEAP32[$4 + 36 >> 2] = jsvGetInteger(HEAP32[$4 + 40 >> 2]);
     if (HEAP32[$4 + 36 >> 2] >= HEAP32[$4 + 84 >> 2]) {
      label$13: {
       if (HEAP32[$4 + 36 >> 2] < (HEAP32[$4 + 84 >> 2] + HEAP32[$4 + 68 >> 2] | 0)) {
        if (HEAP32[$4 + 52 >> 2]) {
         HEAP32[$4 + 32 >> 2] = jsvObjectIteratorGetValue_6($4 + 48 | 0);
         jsvArrayPushAndUnLock(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 32 >> 2]);
        }
        HEAP8[$4 + 47 | 0] = 0;
        HEAP32[$4 + 28 >> 2] = jsvObjectIteratorGetKey_4($4 + 48 | 0);
        jsvObjectIteratorNext($4 + 48 | 0);
        jsvRemoveChildAndUnLock(HEAP32[$4 + 88 >> 2], HEAP32[$4 + 28 >> 2]);
        break label$13;
       }
       HEAP8[$4 + 59 | 0] = 1;
       HEAP8[$4 + 47 | 0] = 0;
      }
     }
    }
    jsvUnLock(HEAP32[$4 + 40 >> 2]);
    if (HEAP8[$4 + 47 | 0] & 1) {
     jsvObjectIteratorNext($4 + 48 | 0);
    }
    continue;
   }
   break;
  }
  HEAP32[$4 + 24 >> 2] = jsvObjectIteratorGetKey_4($4 + 48 | 0);
  jsvObjectIteratorNew($4 + 16 | 0, HEAP32[$4 + 76 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_6($4 + 16 | 0) & 1) {
    HEAP32[$4 + 12 >> 2] = jsvObjectIteratorGetValue_6($4 + 16 | 0);
    jsvArrayInsertBefore(HEAP32[$4 + 88 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 12 >> 2]);
    jsvUnLock(HEAP32[$4 + 12 >> 2]);
    jsvObjectIteratorNext($4 + 16 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_6($4 + 16 | 0);
  jsvUnLock(HEAP32[$4 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_6($4 + 48 | 0) & 1) {
    HEAP32[$4 + 8 >> 2] = jsvObjectIteratorGetKey_4($4 + 48 | 0);
    label$21: {
     if (!HEAP32[$4 + 8 >> 2]) {
      break label$21;
     }
     if (!(jsvIsInt(HEAP32[$4 + 8 >> 2]) & 1)) {
      break label$21;
     }
     jsvSetInteger(HEAP32[$4 + 8 >> 2], jsvGetInteger(HEAP32[$4 + 8 >> 2]) + HEAP32[$4 + 60 >> 2] | 0);
    }
    jsvUnLock(HEAP32[$4 + 8 >> 2]);
    jsvObjectIteratorNext($4 + 48 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_6($4 + 48 | 0);
  jsvSetArrayLength(HEAP32[$4 + 88 >> 2], HEAP32[$4 + 72 >> 2] + HEAP32[$4 + 60 >> 2] | 0, 0);
  HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 52 >> 2];
 }
 __stack_pointer = $4 + 96 | 0;
 return HEAP32[$4 + 92 >> 2];
}

function tflite__reference_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20short__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0;
 $9 = __stack_pointer - 112 | 0;
 __stack_pointer = $9;
 HEAP32[$9 + 108 >> 2] = $0;
 HEAP32[$9 + 104 >> 2] = $1;
 HEAP32[$9 + 100 >> 2] = $2;
 HEAP32[$9 + 96 >> 2] = $3;
 HEAP32[$9 + 92 >> 2] = $4;
 HEAP32[$9 + 88 >> 2] = $5;
 HEAP32[$9 + 84 >> 2] = $6;
 HEAP32[$9 + 80 >> 2] = $7;
 HEAP32[$9 + 76 >> 2] = $8;
 HEAP32[$9 + 72 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] >> 2];
 HEAP32[$9 + 68 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 4 >> 2];
 HEAP32[$9 + 64 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 8 >> 2];
 HEAP32[$9 + 60 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 12 >> 2];
 HEAP32[$9 + 56 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 16 >> 2];
 HEAP32[$9 + 52 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 20 >> 2];
 HEAP32[$9 + 48 >> 2] = HEAP32[HEAP32[$9 + 108 >> 2] + 24 >> 2];
 label$1: {
  if (HEAP32[$9 + 52 >> 2] > HEAP32[$9 + 48 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (HEAP32[$9 + 64 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$9 + 44 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 80 >> 2]);
 HEAP32[$9 + 40 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 96 >> 2]);
 HEAP32[$9 + 36 >> 2] = tflite__FlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 80 >> 2], HEAP32[$9 + 44 >> 2] - 1 | 0);
 HEAP32[$9 + 32 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 96 >> 2], HEAP32[$9 + 40 >> 2] - 2 | 0, HEAP32[$9 + 80 >> 2], HEAP32[$9 + 44 >> 2] - 1 | 0);
 HEAP32[$9 + 28 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 96 >> 2], HEAP32[$9 + 40 >> 2] - 1 | 0);
 HEAP32[$9 + 24 >> 2] = 0;
 while (1) {
  if (HEAP32[$9 + 24 >> 2] < HEAP32[$9 + 36 >> 2]) {
   HEAP32[$9 + 20 >> 2] = 0;
   while (1) {
    if (HEAP32[$9 + 20 >> 2] < HEAP32[$9 + 32 >> 2]) {
     HEAP32[$9 + 16 >> 2] = HEAP32[HEAP32[$9 + 84 >> 2] + (HEAP32[$9 + 20 >> 2] << 2) >> 2];
     HEAP32[$9 + 12 >> 2] = 0;
     while (1) {
      if (HEAP32[$9 + 12 >> 2] < HEAP32[$9 + 28 >> 2]) {
       HEAP16[$9 + 10 >> 1] = HEAPU8[HEAP32[$9 + 100 >> 2] + (HEAP32[$9 + 12 >> 2] + Math_imul(HEAP32[$9 + 24 >> 2], HEAP32[$9 + 28 >> 2]) | 0) | 0] + HEAP32[$9 + 72 >> 2];
       HEAP16[$9 + 8 >> 1] = HEAPU8[HEAP32[$9 + 92 >> 2] + (HEAP32[$9 + 12 >> 2] + Math_imul(HEAP32[$9 + 20 >> 2], HEAP32[$9 + 28 >> 2]) | 0) | 0] + HEAP32[$9 + 68 >> 2];
       HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 16 >> 2] + Math_imul(HEAP16[$9 + 8 >> 1], HEAP16[$9 + 10 >> 1]);
       HEAP32[$9 + 12 >> 2] = HEAP32[$9 + 12 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP32[$9 + 16 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$9 + 16 >> 2], HEAP32[$9 + 60 >> 2], HEAP32[$9 + 56 >> 2]);
     HEAP32[$9 + 4 >> 2] = HEAP32[$9 + 52 >> 2] - HEAP32[$9 + 64 >> 2];
     HEAP32[$9 + 16 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($9 + 16 | 0, $9 + 4 | 0) >> 2];
     HEAP32[$9 >> 2] = HEAP32[$9 + 48 >> 2] - HEAP32[$9 + 64 >> 2];
     HEAP32[$9 + 16 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($9 + 16 | 0, $9) >> 2];
     HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 64 >> 2] + HEAP32[$9 + 16 >> 2];
     HEAP16[HEAP32[$9 + 76 >> 2] + (HEAP32[$9 + 20 >> 2] + Math_imul(HEAP32[$9 + 32 >> 2], HEAP32[$9 + 24 >> 2]) << 1) >> 1] = HEAP32[$9 + 16 >> 2];
     HEAP32[$9 + 20 >> 2] = HEAP32[$9 + 20 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$9 + 24 >> 2] = HEAP32[$9 + 24 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $9 + 112 | 0;
}

function jsserialPopulateUSARTInfo($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 192 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 188 >> 2] = $0;
 HEAP32[$3 + 184 >> 2] = $1;
 HEAP32[$3 + 180 >> 2] = $2;
 jshUSARTInitInfo(HEAP32[$3 + 188 >> 2]);
 HEAP32[$3 + 176 >> 2] = 0;
 HEAP32[$3 + 172 >> 2] = 0;
 HEAP32[$3 + 168 >> 2] = HEAPU8[HEAP32[$3 + 188 >> 2] + 8 | 0];
 HEAP32[$3 + 164 >> 2] = HEAPU8[HEAP32[$3 + 188 >> 2] + 10 | 0];
 HEAP32[$3 + 48 >> 2] = 116402;
 HEAP16[$3 + 52 >> 1] = 13;
 HEAP32[$3 + 56 >> 2] = HEAP32[$3 + 188 >> 2] + 4;
 HEAP32[$3 + 60 >> 2] = 116399;
 HEAP16[$3 + 64 >> 1] = 13;
 HEAP32[$3 + 68 >> 2] = HEAP32[$3 + 188 >> 2] + 5;
 HEAP32[$3 + 72 >> 2] = 129133;
 HEAP16[$3 + 76 >> 1] = 13;
 HEAP32[$3 + 80 >> 2] = HEAP32[$3 + 188 >> 2] + 6;
 HEAP32[$3 + 84 >> 2] = 119854;
 HEAP16[$3 + 88 >> 1] = 13;
 HEAP32[$3 + 92 >> 2] = HEAP32[$3 + 188 >> 2] + 7;
 HEAP32[$3 + 96 >> 2] = 131525;
 HEAP16[$3 + 100 >> 1] = 10;
 HEAP32[$3 + 104 >> 2] = $3 + 168;
 HEAP32[$3 + 108 >> 2] = 119822;
 HEAP16[$3 + 112 >> 1] = 10;
 HEAP32[$3 + 116 >> 2] = $3 + 164;
 HEAP32[$3 + 120 >> 2] = 116111;
 HEAP16[$3 + 124 >> 1] = 5;
 HEAP32[$3 + 128 >> 2] = $3 + 176;
 HEAP32[$3 + 132 >> 2] = 116587;
 HEAP16[$3 + 136 >> 1] = 5;
 HEAP32[$3 + 140 >> 2] = $3 + 172;
 HEAP32[$3 + 144 >> 2] = 119915;
 HEAP16[$3 + 148 >> 1] = 12;
 HEAP32[$3 + 152 >> 2] = HEAP32[$3 + 188 >> 2] + 12;
 if (!(jsvIsUndefined(HEAP32[$3 + 184 >> 2]) & 1)) {
  HEAP32[$3 + 44 >> 2] = jsvGetInteger(HEAP32[$3 + 184 >> 2]);
  label$2: {
   if (!(HEAP32[$3 + 44 >> 2] <= 1e7 & HEAP32[$3 + 44 >> 2] > 100)) {
    HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 44 >> 2];
    jsExceptionHere(1, 134972, $3 + 32 | 0);
    break label$2;
   }
   $0 = HEAP32[$3 + 188 >> 2];
   $1 = HEAP32[$3 + 44 >> 2];
   HEAP8[$0 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1 >>> 8;
   HEAP8[$0 + 2 | 0] = $1 >>> 16;
   HEAP8[$0 + 3 | 0] = $1 >>> 24;
  }
 }
 HEAP8[$3 + 43 | 0] = 1;
 if (jsvReadConfigObject(HEAP32[$3 + 180 >> 2], $3 + 48 | 0, 9) & 1) {
  HEAP8[HEAP32[$3 + 188 >> 2] + 8 | 0] = HEAP32[$3 + 168 >> 2];
  HEAP8[HEAP32[$3 + 188 >> 2] + 10 | 0] = HEAP32[$3 + 164 >> 2];
  HEAP8[HEAP32[$3 + 188 >> 2] + 9 | 0] = 0;
  label$6: {
   if (jsvIsString(HEAP32[$3 + 176 >> 2]) & 1) {
    label$8: {
     if (!(jsvIsStringEqual(HEAP32[$3 + 176 >> 2], 128056) & 1)) {
      if (!(jsvIsStringEqual(HEAP32[$3 + 176 >> 2], 134137) & 1)) {
       break label$8;
      }
     }
     HEAP8[HEAP32[$3 + 188 >> 2] + 9 | 0] = 1;
     break label$6;
    }
    label$10: {
     if (!(jsvIsStringEqual(HEAP32[$3 + 176 >> 2], 132892) & 1)) {
      if (!(jsvIsStringEqual(HEAP32[$3 + 176 >> 2], 128536) & 1)) {
       break label$10;
      }
     }
     HEAP8[HEAP32[$3 + 188 >> 2] + 9 | 0] = 2;
    }
    break label$6;
   }
   if (jsvIsInt(HEAP32[$3 + 176 >> 2]) & 1) {
    $0 = jsvGetInteger(HEAP32[$3 + 176 >> 2]);
    HEAP8[HEAP32[$3 + 188 >> 2] + 9 | 0] = $0;
   }
  }
  if (HEAPU8[HEAP32[$3 + 188 >> 2] + 9 | 0] > 2) {
   HEAP32[$3 + 16 >> 2] = HEAPU8[HEAP32[$3 + 188 >> 2] + 9 | 0];
   jsExceptionHere(1, 134582, $3 + 16 | 0);
   HEAP8[$3 + 43 | 0] = 0;
  }
  if (HEAP8[$3 + 43 | 0] & 1) {
   label$15: {
    label$16: {
     label$17: {
      if (jsvIsUndefined(HEAP32[$3 + 172 >> 2]) & 1) {
       break label$17;
      }
      if (jsvIsNull(HEAP32[$3 + 172 >> 2]) & 1) {
       break label$17;
      }
      if (!(jsvIsStringEqual(HEAP32[$3 + 172 >> 2], 132365) & 1)) {
       break label$16;
      }
     }
     HEAP8[HEAP32[$3 + 188 >> 2] + 11 | 0] = 0;
     break label$15;
    }
    label$18: {
     if (jsvIsStringEqual(HEAP32[$3 + 172 >> 2], 128087) & 1) {
      HEAP8[HEAP32[$3 + 188 >> 2] + 11 | 0] = 1;
      break label$18;
     }
     HEAP32[$3 >> 2] = HEAP32[$3 + 172 >> 2];
     jsExceptionHere(1, 121652, $3);
     HEAP8[$3 + 43 | 0] = 0;
    }
   }
  }
 }
 jsvUnLock2(HEAP32[$3 + 176 >> 2], HEAP32[$3 + 172 >> 2]);
 __stack_pointer = $3 + 192 | 0;
 return HEAP8[$3 + 43 | 0] & 1;
}

function jsfCompactInternal($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 96 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP32[$3 + 80 >> 2] = $2;
 HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 88 >> 2];
 jsiConsolePrintf(146346, 0);
 HEAP32[$3 + 72 >> 2] = 0;
 HEAP32[$3 + 68 >> 2] = 0;
 HEAP32[$3 + 64 >> 2] = 0;
 HEAP32[$3 + 56 >> 2] = 0;
 HEAP32[$3 + 60 >> 2] = 0;
 HEAP32[$3 + 48 >> 2] = 0;
 HEAP32[$3 + 52 >> 2] = 0;
 HEAP32[$3 + 40 >> 2] = 0;
 HEAP32[$3 + 44 >> 2] = 0;
 HEAP32[$3 + 32 >> 2] = 0;
 HEAP32[$3 + 36 >> 2] = 0;
 HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 88 >> 2];
 HEAP32[$3 + 24 >> 2] = 0;
 label$1: {
  if (jsfGetFileHeader(HEAP32[$3 + 28 >> 2], $3 + 32 | 0, 1) & 1) {
   while (1) {
    if (jsfIsRealFile($3 + 32 | 0) & 1) {
     HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 76 >> 2] + HEAP32[$3 + 64 >> 2];
     if (HEAP32[$3 + 28 >> 2] != HEAP32[$3 + 20 >> 2]) {
      jsvUpdateMemoryAddress(HEAP32[$3 + 28 >> 2], jsfGetFileSize($3 + 32 | 0) + 32 | 0, HEAP32[$3 + 20 >> 2]);
     }
     memcpy_circular(HEAP32[$3 + 84 >> 2], $3 + 72 | 0, HEAP32[$3 + 80 >> 2], $3 + 32 | 0, 32);
     HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 64 >> 2] + 32;
     HEAP32[$3 + 16 >> 2] = jsfAlignAddress(jsfGetFileSize($3 + 32 | 0));
     HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 28 >> 2] + 32;
     jsfCompactWriteBuffer($3 + 76 | 0, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2], $3 - -64 | 0, $3 + 68 | 0);
     while (1) {
      if (HEAP32[$3 + 16 >> 2]) {
       HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 80 >> 2] - HEAP32[$3 + 64 >> 2];
       if (HEAPU32[$3 + 8 >> 2] > HEAP32[$3 + 80 >> 2] - HEAP32[$3 + 72 >> 2] >>> 0) {
        HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 80 >> 2] - HEAP32[$3 + 72 >> 2];
       }
       if (!(HEAPU32[$3 + 68 >> 2] <= HEAPU32[$3 + 72 >> 2] | HEAPU32[$3 + 8 >> 2] <= HEAP32[$3 + 68 >> 2] - HEAP32[$3 + 72 >> 2] >>> 0)) {
        HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 68 >> 2] - HEAP32[$3 + 72 >> 2];
       }
       if (!HEAP32[$3 + 8 >> 2]) {
        HEAP8[$3 + 95 | 0] = 0;
        break label$1;
       }
       if (HEAPU32[$3 + 8 >> 2] > HEAPU32[$3 + 16 >> 2]) {
        HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 16 >> 2];
       }
       jshFlashRead(HEAP32[$3 + 84 >> 2] + HEAP32[$3 + 72 >> 2] | 0, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
       HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] - HEAP32[$3 + 8 >> 2];
       HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$3 + 12 >> 2];
       HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$3 + 64 >> 2];
       HEAP32[$3 + 72 >> 2] = (HEAP32[$3 + 72 >> 2] + HEAP32[$3 + 8 >> 2] >>> 0) % HEAPU32[$3 + 80 >> 2];
       jsfCompactWriteBuffer($3 + 76 | 0, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2], $3 - -64 | 0, $3 + 68 | 0);
       continue;
      }
      break;
     }
     HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 28 >> 2] - HEAP32[$3 + 88 >> 2] >>> 14;
     if (HEAP32[$3 + 4 >> 2] != HEAP32[$3 + 24 >> 2]) {
      HEAP32[$3 >> 2] = HEAP8[(HEAP32[$3 + 4 >> 2] & 3) + 116066 | 0];
      jsiConsolePrintf(135685, $3);
      HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 4 >> 2];
     }
    }
    jshKickWatchDog();
    jshKickSoftWatchDog();
    if (jsfGetNextFileHeader($3 + 28 | 0, $3 + 32 | 0, 1) & 1) {
     continue;
    }
    break;
   }
  }
  jsfCompactWriteBuffer($3 + 76 | 0, jsfGetBankEndAddress(HEAP32[$3 + 76 >> 2]), HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2], $3 - -64 | 0, $3 + 68 | 0);
  if (HEAP32[$3 + 76 >> 2] != HEAP32[$3 + 88 >> 2]) {
   HEAP32[$3 + 76 >> 2] = jsfGetAddressOfNextPage(HEAP32[$3 + 76 >> 2] - 1 | 0);
  }
  if (HEAP32[$3 + 76 >> 2]) {
   if (!HEAP32[$3 + 28 >> 2]) {
    HEAP32[$3 + 28 >> 2] = jsfGetBankEndAddress(HEAP32[$3 + 76 >> 2]);
   }
   jshFlashErasePages(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 28 >> 2] - HEAP32[$3 + 76 >> 2] | 0);
  }
  jsiConsolePrintf(148266, 0);
  HEAP8[$3 + 95 | 0] = 1;
 }
 __stack_pointer = $3 + 96 | 0;
 return HEAP8[$3 + 95 | 0] & 1;
}

function jswrap_function_bind($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 80 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 72 >> 2] = $0;
 HEAP32[$3 + 68 >> 2] = $1;
 HEAP32[$3 + 64 >> 2] = $2;
 label$1: {
  if (!(jsvIsFunction(HEAP32[$3 + 72 >> 2]) & 1)) {
   HEAP32[$3 >> 2] = HEAP32[$3 + 72 >> 2];
   jsExceptionHere(3, 118710, $3);
   HEAP32[$3 + 76 >> 2] = 0;
   break label$1;
  }
  label$3: {
   if (jsvIsNativeFunction(HEAP32[$3 + 72 >> 2]) & 1) {
    $0 = HEAP32[$3 + 72 >> 2];
    $1 = HEAP32[$3 + 72 >> 2];
    HEAP32[$3 + 60 >> 2] = jsvNewNativeFunction(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8);
    break label$3;
   }
   HEAP32[$3 + 60 >> 2] = jsvNewWithFlags((jsvIsFunctionReturn(HEAP32[$3 + 72 >> 2]) & 1 ? 9 : 7) & 65535);
  }
  if (!HEAP32[$3 + 60 >> 2]) {
   HEAP32[$3 + 76 >> 2] = 0;
   break label$1;
  }
  jsvObjectIteratorNew($3 + 56 | 0, HEAP32[$3 + 72 >> 2]);
  while (1) {
   label$7: {
    if (!(jsvObjectIteratorHasValue_9($3 + 56 | 0) & 1)) {
     break label$7;
    }
    HEAP32[$3 + 52 >> 2] = jsvObjectIteratorGetKey_6($3 + 56 | 0);
    HEAP32[$3 + 48 >> 2] = jsvObjectIteratorGetValue_9($3 + 56 | 0);
    $0 = 0;
    if (jsvIsFunctionParameter(HEAP32[$3 + 52 >> 2]) & 1) {
     $0 = HEAP32[$3 + 48 >> 2] != 0;
    }
    HEAP8[$3 + 47 | 0] = $0;
    if (HEAP8[$3 + 47 | 0] & 1) {
     HEAP32[$3 + 40 >> 2] = jsvCopy(HEAP32[$3 + 52 >> 2], 1);
     if (HEAP32[$3 + 40 >> 2]) {
      jsvAddName(HEAP32[$3 + 60 >> 2], HEAP32[$3 + 40 >> 2]);
      jsvUnLock(HEAP32[$3 + 40 >> 2]);
     }
    }
    jsvUnLock2(HEAP32[$3 + 52 >> 2], HEAP32[$3 + 48 >> 2]);
    if (!(HEAP8[$3 + 47 | 0] & 1)) {
     break label$7;
    }
    jsvObjectIteratorNext($3 + 56 | 0);
    continue;
   }
   break;
  }
  if (HEAP32[$3 + 64 >> 2]) {
   jsvObjectIteratorNew($3 + 32 | 0, HEAP32[$3 + 64 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_9($3 + 32 | 0) & 1) {
     HEAP32[$3 + 28 >> 2] = jsvObjectIteratorGetValue_9($3 + 32 | 0);
     HEAP8[$3 + 27 | 0] = 0;
     while (1) {
      $0 = 0;
      if (!(HEAP8[$3 + 27 | 0] & 1)) {
       $0 = jsvObjectIteratorHasValue_9($3 + 56 | 0);
      }
      label$16: {
       if (!($0 & 1)) {
        break label$16;
       }
       HEAP32[$3 + 20 >> 2] = jsvObjectIteratorGetKey_6($3 + 56 | 0);
       if (!(jsvIsFunctionParameter(HEAP32[$3 + 20 >> 2]) & 1)) {
        jsvUnLock(HEAP32[$3 + 20 >> 2]);
        break label$16;
       }
       HEAP32[$3 + 16 >> 2] = jsvCopyNameOnly(HEAP32[$3 + 20 >> 2], 0, 1);
       jsvSetValueOfName(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 28 >> 2]);
       jsvAddName(HEAP32[$3 + 60 >> 2], HEAP32[$3 + 16 >> 2]);
       HEAP8[$3 + 27 | 0] = 1;
       jsvUnLock2(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
       jsvObjectIteratorNext($3 + 56 | 0);
       continue;
      }
      break;
     }
     if (!(HEAP8[$3 + 27 | 0] & 1)) {
      jsvAddFunctionParameter(HEAP32[$3 + 60 >> 2], 0, HEAP32[$3 + 28 >> 2]);
     }
     jsvUnLock(HEAP32[$3 + 28 >> 2]);
     jsvObjectIteratorNext($3 + 32 | 0);
     continue;
    }
    break;
   }
   jsvObjectIteratorFree_9($3 + 32 | 0);
  }
  while (1) {
   if (jsvObjectIteratorHasValue_9($3 + 56 | 0) & 1) {
    HEAP32[$3 + 12 >> 2] = jsvObjectIteratorGetKey_6($3 + 56 | 0);
    HEAP32[$3 + 8 >> 2] = jsvCopyNameOnly(HEAP32[$3 + 12 >> 2], 1, 1);
    if (HEAP32[$3 + 8 >> 2]) {
     jsvAddName(HEAP32[$3 + 60 >> 2], HEAP32[$3 + 8 >> 2]);
     jsvUnLock(HEAP32[$3 + 8 >> 2]);
    }
    jsvUnLock(HEAP32[$3 + 12 >> 2]);
    jsvObjectIteratorNext($3 + 56 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_9($3 + 56 | 0);
  jsvObjectSetChild(HEAP32[$3 + 60 >> 2], 120157, HEAP32[$3 + 68 >> 2]);
  HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 60 >> 2];
 }
 __stack_pointer = $3 + 80 | 0;
 return HEAP32[$3 + 76 >> 2];
}

function jswrap_function_replaceWith($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP32[$2 + 40 >> 2] = $1;
 label$1: {
  label$2: {
   if (jsvIsFunction(HEAP32[$2 + 44 >> 2]) & 1) {
    if (jsvIsFunction(HEAP32[$2 + 40 >> 2]) & 1) {
     break label$2;
    }
   }
   jsExceptionHere(3, 128324, 0);
   break label$1;
  }
  if ((jsvIsNativeFunction(HEAP32[$2 + 44 >> 2]) & 1) != (jsvIsNativeFunction(HEAP32[$2 + 40 >> 2]) & 1)) {
   label$5: {
    if (jsvIsNativeFunction(HEAP32[$2 + 40 >> 2]) & 1) {
     $0 = HEAP32[$2 + 44 >> 2];
     $1 = HEAP32[$2 + 44 >> 2];
     $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64 | 8;
     HEAP8[$0 + 12 | 0] = $1;
     HEAP8[$0 + 13 | 0] = $1 >>> 8;
     $0 = HEAP32[$2 + 44 >> 2];
     $1 = HEAP32[$2 + 40 >> 2];
     $3 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
     HEAP8[$0 | 0] = $3;
     HEAP8[$0 + 1 | 0] = $3 >>> 8;
     HEAP8[$0 + 2 | 0] = $3 >>> 16;
     HEAP8[$0 + 3 | 0] = $3 >>> 24;
     $1 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8;
     HEAP8[$0 + 4 | 0] = $1;
     HEAP8[$0 + 5 | 0] = $1 >>> 8;
     break label$5;
    }
    $0 = HEAP32[$2 + 44 >> 2];
    HEAP8[$0 | 0] = 0;
    HEAP8[$0 + 1 | 0] = 0;
    HEAP8[$0 + 2 | 0] = 0;
    HEAP8[$0 + 3 | 0] = 0;
    HEAP8[$0 + 4 | 0] = 0;
    HEAP8[$0 + 5 | 0] = 0;
    $0 = HEAP32[$2 + 44 >> 2];
    $1 = HEAP32[$2 + 44 >> 2];
    $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64 | 7;
    HEAP8[$0 + 12 | 0] = $1;
    HEAP8[$0 + 13 | 0] = $1 >>> 8;
   }
  }
  if ((jsvIsFunctionReturn(HEAP32[$2 + 44 >> 2]) & 1) != (jsvIsFunctionReturn(HEAP32[$2 + 40 >> 2]) & 1)) {
   label$8: {
    if (jsvIsFunctionReturn(HEAP32[$2 + 40 >> 2]) & 1) {
     $0 = HEAP32[$2 + 44 >> 2];
     $1 = HEAP32[$2 + 44 >> 2];
     $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64 | 9;
     HEAP8[$0 + 12 | 0] = $1;
     HEAP8[$0 + 13 | 0] = $1 >>> 8;
     break label$8;
    }
    $0 = HEAP32[$2 + 44 >> 2];
    $1 = HEAP32[$2 + 44 >> 2];
    $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64 | 7;
    HEAP8[$0 + 12 | 0] = $1;
    HEAP8[$0 + 13 | 0] = $1 >>> 8;
   }
  }
  HEAP32[$2 + 36 >> 2] = jsvFindChildFromString(HEAP32[$2 + 44 >> 2], 128047);
  HEAP32[$2 + 32 >> 2] = jsvFindChildFromString(HEAP32[$2 + 44 >> 2], 132159);
  jsvRemoveAllChildren(HEAP32[$2 + 44 >> 2]);
  jsvObjectIteratorNew($2 + 24 | 0, HEAP32[$2 + 40 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_9($2 + 24 | 0) & 1) {
    HEAP32[$2 + 20 >> 2] = jsvObjectIteratorGetKey_6($2 + 24 | 0);
    jsvObjectIteratorNext($2 + 24 | 0);
    label$12: {
     if (jsvIsStringEqual(HEAP32[$2 + 20 >> 2], 128047) & 1) {
      break label$12;
     }
     if (jsvIsStringEqual(HEAP32[$2 + 20 >> 2], 132159) & 1) {
      break label$12;
     }
     label$13: {
      if (jsvIsStringEqual(HEAP32[$2 + 20 >> 2], 133204) & 1) {
       HEAP32[$2 + 12 >> 2] = jsvSkipName(HEAP32[$2 + 20 >> 2]);
       HEAP32[$2 + 16 >> 2] = jsvMakeIntoVariableName(jsvNewFromStringVarComplete(HEAP32[$2 + 20 >> 2]), HEAP32[$2 + 12 >> 2]);
       jsvUnLock(HEAP32[$2 + 12 >> 2]);
       break label$13;
      }
      HEAP32[$2 + 16 >> 2] = jsvCopy(HEAP32[$2 + 20 >> 2], 1);
     }
     if (HEAP32[$2 + 16 >> 2]) {
      jsvAddName(HEAP32[$2 + 44 >> 2], HEAP32[$2 + 16 >> 2]);
      jsvUnLock(HEAP32[$2 + 16 >> 2]);
     }
    }
    jsvUnLock(HEAP32[$2 + 20 >> 2]);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_9($2 + 24 | 0);
  if (HEAP32[$2 + 36 >> 2]) {
   jsvAddName(HEAP32[$2 + 44 >> 2], HEAP32[$2 + 36 >> 2]);
  }
  jsvUnLock(HEAP32[$2 + 36 >> 2]);
  if (HEAP32[$2 + 32 >> 2]) {
   jsvAddName(HEAP32[$2 + 44 >> 2], HEAP32[$2 + 32 >> 2]);
  }
  jsvUnLock(HEAP32[$2 + 32 >> 2]);
 }
 __stack_pointer = $2 + 48 | 0;
}

function graphicsDrawCircleAA($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 44 >> 2] = $0;
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 36 >> 2] = $2;
 HEAP32[$4 + 32 >> 2] = $3;
 graphicsToDeviceCoordinates(HEAP32[$4 + 44 >> 2], $4 + 40 | 0, $4 + 36 | 0);
 HEAP32[$4 + 28 >> 2] = 0 - HEAP32[$4 + 32 >> 2];
 HEAP32[$4 + 24 >> 2] = 0;
 HEAP32[$4 + 20 >> 2] = 2 - (HEAP32[$4 + 32 >> 2] << 1);
 HEAP32[$4 + 32 >> 2] = 1 - HEAP32[$4 + 20 >> 2];
 while (1) {
  HEAP32[$4 + 16 >> 2] = 255 - ((Math_imul(abs((HEAP32[$4 + 20 >> 2] - (HEAP32[$4 + 28 >> 2] + HEAP32[$4 + 24 >> 2] << 1) | 0) - 2 | 0), 255) | 0) / HEAP32[$4 + 32 >> 2] | 0);
  graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] - HEAP32[$4 + 28 >> 2] | 0, HEAP32[$4 + 36 >> 2] + HEAP32[$4 + 24 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
  graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] - HEAP32[$4 + 24 >> 2] | 0, HEAP32[$4 + 36 >> 2] - HEAP32[$4 + 28 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
  graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 28 >> 2] | 0, HEAP32[$4 + 36 >> 2] - HEAP32[$4 + 24 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
  graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 24 >> 2] | 0, HEAP32[$4 + 36 >> 2] + HEAP32[$4 + 28 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
  HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 20 >> 2];
  HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 28 >> 2];
  if ((HEAP32[$4 + 20 >> 2] + HEAP32[$4 + 24 >> 2] | 0) > 0) {
   HEAP32[$4 + 16 >> 2] = 255 - ((Math_imul((HEAP32[$4 + 20 >> 2] - (HEAP32[$4 + 28 >> 2] << 1) | 0) - 1 | 0, 255) | 0) / HEAP32[$4 + 32 >> 2] | 0);
   if (HEAP32[$4 + 16 >> 2] > 0) {
    graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] - HEAP32[$4 + 28 >> 2] | 0, (HEAP32[$4 + 36 >> 2] + HEAP32[$4 + 24 >> 2] | 0) + 1 | 0, HEAP32[$4 + 16 >> 2]);
    graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], (HEAP32[$4 + 40 >> 2] - HEAP32[$4 + 24 >> 2] | 0) - 1 | 0, HEAP32[$4 + 36 >> 2] - HEAP32[$4 + 28 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
    graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 28 >> 2] | 0, (HEAP32[$4 + 36 >> 2] - HEAP32[$4 + 24 >> 2] | 0) - 1 | 0, HEAP32[$4 + 16 >> 2]);
    graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], (HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 24 >> 2] | 0) + 1 | 0, HEAP32[$4 + 36 >> 2] + HEAP32[$4 + 28 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
   }
   $0 = HEAP32[$4 + 28 >> 2] + 1 | 0;
   HEAP32[$4 + 28 >> 2] = $0;
   HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + (($0 << 1) + 1 | 0);
  }
  if ((HEAP32[$4 + 8 >> 2] + HEAP32[$4 + 12 >> 2] | 0) <= 0) {
   HEAP32[$4 + 16 >> 2] = 255 - ((Math_imul(((HEAP32[$4 + 24 >> 2] << 1) + 3 | 0) - HEAP32[$4 + 8 >> 2] | 0, 255) | 0) / HEAP32[$4 + 32 >> 2] | 0);
   if (HEAP32[$4 + 16 >> 2] > 0) {
    graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], (HEAP32[$4 + 40 >> 2] - HEAP32[$4 + 12 >> 2] | 0) - 1 | 0, HEAP32[$4 + 36 >> 2] + HEAP32[$4 + 24 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
    graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] - HEAP32[$4 + 24 >> 2] | 0, (HEAP32[$4 + 36 >> 2] - HEAP32[$4 + 12 >> 2] | 0) - 1 | 0, HEAP32[$4 + 16 >> 2]);
    graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], (HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 12 >> 2] | 0) + 1 | 0, HEAP32[$4 + 36 >> 2] - HEAP32[$4 + 24 >> 2] | 0, HEAP32[$4 + 16 >> 2]);
    graphicsSetPixelDeviceBlended(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 24 >> 2] | 0, (HEAP32[$4 + 36 >> 2] + HEAP32[$4 + 12 >> 2] | 0) + 1 | 0, HEAP32[$4 + 16 >> 2]);
   }
   $0 = HEAP32[$4 + 24 >> 2] + 1 | 0;
   HEAP32[$4 + 24 >> 2] = $0;
   HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + (($0 << 1) + 1 | 0);
  }
  if (HEAP32[$4 + 28 >> 2] < 0) {
   continue;
  }
  break;
 }
 __stack_pointer = $4 + 48 | 0;
}

function mbedtls_sha256_finish($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 28 >> 2] + 4 >> 2] << 3 | HEAP32[HEAP32[$2 + 28 >> 2] >> 2] >>> 29;
 HEAP32[$2 + 8 >> 2] = HEAP32[HEAP32[$2 + 28 >> 2] >> 2] << 3;
 HEAP8[$2 | 0] = HEAP32[$2 + 12 >> 2] >>> 24;
 HEAP8[$2 + 1 | 0] = HEAP32[$2 + 12 >> 2] >>> 16;
 HEAP8[$2 + 2 | 0] = HEAP32[$2 + 12 >> 2] >>> 8;
 HEAP8[$2 + 3 | 0] = HEAP32[$2 + 12 >> 2];
 HEAP8[$2 + 4 | 0] = HEAP32[$2 + 8 >> 2] >>> 24;
 HEAP8[$2 + 5 | 0] = HEAP32[$2 + 8 >> 2] >>> 16;
 HEAP8[$2 + 6 | 0] = HEAP32[$2 + 8 >> 2] >>> 8;
 HEAP8[$2 + 7 | 0] = HEAP32[$2 + 8 >> 2];
 HEAP32[$2 + 20 >> 2] = HEAP32[HEAP32[$2 + 28 >> 2] >> 2] & 63;
 if (HEAPU32[$2 + 20 >> 2] < 56) {
  $0 = 56 - HEAP32[$2 + 20 >> 2] | 0;
 } else {
  $0 = 120 - HEAP32[$2 + 20 >> 2] | 0;
 }
 HEAP32[$2 + 16 >> 2] = $0;
 mbedtls_sha256_update(HEAP32[$2 + 28 >> 2], 170864, HEAP32[$2 + 16 >> 2]);
 mbedtls_sha256_update(HEAP32[$2 + 28 >> 2], $2, 8);
 HEAP8[HEAP32[$2 + 24 >> 2]] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 24 >> 2] + 1 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 24 >> 2] + 2 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 24 >> 2] + 3 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2];
 HEAP8[HEAP32[$2 + 24 >> 2] + 4 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 12 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 24 >> 2] + 5 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 12 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 24 >> 2] + 6 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 12 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 24 >> 2] + 7 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 12 >> 2];
 HEAP8[HEAP32[$2 + 24 >> 2] + 8 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 16 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 24 >> 2] + 9 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 16 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 24 >> 2] + 10 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 16 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 24 >> 2] + 11 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 16 >> 2];
 HEAP8[HEAP32[$2 + 24 >> 2] + 12 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 20 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 24 >> 2] + 13 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 20 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 24 >> 2] + 14 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 20 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 24 >> 2] + 15 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 20 >> 2];
 HEAP8[HEAP32[$2 + 24 >> 2] + 16 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 24 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 24 >> 2] + 17 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 24 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 24 >> 2] + 18 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 24 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 24 >> 2] + 19 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 24 >> 2];
 HEAP8[HEAP32[$2 + 24 >> 2] + 20 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 24 >> 2] + 21 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 24 >> 2] + 22 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 24 >> 2] + 23 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2];
 HEAP8[HEAP32[$2 + 24 >> 2] + 24 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 32 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 24 >> 2] + 25 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 32 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 24 >> 2] + 26 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 32 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 24 >> 2] + 27 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 32 >> 2];
 if (!HEAP32[HEAP32[$2 + 28 >> 2] + 104 >> 2]) {
  HEAP8[HEAP32[$2 + 24 >> 2] + 28 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 36 >> 2] >>> 24;
  HEAP8[HEAP32[$2 + 24 >> 2] + 29 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 36 >> 2] >>> 16;
  HEAP8[HEAP32[$2 + 24 >> 2] + 30 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 36 >> 2] >>> 8;
  HEAP8[HEAP32[$2 + 24 >> 2] + 31 | 0] = HEAP32[HEAP32[$2 + 28 >> 2] + 36 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
}

function tflite__ops__micro__conv__EvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams__2c_20tflite__ops__micro__conv__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
 var $10 = 0;
 $10 = __stack_pointer - 240 | 0;
 __stack_pointer = $10;
 HEAP32[$10 + 236 >> 2] = $0;
 HEAP32[$10 + 232 >> 2] = $1;
 HEAP32[$10 + 228 >> 2] = $2;
 HEAP32[$10 + 224 >> 2] = $3;
 HEAP32[$10 + 220 >> 2] = $4;
 HEAP32[$10 + 216 >> 2] = $5;
 HEAP32[$10 + 212 >> 2] = $6;
 HEAP32[$10 + 208 >> 2] = $7;
 HEAP32[$10 + 204 >> 2] = $8;
 HEAP32[$10 + 200 >> 2] = $9;
 HEAP32[$10 + 196 >> 2] = 0 - HEAP32[HEAP32[$10 + 224 >> 2] + 16 >> 2];
 HEAP32[$10 + 192 >> 2] = 0 - HEAP32[HEAP32[$10 + 224 >> 2] + 20 >> 2];
 HEAP32[$10 + 188 >> 2] = HEAP32[HEAP32[$10 + 224 >> 2] + 24 >> 2];
 HEAP8[$10 + 128 | 0] = tflite__ops__micro__conv__RuntimePaddingType_28TfLitePadding_29(HEAP32[HEAP32[$10 + 228 >> 2] >> 2]);
 HEAP16[$10 + 130 >> 1] = HEAP32[HEAP32[$10 + 224 >> 2] >> 2];
 HEAP16[$10 + 132 >> 1] = HEAP32[HEAP32[$10 + 224 >> 2] + 4 >> 2];
 HEAP16[$10 + 138 >> 1] = HEAP32[HEAP32[$10 + 228 >> 2] + 4 >> 2];
 HEAP16[$10 + 140 >> 1] = HEAP32[HEAP32[$10 + 228 >> 2] + 8 >> 2];
 HEAP16[$10 + 142 >> 1] = HEAP32[HEAP32[$10 + 228 >> 2] + 16 >> 2];
 HEAP16[$10 + 144 >> 1] = HEAP32[HEAP32[$10 + 228 >> 2] + 20 >> 2];
 HEAP32[$10 + 148 >> 2] = HEAP32[$10 + 196 >> 2];
 HEAP32[$10 + 152 >> 2] = HEAP32[$10 + 192 >> 2];
 HEAP32[$10 + 156 >> 2] = HEAP32[$10 + 188 >> 2];
 HEAP32[$10 + 160 >> 2] = HEAP32[HEAP32[$10 + 224 >> 2] + 28 >> 2];
 HEAP32[$10 + 164 >> 2] = 0 - HEAP32[HEAP32[$10 + 224 >> 2] + 32 >> 2];
 HEAP32[$10 + 168 >> 2] = HEAP32[HEAP32[$10 + 224 >> 2] + 44 >> 2];
 HEAP32[$10 + 172 >> 2] = HEAP32[HEAP32[$10 + 224 >> 2] + 48 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($10 + 104 | 0, HEAP32[$10 + 220 >> 2]);
 $0 = unsigned_20char_20const__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor_20const__29(HEAP32[$10 + 220 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($10 + 80 | 0, HEAP32[$10 + 216 >> 2]);
 $1 = unsigned_20char_20const__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor_20const__29(HEAP32[$10 + 216 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($10 + 56 | 0, HEAP32[$10 + 212 >> 2]);
 $2 = int_20const__20tflite__micro__GetTensorData_int__28TfLiteEvalTensor_20const__29(HEAP32[$10 + 212 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($10 + 32 | 0, HEAP32[$10 + 200 >> 2]);
 $3 = unsigned_20char__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor__29(HEAP32[$10 + 200 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($10 + 8 | 0, HEAP32[$10 + 208 >> 2]);
 tflite__reference_ops__Conv_28tflite__ConvParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__2c_20void__29($10 + 128 | 0, $10 + 104 | 0, $0, $10 + 80 | 0, $1, $10 + 56 | 0, $2, $10 + 32 | 0, $3, $10 + 8 | 0, unsigned_20char__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor__29(HEAP32[$10 + 208 >> 2]), 0);
 tflite__RuntimeShape___RuntimeShape_28_29($10 + 8 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($10 + 32 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($10 + 56 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($10 + 80 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($10 + 104 | 0);
 __stack_pointer = $10 + 240 | 0;
}

function stringToFloatWithRadix($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 52 >> 2] = $0;
 HEAP32[$3 + 48 >> 2] = $1;
 HEAP32[$3 + 44 >> 2] = $2;
 while (1) {
  if (isWhitespace(HEAP8[HEAP32[$3 + 52 >> 2]]) & 1) {
   HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP8[$3 + 43 | 0] = 0;
 label$3: {
  if (HEAP8[HEAP32[$3 + 52 >> 2]] == 45) {
   HEAP8[$3 + 43 | 0] = 1;
   HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
   break label$3;
  }
  if (HEAP8[HEAP32[$3 + 52 >> 2]] == 43) {
   HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
  }
 }
 HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 52 >> 2];
 if (HEAP32[$3 + 44 >> 2]) {
  HEAP32[HEAP32[$3 + 44 >> 2] >> 2] = HEAP32[$3 + 52 >> 2];
 }
 if (HEAP32[$3 + 48 >> 2]) {
  $0 = HEAP32[$3 + 48 >> 2];
 } else {
  $0 = getRadix($3 + 52 | 0);
 }
 HEAP32[$3 + 32 >> 2] = $0;
 label$9: {
  if (!HEAP32[$3 + 32 >> 2]) {
   HEAPF64[$3 + 56 >> 3] = nan;
   break label$9;
  }
  HEAPF64[$3 + 24 >> 3] = 0;
  HEAPF64[$3 + 16 >> 3] = .1;
  while (1) {
   label$12: {
    if (!HEAPU8[HEAP32[$3 + 52 >> 2]]) {
     break label$12;
    }
    HEAP32[$3 + 12 >> 2] = chtod(HEAP8[HEAP32[$3 + 52 >> 2]]);
    if (HEAP32[$3 + 12 >> 2] < 0 | HEAP32[$3 + 12 >> 2] >= HEAP32[$3 + 32 >> 2]) {
     break label$12;
    }
    HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 24 >> 3] * +HEAP32[$3 + 32 >> 2] + +HEAP32[$3 + 12 >> 2];
    HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[$3 + 32 >> 2] == 10) {
   if (HEAP8[HEAP32[$3 + 52 >> 2]] == 46) {
    HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
    while (1) {
     if (!(!HEAPU8[HEAP32[$3 + 52 >> 2]] | HEAP8[HEAP32[$3 + 52 >> 2]] < 48 | HEAP8[HEAP32[$3 + 52 >> 2]] > 57)) {
      HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 16 >> 3] * +(HEAP8[HEAP32[$3 + 52 >> 2]] - 48 | 0) + HEAPF64[$3 + 24 >> 3];
      HEAPF64[$3 + 16 >> 3] = HEAPF64[$3 + 16 >> 3] / 10;
      HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
      continue;
     }
     break;
    }
   }
   if (!(HEAP8[HEAP32[$3 + 52 >> 2]] != 101 & HEAP8[HEAP32[$3 + 52 >> 2]] != 69)) {
    HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
    HEAP8[$3 + 11 | 0] = 0;
    if (!(HEAP8[HEAP32[$3 + 52 >> 2]] != 45 & HEAP8[HEAP32[$3 + 52 >> 2]] != 43)) {
     HEAP8[$3 + 11 | 0] = HEAP8[HEAP32[$3 + 52 >> 2]] == 45;
     HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
    }
    HEAP32[$3 + 4 >> 2] = 0;
    while (1) {
     if (!(!HEAPU8[HEAP32[$3 + 52 >> 2]] | HEAP8[HEAP32[$3 + 52 >> 2]] < 48 | HEAP8[HEAP32[$3 + 52 >> 2]] > 57)) {
      HEAP32[$3 + 4 >> 2] = (HEAP8[HEAP32[$3 + 52 >> 2]] - 48 | 0) + Math_imul(HEAP32[$3 + 4 >> 2], 10);
      HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
      continue;
     }
     break;
    }
    if (HEAP8[$3 + 11 | 0] & 1) {
     HEAP32[$3 + 4 >> 2] = 0 - HEAP32[$3 + 4 >> 2];
    }
    while (1) {
     if (HEAP32[$3 + 4 >> 2] > 0) {
      HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 24 >> 3] * 10;
      HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] - 1;
      continue;
     }
     break;
    }
    while (1) {
     if (HEAP32[$3 + 4 >> 2] < 0) {
      HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 24 >> 3] / 10;
      HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 1;
      continue;
     }
     break;
    }
   }
  }
  if (HEAP32[$3 + 44 >> 2]) {
   HEAP32[HEAP32[$3 + 44 >> 2] >> 2] = HEAP32[$3 + 52 >> 2];
  }
  if (!((HEAP8[HEAP32[$3 + 36 >> 2]] != 46 | HEAP32[$3 + 52 >> 2] != (HEAP32[$3 + 36 >> 2] + 1 | 0)) & HEAP32[$3 + 36 >> 2] != HEAP32[$3 + 52 >> 2])) {
   HEAPF64[$3 + 56 >> 3] = nan;
   break label$9;
  }
  if (HEAP8[$3 + 43 | 0] & 1) {
   HEAPF64[$3 + 56 >> 3] = -HEAPF64[$3 + 24 >> 3];
   break label$9;
  }
  HEAPF64[$3 + 56 >> 3] = HEAPF64[$3 + 24 >> 3];
 }
 __stack_pointer = $3 - -64 | 0;
 return HEAPF64[$3 + 56 >> 3];
}

function _jswrap_drawImageLayerInit($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 HEAP32[HEAP32[$1 + 44 >> 2] + 156 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 36 >> 2] << 8;
 HEAP32[HEAP32[$1 + 44 >> 2] + 160 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 40 >> 2] << 8;
 HEAPF64[$1 + 32 >> 3] = jswrap_math_cos(HEAPF64[HEAP32[$1 + 44 >> 2] + 16 >> 3]);
 HEAPF64[$1 + 24 >> 3] = jswrap_math_sin(HEAPF64[HEAP32[$1 + 44 >> 2] + 16 >> 3]);
 $3 = HEAP32[$1 + 44 >> 2];
 $2 = HEAPF64[$1 + 32 >> 3] / HEAPF64[HEAP32[$1 + 44 >> 2] + 24 >> 3] * 256;
 label$1: {
  if (Math_abs($2) < 2147483648) {
   $0 = ~~$2;
   break label$1;
  }
  $0 = -2147483648;
 }
 HEAP32[$3 + 164 >> 2] = $0;
 $3 = HEAP32[$1 + 44 >> 2];
 $2 = HEAPF64[$1 + 24 >> 3] / HEAPF64[HEAP32[$1 + 44 >> 2] + 24 >> 3] * 256;
 label$3: {
  if (Math_abs($2) < 2147483648) {
   $0 = ~~$2;
   break label$3;
  }
  $0 = -2147483648;
 }
 HEAP32[$3 + 168 >> 2] = $0;
 $2 = HEAPF64[HEAP32[$1 + 44 >> 2] + 24 >> 3] * (+HEAP32[HEAP32[$1 + 44 >> 2] + 36 >> 2] * Math_abs(HEAPF64[$1 + 32 >> 3]) + +HEAP32[HEAP32[$1 + 44 >> 2] + 40 >> 2] * Math_abs(HEAPF64[$1 + 24 >> 3])) + .5;
 label$5: {
  if (Math_abs($2) < 2147483648) {
   $0 = ~~$2;
   break label$5;
  }
  $0 = -2147483648;
 }
 HEAP32[$1 + 20 >> 2] = $0;
 $2 = HEAPF64[HEAP32[$1 + 44 >> 2] + 24 >> 3] * (+HEAP32[HEAP32[$1 + 44 >> 2] + 36 >> 2] * Math_abs(HEAPF64[$1 + 24 >> 3]) + +HEAP32[HEAP32[$1 + 44 >> 2] + 40 >> 2] * Math_abs(HEAPF64[$1 + 32 >> 3])) + .5;
 label$7: {
  if (Math_abs($2) < 2147483648) {
   $0 = ~~$2;
   break label$7;
  }
  $0 = -2147483648;
 }
 HEAP32[$1 + 16 >> 2] = $0;
 if (HEAP8[HEAP32[$1 + 44 >> 2] + 32 | 0] & 1) {
  $0 = HEAP32[$1 + 44 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - (HEAP32[$1 + 20 >> 2] << 7);
  $0 = HEAP32[$1 + 44 >> 2];
  HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] - (HEAP32[$1 + 16 >> 2] << 7);
 }
 HEAP32[HEAP32[$1 + 44 >> 2] + 8 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] >> 2] + (HEAP32[$1 + 20 >> 2] << 8);
 HEAP32[HEAP32[$1 + 44 >> 2] + 12 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 4 >> 2] + (HEAP32[$1 + 16 >> 2] << 8);
 HEAP32[$1 + 12 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 36 >> 2] << 7;
 HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 40 >> 2] << 7;
 HEAP32[HEAP32[$1 + 44 >> 2] + 172 >> 2] = HEAP32[$1 + 12 >> 2] - (((Math_imul(HEAP32[HEAP32[$1 + 44 >> 2] + 164 >> 2], HEAP32[$1 + 20 >> 2]) + 1 | 0) + Math_imul(HEAP32[HEAP32[$1 + 44 >> 2] + 168 >> 2], HEAP32[$1 + 16 >> 2]) | 0) / 2 | 0);
 HEAP32[HEAP32[$1 + 44 >> 2] + 176 >> 2] = HEAP32[$1 + 8 >> 2] - (((Math_imul(HEAP32[HEAP32[$1 + 44 >> 2] + 164 >> 2], HEAP32[$1 + 16 >> 2]) + 1 | 0) - Math_imul(HEAP32[HEAP32[$1 + 44 >> 2] + 168 >> 2], HEAP32[$1 + 20 >> 2]) | 0) / 2 | 0);
 if (HEAP8[HEAP32[$1 + 44 >> 2] + 33 | 0] & 1) {
  while (1) {
   if (HEAP32[HEAP32[$1 + 44 >> 2] + 172 >> 2] < 0) {
    $0 = HEAP32[$1 + 44 >> 2];
    HEAP32[$0 + 172 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 156 >> 2] + HEAP32[$0 + 172 >> 2];
    continue;
   }
   break;
  }
  while (1) {
   if (HEAP32[HEAP32[$1 + 44 >> 2] + 172 >> 2] >= HEAP32[HEAP32[$1 + 44 >> 2] + 156 >> 2]) {
    $0 = HEAP32[$1 + 44 >> 2];
    HEAP32[$0 + 172 >> 2] = HEAP32[$0 + 172 >> 2] - HEAP32[HEAP32[$1 + 44 >> 2] + 156 >> 2];
    continue;
   }
   break;
  }
  while (1) {
   if (HEAP32[HEAP32[$1 + 44 >> 2] + 176 >> 2] < 0) {
    $0 = HEAP32[$1 + 44 >> 2];
    HEAP32[$0 + 176 >> 2] = HEAP32[HEAP32[$1 + 44 >> 2] + 160 >> 2] + HEAP32[$0 + 176 >> 2];
    continue;
   }
   break;
  }
  while (1) {
   if (HEAP32[HEAP32[$1 + 44 >> 2] + 176 >> 2] >= HEAP32[HEAP32[$1 + 44 >> 2] + 160 >> 2]) {
    $0 = HEAP32[$1 + 44 >> 2];
    HEAP32[$0 + 176 >> 2] = HEAP32[$0 + 176 >> 2] - HEAP32[HEAP32[$1 + 44 >> 2] + 160 >> 2];
    continue;
   }
   break;
  }
 }
 __stack_pointer = $1 + 48 | 0;
}

function jshPinFunctionToString($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP16[$4 + 46 >> 1] = $0;
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 36 >> 2] = $2;
 HEAP32[$4 + 32 >> 2] = $3;
 HEAP32[$4 + 28 >> 2] = 148267;
 HEAP16[$4 + 26 >> 1] = HEAPU16[$4 + 46 >> 1] & 61440;
 HEAP16[$4 + 24 >> 1] = 0;
 HEAP32[$4 + 20 >> 2] = 0;
 HEAP8[HEAP32[$4 + 36 >> 2]] = 0;
 label$1: {
  if (!((HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 < 768 | (HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 > 848)) {
   HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 40 >> 2] & 16 ? 129076 : 136604;
   HEAP16[$4 + 24 >> 1] = 768;
   label$3: {
    if (!HEAPU16[$4 + 26 >> 1]) {
     HEAP32[$4 + 20 >> 2] = 136446;
     break label$3;
    }
    label$5: {
     if (HEAPU16[$4 + 26 >> 1] == 4096) {
      HEAP32[$4 + 20 >> 2] = 136362;
      break label$5;
     }
     if (HEAPU16[$4 + 26 >> 1] == 8192) {
      HEAP32[$4 + 20 >> 2] = 137455;
     }
    }
   }
   break label$1;
  }
  label$8: {
   if (!((HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 < 512 | (HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 > 544)) {
    HEAP32[$4 + 28 >> 2] = 137555;
    HEAP16[$4 + 24 >> 1] = 512;
    label$10: {
     if (!HEAPU16[$4 + 26 >> 1]) {
      HEAP32[$4 + 20 >> 2] = 136962;
      break label$10;
     }
     label$12: {
      if (HEAPU16[$4 + 26 >> 1] == 4096) {
       HEAP32[$4 + 20 >> 2] = 137462;
       break label$12;
      }
      if (HEAPU16[$4 + 26 >> 1] == 8192) {
       HEAP32[$4 + 20 >> 2] = 137438;
      }
     }
    }
    break label$8;
   }
   label$15: {
    if (!((HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 < 640 | (HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 > 688)) {
     HEAP32[$4 + 28 >> 2] = 138134;
     HEAP16[$4 + 24 >> 1] = 640;
     label$17: {
      if (!HEAPU16[$4 + 26 >> 1]) {
       HEAP32[$4 + 20 >> 2] = 137359;
       break label$17;
      }
      if (HEAPU16[$4 + 26 >> 1] == 4096) {
       HEAP32[$4 + 20 >> 2] = 138215;
      }
     }
     break label$15;
    }
    label$20: {
     if ((HEAPU16[$4 + 46 >> 1] & 4080) == 384) {
      HEAP32[$4 + 28 >> 2] = 138130;
      HEAP16[$4 + 24 >> 1] = 384;
      label$22: {
       if (!HEAPU16[$4 + 26 >> 1]) {
        HEAP32[$4 + 20 >> 2] = 139918;
        break label$22;
       }
       if (HEAPU16[$4 + 26 >> 1] == 4096) {
        HEAP32[$4 + 20 >> 2] = 139643;
       }
      }
      break label$20;
     }
     if (!((HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 < 16 | (HEAPU16[$4 + 46 >> 1] & 4080) >>> 0 > 288)) {
      HEAP32[$4 + 28 >> 2] = 137248;
      HEAP16[$4 + 24 >> 1] = 16;
      HEAP32[$4 + 20 >> 2] = $4 + 15;
      HEAP8[$4 + 15 | 0] = 67;
      HEAP8[$4 + 16 | 0] = 72;
      HEAP8[$4 + 17 | 0] = ((HEAPU16[$4 + 26 >> 1] & 28672) >>> 12 | 0) + 49;
      label$26: {
       if (HEAPU16[$4 + 26 >> 1] & 32768) {
        HEAP8[$4 + 18 | 0] = 78;
        HEAP8[$4 + 19 | 0] = 0;
        break label$26;
       }
       HEAP8[$4 + 18 | 0] = 0;
      }
     }
    }
   }
  }
 }
 HEAP32[$4 + 8 >> 2] = ((HEAPU16[$4 + 46 >> 1] & 4080) - HEAPU16[$4 + 24 >> 1] >> 4) + 1;
 label$28: {
  if (!HEAP32[$4 + 28 >> 2]) {
   HEAP32[$4 >> 2] = HEAPU16[$4 + 46 >> 1];
   jsiConsolePrintf(147239, $4);
   break label$28;
  }
  if (HEAP32[$4 + 40 >> 2] & 1) {
   strncat(HEAP32[$4 + 36 >> 2], HEAP32[$4 + 28 >> 2], HEAP32[$4 + 32 >> 2] - 1 | 0);
  }
  if (HEAP32[$4 + 40 >> 2] & 2) {
   itostr_2(HEAP32[$4 + 8 >> 2], HEAP32[$4 + 36 >> 2] + strlen(HEAP32[$4 + 36 >> 2]) | 0, 10);
  }
  if (HEAP32[$4 + 40 >> 2] & 4) {
   strncat(HEAP32[$4 + 36 >> 2], 146437, HEAP32[$4 + 32 >> 2] - (strlen(HEAP32[$4 + 36 >> 2]) + 1 | 0) | 0);
  }
  if (!HEAP32[$4 + 20 >> 2] | !(HEAP32[$4 + 40 >> 2] & 8)) {
   break label$28;
  }
  strncat(HEAP32[$4 + 36 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 32 >> 2] - (strlen(HEAP32[$4 + 36 >> 2]) + 1 | 0) | 0);
 }
 __stack_pointer = $4 + 48 | 0;
}

function jsvAsString($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 112 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 108 >> 2] = $0;
 HEAP32[$1 + 104 >> 2] = 0;
 label$1: {
  label$2: {
   if (!(jsvHasCharacterData(HEAP32[$1 + 108 >> 2]) & 1)) {
    break label$2;
   }
   if (!(jsvIsName(HEAP32[$1 + 108 >> 2]) & 1)) {
    break label$2;
   }
   HEAP32[$1 + 104 >> 2] = jsvNewFromStringVarComplete(HEAP32[$1 + 108 >> 2]);
   break label$1;
  }
  label$3: {
   if (jsvIsString(HEAP32[$1 + 108 >> 2]) & 1) {
    HEAP32[$1 + 104 >> 2] = jsvLockAgain(HEAP32[$1 + 108 >> 2]);
    break label$3;
   }
   label$5: {
    if (jsvIsObject(HEAP32[$1 + 108 >> 2]) & 1) {
     HEAP32[$1 + 100 >> 2] = jspGetNamedField(HEAP32[$1 + 108 >> 2], 129776, 0);
     label$7: {
      label$8: {
       if (!HEAP32[$1 + 100 >> 2]) {
        break label$8;
       }
       $0 = HEAP32[$1 + 100 >> 2];
       if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 1) {
        break label$8;
       }
       HEAP32[$1 + 96 >> 2] = jspExecuteFunction(HEAP32[$1 + 100 >> 2], HEAP32[$1 + 108 >> 2], 0, 0);
       jsvUnLock(HEAP32[$1 + 100 >> 2]);
       HEAP32[$1 + 104 >> 2] = jsvAsStringAndUnLock(HEAP32[$1 + 96 >> 2]);
       break label$7;
      }
      jsvUnLock(HEAP32[$1 + 100 >> 2]);
      HEAP32[$1 + 104 >> 2] = jsvNewFromString(135884);
     }
     break label$5;
    }
    HEAP32[$1 + 92 >> 2] = jsvGetConstString(HEAP32[$1 + 108 >> 2]);
    label$9: {
     if (HEAP32[$1 + 92 >> 2]) {
      HEAP32[$1 + 104 >> 2] = jsvNewFromString(HEAP32[$1 + 92 >> 2]);
      break label$9;
     }
     label$11: {
      if (jsvIsPin(HEAP32[$1 + 108 >> 2]) & 1) {
       $0 = HEAP32[$1 + 108 >> 2];
       jshGetPinString($1 + 16 | 0, (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) & 255);
       HEAP32[$1 + 104 >> 2] = jsvNewFromString($1 + 16 | 0);
       break label$11;
      }
      label$13: {
       if (jsvIsInt(HEAP32[$1 + 108 >> 2]) & 1) {
        $0 = HEAP32[$1 + 108 >> 2];
        itostr(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), $1 + 16 | 0, 10);
        HEAP32[$1 + 104 >> 2] = jsvNewFromString($1 + 16 | 0);
        break label$13;
       }
       label$15: {
        if (jsvIsFloat(HEAP32[$1 + 108 >> 2]) & 1) {
         $0 = HEAP32[$1 + 108 >> 2];
         $2 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
         wasm2js_scratch_store_i32(0, HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
         wasm2js_scratch_store_i32(1, $2 | 0);
         ftoa_bounded(+wasm2js_scratch_load_f64(), $1 + 16 | 0, 70);
         HEAP32[$1 + 104 >> 2] = jsvNewFromString($1 + 16 | 0);
         break label$15;
        }
        label$17: {
         label$18: {
          if (!(jsvIsArray(HEAP32[$1 + 108 >> 2]) & 1)) {
           if (!(jsvIsArrayBuffer(HEAP32[$1 + 108 >> 2]) & 1)) {
            break label$18;
           }
          }
          HEAP32[$1 + 12 >> 2] = jsvNewFromString(141344);
          HEAP32[$1 + 104 >> 2] = jsvArrayJoin(HEAP32[$1 + 108 >> 2], HEAP32[$1 + 12 >> 2], 1);
          jsvUnLock(HEAP32[$1 + 12 >> 2]);
          break label$17;
         }
         label$20: {
          if (jsvIsFunction(HEAP32[$1 + 108 >> 2]) & 1) {
           HEAP32[$1 + 104 >> 2] = jsvNewFromEmptyString_1();
           if (HEAP32[$1 + 104 >> 2]) {
            jsfGetJSON(HEAP32[$1 + 108 >> 2], HEAP32[$1 + 104 >> 2], 0);
           }
           break label$20;
          }
          jsExceptionHere(4, 129732, 0);
         }
        }
       }
      }
     }
    }
   }
  }
 }
 __stack_pointer = $1 + 112 | 0;
 return HEAP32[$1 + 104 >> 2];
}

function jspeStatementSwitch() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 48 | 0;
 __stack_pointer = $0;
 jslGetNextToken();
 label$1: {
  if (!(jslMatch(40) & 1)) {
   break label$1;
  }
  HEAP32[$0 + 40 >> 2] = jspeExpression();
  HEAP32[$0 + 36 >> 2] = HEAP32[91094] & 512;
  HEAP32[$0 + 32 >> 2] = HEAP32[91094];
  HEAP8[$0 + 31 | 0] = (HEAP32[91094] & 63) == 1;
  if (!(jslMatch(41) & 1)) {
   jsvUnLock(HEAP32[$0 + 40 >> 2]);
   break label$1;
  }
  if (!(HEAP8[$0 + 31 | 0] & 1)) {
   jsvUnLock(HEAP32[$0 + 40 >> 2]);
   jspeBlock();
   break label$1;
  }
  if (!(jslMatch(123) & 1)) {
   jsvUnLock(HEAP32[$0 + 40 >> 2]);
   break label$1;
  }
  HEAP8[$0 + 30 | 0] = 1;
  if (HEAP8[$0 + 31 | 0] & 1) {
   HEAP32[91094] = HEAP32[$0 + 36 >> 2] | 1024;
  }
  while (1) {
   if (HEAP16[HEAP32[49079] + 2 >> 1] == 188) {
    HEAP32[$0 + 24 >> 2] = HEAP32[91094];
    if (HEAP8[$0 + 31 | 0] & 1) {
     HEAP32[91094] = HEAP32[$0 + 36 >> 2] | 1025;
    }
    if (!(jslMatch(188) & 1)) {
     jsvUnLock(HEAP32[$0 + 40 >> 2]);
     break label$1;
    }
    HEAP32[$0 + 20 >> 2] = jspeAssignmentExpression();
    HEAP32[91094] = HEAP32[$0 + 24 >> 2] | 1024;
    if (!(jslMatch(58) & 1)) {
     jsvUnLock2(HEAP32[$0 + 40 >> 2], HEAP32[$0 + 20 >> 2]);
     break label$1;
    }
    HEAP8[$0 + 19 | 0] = 0;
    if (HEAP8[$0 + 31 | 0] & 1) {
     HEAP8[$0 + 19 | 0] = jsvGetBoolAndUnLock(jsvMathsOpSkipNames(HEAP32[$0 + 40 >> 2], HEAP32[$0 + 20 >> 2], 139)) & 1;
    }
    if (HEAP8[$0 + 19 | 0] & 1) {
     HEAP8[$0 + 30 | 0] = 0;
    }
    jsvUnLock(HEAP32[$0 + 20 >> 2]);
    if (!(!(HEAP8[$0 + 19 | 0] & 1) | HEAP32[91094] & 63)) {
     HEAP32[91094] = HEAP32[$0 + 36 >> 2] | 1025;
    }
    while (1) {
     $1 = 0;
     label$16: {
      if (HEAP32[91094] & 80) {
       break label$16;
      }
      $1 = 0;
      if (!HEAP16[HEAP32[49079] + 2 >> 1]) {
       break label$16;
      }
      $1 = 0;
      if (HEAP16[HEAP32[49079] + 2 >> 1] == 188) {
       break label$16;
      }
      $1 = 0;
      if (HEAP16[HEAP32[49079] + 2 >> 1] == 189) {
       break label$16;
      }
      $1 = HEAP16[HEAP32[49079] + 2 >> 1] != 125;
     }
     if ($1) {
      jsvUnLock(jspeBlockOrStatement());
      continue;
     }
     break;
    }
    HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 32 >> 2] | HEAP32[91094] & 124;
    continue;
   }
   break;
  }
  jsvUnLock(HEAP32[$0 + 40 >> 2]);
  label$18: {
   if (!(!(HEAP8[$0 + 31 | 0] & 1) | (HEAP32[91094] & 63) != 2)) {
    HEAP32[91094] = HEAP32[$0 + 36 >> 2] | 1025;
    break label$18;
   }
   HEAP8[$0 + 30 | 0] = 1;
  }
  HEAP32[91094] = HEAP32[91094] & -1664 | HEAP32[$0 + 32 >> 2] & 1663;
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 189) {
   jslGetNextToken();
   if (!(jslMatch(58) & 1)) {
    break label$1;
   }
   HEAP32[$0 + 12 >> 2] = HEAP32[91094];
   label$22: {
    if (!(HEAP8[$0 + 30 | 0] & 1)) {
     jspSetNoExecute();
     break label$22;
    }
    HEAP32[91094] = HEAP32[91094] | 1024;
   }
   while (1) {
    $1 = 0;
    label$25: {
     if (HEAP32[91094] & 80) {
      break label$25;
     }
     $1 = 0;
     if (!HEAP16[HEAP32[49079] + 2 >> 1]) {
      break label$25;
     }
     $1 = 0;
     if (HEAP16[HEAP32[49079] + 2 >> 1] == 125) {
      break label$25;
     }
     $1 = HEAP16[HEAP32[49079] + 2 >> 1] != 188;
    }
    if ($1) {
     jsvUnLock(jspeBlockOrStatement());
     continue;
    }
    break;
   }
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] | HEAP32[91094] & 124;
   HEAP32[91094] = HEAP32[91094] & -3;
   HEAP32[91094] = HEAP32[91094] & -1664 | HEAP32[$0 + 12 >> 2] & 1663;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 188) {
   jsExceptionHere(2, 133363, 0);
   break label$1;
  }
  jslMatch(125);
 }
 HEAP32[$0 + 44 >> 2] = 0;
 __stack_pointer = $0 + 48 | 0;
 return HEAP32[$0 + 44 >> 2];
}

function _jswrap_drawImageSimple($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer + -64 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 60 >> 2] = $0;
 HEAP32[$6 + 56 >> 2] = $1;
 HEAP32[$6 + 52 >> 2] = $2;
 HEAP32[$6 + 48 >> 2] = $3;
 HEAP32[$6 + 44 >> 2] = $4;
 HEAP8[$6 + 43 | 0] = $5;
 HEAP32[$6 + 36 >> 2] = 0;
 HEAP32[$6 + 32 >> 2] = 0;
 HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 56 >> 2];
 HEAP32[$6 + 24 >> 2] = HEAP32[$6 + 52 >> 2];
 HEAP32[$6 + 20 >> 2] = (HEAP32[$6 + 56 >> 2] + HEAP32[HEAP32[$6 + 48 >> 2] >> 2] | 0) - 1;
 HEAP32[$6 + 16 >> 2] = (HEAP32[$6 + 52 >> 2] + HEAP32[HEAP32[$6 + 48 >> 2] + 4 >> 2] | 0) - 1;
 label$1: {
  if (!(jsvStringIteratorHasChar_12(HEAP32[$6 + 44 >> 2]) & 1)) {
   break label$1;
  }
  graphicsSetModifiedAndClip(HEAP32[$6 + 60 >> 2], $6 + 28 | 0, $6 + 24 | 0, $6 + 20 | 0, $6 + 16 | 0, 1);
  if (!(HEAP32[$6 + 16 >> 2] >= HEAP32[$6 + 24 >> 2] & HEAP32[$6 + 20 >> 2] >= HEAP32[$6 + 28 >> 2])) {
   if (HEAP8[$6 + 43 | 0] & 1) {
    HEAP32[$6 + 36 >> 2] = 0 - Math_imul(HEAP32[HEAP32[$6 + 48 >> 2] + 4 >> 2], Math_imul(HEAP32[HEAP32[$6 + 48 >> 2] >> 2], HEAP32[HEAP32[$6 + 48 >> 2] + 8 >> 2]));
    while (1) {
     if (HEAP32[$6 + 36 >> 2] < 0) {
      jsvStringIteratorNextUTF8(HEAP32[$6 + 44 >> 2]);
      HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 36 >> 2] + 8;
      continue;
     }
     break;
    }
   }
   break label$1;
  }
  HEAP32[$6 + 36 >> 2] = 0 - Math_imul(HEAP32[HEAP32[$6 + 48 >> 2] >> 2], Math_imul(HEAP32[HEAP32[$6 + 48 >> 2] + 8 >> 2], HEAP32[$6 + 24 >> 2] - HEAP32[$6 + 52 >> 2] | 0));
  HEAP32[$6 + 12 >> 2] = graphicsGetSetPixelUnclippedFn(HEAP32[$6 + 60 >> 2], HEAP32[$6 + 56 >> 2], HEAP32[$6 + 24 >> 2], (HEAP32[$6 + 56 >> 2] + HEAP32[HEAP32[$6 + 48 >> 2] >> 2] | 0) - 1 | 0, HEAP32[$6 + 16 >> 2], 1);
  HEAP32[$6 + 8 >> 2] = HEAP32[$6 + 24 >> 2];
  while (1) {
   if (HEAP32[$6 + 8 >> 2] <= HEAP32[$6 + 16 >> 2]) {
    HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 56 >> 2];
    while (1) {
     if (HEAP32[$6 + 4 >> 2] < (HEAP32[$6 + 56 >> 2] + HEAP32[HEAP32[$6 + 48 >> 2] >> 2] | 0)) {
      while (1) {
       if (HEAP32[$6 + 36 >> 2] < HEAP32[HEAP32[$6 + 48 >> 2] + 8 >> 2]) {
        HEAP32[$6 + 32 >> 2] = HEAP32[$6 + 32 >> 2] << 8 | jsvStringIteratorGetUTF8CharAndNext(HEAP32[$6 + 44 >> 2]) & 255;
        HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 36 >> 2] + 8;
        continue;
       }
       break;
      }
      HEAP32[$6 >> 2] = HEAP32[HEAP32[$6 + 48 >> 2] + 36 >> 2] & HEAP32[$6 + 32 >> 2] >>> HEAP32[$6 + 36 >> 2] - HEAP32[HEAP32[$6 + 48 >> 2] + 8 >> 2];
      HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 36 >> 2] - HEAP32[HEAP32[$6 + 48 >> 2] + 8 >> 2];
      if (HEAP32[HEAP32[$6 + 48 >> 2] + 16 >> 2] != HEAP32[$6 >> 2]) {
       if (HEAP32[HEAP32[$6 + 48 >> 2] + 28 >> 2]) {
        HEAP32[$6 >> 2] = HEAPU16[HEAP32[HEAP32[$6 + 48 >> 2] + 28 >> 2] + ((HEAP32[$6 >> 2] & HEAP32[HEAP32[$6 + 48 >> 2] + 32 >> 2]) << 1) >> 1];
       }
       FUNCTION_TABLE[HEAP32[$6 + 12 >> 2]](HEAP32[$6 + 60 >> 2], HEAP32[$6 + 4 >> 2], HEAP32[$6 + 8 >> 2], HEAP32[$6 >> 2]);
      }
      HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] + 1;
      continue;
     }
     break;
    }
    HEAP32[$6 + 8 >> 2] = HEAP32[$6 + 8 >> 2] + 1;
    continue;
   }
   break;
  }
  if (!(HEAP8[$6 + 43 | 0] & 1)) {
   break label$1;
  }
  HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 36 >> 2] + (HEAP32[HEAP32[$6 + 48 >> 2] + 8 >> 2] - Math_imul(HEAP32[HEAP32[$6 + 48 >> 2] >> 2], Math_imul(HEAP32[HEAP32[$6 + 48 >> 2] + 8 >> 2], HEAP32[$6 + 52 >> 2] + HEAP32[HEAP32[$6 + 48 >> 2] + 4 >> 2] - (HEAP32[$6 + 16 >> 2] + 1) | 0)) | 0);
  while (1) {
   if (HEAP32[$6 + 36 >> 2] < 0) {
    jsvStringIteratorNextUTF8(HEAP32[$6 + 44 >> 2]);
    HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 36 >> 2] + 8;
    continue;
   }
   break;
  }
 }
 __stack_pointer = $6 - -64 | 0;
}

function jswrap_graphics_transformVertices($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 320 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 312 >> 2] = $0;
 HEAP32[$3 + 308 >> 2] = $1;
 HEAP32[$3 + 304 >> 2] = $2;
 HEAP32[$3 + 300 >> 2] = jsvNewEmptyArray();
 label$1: {
  if (!HEAP32[$3 + 300 >> 2]) {
   HEAP32[$3 + 316 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsIterable(HEAP32[$3 + 308 >> 2]) & 1)) {
   HEAP32[$3 + 316 >> 2] = HEAP32[$3 + 300 >> 2];
   break label$1;
  }
  label$4: {
   if (jsvIsObject(HEAP32[$3 + 304 >> 2]) & 1) {
    HEAPF64[$3 + 232 >> 3] = 0;
    HEAPF64[$3 + 224 >> 3] = 0;
    HEAPF64[$3 + 216 >> 3] = 1;
    HEAPF64[$3 + 208 >> 3] = 0;
    HEAP32[$3 + 160 >> 2] = 116522;
    HEAP16[$3 + 164 >> 1] = 11;
    HEAP32[$3 + 168 >> 2] = $3 + 232;
    HEAP32[$3 + 172 >> 2] = 116397;
    HEAP16[$3 + 176 >> 1] = 11;
    HEAP32[$3 + 180 >> 2] = $3 + 224;
    HEAP32[$3 + 184 >> 2] = 132619;
    HEAP16[$3 + 188 >> 1] = 11;
    HEAP32[$3 + 192 >> 2] = $3 + 216;
    HEAP32[$3 + 196 >> 2] = 131999;
    HEAP16[$3 + 200 >> 1] = 11;
    HEAP32[$3 + 204 >> 2] = $3 + 208;
    if (!(jsvReadConfigObject(HEAP32[$3 + 304 >> 2], $3 + 160 | 0, 4) & 1)) {
     HEAP32[$3 + 316 >> 2] = HEAP32[$3 + 300 >> 2];
     break label$1;
    }
    HEAPF64[$3 + 152 >> 3] = 1;
    HEAPF64[$3 + 144 >> 3] = 0;
    if (HEAPF64[$3 + 208 >> 3] != 0) {
     HEAPF64[$3 + 152 >> 3] = jswrap_math_cos(HEAPF64[$3 + 208 >> 3]);
     HEAPF64[$3 + 144 >> 3] = jswrap_math_sin(HEAPF64[$3 + 208 >> 3]);
    }
    HEAPF64[$3 + 240 >> 3] = HEAPF64[$3 + 152 >> 3] * HEAPF64[$3 + 216 >> 3];
    HEAPF64[$3 + 256 >> 3] = -HEAPF64[$3 + 144 >> 3] * HEAPF64[$3 + 216 >> 3];
    HEAPF64[$3 + 272 >> 3] = HEAPF64[$3 + 232 >> 3];
    HEAPF64[$3 + 248 >> 3] = HEAPF64[$3 + 144 >> 3] * HEAPF64[$3 + 216 >> 3];
    HEAPF64[$3 + 264 >> 3] = HEAPF64[$3 + 152 >> 3] * HEAPF64[$3 + 216 >> 3];
    HEAPF64[$3 + 280 >> 3] = HEAPF64[$3 + 224 >> 3];
    break label$4;
   }
   label$8: {
    label$9: {
     if (!(jsvIsIterable(HEAP32[$3 + 304 >> 2]) & 1)) {
      break label$9;
     }
     if ((jsvGetLength(HEAP32[$3 + 304 >> 2]) | 0) != 6) {
      break label$9;
     }
     jsvIteratorNew($3 + 80 | 0, HEAP32[$3 + 304 >> 2], 1);
     HEAP32[$3 + 76 >> 2] = 0;
     while (1) {
      if (HEAP32[$3 + 76 >> 2] < 6) {
       $4 = jsvIteratorGetFloatValue($3 + 80 | 0);
       HEAPF64[($3 + 240 | 0) + (HEAP32[$3 + 76 >> 2] << 3) >> 3] = $4;
       jsvIteratorNext($3 + 80 | 0);
       HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
       continue;
      }
      break;
     }
     jsvIteratorFree($3 + 80 | 0);
     break label$8;
    }
    jsExceptionHere(3, 117532, 0);
    HEAP32[$3 + 316 >> 2] = 0;
    break label$1;
   }
  }
  jsvIteratorNew($3 + 16 | 0, HEAP32[$3 + 308 >> 2], 1);
  while (1) {
   label$13: {
    if (!(jsvIteratorHasElement($3 + 16 | 0) & 1)) {
     break label$13;
    }
    HEAPF64[$3 + 8 >> 3] = jsvIteratorGetFloatValue($3 + 16 | 0);
    jsvIteratorNext($3 + 16 | 0);
    if (!(jsvIteratorHasElement($3 + 16 | 0) & 1)) {
     break label$13;
    }
    HEAPF64[$3 >> 3] = jsvIteratorGetFloatValue($3 + 16 | 0);
    jsvIteratorNext($3 + 16 | 0);
    jsvArrayPushAndUnLock(HEAP32[$3 + 300 >> 2], jsvNewFromFloat(HEAPF64[$3 + 240 >> 3] * HEAPF64[$3 + 8 >> 3] + HEAPF64[$3 + 256 >> 3] * HEAPF64[$3 >> 3] + HEAPF64[$3 + 272 >> 3]));
    jsvArrayPushAndUnLock(HEAP32[$3 + 300 >> 2], jsvNewFromFloat(HEAPF64[$3 + 248 >> 3] * HEAPF64[$3 + 8 >> 3] + HEAPF64[$3 + 264 >> 3] * HEAPF64[$3 >> 3] + HEAPF64[$3 + 280 >> 3]));
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 16 | 0);
  HEAP32[$3 + 316 >> 2] = HEAP32[$3 + 300 >> 2];
 }
 __stack_pointer = $3 + 320 | 0;
 return HEAP32[$3 + 316 >> 2];
}

function jspeFactorMember($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 72 >> 2] = $0;
 HEAP32[$2 + 68 >> 2] = $1;
 HEAP32[$2 + 64 >> 2] = 0;
 label$1: {
  while (1) {
   $0 = 1;
   $0 = HEAP16[HEAP32[49079] + 2 >> 1] != 46 ? HEAP16[HEAP32[49079] + 2 >> 1] == 91 : $0;
   if ($0) {
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 46) {
     jslGetNextToken();
     label$6: {
      if (jslIsIDOrReservedWord() & 1) {
       if ((HEAP32[91094] & 63) == 1) {
        HEAP32[$2 + 60 >> 2] = jslGetTokenValueAsString();
        HEAP32[$2 + 56 >> 2] = jsvSkipNameWithParent(HEAP32[$2 + 72 >> 2], 1, HEAP32[$2 + 64 >> 2]);
        HEAP32[$2 + 52 >> 2] = 0;
        if (HEAP32[$2 + 56 >> 2]) {
         HEAP32[$2 + 52 >> 2] = jspGetNamedField(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 60 >> 2], 1);
        }
        if (!HEAP32[$2 + 52 >> 2]) {
         label$11: {
          if (!(jsvIsNullish(HEAP32[$2 + 56 >> 2]) & 1)) {
           HEAP32[$2 + 48 >> 2] = jsvNewNameFromString(jslGetTokenValueAsString());
           HEAP32[$2 + 52 >> 2] = jsvCreateNewChild(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 48 >> 2], 0);
           jsvUnLock(HEAP32[$2 + 48 >> 2]);
           break label$11;
          }
          $0 = HEAP32[$2 + 60 >> 2];
          HEAP32[$2 + 4 >> 2] = jsvIsUndefined(HEAP32[$2 + 56 >> 2]) & 1 ? 133948 : 128729;
          HEAP32[$2 >> 2] = $0;
          jsExceptionHere(1, 120579, $2);
         }
        }
        jsvUnLock(HEAP32[$2 + 64 >> 2]);
        HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 56 >> 2];
        jsvUnLock(HEAP32[$2 + 72 >> 2]);
        HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 52 >> 2];
       }
       jslGetNextToken();
       break label$6;
      }
      if (!(jslMatch(128) & 1)) {
       HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 72 >> 2];
       break label$1;
      }
     }
     continue;
    }
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 91) {
     jslGetNextToken();
     if (!(jspCheckStackPosition() & 1)) {
      HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 64 >> 2];
      break label$1;
     }
     HEAP32[$2 + 44 >> 2] = jsvSkipNameAndUnLock(jspeAssignmentExpression());
     if (!(jslMatch(93) & 1)) {
      jsvUnLock2(HEAP32[$2 + 64 >> 2], HEAP32[$2 + 44 >> 2]);
      HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 72 >> 2];
      break label$1;
     }
     if ((HEAP32[91094] & 63) == 1) {
      HEAP32[$2 + 44 >> 2] = jsvAsArrayIndexAndUnLock(HEAP32[$2 + 44 >> 2]);
      HEAP32[$2 + 40 >> 2] = jsvSkipNameWithParent(HEAP32[$2 + 72 >> 2], 1, HEAP32[$2 + 64 >> 2]);
      HEAP32[$2 + 36 >> 2] = 0;
      if (HEAP32[$2 + 40 >> 2]) {
       HEAP32[$2 + 36 >> 2] = jspGetVarNamedField(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 44 >> 2], 1);
      }
      if (!HEAP32[$2 + 36 >> 2]) {
       label$20: {
        if (jsvHasChildren(HEAP32[$2 + 40 >> 2]) & 1) {
         HEAP32[$2 + 36 >> 2] = jsvCreateNewChild(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 44 >> 2], 0);
         break label$20;
        }
        $0 = HEAP32[$2 + 44 >> 2];
        HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 40 >> 2];
        HEAP32[$2 + 16 >> 2] = $0;
        jsExceptionHere(1, 119194, $2 + 16 | 0);
       }
      }
      jsvUnLock(HEAP32[$2 + 64 >> 2]);
      HEAP32[$2 + 64 >> 2] = jsvLockAgainSafe(HEAP32[$2 + 40 >> 2]);
      jsvUnLock(HEAP32[$2 + 72 >> 2]);
      HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 36 >> 2];
      jsvUnLock(HEAP32[$2 + 40 >> 2]);
     }
     jsvUnLock(HEAP32[$2 + 44 >> 2]);
    }
    continue;
   }
   break;
  }
  label$22: {
   if (HEAP32[$2 + 68 >> 2]) {
    HEAP32[HEAP32[$2 + 68 >> 2] >> 2] = HEAP32[$2 + 64 >> 2];
    break label$22;
   }
   jsvUnLock(HEAP32[$2 + 64 >> 2]);
  }
  HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 72 >> 2];
 }
 __stack_pointer = $2 + 80 | 0;
 return HEAP32[$2 + 76 >> 2];
}

function tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__CalculateOpData_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLiteType_2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0;
 $9 = __stack_pointer - 112 | 0;
 __stack_pointer = $9;
 HEAP32[$9 + 104 >> 2] = $0;
 HEAP32[$9 + 100 >> 2] = $1;
 HEAP32[$9 + 96 >> 2] = $2;
 HEAP32[$9 + 92 >> 2] = $3;
 HEAP32[$9 + 88 >> 2] = $4;
 HEAP32[$9 + 84 >> 2] = $5;
 HEAP32[$9 + 80 >> 2] = $6;
 HEAP32[$9 + 76 >> 2] = $7;
 HEAP32[$9 + 72 >> 2] = $8;
 HEAP8[$9 + 71 | 0] = HEAP32[HEAP32[HEAP32[$9 + 100 >> 2] >> 2] >> 2] == 3;
 label$1: {
  if (!(HEAP8[$9 + 71 | 0] & 1 | HEAP32[HEAP32[HEAP32[$9 + 100 >> 2] >> 2] >> 2] == 2)) {
   $0 = HEAP32[HEAP32[$9 + 104 >> 2] + 20 >> 2];
   $1 = HEAP32[$9 + 104 >> 2];
   HEAP32[$9 + 16 >> 2] = 139773;
   FUNCTION_TABLE[$0 | 0]($1, 140586, $9 + 16 | 0);
   HEAP32[$9 + 108 >> 2] = 1;
   break label$1;
  }
  if (HEAP32[HEAP32[HEAP32[$9 + 100 >> 2] + 4 >> 2] >> 2] != 1) {
   $0 = HEAP32[HEAP32[$9 + 104 >> 2] + 20 >> 2];
   $1 = HEAP32[$9 + 104 >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$9 + 100 >> 2] + 4 >> 2] >> 2];
   HEAP32[$9 + 12 >> 2] = 1;
   HEAP32[$9 + 8 >> 2] = $2;
   HEAP32[$9 + 4 >> 2] = 139997;
   HEAP32[$9 >> 2] = 131572;
   FUNCTION_TABLE[$0 | 0]($1, 143305, $9);
   HEAP32[$9 + 108 >> 2] = 1;
   break label$1;
  }
  tflite__ComputePaddingHeightWidth_28int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLitePadding_2c_20int__2c_20int__29($9 + 40 | 0, HEAP32[HEAP32[$9 + 96 >> 2] + 8 >> 2], HEAP32[HEAP32[$9 + 96 >> 2] + 4 >> 2], 1, 1, HEAP32[$9 + 88 >> 2], HEAP32[$9 + 92 >> 2], HEAP32[$9 + 80 >> 2], HEAP32[$9 + 84 >> 2], HEAP32[HEAP32[$9 + 96 >> 2] >> 2], $9 - -64 | 0, $9 + 60 | 0);
  $0 = HEAP32[$9 + 44 >> 2];
  $1 = HEAP32[$9 + 40 >> 2];
  $3 = $1;
  $2 = HEAP32[$9 + 72 >> 2];
  $1 = $2;
  HEAP32[$1 >> 2] = $3;
  HEAP32[$1 + 4 >> 2] = $0;
  $1 = HEAP32[$9 + 52 >> 2];
  $0 = HEAP32[$9 + 48 >> 2];
  $3 = $0;
  $0 = $2;
  HEAP32[$0 + 8 >> 2] = $3;
  HEAP32[$0 + 12 >> 2] = $1;
  if (HEAP32[$9 + 76 >> 2] != 1) {
   HEAP32[$9 + 36 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$9 + 104 >> 2], HEAP32[$9 + 100 >> 2], 0);
   HEAP32[$9 + 32 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$9 + 104 >> 2], HEAP32[$9 + 100 >> 2], 1);
   HEAP32[$9 + 28 >> 2] = tflite__GetOptionalInputTensor_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$9 + 104 >> 2], HEAP32[$9 + 100 >> 2], 2);
   HEAP32[$9 + 24 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$9 + 104 >> 2], HEAP32[$9 + 100 >> 2], 0);
   HEAP32[$9 + 20 >> 2] = HEAP32[HEAP32[HEAP32[$9 + 32 >> 2] + 20 >> 2] + 16 >> 2];
   HEAP32[$9 + 108 >> 2] = tflite__PopulateConvolutionQuantizationParams_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20TfLiteFusedActivation_20const__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int__2c_20int_29(HEAP32[$9 + 104 >> 2], HEAP32[$9 + 36 >> 2], HEAP32[$9 + 32 >> 2], HEAP32[$9 + 28 >> 2], HEAP32[$9 + 24 >> 2], HEAP32[$9 + 96 >> 2] + 16 | 0, HEAP32[$9 + 72 >> 2] + 28 | 0, HEAP32[$9 + 72 >> 2] + 32 | 0, HEAP32[$9 + 72 >> 2] + 44 | 0, HEAP32[$9 + 72 >> 2] + 48 | 0, HEAP32[HEAP32[$9 + 72 >> 2] + 36 >> 2], HEAP32[HEAP32[$9 + 72 >> 2] + 40 >> 2], HEAP32[$9 + 20 >> 2]);
   break label$1;
  }
  HEAP32[$9 + 108 >> 2] = 0;
 }
 __stack_pointer = $9 + 112 | 0;
 return HEAP32[$9 + 108 >> 2];
}

function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__one_over_one_plus_x_for_x_in_0_1_int__28gemmlowp__FixedPoint_int_2c_200__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 208 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 192 >> 2] = $0;
 HEAP32[$1 + 176 >> 2] = HEAP32[$1 + 192 >> 2];
 HEAP32[$1 + 168 >> 2] = gemmlowp__FixedPoint_int_2c_200___One_28_29();
 HEAP32[$1 + 184 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__RoundingHalfSum_int_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$1 + 176 >> 2], HEAP32[$1 + 168 >> 2]);
 HEAP32[$1 + 160 >> 2] = gemmlowp__FixedPoint_int_2c_202___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_202___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_202___28int_29(1515870810));
 HEAP32[$1 + 152 >> 2] = gemmlowp__FixedPoint_int_2c_202___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_202___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_202___28int_29(-1010580540));
 HEAP32[$1 + 136 >> 2] = HEAP32[$1 + 160 >> 2];
 HEAP32[$1 + 120 >> 2] = HEAP32[$1 + 184 >> 2];
 HEAP32[$1 + 112 >> 2] = HEAP32[$1 + 152 >> 2];
 HEAP32[$1 + 128 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__202__20gemmlowp__operator__int_2c_200_2c_202__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_202__29(HEAP32[$1 + 120 >> 2], HEAP32[$1 + 112 >> 2]);
 HEAP32[$1 + 144 >> 2] = gemmlowp__FixedPoint_int_2c_202__20gemmlowp__operator__int_2c_202__28gemmlowp__FixedPoint_int_2c_202__2c_20gemmlowp__FixedPoint_int_2c_202__29(HEAP32[$1 + 136 >> 2], HEAP32[$1 + 128 >> 2]);
 HEAP32[$1 + 108 >> 2] = 0;
 while (1) {
  if (HEAP32[$1 + 108 >> 2] < 3) {
   HEAP32[$1 + 96 >> 2] = HEAP32[$1 + 184 >> 2];
   HEAP32[$1 + 88 >> 2] = HEAP32[$1 + 144 >> 2];
   HEAP32[$1 + 104 >> 2] = gemmlowp__FixedPoint_int_2c_200_20__202__20gemmlowp__operator__int_2c_200_2c_202__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_202__29(HEAP32[$1 + 96 >> 2], HEAP32[$1 + 88 >> 2]);
   HEAP32[$1 + 72 >> 2] = gemmlowp__FixedPoint_int_2c_202___One_28_29();
   HEAP32[$1 + 64 >> 2] = HEAP32[$1 + 104 >> 2];
   HEAP32[$1 + 80 >> 2] = gemmlowp__FixedPoint_int_2c_202__20gemmlowp__operator__int_2c_202__28gemmlowp__FixedPoint_int_2c_202__2c_20gemmlowp__FixedPoint_int_2c_202__29_1(HEAP32[$1 + 72 >> 2], HEAP32[$1 + 64 >> 2]);
   HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 144 >> 2];
   HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 144 >> 2];
   HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 80 >> 2];
   HEAP32[$1 + 32 >> 2] = gemmlowp__FixedPoint_int_2c_202_20__202__20gemmlowp__operator__int_2c_202_2c_202__28gemmlowp__FixedPoint_int_2c_202__2c_20gemmlowp__FixedPoint_int_2c_202__29(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 16 >> 2]);
   HEAP32[$1 + 40 >> 2] = gemmlowp__FixedPoint_int_2c_202__20gemmlowp__Rescale_2_2c_20int_2c_204__28gemmlowp__FixedPoint_int_2c_204__29(HEAP32[$1 + 32 >> 2]);
   HEAP32[$1 + 56 >> 2] = gemmlowp__FixedPoint_int_2c_202__20gemmlowp__operator__int_2c_202__28gemmlowp__FixedPoint_int_2c_202__2c_20gemmlowp__FixedPoint_int_2c_202__29(HEAP32[$1 + 48 >> 2], HEAP32[$1 + 40 >> 2]);
   HEAP32[$1 + 144 >> 2] = HEAP32[$1 + 56 >> 2];
   HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 108 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$1 >> 2] = HEAP32[$1 + 144 >> 2];
 HEAP32[$1 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_20_1_20__202__20gemmlowp__ExactMulByPot__1_2c_20int_2c_202__28gemmlowp__FixedPoint_int_2c_202__29(HEAP32[$1 >> 2]);
 HEAP32[$1 + 200 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__Rescale_0_2c_20int_2c_201__28gemmlowp__FixedPoint_int_2c_201__29(HEAP32[$1 + 8 >> 2]);
 __stack_pointer = $1 + 208 | 0;
 return HEAP32[$1 + 200 >> 2];
}

function mbedtls_sha256_process($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 320 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 316 >> 2] = $0;
 HEAP32[$2 + 312 >> 2] = $1;
 HEAP32[$2 + 12 >> 2] = 0;
 while (1) {
  if (HEAPU32[$2 + 12 >> 2] < 8) {
   HEAP32[($2 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] = HEAP32[(HEAP32[$2 + 316 >> 2] + 8 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2];
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$2 + 12 >> 2] = 0;
 while (1) {
  if (HEAPU32[$2 + 12 >> 2] < 64) {
   label$5: {
    if (HEAPU32[$2 + 12 >> 2] < 16) {
     HEAP32[($2 + 48 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] = HEAPU8[HEAP32[$2 + 312 >> 2] + ((HEAP32[$2 + 12 >> 2] << 2) + 3 | 0) | 0] | (HEAPU8[HEAP32[$2 + 312 >> 2] + (HEAP32[$2 + 12 >> 2] << 2) | 0] << 24 | HEAPU8[HEAP32[$2 + 312 >> 2] + ((HEAP32[$2 + 12 >> 2] << 2) + 1 | 0) | 0] << 16 | HEAPU8[HEAP32[$2 + 312 >> 2] + ((HEAP32[$2 + 12 >> 2] << 2) + 2 | 0) | 0] << 8);
     break label$5;
    }
    HEAP32[($2 + 48 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] = HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) - 16 >> 2] + ((HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 20 >> 2] + ((HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 40 >> 2] << 15 | HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 40 >> 2] >>> 17) ^ (HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 40 >> 2] << 13 | HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 40 >> 2] >>> 19) ^ HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) + 40 >> 2] >>> 10) | 0) + ((HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) - 12 >> 2] << 25 | HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) - 12 >> 2] >>> 7) ^ (HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) - 12 >> 2] << 14 | HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) - 12 >> 2] >>> 18) ^ HEAP32[((HEAP32[$2 + 12 >> 2] << 2) + $2 | 0) - 12 >> 2] >>> 3) | 0);
   }
   HEAP32[$2 + 308 >> 2] = HEAP32[($2 + 48 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] + (HEAP32[(HEAP32[$2 + 12 >> 2] << 2) + 170608 >> 2] + ((HEAP32[$2 + 44 >> 2] + ((HEAP32[$2 + 32 >> 2] << 7 | HEAP32[$2 + 32 >> 2] >>> 25) ^ ((HEAP32[$2 + 32 >> 2] << 26 | HEAP32[$2 + 32 >> 2] >>> 6) ^ (HEAP32[$2 + 32 >> 2] << 21 | HEAP32[$2 + 32 >> 2] >>> 11))) | 0) + (HEAP32[$2 + 40 >> 2] ^ HEAP32[$2 + 32 >> 2] & (HEAP32[$2 + 36 >> 2] ^ HEAP32[$2 + 40 >> 2])) | 0) | 0);
   HEAP32[$2 + 304 >> 2] = (HEAP32[$2 + 16 >> 2] & HEAP32[$2 + 20 >> 2] | HEAP32[$2 + 24 >> 2] & (HEAP32[$2 + 16 >> 2] | HEAP32[$2 + 20 >> 2])) + ((HEAP32[$2 + 16 >> 2] << 10 | HEAP32[$2 + 16 >> 2] >>> 22) ^ ((HEAP32[$2 + 16 >> 2] << 30 | HEAP32[$2 + 16 >> 2] >>> 2) ^ (HEAP32[$2 + 16 >> 2] << 19 | HEAP32[$2 + 16 >> 2] >>> 13)));
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 308 >> 2] + HEAP32[$2 + 28 >> 2];
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 308 >> 2] + HEAP32[$2 + 304 >> 2];
   HEAP32[$2 + 308 >> 2] = HEAP32[$2 + 44 >> 2];
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 40 >> 2];
   HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 36 >> 2];
   HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 32 >> 2];
   HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 28 >> 2];
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 24 >> 2];
   HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 20 >> 2];
   HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 16 >> 2];
   HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 308 >> 2];
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$2 + 12 >> 2] = 0;
 while (1) {
  if (HEAPU32[$2 + 12 >> 2] < 8) {
   $0 = (HEAP32[$2 + 316 >> 2] + 8 | 0) + (HEAP32[$2 + 12 >> 2] << 2) | 0;
   HEAP32[$0 >> 2] = HEAP32[($2 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] + HEAP32[$0 >> 2];
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $2 + 320 | 0;
}

function jswrap_espruino_HSBtoRGB_int($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 80 | 0;
 HEAPF64[$3 + 64 >> 3] = $0;
 HEAPF64[$3 + 56 >> 3] = $1;
 HEAPF64[$3 + 48 >> 3] = $2;
 label$1: {
  if (HEAPF64[$3 + 48 >> 3] == 0) {
   HEAP32[$3 + 76 >> 2] = 0;
   break label$1;
  }
  if (HEAPF64[$3 + 56 >> 3] == 0) {
   $0 = HEAPF64[$3 + 48 >> 3] * 255;
   label$4: {
    if (Math_abs($0) < 2147483648) {
     $4 = ~~$0;
     break label$4;
    }
    $4 = -2147483648;
   }
   HEAP32[$3 + 44 >> 2] = $4;
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 44 >> 2] | (HEAP32[$3 + 44 >> 2] << 16 | HEAP32[$3 + 44 >> 2] << 8);
   break label$1;
  }
  HEAPF64[$3 + 64 >> 3] = (HEAPF64[$3 + 64 >> 3] - Math_floor(HEAPF64[$3 + 64 >> 3])) * 6;
  $0 = HEAPF64[$3 + 64 >> 3];
  label$6: {
   if (Math_abs($0) < 2147483648) {
    $4 = ~~$0;
    break label$6;
   }
   $4 = -2147483648;
  }
  HEAP32[$3 + 32 >> 2] = $4;
  HEAPF64[$3 + 8 >> 3] = HEAPF64[$3 + 64 >> 3] - +HEAP32[$3 + 32 >> 2];
  HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] % 6;
  HEAPF64[$3 + 48 >> 3] = HEAPF64[$3 + 48 >> 3] * 255;
  $0 = HEAPF64[$3 + 48 >> 3];
  label$8: {
   if (Math_abs($0) < 2147483648) {
    $4 = ~~$0;
    break label$8;
   }
   $4 = -2147483648;
  }
  HEAP32[$3 + 28 >> 2] = $4;
  $0 = (1 - HEAPF64[$3 + 56 >> 3]) * HEAPF64[$3 + 48 >> 3];
  label$10: {
   if (Math_abs($0) < 2147483648) {
    $4 = ~~$0;
    break label$10;
   }
   $4 = -2147483648;
  }
  HEAP32[$3 + 24 >> 2] = $4;
  $0 = (-HEAPF64[$3 + 56 >> 3] * HEAPF64[$3 + 8 >> 3] + 1) * HEAPF64[$3 + 48 >> 3];
  label$12: {
   if (Math_abs($0) < 2147483648) {
    $4 = ~~$0;
    break label$12;
   }
   $4 = -2147483648;
  }
  HEAP32[$3 + 20 >> 2] = $4;
  $0 = (-HEAPF64[$3 + 56 >> 3] * (1 - HEAPF64[$3 + 8 >> 3]) + 1) * HEAPF64[$3 + 48 >> 3];
  label$14: {
   if (Math_abs($0) < 2147483648) {
    $4 = ~~$0;
    break label$14;
   }
   $4 = -2147483648;
  }
  HEAP32[$3 + 16 >> 2] = $4;
  label$16: {
   if (!HEAP32[$3 + 32 >> 2]) {
    HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 28 >> 2];
    HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 16 >> 2];
    HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 24 >> 2];
    break label$16;
   }
   label$18: {
    if (HEAP32[$3 + 32 >> 2] == 1) {
     HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 20 >> 2];
     HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 28 >> 2];
     HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 24 >> 2];
     break label$18;
    }
    label$20: {
     if (HEAP32[$3 + 32 >> 2] == 2) {
      HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 24 >> 2];
      HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 28 >> 2];
      HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 16 >> 2];
      break label$20;
     }
     label$22: {
      if (HEAP32[$3 + 32 >> 2] == 3) {
       HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 24 >> 2];
       HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 20 >> 2];
       HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 28 >> 2];
       break label$22;
      }
      label$24: {
       if (HEAP32[$3 + 32 >> 2] == 4) {
        HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 16 >> 2];
        HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 24 >> 2];
        HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 28 >> 2];
        break label$24;
       }
       label$26: {
        if (HEAP32[$3 + 32 >> 2] == 5) {
         HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 28 >> 2];
         HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 24 >> 2];
         HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 20 >> 2];
         break label$26;
        }
        HEAP32[$3 + 44 >> 2] = 0;
        HEAP32[$3 + 40 >> 2] = 0;
        HEAP32[$3 + 36 >> 2] = 0;
       }
      }
     }
    }
   }
  }
  HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 44 >> 2] | (HEAP32[$3 + 36 >> 2] << 16 | HEAP32[$3 + 40 >> 2] << 8);
 }
 return HEAP32[$3 + 76 >> 2];
}

function jswrap_date_parse($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 208 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 196 >> 2] = $0;
 label$1: {
  if (!(jsvIsString(HEAP32[$1 + 196 >> 2]) & 1)) {
   HEAPF64[$1 + 200 >> 3] = 0;
   break label$1;
  }
  HEAP32[$1 + 168 >> 2] = 0;
  HEAP32[$1 + 184 >> 2] = 0;
  HEAP32[$1 + 180 >> 2] = 0;
  HEAP32[$1 + 176 >> 2] = 0;
  HEAP32[$1 + 172 >> 2] = 0;
  HEAP32[$1 + 188 >> 2] = 0;
  HEAP8[$1 + 192 | 0] = 0;
  getCalendarDate($1 + 144 | 0, 0);
  HEAP8[$1 + 143 | 0] = 0;
  HEAP32[$1 + 12 >> 2] = jslSetLex($1 + 16 | 0);
  jslInit(HEAP32[$1 + 196 >> 2]);
  label$3: {
   if (HEAP16[$1 + 18 >> 1] == 128) {
    HEAP32[$1 + 152 >> 2] = getMonth(jslGetTokenValueAsString());
    HEAP32[$1 + 160 >> 2] = getDay(jslGetTokenValueAsString());
    label$5: {
     if (HEAP32[$1 + 152 >> 2] >= 0) {
      jslGetNextToken();
      if (HEAP16[$1 + 18 >> 1] == 129) {
       HEAP32[$1 + 148 >> 2] = _parse_int();
       jslGetNextToken();
       if (HEAP16[$1 + 18 >> 1] == 44) {
        jslGetNextToken();
        if (HEAP16[$1 + 18 >> 1] == 129) {
         HEAP32[$1 + 156 >> 2] = _parse_int();
         HEAP32[$1 + 168 >> 2] = fromCalendarDate($1 + 144 | 0);
         jslGetNextToken();
         if (HEAP16[$1 + 18 >> 1] == 129) {
          _parse_time($1 + 168 | 0, 0);
          HEAP8[$1 + 143 | 0] = 1;
         }
        }
       }
      }
      break label$5;
     }
     label$11: {
      if (HEAP32[$1 + 160 >> 2] >= 0) {
       HEAP32[$1 + 152 >> 2] = 0;
       jslGetNextToken();
       if (HEAP16[$1 + 18 >> 1] == 44) {
        jslGetNextToken();
        if (HEAP16[$1 + 18 >> 1] == 129) {
         HEAP32[$1 + 148 >> 2] = _parse_int();
         jslGetNextToken();
         label$15: {
          if (HEAP16[$1 + 18 >> 1] != 128) {
           break label$15;
          }
          if ((getMonth(jslGetTokenValueAsString()) | 0) < 0) {
           break label$15;
          }
          HEAP32[$1 + 152 >> 2] = getMonth(jslGetTokenValueAsString());
          jslGetNextToken();
          if (HEAP16[$1 + 18 >> 1] == 129) {
           HEAP32[$1 + 156 >> 2] = _parse_int();
           HEAP32[$1 + 168 >> 2] = fromCalendarDate($1 + 144 | 0);
           jslGetNextToken();
           if (HEAP16[$1 + 18 >> 1] == 129) {
            _parse_time($1 + 168 | 0, 0);
            HEAP8[$1 + 143 | 0] = 1;
           }
          }
         }
        }
       }
       break label$11;
      }
      HEAP32[$1 + 160 >> 2] = 0;
      HEAP32[$1 + 152 >> 2] = 0;
     }
    }
    break label$3;
   }
   if (HEAP16[$1 + 18 >> 1] == 129) {
    HEAP32[$1 + 156 >> 2] = _parse_int();
    jslGetNextToken();
    if (HEAP16[$1 + 18 >> 1] == 45) {
     jslGetNextToken();
     if (HEAP16[$1 + 18 >> 1] == 129) {
      HEAP32[$1 + 152 >> 2] = _parse_int() - 1;
      jslGetNextToken();
      if (HEAP16[$1 + 18 >> 1] == 45) {
       jslGetNextToken();
       if (HEAP16[$1 + 18 >> 1] == 129) {
        HEAP32[$1 + 148 >> 2] = _parse_int();
        HEAP32[$1 + 168 >> 2] = fromCalendarDate($1 + 144 | 0);
        jslGetNextToken();
        label$23: {
         if (HEAP16[$1 + 18 >> 1] != 128) {
          break label$23;
         }
         if (HEAP8[jslGetTokenValueAsString() | 0] != 84) {
          break label$23;
         }
         _parse_time($1 + 168 | 0, 1);
         HEAP8[$1 + 143 | 0] = 1;
        }
       }
      }
     }
    }
   }
  }
  if (!(HEAP8[$1 + 143 | 0] & 1)) {
   setCorrectTimeZone($1 + 168 | 0);
  }
  jslKill();
  jslSetLex(HEAP32[$1 + 12 >> 2]);
  HEAPF64[$1 + 200 >> 3] = fromTimeInDay($1 + 168 | 0);
 }
 __stack_pointer = $1 + 208 | 0;
 return +HEAPF64[$1 + 200 >> 3];
}

function jsiTabComplete() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 320 | 0;
 __stack_pointer = $0;
 label$1: {
  if (!(jsvIsString(HEAP32[91104]) & 1)) {
   break label$1;
  }
  HEAP32[$0 + 316 >> 2] = 0;
  HEAP32[$0 + 300 >> 2] = 0;
  HEAP32[$0 + 292 >> 2] = 0;
  HEAP32[$0 + 164 >> 2] = jslSetLex($0 + 168 | 0);
  jslInit(HEAP32[91104]);
  while (1) {
   $1 = 0;
   $1 = HEAP16[$0 + 170 >> 1] ? HEAPU32[91106] >= HEAP32[$0 + 172 >> 2] + 1 >>> 0 : $1;
   if ($1) {
    label$5: {
     if (HEAP16[$0 + 170 >> 1] == 46) {
      jsvUnLock(HEAP32[$0 + 316 >> 2]);
      HEAP32[$0 + 316 >> 2] = HEAP32[$0 + 300 >> 2];
      HEAP32[$0 + 300 >> 2] = 0;
      break label$5;
     }
     label$7: {
      if (HEAP16[$0 + 170 >> 1] == 128) {
       jsvUnLock(HEAP32[$0 + 300 >> 2]);
       HEAP32[$0 + 300 >> 2] = jslGetTokenValueAsVar();
       HEAP32[$0 + 292 >> 2] = HEAP32[$0 + 172 >> 2] + 1;
       break label$7;
      }
      jsvUnLock(HEAP32[$0 + 316 >> 2]);
      HEAP32[$0 + 316 >> 2] = 0;
      jsvUnLock(HEAP32[$0 + 300 >> 2]);
      HEAP32[$0 + 300 >> 2] = 0;
     }
    }
    jslGetNextToken();
    continue;
   }
   break;
  }
  jslKill();
  jslSetLex(HEAP32[$0 + 164 >> 2]);
  if (!(HEAP32[$0 + 316 >> 2] | HEAP32[$0 + 300 >> 2])) {
   break label$1;
  }
  label$10: {
   if (HEAP32[$0 + 300 >> 2]) {
    HEAP32[$0 + 296 >> 2] = jsvGetStringLength(HEAP32[$0 + 300 >> 2]);
    HEAP32[$0 + 160 >> 2] = (HEAP32[91106] + 1 | 0) - HEAP32[$0 + 292 >> 2];
    if (HEAPU32[$0 + 160 >> 2] > HEAPU32[$0 + 296 >> 2]) {
     jsvUnLock2(HEAP32[$0 + 316 >> 2], HEAP32[$0 + 300 >> 2]);
     break label$1;
    }
    if (HEAPU32[$0 + 160 >> 2] < HEAPU32[$0 + 296 >> 2]) {
     HEAP32[$0 + 156 >> 2] = jsvNewFromStringVar(HEAP32[$0 + 300 >> 2], 0, HEAP32[$0 + 160 >> 2]);
     jsvUnLock(HEAP32[$0 + 300 >> 2]);
     HEAP32[$0 + 300 >> 2] = HEAP32[$0 + 156 >> 2];
     HEAP32[$0 + 296 >> 2] = HEAP32[$0 + 160 >> 2];
    }
    break label$10;
   }
   HEAP32[$0 + 300 >> 2] = jsvNewFromEmptyString_5();
   HEAP32[$0 + 296 >> 2] = 0;
  }
  if (HEAP32[$0 + 316 >> 2]) {
   jsvGetString(HEAP32[$0 + 316 >> 2], $0 + 80 | 0, 64);
   HEAP32[$0 + 76 >> 2] = jspGetNamedVariable($0 + 80 | 0);
   label$15: {
    if (jsvIsVariableDefined(HEAP32[$0 + 76 >> 2]) & 1) {
     HEAP32[$0 + 76 >> 2] = jsvSkipNameAndUnLock(HEAP32[$0 + 76 >> 2]);
     break label$15;
    }
    jsvUnLock(HEAP32[$0 + 76 >> 2]);
    HEAP32[$0 + 76 >> 2] = 0;
   }
   jsvUnLock(HEAP32[$0 + 316 >> 2]);
   HEAP32[$0 + 316 >> 2] = HEAP32[$0 + 76 >> 2];
   if (!HEAP32[$0 + 76 >> 2]) {
    jsvUnLock(HEAP32[$0 + 300 >> 2]);
    break label$1;
   }
  }
  if (!HEAP32[$0 + 316 >> 2]) {
   HEAP32[$0 + 316 >> 2] = jsvLockAgain(HEAP32[91086]);
  }
  HEAP32[$0 + 304 >> 2] = 0;
  HEAP32[$0 + 308 >> 2] = 0;
  jswrap_object_keys_or_property_names_cb(HEAP32[$0 + 316 >> 2], 7, 563, $0 + 296 | 0);
  if (HEAP32[$0 + 308 >> 2] > 1) {
   jsiMoveCursorChar(HEAP32[91104], HEAP32[91106], HEAP32[48917]);
   HEAP8[364420] = 1;
   jsiConsolePrintString(148265);
   HEAP32[$0 + 312 >> 2] = 0;
   jswrap_object_keys_or_property_names_cb(HEAP32[$0 + 316 >> 2], 7, 564, $0 + 296 | 0);
   if (HEAP32[$0 + 312 >> 2]) {
    jsiConsolePrintString(148266);
   }
   jsiConsolePrintString(148266);
   jsiConsoleReturnInputLine();
  }
  jsvUnLock2(HEAP32[$0 + 316 >> 2], HEAP32[$0 + 300 >> 2]);
  if (!HEAP32[$0 + 304 >> 2]) {
   break label$1;
  }
  jsvGetString(HEAP32[$0 + 304 >> 2], $0, 64);
  if (HEAPU32[$0 + 296 >> 2] < strlen($0) >>> 0) {
   jsiAppendStringToInputLine(HEAP32[$0 + 296 >> 2] + $0 | 0);
  }
  jsvUnLock(HEAP32[$0 + 304 >> 2]);
 }
 __stack_pointer = $0 + 320 | 0;
}

function jspeStatementDoOrWhile($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = __stack_pointer - 160 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 155 | 0] = $0;
 HEAP8[$1 + 147 | 0] = 1;
 HEAP8[$1 + 146 | 0] = 0;
 HEAP8[$1 + 103 | 0] = (HEAP32[91094] & 512) != 0;
 label$1: {
  label$2: {
   if (HEAP8[$1 + 155 | 0] & 1) {
    jslGetNextToken();
    jslCharPosFromLex($1 + 104 | 0);
    if (!(jslMatch(40) & 1)) {
     jslCharPosFree($1 + 104 | 0);
     break label$1;
    }
    HEAP32[$1 + 148 >> 2] = jspeExpression();
    if ((HEAP32[91094] & 63) == 1) {
     $3 = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$1 + 148 >> 2]));
    }
    HEAP8[$1 + 147 | 0] = $3 & 1;
    jsvUnLock(HEAP32[$1 + 148 >> 2]);
    jslCharPosFromLex($1 + 56 | 0);
    if (!(jslMatch(41) & 1)) {
     jslCharPosFree($1 + 56 | 0);
     jslCharPosFree($1 + 104 | 0);
     break label$1;
    }
    break label$2;
   }
   jslCharPosFromLex($1 + 56 | 0);
   if (!(jslMatch(165) & 1)) {
    jslCharPosFree($1 + 56 | 0);
    break label$1;
   }
   jslCharPosClear($1 + 104 | 0);
  }
  HEAP32[$1 + 52 >> 2] = HEAP32[91094];
  if (!(HEAP8[$1 + 147 | 0] & 1)) {
   jspSetNoExecute();
  }
  HEAP32[91094] = HEAP32[91094] | 512;
  $2 = HEAP8[$1 + 155 | 0] & 1 ? $2 : HEAP16[HEAP32[49079] + 2 >> 1] != 123;
  HEAP8[$1 + 51 | 0] = $2;
  jsvUnLock(jspeBlockOrStatement());
  if (HEAP8[$1 + 51 | 0] & 1) {
   if (!(jslMatch(59) & 1)) {
    jslCharPosFree($1 + 56 | 0);
    jslCharPosFree($1 + 104 | 0);
    break label$1;
   }
  }
  if (!(HEAP8[$1 + 103 | 0] & 1)) {
   HEAP32[91094] = HEAP32[91094] & -513;
  }
  HEAP8[$1 + 146 | 0] = jspeCheckBreakContinue() & 1 | HEAP8[$1 + 146 | 0] & 1;
  if (!(HEAP8[$1 + 147 | 0] & 1)) {
   HEAP32[91094] = HEAP32[91094] & -1664 | HEAP32[$1 + 52 >> 2] & 1663;
  }
  if (!(HEAP8[$1 + 155 | 0] & 1)) {
   if (!(jslMatch(166) & 1)) {
    jslCharPosFree($1 + 56 | 0);
    break label$1;
   }
   jslCharPosFromLex($1 + 104 | 0);
   if (!(jslMatch(40) & 1)) {
    jslCharPosFree($1 + 56 | 0);
    jslCharPosFree($1 + 104 | 0);
    break label$1;
   }
   HEAP32[$1 + 148 >> 2] = jspeExpression();
   if ((HEAP32[91094] & 63) == 1) {
    $4 = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$1 + 148 >> 2]));
   }
   HEAP8[$1 + 147 | 0] = $4 & 1;
   jsvUnLock(HEAP32[$1 + 148 >> 2]);
   if (!(jslMatch(41) & 1)) {
    jslCharPosFree($1 + 56 | 0);
    jslCharPosFree($1 + 104 | 0);
    break label$1;
   }
  }
  jslCharPosNew($1 + 8 | 0, HEAP32[HEAP32[49079] + 84 >> 2], HEAP32[HEAP32[49079] + 4 >> 2]);
  HEAP32[$1 + 4 >> 2] = 0;
  while (1) {
   $0 = 0;
   $0 = HEAP8[$1 + 146 | 0] & 1 ? $0 : HEAPU8[$1 + 147 | 0];
   if ($0 & 1) {
    if (HEAP32[$1 + 4 >> 2] ? 1 : HEAP8[$1 + 155 | 0] & 1) {
     jslSeekToP($1 + 104 | 0);
     HEAP32[$1 + 148 >> 2] = jspeExpression();
     $0 = 0;
     if ((HEAP32[91094] & 63) == 1) {
      $0 = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$1 + 148 >> 2]));
     }
     HEAP8[$1 + 147 | 0] = $0 & 1;
     jsvUnLock(HEAP32[$1 + 148 >> 2]);
    }
    if (HEAP8[$1 + 147 | 0] & 1) {
     jslSeekToP($1 + 56 | 0);
     HEAP32[91094] = HEAP32[91094] | 512;
     jspDebuggerLoopIfCtrlC();
     jsvUnLock(jspeBlockOrStatement());
     if (!(HEAP8[$1 + 103 | 0] & 1)) {
      HEAP32[91094] = HEAP32[91094] & -513;
     }
     HEAP8[$1 + 146 | 0] = jspeCheckBreakContinue() & 1 | HEAP8[$1 + 146 | 0] & 1;
    }
    HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
    continue;
   }
   break;
  }
  jslSeekToP($1 + 8 | 0);
  jslCharPosFree($1 + 104 | 0);
  jslCharPosFree($1 + 56 | 0);
  jslCharPosFree($1 + 8 | 0);
 }
 HEAP32[$1 + 156 >> 2] = 0;
 __stack_pointer = $1 + 160 | 0;
 return HEAP32[$1 + 156 >> 2];
}

function jsfCreateFile($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 112 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 104 >> 2] = $1;
 HEAP32[$4 + 100 >> 2] = $2;
 HEAP32[$4 + 96 >> 2] = $3;
 HEAP8[$4 + 95 | 0] = jsfStripDriveFromName($0, 0);
 HEAP32[$4 + 32 >> 2] = HEAP32[$0 + 24 >> 2];
 $3 = $0;
 $2 = HEAP32[$3 + 16 >> 2];
 $1 = HEAP32[$3 + 20 >> 2];
 HEAP32[$4 + 24 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $1;
 $2 = HEAP32[$3 + 12 >> 2];
 $1 = HEAP32[$3 + 8 >> 2];
 HEAP32[$4 + 16 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 $1 = HEAP32[$3 + 4 >> 2];
 $2 = HEAP32[$3 >> 2];
 HEAP32[$4 + 8 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $1;
 jsfCacheClearFile($4 + 8 | 0);
 jsfGetDriveBankAddress(HEAP8[$4 + 95 | 0], $4 + 88 | 0, $4 + 84 | 0);
 HEAP32[$4 + 80 >> 2] = jsfAlignAddress(HEAP32[$4 + 104 >> 2]) + 32;
 HEAP8[$4 + 79 | 0] = 0;
 HEAP32[$4 + 72 >> 2] = 0;
 HEAP32[$4 + 36 >> 2] = 0;
 label$1: {
  while (1) {
   if ((HEAP32[$4 + 36 >> 2] != 0 ^ -1) & 1) {
    HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 88 >> 2];
    HEAP32[$4 + 36 >> 2] = 0;
    while (1) {
     if (jsfGetFileHeader(HEAP32[$4 + 72 >> 2], $4 + 40 | 0, 0) & 1) {
      while (1) {
       if (jsfGetNextFileHeader($4 + 72 | 0, $4 + 40 | 0, 0) & 1) {
        continue;
       }
       break;
      }
     }
     label$7: {
      if (jsfGetSpaceLeftInPage(HEAP32[$4 + 72 >> 2]) >>> 0 < HEAPU32[$4 + 80 >> 2]) {
       HEAP32[$4 + 72 >> 2] = jsfGetAddressOfNextPage(HEAP32[$4 + 72 >> 2]);
       break label$7;
      }
      HEAP32[$4 + 36 >> 2] = HEAP32[$4 + 72 >> 2];
     }
     $1 = 0;
     $1 = HEAP32[$4 + 72 >> 2] ? HEAP32[$4 + 36 >> 2] != 0 ^ -1 : $1;
     if ($1 & 1) {
      continue;
     }
     break;
    }
    if (!HEAP32[$4 + 36 >> 2]) {
     label$11: {
      if (!(HEAP8[$4 + 79 | 0] & 1)) {
       HEAP8[$4 + 79 | 0] = 1;
       if (!(jsfCompact(1) & 1)) {
        HEAP32[$4 + 108 >> 2] = 0;
        break label$1;
       }
       HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 88 >> 2];
       break label$11;
      }
      HEAP32[$4 + 108 >> 2] = 0;
      break label$1;
     }
    }
    continue;
   }
   break;
  }
  HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 36 >> 2];
  HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 104 >> 2] | HEAP32[$4 + 100 >> 2] << 24;
  $1 = HEAP32[$0 >> 2];
  $2 = HEAP32[$3 + 4 >> 2];
  $5 = $1;
  $0 = $4 + 40 | 0;
  $1 = $0;
  HEAP32[$1 + 4 >> 2] = $5;
  HEAP32[$1 + 8 >> 2] = $2;
  HEAP32[$1 + 28 >> 2] = HEAP32[$3 + 24 >> 2];
  $1 = HEAP32[$3 + 20 >> 2];
  $2 = HEAP32[$3 + 16 >> 2];
  $5 = $2;
  $2 = $0;
  HEAP32[$2 + 20 >> 2] = $5;
  HEAP32[$2 + 24 >> 2] = $1;
  $2 = HEAP32[$3 + 12 >> 2];
  $1 = HEAP32[$3 + 8 >> 2];
  $3 = $1;
  $1 = $0;
  HEAP32[$1 + 12 >> 2] = $3;
  HEAP32[$1 + 16 >> 2] = $2;
  jshFlashWrite($4 + 40 | 0, HEAP32[$4 + 72 >> 2], 32);
  if (HEAP32[$4 + 96 >> 2]) {
   $1 = HEAP32[$4 + 44 >> 2];
   $2 = HEAP32[$4 + 40 >> 2];
   $3 = $2;
   $0 = HEAP32[$4 + 96 >> 2];
   $2 = $0;
   HEAP32[$2 >> 2] = $3;
   HEAP32[$2 + 4 >> 2] = $1;
   $2 = HEAP32[$4 + 68 >> 2];
   $1 = HEAP32[$4 + 64 >> 2];
   $3 = $1;
   $1 = $0;
   HEAP32[$1 + 24 >> 2] = $3;
   HEAP32[$1 + 28 >> 2] = $2;
   $1 = HEAP32[$4 + 60 >> 2];
   $2 = HEAP32[$4 + 56 >> 2];
   $3 = $2;
   $2 = $0;
   HEAP32[$2 + 16 >> 2] = $3;
   HEAP32[$2 + 20 >> 2] = $1;
   $2 = HEAP32[$4 + 52 >> 2];
   $1 = HEAP32[$4 + 48 >> 2];
   $3 = $1;
   $1 = $0;
   HEAP32[$1 + 8 >> 2] = $3;
   HEAP32[$1 + 12 >> 2] = $2;
  }
  HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 72 >> 2] + 32;
  jsfCachePut($4 + 40 | 0, HEAP32[$4 + 72 >> 2]);
  HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 72 >> 2];
 }
 __stack_pointer = $4 + 112 | 0;
 return HEAP32[$4 + 108 >> 2];
}

function graphicsFillEllipse($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 80 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 76 >> 2] = $0;
 HEAP32[$5 + 72 >> 2] = $1;
 HEAP32[$5 + 68 >> 2] = $2;
 HEAP32[$5 + 64 >> 2] = $3;
 HEAP32[$5 + 60 >> 2] = $4;
 graphicsToDeviceCoordinates(HEAP32[$5 + 76 >> 2], $5 + 72 | 0, $5 + 68 | 0);
 graphicsToDeviceCoordinates(HEAP32[$5 + 76 >> 2], $5 - -64 | 0, $5 + 60 | 0);
 if (HEAP32[$5 + 72 >> 2] > HEAP32[$5 + 64 >> 2]) {
  HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 72 >> 2];
  HEAP32[$5 + 72 >> 2] = HEAP32[$5 + 64 >> 2];
  HEAP32[$5 + 64 >> 2] = HEAP32[$5 + 56 >> 2];
 }
 if (HEAP32[$5 + 68 >> 2] > HEAP32[$5 + 60 >> 2]) {
  HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 68 >> 2];
  HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 60 >> 2];
  HEAP32[$5 + 60 >> 2] = HEAP32[$5 + 52 >> 2];
 }
 HEAP32[$5 + 48 >> 2] = (HEAP32[$5 + 72 >> 2] + HEAP32[$5 + 64 >> 2] | 0) / 2;
 HEAP32[$5 + 44 >> 2] = (HEAP32[$5 + 68 >> 2] + HEAP32[$5 + 60 >> 2] | 0) / 2;
 HEAP32[$5 + 40 >> 2] = (HEAP32[$5 + 64 >> 2] - HEAP32[$5 + 72 >> 2] | 0) / 2;
 HEAP32[$5 + 36 >> 2] = (HEAP32[$5 + 60 >> 2] - HEAP32[$5 + 68 >> 2] | 0) / 2;
 HEAP32[$5 + 32 >> 2] = 0;
 HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 36 >> 2];
 HEAP32[$5 + 24 >> 2] = Math_imul(HEAP32[$5 + 40 >> 2], HEAP32[$5 + 40 >> 2]);
 HEAP32[$5 + 20 >> 2] = Math_imul(HEAP32[$5 + 36 >> 2], HEAP32[$5 + 36 >> 2]);
 HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 20 >> 2] - Math_imul(HEAP32[$5 + 24 >> 2], (HEAP32[$5 + 36 >> 2] << 1) - 1 | 0);
 HEAP8[$5 + 11 | 0] = 0;
 while (1) {
  HEAP8[$5 + 11 | 0] = 0;
  HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 16 >> 2] << 1;
  if (HEAP32[$5 + 12 >> 2] < (Math_imul(HEAP32[$5 + 20 >> 2], (HEAP32[$5 + 32 >> 2] << 1) + 1 | 0) | 0)) {
   HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 32 >> 2] + 1;
   HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + Math_imul(HEAP32[$5 + 20 >> 2], (HEAP32[$5 + 32 >> 2] << 1) + 1 | 0);
   HEAP8[$5 + 11 | 0] = 1;
  }
  if (HEAP32[$5 + 12 >> 2] > (Math_imul(HEAP32[$5 + 24 >> 2], 1 - (HEAP32[$5 + 28 >> 2] << 1) | 0) | 0)) {
   $0 = HEAP32[$5 + 76 >> 2];
   graphicsFillRectDevice(HEAP32[$5 + 76 >> 2], HEAP32[$5 + 48 >> 2] + HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2] + HEAP32[$5 + 28 >> 2] | 0, HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2] + HEAP32[$5 + 28 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
   $0 = HEAP32[$5 + 76 >> 2];
   graphicsFillRectDevice(HEAP32[$5 + 76 >> 2], HEAP32[$5 + 48 >> 2] + HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2] - HEAP32[$5 + 28 >> 2] | 0, HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2] - HEAP32[$5 + 28 >> 2] | 0, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
   HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 28 >> 2] - 1;
   HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] - Math_imul(HEAP32[$5 + 24 >> 2], (HEAP32[$5 + 28 >> 2] << 1) - 1 | 0);
   HEAP8[$5 + 11 | 0] = 1;
  }
  $0 = 0;
  $0 = HEAP8[$5 + 11 | 0] & 1 ? HEAP32[$5 + 28 >> 2] >= 0 : $0;
  if ($0) {
   continue;
  }
  break;
 }
 while (1) {
  $0 = HEAP32[$5 + 32 >> 2];
  HEAP32[$5 + 32 >> 2] = $0 + 1;
  if (($0 | 0) < HEAP32[$5 + 40 >> 2]) {
   $0 = HEAP32[$5 + 76 >> 2];
   graphicsFillRectDevice(HEAP32[$5 + 76 >> 2], HEAP32[$5 + 48 >> 2] + HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2], HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 32 >> 2] | 0, HEAP32[$5 + 44 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 80 | 0;
}

function _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        label$8: {
         label$9: {
          label$11: {
           $5 = $1;
           if ($5) {
            $7 = $2;
            if (!$7) {
             break label$11;
            }
            $4 = $3;
            if (!$4) {
             break label$9;
            }
            $5 = Math_clz32($4) - Math_clz32($5) | 0;
            if ($5 >>> 0 <= 31) {
             break label$8;
            }
            break label$2;
           }
           $4 = $3;
           if (($4 | 0) == 1 | $4 >>> 0 > 1) {
            break label$2;
           }
           $5 = $0;
           $7 = $2;
           $5 = ($5 >>> 0) / ($7 >>> 0) | 0;
           i64toi32_i32$HIGH_BITS = 0;
           return $5;
          }
          $7 = $3;
          if (!$0) {
           break label$7;
          }
          if (!$7) {
           break label$6;
          }
          $4 = $7 - 1 | 0;
          if ($4 & $7) {
           break label$6;
          }
          $1 = $5 >>> __wasm_ctz_i32($7) | 0;
          i64toi32_i32$HIGH_BITS = 0;
          return $1;
         }
         if (!($7 - 1 & $7)) {
          break label$5;
         }
         $5 = (Math_clz32($7) + 33 | 0) - Math_clz32($5) | 0;
         $7 = 0 - $5 | 0;
         break label$3;
        }
        $7 = 63 - $5 | 0;
        $5 = $5 + 1 | 0;
        break label$3;
       }
       $4 = ($5 >>> 0) / ($7 >>> 0) | 0;
       i64toi32_i32$HIGH_BITS = 0;
       return $4;
      }
      $5 = Math_clz32($7) - Math_clz32($5) | 0;
      if ($5 >>> 0 < 31) {
       break label$4;
      }
      break label$2;
     }
     if (($7 | 0) == 1) {
      break label$1;
     }
     $4 = $1;
     $1 = $0;
     $9 = 0;
     $8 = __wasm_ctz_i32($7);
     $6 = $8 & 31;
     if (($8 & 63) >>> 0 >= 32) {
      $1 = $4 >>> $6 | 0;
     } else {
      $9 = $4 >>> $6 | 0;
      $1 = ((1 << $6) - 1 & $4) << 32 - $6 | $1 >>> $6;
     }
     i64toi32_i32$HIGH_BITS = $9;
     return $1;
    }
    $7 = 63 - $5 | 0;
    $5 = $5 + 1 | 0;
   }
   $4 = $0;
   $9 = 0;
   $8 = $5 & 63;
   $6 = $8 & 31;
   if (($8 & 63) >>> 0 >= 32) {
    $10 = $1 >>> $6 | 0;
   } else {
    $9 = $1 >>> $6 | 0;
    $10 = ((1 << $6) - 1 & $1) << 32 - $6 | $4 >>> $6;
   }
   $12 = $9;
   $9 = $1;
   $1 = $0;
   $8 = $7 & 63;
   $6 = $8 & 31;
   if (($8 & 63) >>> 0 >= 32) {
    $4 = $1 << $6;
    $0 = 0;
   } else {
    $4 = (1 << $6) - 1 & $1 >>> 32 - $6 | $9 << $6;
    $0 = $1 << $6;
   }
   $1 = $4;
   if ($5) {
    $4 = $3 - 1 | 0;
    $6 = $2 - 1 | 0;
    $4 = ($6 | 0) != -1 ? $4 + 1 | 0 : $4;
    $13 = $6;
    $7 = $4;
    while (1) {
     $4 = $10;
     $8 = $4 << 1;
     $4 = $12 << 1 | $4 >>> 31;
     $10 = $8 | $1 >>> 31;
     $9 = $4;
     $4 = $13;
     $8 = $10;
     $6 = $7 - (($4 >>> 0 < $8 >>> 0) + $9 | 0) | 0;
     $12 = $3 & $6 >> 31;
     $4 = $8;
     $11 = $6 >> 31;
     $8 = $11 & $2;
     $10 = $4 - $8 | 0;
     $12 = $9 - (($4 >>> 0 < $8 >>> 0) + $12 | 0) | 0;
     $4 = $1 << 1 | $0 >>> 31;
     $0 = $0 << 1 | $14;
     $1 = $4 | $16;
     $15 = 0;
     $11 = $11 & 1;
     $14 = $11;
     $5 = $5 - 1 | 0;
     if ($5) {
      continue;
     }
     break;
    }
   }
   i64toi32_i32$HIGH_BITS = $15 | ($1 << 1 | $0 >>> 31);
   return $0 << 1 | $11;
  }
  $0 = 0;
  $1 = 0;
 }
 i64toi32_i32$HIGH_BITS = $1;
 return $0;
}

function jswrap_storagefile_getLength($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 240 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 236 >> 2] = $0;
 HEAP32[$1 + 232 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 236 >> 2], 132398);
 jsfNameFromVar($1 + 200 | 0, HEAP32[$1 + 232 >> 2]);
 jsvUnLock(HEAP32[$1 + 232 >> 2]);
 HEAP32[$1 + 196 >> 2] = 27;
 while (1) {
  $0 = 0;
  $0 = HEAP32[$1 + 196 >> 2] ? !HEAP8[(HEAP32[$1 + 196 >> 2] + $1 | 0) + 199 | 0] : $0;
  if ($0) {
   HEAP32[$1 + 196 >> 2] = HEAP32[$1 + 196 >> 2] - 1;
   continue;
  }
  break;
 }
 HEAP32[$1 + 192 >> 2] = 1;
 HEAP8[HEAP32[$1 + 196 >> 2] + ($1 + 200 | 0) | 0] = HEAP32[$1 + 192 >> 2];
 HEAP32[$1 + 188 >> 2] = 0;
 HEAP32[$1 + 184 >> 2] = 0;
 HEAP32[$1 + 64 >> 2] = HEAP32[$1 + 224 >> 2];
 $2 = HEAP32[$1 + 220 >> 2];
 $0 = HEAP32[$1 + 216 >> 2];
 HEAP32[$1 + 56 >> 2] = $0;
 HEAP32[$1 + 60 >> 2] = $2;
 $0 = HEAP32[$1 + 212 >> 2];
 $2 = HEAP32[$1 + 208 >> 2];
 HEAP32[$1 + 48 >> 2] = $2;
 HEAP32[$1 + 52 >> 2] = $0;
 $2 = HEAP32[$1 + 204 >> 2];
 $0 = HEAP32[$1 + 200 >> 2];
 HEAP32[$1 + 40 >> 2] = $0;
 HEAP32[$1 + 44 >> 2] = $2;
 HEAP32[$1 + 148 >> 2] = jsfFindFile($1 + 40 | 0, $1 + 152 | 0);
 HEAP8[$1 + 147 | 0] = 255;
 if (HEAP32[$1 + 148 >> 2]) {
  jshFlashRead($1 + 147 | 0, (HEAP32[$1 + 148 >> 2] + jsfGetFileSize($1 + 152 | 0) | 0) - 1 | 0, 1);
 }
 while (1) {
  $0 = 0;
  label$6: {
   if (!HEAP32[$1 + 148 >> 2]) {
    break label$6;
   }
   $0 = 0;
   if (HEAPU8[$1 + 147 | 0] == 255) {
    break label$6;
   }
   $0 = HEAP32[$1 + 192 >> 2] < 255;
  }
  if ($0) {
   HEAP32[$1 + 188 >> 2] = jsfGetFileSize($1 + 152 | 0) + HEAP32[$1 + 188 >> 2];
   HEAP32[$1 + 192 >> 2] = HEAP32[$1 + 192 >> 2] + 1;
   HEAP8[HEAP32[$1 + 196 >> 2] + ($1 + 200 | 0) | 0] = HEAP32[$1 + 192 >> 2];
   HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 224 >> 2];
   $0 = HEAP32[$1 + 220 >> 2];
   $2 = HEAP32[$1 + 216 >> 2];
   HEAP32[$1 + 24 >> 2] = $2;
   HEAP32[$1 + 28 >> 2] = $0;
   $2 = HEAP32[$1 + 212 >> 2];
   $0 = HEAP32[$1 + 208 >> 2];
   HEAP32[$1 + 16 >> 2] = $0;
   HEAP32[$1 + 20 >> 2] = $2;
   $0 = HEAP32[$1 + 204 >> 2];
   $2 = HEAP32[$1 + 200 >> 2];
   HEAP32[$1 + 8 >> 2] = $2;
   HEAP32[$1 + 12 >> 2] = $0;
   HEAP32[$1 + 148 >> 2] = jsfFindFile($1 + 8 | 0, $1 + 152 | 0);
   if (HEAP32[$1 + 148 >> 2]) {
    jshFlashRead($1 + 147 | 0, (HEAP32[$1 + 148 >> 2] + jsfGetFileSize($1 + 152 | 0) | 0) - 1 | 0, 1);
   }
   continue;
  }
  break;
 }
 if (HEAP32[$1 + 148 >> 2]) {
  HEAP8[$1 + 79 | 0] = 0;
  while (1) {
   label$11: {
    if (!((HEAPU8[$1 + 79 | 0] ^ -1) & 1)) {
     break label$11;
    }
    HEAP32[$1 + 72 >> 2] = jsfGetFileSize($1 + 152 | 0) - HEAP32[$1 + 184 >> 2];
    if (HEAP32[$1 + 72 >> 2] <= 0) {
     HEAP8[$1 + 79 | 0] = 1;
     break label$11;
    }
    if (HEAP32[$1 + 72 >> 2] > 64) {
     HEAP32[$1 + 72 >> 2] = 64;
    }
    jshFlashRead($1 + 80 | 0, HEAP32[$1 + 148 >> 2] + HEAP32[$1 + 184 >> 2] | 0, HEAP32[$1 + 72 >> 2]);
    HEAP32[$1 + 68 >> 2] = 0;
    while (1) {
     if (HEAP32[$1 + 68 >> 2] < HEAP32[$1 + 72 >> 2]) {
      if (HEAP8[HEAP32[$1 + 68 >> 2] + ($1 + 80 | 0) | 0] == -1) {
       HEAP32[$1 + 72 >> 2] = HEAP32[$1 + 68 >> 2];
       HEAP8[$1 + 79 | 0] = 1;
      } else {
       HEAP32[$1 + 68 >> 2] = HEAP32[$1 + 68 >> 2] + 1;
       continue;
      }
     }
     break;
    }
    HEAP32[$1 + 184 >> 2] = HEAP32[$1 + 72 >> 2] + HEAP32[$1 + 184 >> 2];
    continue;
   }
   break;
  }
 }
 HEAP32[$1 + 188 >> 2] = HEAP32[$1 + 184 >> 2] + HEAP32[$1 + 188 >> 2];
 __stack_pointer = $1 + 240 | 0;
 return HEAP32[$1 + 188 >> 2];
}

function tflite__ops__micro__depthwise_conv__Eval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1: {
  if (!HEAP32[HEAP32[$2 + 36 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (!HEAP32[HEAP32[$2 + 36 >> 2] + 12 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 32 >> 2] = HEAP32[HEAP32[$2 + 36 >> 2] + 12 >> 2];
 HEAP32[$2 + 28 >> 2] = HEAP32[HEAP32[$2 + 36 >> 2] + 8 >> 2];
 HEAP32[$2 + 24 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 0);
 HEAP32[$2 + 20 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 0);
 HEAP32[$2 + 16 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 1);
 label$3: {
  if ((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 36 >> 2]) | 0) == 3) {
   $0 = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 2);
   break label$3;
  }
  $0 = 0;
 }
 HEAP32[$2 + 12 >> 2] = $0;
 label$5: {
  label$6: {
   label$7: {
    switch (HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2] - 1 | 0) {
    case 0:
     tflite__ops__micro__depthwise_conv__EvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 24 >> 2]);
     break label$6;

    case 8:
     tflite__ops__micro__depthwise_conv__EvalQuantizedPerChannel_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 24 >> 2]);
     break label$6;

    case 2:
     tflite__ops__micro__depthwise_conv__EvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 24 >> 2]);
     break label$6;

    default:
     break label$7;
    }
   }
   $0 = HEAP32[HEAP32[$2 + 40 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 40 >> 2];
   $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2]);
   HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2];
   HEAP32[$2 >> 2] = $3;
   FUNCTION_TABLE[$0 | 0]($1, 140819, $2);
   HEAP32[$2 + 44 >> 2] = 1;
   break label$5;
  }
  HEAP32[$2 + 44 >> 2] = 0;
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function jswrap_waveform_start($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $5 = __stack_pointer - 112 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 108 >> 2] = $0;
 HEAP8[$5 + 107 | 0] = $1;
 HEAPF64[$5 + 96 >> 3] = $2;
 HEAP32[$5 + 92 >> 2] = $3;
 HEAP8[$5 + 91 | 0] = $4;
 HEAP8[$5 + 90 | 0] = jsvObjectGetBoolChild(HEAP32[$5 + 108 >> 2], 129992) & 1;
 label$1: {
  if (HEAP8[$5 + 90 | 0] & 1) {
   jsExceptionHere(1, 129948, 0);
   break label$1;
  }
  if (!(jshIsPinValid(HEAPU8[$5 + 107 | 0]) & 1)) {
   jsExceptionHere(1, 128480, 0);
   break label$1;
  }
  $1 = __DOUBLE_BITS_10(HEAPF64[$5 + 96 >> 3]);
  $0 = $1;
  $1 = i64toi32_i32$HIGH_BITS;
  $1 = $1 & 2147483647;
  if (HEAPF64[$5 + 96 >> 3] < .001 ? 1 : ($1 | 0) == 2146435072 | $1 >>> 0 > 2146435072) {
   jsExceptionHere(1, 116076, 0);
   break label$1;
  }
  HEAP32[$5 + 80 >> 2] = 0;
  HEAP32[$5 + 84 >> 2] = 0;
  HEAP8[$5 + 79 | 0] = 0;
  HEAP8[$5 + 78 | 0] = 255;
  label$7: {
   if (jsvIsObject(HEAP32[$5 + 92 >> 2]) & 1) {
    HEAPF64[$5 + 64 >> 3] = jsvObjectGetFloatChild(HEAP32[$5 + 92 >> 2], 132372);
    $1 = __DOUBLE_BITS_10(HEAPF64[$5 + 64 >> 3]);
    $4 = $1;
    $1 = i64toi32_i32$HIGH_BITS;
    $1 = $1 & 2147483647;
    if (!(!(HEAPF64[$5 + 64 >> 3] > 0) | (($1 | 0) == 2146435072 | $1 >>> 0 > 2146435072))) {
     $1 = jshGetTimeFromMilliseconds(HEAPF64[$5 + 64 >> 3] * 1e3);
     $0 = $1;
     $1 = i64toi32_i32$HIGH_BITS;
     $6 = $1;
     $1 = jshGetSystemTime();
     $4 = $1;
     $1 = i64toi32_i32$HIGH_BITS;
     $3 = $1 + ($0 >>> 0 < $4 >>> 0) | 0;
     HEAP32[$5 + 80 >> 2] = $0 - $4;
     $1 = $6;
     $3 = $1 - $3 | 0;
     HEAP32[$5 + 84 >> 2] = $3;
    }
    HEAP8[$5 + 79 | 0] = jsvObjectGetBoolChild(HEAP32[$5 + 92 >> 2], 117940) & 1;
    HEAP8[$5 + 78 | 0] = jshGetPinFromVarAndUnLock(jsvObjectGetChildIfExists(HEAP32[$5 + 92 >> 2], 128475));
    break label$7;
   }
   if (!(jsvIsUndefined(HEAP32[$5 + 92 >> 2]) & 1)) {
    HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 92 >> 2];
    jsExceptionHere(1, 117992, $5 + 16 | 0);
   }
  }
  HEAP8[$5 + 63 | 0] = 0;
  HEAP32[$5 + 56 >> 2] = jswrap_waveform_getBuffer(HEAP32[$5 + 108 >> 2], 0, $5 + 63 | 0);
  HEAP32[$5 + 52 >> 2] = jswrap_waveform_getBuffer(HEAP32[$5 + 108 >> 2], 1, 0);
  label$12: {
   if (HEAP8[$5 + 63 | 0] & 1) {
    HEAP8[$5 + 51 | 0] = HEAP8[$5 + 91 | 0] & 1 ? 6 : 7;
    break label$12;
   }
   HEAP8[$5 + 51 | 0] = HEAP8[$5 + 91 | 0] & 1 ? 4 : 5;
  }
  $3 = HEAP32[$5 + 80 >> 2];
  $1 = $3;
  $0 = HEAP32[$5 + 84 >> 2];
  $4 = $0;
  $0 = jshGetTimeFromMilliseconds(1e3 / HEAPF64[$5 + 96 >> 3]);
  $3 = i64toi32_i32$HIGH_BITS;
  $6 = $3;
  $3 = $4;
  $4 = $0;
  $0 = $6;
  $6 = $0;
  $7 = HEAPU8[$5 + 107 | 0];
  $8 = HEAPU8[$5 + 78 | 0];
  $9 = HEAP32[$5 + 56 >> 2];
  if (HEAP8[$5 + 79 | 0] & 1) {
   if (HEAP32[$5 + 52 >> 2]) {
    $0 = HEAP32[$5 + 52 >> 2];
   } else {
    $0 = HEAP32[$5 + 56 >> 2];
   }
  } else {
   $0 = 0;
  }
  if (!(jstStartSignal($1, $3, $4, $6, $7, $8, $9, $0, HEAPU8[$5 + 51 | 0]) & 1)) {
   jsWarn(121037, 0);
  }
  jsvUnLock2(HEAP32[$5 + 56 >> 2], HEAP32[$5 + 52 >> 2]);
  jsvObjectSetChildAndUnLock(HEAP32[$5 + 108 >> 2], 129992, jsvNewFromBool(1));
  jsvObjectSetChildAndUnLock(HEAP32[$5 + 108 >> 2], 121475, jsvNewFromFloat(HEAPF64[$5 + 96 >> 3]));
  HEAP32[$5 + 44 >> 2] = jsvObjectGetChild(HEAP32[91087], 131709, 3);
  if (!HEAP32[$5 + 44 >> 2]) {
   break label$1;
  }
  jsvArrayPush(HEAP32[$5 + 44 >> 2], HEAP32[$5 + 108 >> 2]);
  jsvUnLock(HEAP32[$5 + 44 >> 2]);
 }
 __stack_pointer = $5 + 112 | 0;
}

function jswrap_pin_getInfo($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer + -64 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 HEAP8[$1 + 55 | 0] = jshGetPinFromVar(HEAP32[$1 + 56 >> 2]);
 label$1: {
  if (!(jshIsPinValid(HEAPU8[$1 + 55 | 0]) & 1)) {
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 48 >> 2] = Math_imul(HEAPU8[$1 + 55 | 0], 3) + 180752;
  HEAP32[$1 + 44 >> 2] = jsvNewObject();
  if (!HEAP32[$1 + 44 >> 2]) {
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP8[$1 + 42 | 0] = HEAPU8[HEAP32[$1 + 48 >> 2]] - -64;
  HEAP8[$1 + 43 | 0] = 0;
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 117348, jsvNewFromString($1 + 42 | 0));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 128570, jsvNewFromInteger(HEAPU8[HEAP32[$1 + 48 >> 2] + 1 | 0]));
  HEAP8[$1 + 41 | 0] = jshPinGetState(HEAPU8[$1 + 55 | 0]);
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 132782, jshGetPinStateString(HEAPU8[$1 + 41 | 0]));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 117129, jsvNewFromInteger(!!(HEAPU8[$1 + 41 | 0] & 16)));
  if (HEAPU8[HEAP32[$1 + 48 >> 2] + 2 | 0]) {
   HEAP32[$1 + 36 >> 2] = jsvNewObject();
   if (HEAP32[$1 + 36 >> 2]) {
    HEAP32[$1 + 32 >> 2] = jsvNewEmptyArray();
    if (HEAP32[$1 + 32 >> 2]) {
     HEAP32[$1 + 28 >> 2] = 0;
     while (1) {
      if (HEAP32[$1 + 28 >> 2] < 0) {
       if (HEAPU8[HEAP32[$1 + 48 >> 2] + 2 | 0] & 32 << HEAP32[$1 + 28 >> 2]) {
        jsvArrayPushAndUnLock(HEAP32[$1 + 32 >> 2], jsvNewFromInteger(HEAP32[$1 + 28 >> 2] + 1 | 0));
       }
       HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 28 >> 2] + 1;
       continue;
      }
      break;
     }
     jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 120486, HEAP32[$1 + 32 >> 2]);
    }
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 128810, jsvNewFromInteger(HEAPU8[HEAP32[$1 + 48 >> 2] + 2 | 0] & 31));
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 128810, jsvNewFromInteger(HEAPU8[HEAP32[$1 + 48 >> 2] + 2 | 0] & 31));
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 129682, HEAP32[$1 + 36 >> 2]);
   }
  }
  HEAP32[$1 + 24 >> 2] = jsvNewObject();
  if (HEAP32[$1 + 24 >> 2]) {
   HEAP32[$1 + 20 >> 2] = 0;
   while (1) {
    if (HEAP32[$1 + 20 >> 2] < 0) {
     $0 = (HEAP32[$1 + 48 >> 2] + 3 | 0) + (HEAP32[$1 + 20 >> 2] << 1) | 0;
     if (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8) {
      HEAP32[$1 + 16 >> 2] = jsvNewObject();
      if (HEAP32[$1 + 16 >> 2]) {
       $0 = (HEAP32[$1 + 48 >> 2] + 3 | 0) + (HEAP32[$1 + 20 >> 2] << 1) | 0;
       jshPinFunctionToString(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8, 8, $1, 16);
       jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 132338, jsvNewFromString($1));
       $0 = (HEAP32[$1 + 48 >> 2] + 3 | 0) + (HEAP32[$1 + 20 >> 2] << 1) | 0;
       jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 130145, jsvNewFromInteger((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8) & 15));
       $0 = (HEAP32[$1 + 48 >> 2] + 3 | 0) + (HEAP32[$1 + 20 >> 2] << 1) | 0;
       jshPinFunctionToString(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8, 3, $1, 16);
       jsvObjectSetChildAndUnLock(HEAP32[$1 + 24 >> 2], $1, HEAP32[$1 + 16 >> 2]);
      }
     }
     HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 20 >> 2] + 1;
     continue;
    }
    break;
   }
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 44 >> 2], 120100, HEAP32[$1 + 24 >> 2]);
  }
  HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 44 >> 2];
 }
 __stack_pointer = $1 - -64 | 0;
 return HEAP32[$1 + 60 >> 2];
}

function jsfGetJSONForObjectItWithCallback($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = __stack_pointer - 128 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 124 >> 2] = $0;
 HEAP32[$7 + 120 >> 2] = $1;
 HEAP32[$7 + 116 >> 2] = $2;
 HEAP32[$7 + 112 >> 2] = $3;
 HEAP32[$7 + 108 >> 2] = $4;
 HEAP32[$7 + 104 >> 2] = $5;
 HEAP8[$7 + 103 | 0] = $6;
 HEAP8[$7 + 102 | 0] = 0;
 HEAP32[$7 + 96 >> 2] = 0;
 while (1) {
  $0 = 0;
  if (jsvObjectIteratorHasValue_8(HEAP32[$7 + 124 >> 2]) & 1) {
   $0 = jspIsInterrupted() ^ -1;
  }
  if ($0 & 1) {
   HEAP32[$7 + 92 >> 2] = jsvObjectIteratorGetKey_5(HEAP32[$7 + 124 >> 2]);
   HEAP32[$7 + 88 >> 2] = jsvGetValueOfName(HEAP32[$7 + 92 >> 2]);
   $0 = 1;
   label$4: {
    if (jsvIsInternalObjectKey(HEAP32[$7 + 92 >> 2]) & 1) {
     break label$4;
    }
    if (HEAP32[$7 + 120 >> 2] & 16) {
     $0 = 1;
     if (jsvIsFunction(HEAP32[$7 + 88 >> 2]) & 1) {
      break label$4;
     }
    }
    if (HEAP32[$7 + 120 >> 2] & 64) {
     $0 = 1;
     if (jsvIsUndefined(HEAP32[$7 + 88 >> 2]) & 1) {
      break label$4;
     }
    }
    $0 = jsvIsGetterOrSetter(HEAP32[$7 + 88 >> 2]);
   }
   HEAP8[$7 + 87 | 0] = $0 & 1;
   if (!(HEAP8[$7 + 87 | 0] & 1)) {
    HEAP32[$7 + 96 >> 2] = HEAP32[$7 + 96 >> 2] + 1;
    if (!(HEAP8[$7 + 103 | 0] & 1)) {
     cbprintf(HEAP32[$7 + 108 >> 2], HEAP32[$7 + 104 >> 2], HEAP32[$7 + 120 >> 2] & 4 ? 146375 : 141344, 0);
    }
    $0 = 0;
    if (HEAP32[$7 + 120 >> 2] & 1) {
     $0 = jsonNeedsNewLine(HEAP32[$7 + 88 >> 2]);
    }
    HEAP8[$7 + 86 | 0] = $0 & 1;
    if (!(!(HEAP32[$7 + 120 >> 2] & 1) | HEAPU32[$7 + 96 >> 2] <= 4)) {
     HEAP8[$7 + 102 | 0] = 1;
    }
    if (HEAP32[$7 + 120 >> 2] & 2) {
     HEAP8[$7 + 102 | 0] = 1;
     HEAP8[$7 + 86 | 0] = 1;
    }
    if (HEAP8[$7 + 86 | 0] & 1 ? 1 : HEAP8[$7 + 102 | 0] & 1) {
     jsonNewLine(HEAP32[$7 + 112 >> 2], HEAP32[$7 + 116 >> 2], HEAP32[$7 + 108 >> 2], HEAP32[$7 + 104 >> 2]);
     HEAP8[$7 + 102 | 0] = 0;
     HEAP32[$7 + 96 >> 2] = 0;
    }
    HEAP8[$7 + 85 | 0] = 1;
    if (HEAP32[$7 + 120 >> 2] & 512) {
     label$15: {
      if (jsvIsIntegerish(HEAP32[$7 + 92 >> 2]) & 1) {
       HEAP8[$7 + 85 | 0] = 0;
       break label$15;
      }
      label$17: {
       if (!(jsvIsString(HEAP32[$7 + 92 >> 2]) & 1)) {
        break label$17;
       }
       if (jsvGetStringLength(HEAP32[$7 + 92 >> 2]) >>> 0 >= 63) {
        break label$17;
       }
       jsvGetString(HEAP32[$7 + 92 >> 2], $7 + 16 | 0, 64);
       if (isIDString($7 + 16 | 0) & 1) {
        HEAP8[$7 + 85 | 0] = 0;
       }
      }
     }
    }
    $1 = HEAP32[$7 + 108 >> 2];
    $2 = HEAP32[$7 + 104 >> 2];
    if (HEAP8[$7 + 85 | 0] & 1) {
     $0 = HEAP32[$7 + 120 >> 2] & 2048 ? 120501 : 120496;
    } else {
     $0 = 120491;
    }
    $3 = HEAP32[$7 + 92 >> 2];
    HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 120 >> 2] & 4 ? 146306 : 139035;
    HEAP32[$7 >> 2] = $3;
    cbprintf($1, $2, $0, $7);
    if (HEAP8[$7 + 103 | 0] & 1) {
     HEAP8[$7 + 103 | 0] = 0;
    }
    jsfGetJSONWithCallback(HEAP32[$7 + 88 >> 2], HEAP32[$7 + 92 >> 2], HEAP32[$7 + 112 >> 2], HEAP32[$7 + 116 >> 2], HEAP32[$7 + 108 >> 2], HEAP32[$7 + 104 >> 2]);
    HEAP8[$7 + 102 | 0] = HEAP8[$7 + 86 | 0] & 1;
   }
   jsvUnLock2(HEAP32[$7 + 92 >> 2], HEAP32[$7 + 88 >> 2]);
   jsvObjectIteratorNext(HEAP32[$7 + 124 >> 2]);
   continue;
  }
  break;
 }
 __stack_pointer = $7 + 128 | 0;
 return HEAP8[$7 + 102 | 0] & 1;
}

function jswrap_espruino_decodeUTF8($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 128 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 120 >> 2] = $0;
 HEAP32[$3 + 116 >> 2] = $1;
 HEAP32[$3 + 112 >> 2] = $2;
 label$1: {
  if (!(jsvIsString(HEAP32[$3 + 120 >> 2]) & 1)) {
   jsExceptionHere(1, 129842, 0);
   HEAP32[$3 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 28 >> 2] = jsvNewFromEmptyString_9();
  jsvStringIteratorNew($3 + 72 | 0, HEAP32[$3 + 120 >> 2], 0);
  jsvStringIteratorNew($3 + 32 | 0, HEAP32[$3 + 28 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar_9($3 + 72 | 0) & 1) {
    HEAP8[$3 + 27 | 0] = jsvStringIteratorGetCharAndNext($3 + 72 | 0);
    HEAP32[$3 + 20 >> 2] = HEAPU8[$3 + 27 | 0];
    HEAP32[$3 + 16 >> 2] = 0;
    if (HEAPU8[$3 + 27 | 0] > 127) {
     label$6: {
      if ((HEAPU8[$3 + 27 | 0] & 224) == 192) {
       HEAP32[$3 + 20 >> 2] = HEAPU8[$3 + 27 | 0] & 31;
       HEAP32[$3 + 16 >> 2] = 1;
       break label$6;
      }
      label$8: {
       if ((HEAPU8[$3 + 27 | 0] & 240) == 224) {
        HEAP32[$3 + 20 >> 2] = HEAPU8[$3 + 27 | 0] & 15;
        HEAP32[$3 + 16 >> 2] = 2;
        break label$8;
       }
       if ((HEAPU8[$3 + 27 | 0] & 248) == 240) {
        HEAP32[$3 + 20 >> 2] = HEAPU8[$3 + 27 | 0] & 7;
        HEAP32[$3 + 16 >> 2] = 3;
       }
      }
     }
     while (1) {
      $0 = HEAP32[$3 + 16 >> 2];
      HEAP32[$3 + 16 >> 2] = $0 - 1;
      if ($0) {
       HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] << 6 | jsvStringIteratorGetCharAndNext($3 + 72 | 0) & 63;
       continue;
      }
      break;
     }
    }
    label$13: {
     if (HEAP32[$3 + 20 >> 2] <= 255) {
      jsvStringIteratorAppend($3 + 32 | 0, HEAP32[$3 + 20 >> 2] << 24 >> 24);
      break label$13;
     }
     HEAP32[$3 + 12 >> 2] = 0;
     label$15: {
      if (jsvIsArray(HEAP32[$3 + 116 >> 2]) & 1) {
       HEAP32[$3 + 12 >> 2] = jsvGetArrayItem(HEAP32[$3 + 116 >> 2], HEAP32[$3 + 20 >> 2]);
       break label$15;
      }
      if (jsvIsObject(HEAP32[$3 + 116 >> 2]) & 1) {
       HEAP32[$3 + 8 >> 2] = jsvNewFromInteger(HEAP32[$3 + 20 >> 2]);
       HEAP32[$3 + 12 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromVar(HEAP32[$3 + 116 >> 2], HEAP32[$3 + 8 >> 2], 0));
       jsvUnLock(HEAP32[$3 + 8 >> 2]);
      }
     }
     label$18: {
      if (HEAP32[$3 + 12 >> 2]) {
       break label$18;
      }
      if (!(jsvIsFunction(HEAP32[$3 + 112 >> 2]) & 1)) {
       break label$18;
      }
      HEAP32[$3 + 4 >> 2] = jsvNewFromInteger(HEAP32[$3 + 20 >> 2]);
      HEAP32[$3 + 12 >> 2] = jspExecuteFunction(HEAP32[$3 + 112 >> 2], 0, 1, $3 + 4 | 0);
      jsvUnLock(HEAP32[$3 + 4 >> 2]);
     }
     label$19: {
      if (HEAP32[$3 + 12 >> 2]) {
       break label$19;
      }
      if (!(jsvIsString(HEAP32[$3 + 112 >> 2]) & 1)) {
       break label$19;
      }
      HEAP32[$3 + 12 >> 2] = jsvLockAgain(HEAP32[$3 + 112 >> 2]);
     }
     if (HEAP32[$3 + 12 >> 2]) {
      HEAP32[$3 + 12 >> 2] = jsvAsStringAndUnLock(HEAP32[$3 + 12 >> 2]);
      jsvStringIteratorAppendString($3 + 32 | 0, HEAP32[$3 + 12 >> 2], 0, 2147483647);
      jsvUnLock(HEAP32[$3 + 12 >> 2]);
     }
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree_11($3 + 72 | 0);
  jsvStringIteratorFree_11($3 + 32 | 0);
  HEAP32[$3 + 124 >> 2] = HEAP32[$3 + 28 >> 2];
 }
 __stack_pointer = $3 + 128 | 0;
 return HEAP32[$3 + 124 >> 2];
}

function tflite__ops__micro__conv__Eval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 HEAP32[$2 + 32 >> 2] = HEAP32[HEAP32[$2 + 36 >> 2] + 12 >> 2];
 HEAP32[$2 + 28 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 0);
 HEAP32[$2 + 24 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 1);
 label$1: {
  if ((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 36 >> 2]) | 0) == 3) {
   $0 = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 2);
   break label$1;
  }
  $0 = 0;
 }
 HEAP32[$2 + 20 >> 2] = $0;
 HEAP32[$2 + 16 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 0);
 label$3: {
  if (!HEAP32[HEAP32[$2 + 36 >> 2] + 8 >> 2]) {
   break label$3;
  }
 }
 HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 36 >> 2] + 8 >> 2];
 label$4: {
  label$5: {
   label$6: {
    switch (HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2] - 1 | 0) {
    case 0:
     tflite__ops__micro__conv__EvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams__2c_20tflite__ops__micro__conv__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0, 0, HEAP32[$2 + 16 >> 2]);
     break label$5;

    case 8:
     tflite__ops__micro__conv__EvalQuantizedPerChannel_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams__2c_20tflite__ops__micro__conv__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2], 0);
     break label$5;

    case 2:
     tflite__ops__micro__conv__EvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams__2c_20tflite__ops__micro__conv__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0, 0, HEAP32[$2 + 16 >> 2]);
     break label$5;

    default:
     break label$6;
    }
   }
   $0 = HEAP32[HEAP32[$2 + 40 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 40 >> 2];
   $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2]);
   HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2];
   HEAP32[$2 >> 2] = $3;
   FUNCTION_TABLE[$0 | 0]($1, 140819, $2);
   HEAP32[$2 + 44 >> 2] = 1;
   break label$4;
  }
  HEAP32[$2 + 44 >> 2] = 0;
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function jsfBankCreateFileTable($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 192 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 184 >> 2] = $0;
 HEAP32[$1 + 176 >> 2] = 0;
 HEAP32[$1 + 180 >> 2] = 0;
 HEAP32[$1 + 168 >> 2] = 0;
 HEAP32[$1 + 172 >> 2] = 0;
 HEAP32[$1 + 160 >> 2] = 0;
 HEAP32[$1 + 164 >> 2] = 0;
 HEAP32[$1 + 152 >> 2] = 0;
 HEAP32[$1 + 156 >> 2] = 0;
 HEAP32[$1 + 148 >> 2] = 0;
 HEAP32[$1 + 144 >> 2] = HEAP32[$1 + 184 >> 2];
 if (jsfGetFileHeader(HEAP32[$1 + 144 >> 2], $1 + 152 | 0, 0) & 1) {
  while (1) {
   if (jsfIsRealFile($1 + 152 | 0) & 1) {
    HEAP32[$1 + 148 >> 2] = HEAP32[$1 + 148 >> 2] + 1;
   }
   if (jsfGetNextFileHeader($1 + 144 | 0, $1 + 152 | 0, 1) & 1) {
    continue;
   }
   break;
  }
 }
 jsfNameFromString($1 + 112 | 0, 136225);
 HEAP32[$1 + 56 >> 2] = HEAP32[$1 + 136 >> 2];
 $0 = HEAP32[$1 + 132 >> 2];
 $2 = HEAP32[$1 + 128 >> 2];
 HEAP32[$1 + 48 >> 2] = $2;
 HEAP32[$1 + 52 >> 2] = $0;
 $2 = HEAP32[$1 + 124 >> 2];
 $0 = HEAP32[$1 + 120 >> 2];
 HEAP32[$1 + 40 >> 2] = $0;
 HEAP32[$1 + 44 >> 2] = $2;
 $0 = HEAP32[$1 + 116 >> 2];
 $2 = HEAP32[$1 + 112 >> 2];
 HEAP32[$1 + 32 >> 2] = $2;
 HEAP32[$1 + 36 >> 2] = $0;
 HEAP32[$1 + 108 >> 2] = jsfFindFile($1 + 32 | 0, $1 + 152 | 0);
 if (HEAP32[$1 + 108 >> 2]) {
  jsfEraseFileInternal(HEAP32[$1 + 108 >> 2], $1 + 152 | 0, 0);
 }
 HEAP32[$1 + 104 >> 2] = HEAP32[$1 + 148 >> 2] << 5;
 label$5: {
  if (!HEAP32[$1 + 104 >> 2]) {
   HEAP32[$1 + 188 >> 2] = 0;
   break label$5;
  }
  $3 = HEAP32[$1 + 104 >> 2];
  HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 136 >> 2];
  $2 = HEAP32[$1 + 132 >> 2];
  $0 = HEAP32[$1 + 128 >> 2];
  HEAP32[$1 + 16 >> 2] = $0;
  HEAP32[$1 + 20 >> 2] = $2;
  $0 = HEAP32[$1 + 124 >> 2];
  $2 = HEAP32[$1 + 120 >> 2];
  HEAP32[$1 + 8 >> 2] = $2;
  HEAP32[$1 + 12 >> 2] = $0;
  $2 = HEAP32[$1 + 116 >> 2];
  $0 = HEAP32[$1 + 112 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[$1 + 108 >> 2] = jsfCreateFile($1, $3, 32, $1 + 152 | 0);
  if (!HEAP32[$1 + 108 >> 2]) {
   HEAP32[$1 + 188 >> 2] = 0;
   break label$5;
  }
  HEAP32[$1 + 144 >> 2] = HEAP32[$1 + 184 >> 2];
  HEAP32[$1 + 100 >> 2] = HEAP32[$1 + 108 >> 2];
  if (jsfGetFileHeader(HEAP32[$1 + 144 >> 2], $1 + 152 | 0, 1) & 1) {
   while (1) {
    if (jsfIsRealFile($1 + 152 | 0) & 1) {
     $0 = HEAP32[$1 + 180 >> 2];
     $2 = HEAP32[$1 + 176 >> 2];
     HEAP32[$1 + 88 >> 2] = $2;
     HEAP32[$1 + 92 >> 2] = $0;
     $2 = HEAP32[$1 + 172 >> 2];
     $0 = HEAP32[$1 + 168 >> 2];
     HEAP32[$1 + 80 >> 2] = $0;
     HEAP32[$1 + 84 >> 2] = $2;
     $0 = HEAP32[$1 + 164 >> 2];
     $2 = HEAP32[$1 + 160 >> 2];
     HEAP32[$1 + 72 >> 2] = $2;
     HEAP32[$1 + 76 >> 2] = $0;
     $2 = HEAP32[$1 + 156 >> 2];
     $0 = HEAP32[$1 + 152 >> 2];
     HEAP32[$1 + 64 >> 2] = $0;
     HEAP32[$1 + 68 >> 2] = $2;
     HEAP32[$1 + 64 >> 2] = HEAP32[$1 + 144 >> 2] - HEAP32[$1 + 184 >> 2];
     jshFlashWriteAligned($1 - -64 | 0, HEAP32[$1 + 100 >> 2], 32);
     HEAP32[$1 + 100 >> 2] = HEAP32[$1 + 100 >> 2] + 32;
    }
    if (jsfGetNextFileHeader($1 + 144 | 0, $1 + 152 | 0, 1) & 1) {
     continue;
    }
    break;
   }
  }
  if (HEAP32[$1 + 184 >> 2] == 134217728) {
   HEAP32[91095] = HEAP32[$1 + 108 >> 2];
   HEAP32[91096] = HEAP32[$1 + 104 >> 2];
  }
  HEAP32[$1 + 188 >> 2] = HEAP32[$1 + 108 >> 2];
 }
 __stack_pointer = $1 + 192 | 0;
 return HEAP32[$1 + 188 >> 2];
}

function jsvNewFlatStringOfLength($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 40 >> 2] = $0;
 HEAP8[$1 + 39 | 0] = 1;
 HEAP32[$1 + 32 >> 2] = ((HEAP32[$1 + 40 >> 2] + 13 >>> 0) / 14 | 0) + 1;
 HEAP32[$1 + 28 >> 2] = 0;
 label$1: {
  if (HEAPU8[196322]) {
   HEAP8[364342] = HEAPU8[364342] | 32;
   HEAP32[$1 + 44 >> 2] = 0;
   break label$1;
  }
  while (1) {
   HEAP8[$1 + 27 | 0] = 1;
   while (1) {
    if (HEAP8[$1 + 27 | 0] & 1) {
     HEAP8[$1 + 27 | 0] = 0;
     HEAP8[196321] = 0;
     HEAP16[$1 + 24 >> 1] = 0;
     HEAP16[$1 + 22 >> 1] = HEAPU16[98162];
     HEAP16[$1 + 20 >> 1] = HEAPU16[$1 + 22 >> 1];
     HEAP32[$1 + 16 >> 2] = 0;
     while (1) {
      $0 = 0;
      label$8: {
       $0 = HEAPU16[$1 + 22 >> 1] ? HEAPU8[196321] ^ -1 : $0;
       if (!($0 & 1)) {
        break label$8;
       }
       HEAP32[$1 + 12 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 22 >> 1]);
       HEAP16[$1 + 10 >> 1] = jsvGetNextSibling(HEAP32[$1 + 12 >> 2]);
       label$9: {
        if (!(!HEAP32[$1 + 16 >> 2] | HEAPU16[$1 + 10 >> 1] != (HEAPU16[$1 + 22 >> 1] + 1 | 0))) {
         HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
         if (HEAPU32[$1 + 16 >> 2] >= HEAPU32[$1 + 32 >> 2]) {
          HEAP32[$1 + 4 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 10 >> 1]);
          HEAP16[$1 + 2 >> 1] = jsvGetNextSibling(HEAP32[$1 + 4 >> 2]);
          jshInterruptOff();
          if (!(HEAP8[196321] & 1)) {
           label$13: {
            if (HEAPU16[$1 + 24 >> 1]) {
             jsvSetNextSibling(jsvGetAddressOf(HEAPU16[$1 + 24 >> 1]), HEAPU16[$1 + 2 >> 1]);
             break label$13;
            }
            HEAP16[98162] = HEAPU16[$1 + 2 >> 1];
           }
           HEAP32[$1 + 28 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 20 >> 1]);
           jsvResetVariable(HEAP32[$1 + 28 >> 2], 38);
           $0 = HEAP32[$1 + 28 >> 2];
           $2 = HEAP32[$1 + 40 >> 2];
           HEAP8[$0 | 0] = $2;
           HEAP8[$0 + 1 | 0] = $2 >>> 8;
           HEAP8[$0 + 2 | 0] = $2 >>> 16;
           HEAP8[$0 + 3 | 0] = $2 >>> 24;
          }
          jshInterruptOn();
          if (HEAP32[$1 + 28 >> 2]) {
           break label$8;
          }
         }
         break label$9;
        }
        HEAP16[$1 + 24 >> 1] = HEAPU16[$1 + 22 >> 1];
        HEAP16[$1 + 20 >> 1] = HEAPU16[$1 + 10 >> 1];
        label$15: {
         label$16: {
          if (HEAPU16[$1 + 20 >> 1] != 12e3) {
           if (!(jsvGetAddressOf(HEAPU16[$1 + 20 >> 1] + 1 & 65535) & 3)) {
            break label$16;
           }
          }
          HEAP32[$1 + 16 >> 2] = 0;
          break label$15;
         }
         HEAP32[$1 + 16 >> 2] = 1;
        }
       }
       HEAP16[$1 + 22 >> 1] = HEAPU16[$1 + 10 >> 1];
       continue;
      }
      break;
     }
     if (HEAP8[196321] & 1) {
      HEAP8[$1 + 27 | 0] = 1;
     }
     continue;
    }
    break;
   }
   if (!(HEAP32[$1 + 28 >> 2] | !(HEAP8[$1 + 39 | 0] & 1))) {
    HEAP8[$1 + 39 | 0] = 0;
    jsvGarbageCollect();
    continue;
   }
   break;
  }
  if (!HEAP32[$1 + 28 >> 2]) {
   HEAP32[$1 + 44 >> 2] = 0;
   break label$1;
  }
  memset(HEAP32[$1 + 28 >> 2] + 14 | 0, 0, Math_imul(HEAP32[$1 + 32 >> 2] - 1 | 0, 14));
  HEAP8[196321] = 1;
  HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 28 >> 2];
 }
 __stack_pointer = $1 + 48 | 0;
 return HEAP32[$1 + 44 >> 2];
}

function graphicsFillRectDevice($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 32 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $5;
 if (HEAP32[$6 + 24 >> 2] > HEAP32[$6 + 16 >> 2]) {
  HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 24 >> 2];
  HEAP32[$6 + 24 >> 2] = HEAP32[$6 + 16 >> 2];
  HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 4 >> 2];
 }
 if (HEAP32[$6 + 20 >> 2] > HEAP32[$6 + 12 >> 2]) {
  HEAP32[$6 >> 2] = HEAP32[$6 + 20 >> 2];
  HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 12 >> 2];
  HEAP32[$6 + 12 >> 2] = HEAP32[$6 >> 2];
 }
 $0 = HEAP32[$6 + 28 >> 2];
 if (HEAP32[$6 + 24 >> 2] < (HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8)) {
  $0 = HEAP32[$6 + 28 >> 2];
  HEAP32[$6 + 24 >> 2] = HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8;
 }
 $0 = HEAP32[$6 + 28 >> 2];
 if (HEAP32[$6 + 20 >> 2] < (HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8)) {
  $0 = HEAP32[$6 + 28 >> 2];
  HEAP32[$6 + 20 >> 2] = HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8;
 }
 $0 = HEAP32[$6 + 28 >> 2];
 if (HEAP32[$6 + 16 >> 2] > (HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8)) {
  $0 = HEAP32[$6 + 28 >> 2];
  HEAP32[$6 + 16 >> 2] = HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8;
 }
 $0 = HEAP32[$6 + 28 >> 2];
 if (HEAP32[$6 + 12 >> 2] > (HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8)) {
  $0 = HEAP32[$6 + 28 >> 2];
  HEAP32[$6 + 12 >> 2] = HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8;
 }
 label$7: {
  if (HEAP32[$6 + 16 >> 2] < HEAP32[$6 + 24 >> 2] | HEAP32[$6 + 12 >> 2] < HEAP32[$6 + 20 >> 2]) {
   break label$7;
  }
  $0 = HEAP32[$6 + 28 >> 2];
  if (HEAP32[$6 + 24 >> 2] < (HEAPU8[$0 + 40 | 0] | HEAPU8[$0 + 41 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$6 + 28 >> 2];
   $1 = HEAP32[$6 + 24 >> 2];
   HEAP8[$0 + 40 | 0] = $1;
   HEAP8[$0 + 41 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$6 + 28 >> 2];
  if (HEAP32[$6 + 16 >> 2] > (HEAPU8[$0 + 44 | 0] | HEAPU8[$0 + 45 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$6 + 28 >> 2];
   $1 = HEAP32[$6 + 16 >> 2];
   HEAP8[$0 + 44 | 0] = $1;
   HEAP8[$0 + 45 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$6 + 28 >> 2];
  if (HEAP32[$6 + 20 >> 2] < (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$6 + 28 >> 2];
   $1 = HEAP32[$6 + 20 >> 2];
   HEAP8[$0 + 42 | 0] = $1;
   HEAP8[$0 + 43 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$6 + 28 >> 2];
  if (HEAP32[$6 + 12 >> 2] > (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$6 + 28 >> 2];
   $1 = HEAP32[$6 + 12 >> 2];
   HEAP8[$0 + 46 | 0] = $1;
   HEAP8[$0 + 47 | 0] = $1 >>> 8;
  }
  if (!(HEAP32[$6 + 24 >> 2] != HEAP32[$6 + 16 >> 2] | HEAP32[$6 + 20 >> 2] != HEAP32[$6 + 12 >> 2])) {
   $0 = HEAP32[$6 + 28 >> 2];
   FUNCTION_TABLE[HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24)](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 20 >> 2], HEAP32[$6 + 8 >> 2]);
   break label$7;
  }
  $0 = HEAP32[$6 + 28 >> 2];
  FUNCTION_TABLE[HEAPU8[$0 + 56 | 0] | HEAPU8[$0 + 57 | 0] << 8 | (HEAPU8[$0 + 58 | 0] << 16 | HEAPU8[$0 + 59 | 0] << 24)](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 20 >> 2], HEAP32[$6 + 16 >> 2], HEAP32[$6 + 12 >> 2], HEAP32[$6 + 8 >> 2]);
 }
 __stack_pointer = $6 + 32 | 0;
}

function jsvGetInteger($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = __stack_pointer + -64 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 56 >> 2]) {
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  if (jsvIsNull(HEAP32[$1 + 56 >> 2]) & 1) {
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  if (jsvIsUndefined(HEAP32[$1 + 56 >> 2]) & 1) {
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  label$5: {
   if (!(jsvIsIntegerish(HEAP32[$1 + 56 >> 2]) & 1)) {
    if (!(jsvIsArrayBufferName(HEAP32[$1 + 56 >> 2]) & 1)) {
     break label$5;
    }
   }
   $0 = HEAP32[$1 + 56 >> 2];
   HEAP32[$1 + 60 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   break label$1;
  }
  label$7: {
   if (!(jsvIsArray(HEAP32[$1 + 56 >> 2]) & 1)) {
    if (!(jsvIsArrayBuffer(HEAP32[$1 + 56 >> 2]) & 1)) {
     break label$7;
    }
   }
   HEAP32[$1 + 52 >> 2] = jsvGetLength(HEAP32[$1 + 56 >> 2]);
   if (!HEAP32[$1 + 52 >> 2]) {
    HEAP32[$1 + 60 >> 2] = 0;
    break label$1;
   }
   if (HEAP32[$1 + 52 >> 2] == 1) {
    if (jsvIsArrayBuffer(HEAP32[$1 + 56 >> 2]) & 1) {
     HEAP32[$1 + 60 >> 2] = jsvGetIntegerAndUnLock(jsvArrayBufferGet(HEAP32[$1 + 56 >> 2], 0));
     break label$1;
    }
    HEAP32[$1 + 60 >> 2] = jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jsvGetArrayItem(HEAP32[$1 + 56 >> 2], 0)));
    break label$1;
   }
  }
  if (jsvIsFloat(HEAP32[$1 + 56 >> 2]) & 1) {
   $2 = HEAP32[$1 + 56 >> 2];
   $4 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
   $0 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
   wasm2js_scratch_store_i32(0, $4 | 0);
   wasm2js_scratch_store_i32(1, $0 | 0);
   $0 = __DOUBLE_BITS(+wasm2js_scratch_load_f64());
   $2 = $0;
   $4 = i64toi32_i32$HIGH_BITS;
   $0 = $4 & 2147483647;
   if (!(($0 | 0) == 2146435072 | $0 >>> 0 > 2146435072)) {
    $0 = HEAP32[$1 + 56 >> 2];
    $4 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
    $0 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
    wasm2js_scratch_store_i32(0, $4 | 0);
    wasm2js_scratch_store_i32(1, $0 | 0);
    $3 = +wasm2js_scratch_load_f64();
    label$15: {
     if (Math_abs($3) < 0x8000000000000000) {
      $0 = Math_abs($3) >= 1 ? ~~($3 > 0 ? Math_min(Math_floor($3 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($3 - +(~~$3 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
      $5 = ~~$3 >>> 0;
      break label$15;
     }
     $0 = -2147483648;
    }
    HEAP32[$1 + 60 >> 2] = $5;
    break label$1;
   }
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  label$17: {
   if (!(jsvIsString(HEAP32[$1 + 56 >> 2]) & 1)) {
    break label$17;
   }
   if (!(jsvIsStringNumericInt(HEAP32[$1 + 56 >> 2], 1) & 1)) {
    break label$17;
   }
   label$18: {
    if ((jsvGetString(HEAP32[$1 + 56 >> 2], $1 + 16 | 0, 32) | 0) == 32) {
     jsExceptionHere(1, 121368, 0);
     break label$18;
    }
    $0 = stringToInt($1 + 16 | 0);
    HEAP32[$1 + 60 >> 2] = $0;
    break label$1;
   }
  }
  HEAP32[$1 + 60 >> 2] = 0;
 }
 __stack_pointer = $1 - -64 | 0;
 return HEAP32[$1 + 60 >> 2];
}

function tflite__ops__micro__conv__EvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams__2c_20tflite__ops__micro__conv__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
 var $10 = 0;
 $10 = __stack_pointer - 224 | 0;
 __stack_pointer = $10;
 HEAP32[$10 + 220 >> 2] = $0;
 HEAP32[$10 + 216 >> 2] = $1;
 HEAP32[$10 + 212 >> 2] = $2;
 HEAP32[$10 + 208 >> 2] = $3;
 HEAP32[$10 + 204 >> 2] = $4;
 HEAP32[$10 + 200 >> 2] = $5;
 HEAP32[$10 + 196 >> 2] = $6;
 HEAP32[$10 + 192 >> 2] = $7;
 HEAP32[$10 + 188 >> 2] = $8;
 HEAP32[$10 + 184 >> 2] = $9;
 void_20tflite__CalculateActivationRange_float__28TfLiteFusedActivation_2c_20float__2c_20float__29(HEAP32[HEAP32[$10 + 212 >> 2] + 12 >> 2], $10 + 180 | 0, $10 + 176 | 0);
 HEAP8[$10 + 120 | 0] = tflite__ops__micro__conv__RuntimePaddingType_28TfLitePadding_29(HEAP32[HEAP32[$10 + 212 >> 2] >> 2]);
 HEAP16[$10 + 122 >> 1] = HEAP32[HEAP32[$10 + 208 >> 2] >> 2];
 HEAP16[$10 + 124 >> 1] = HEAP32[HEAP32[$10 + 208 >> 2] + 4 >> 2];
 HEAP16[$10 + 130 >> 1] = HEAP32[HEAP32[$10 + 212 >> 2] + 4 >> 2];
 HEAP16[$10 + 132 >> 1] = HEAP32[HEAP32[$10 + 212 >> 2] + 8 >> 2];
 HEAP16[$10 + 134 >> 1] = HEAP32[HEAP32[$10 + 212 >> 2] + 16 >> 2];
 HEAP16[$10 + 136 >> 1] = HEAP32[HEAP32[$10 + 212 >> 2] + 20 >> 2];
 HEAPF32[$10 + 168 >> 2] = HEAPF32[$10 + 180 >> 2];
 HEAPF32[$10 + 172 >> 2] = HEAPF32[$10 + 176 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($10 + 96 | 0, HEAP32[$10 + 204 >> 2]);
 $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$10 + 204 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($10 + 72 | 0, HEAP32[$10 + 200 >> 2]);
 $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$10 + 200 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($10 + 48 | 0, HEAP32[$10 + 196 >> 2]);
 $2 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$10 + 196 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($10 + 24 | 0, HEAP32[$10 + 184 >> 2]);
 $3 = float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$10 + 184 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($10, HEAP32[$10 + 192 >> 2]);
 tflite__reference_ops__Conv_28tflite__ConvParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__2c_20tflite__RuntimeShape_20const__2c_20float__29($10 + 120 | 0, $10 + 96 | 0, $0, $10 + 72 | 0, $1, $10 + 48 | 0, $2, $10 + 24 | 0, $3, $10, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$10 + 192 >> 2]));
 tflite__RuntimeShape___RuntimeShape_28_29($10);
 tflite__RuntimeShape___RuntimeShape_28_29($10 + 24 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($10 + 48 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($10 + 72 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($10 + 96 | 0);
 __stack_pointer = $10 + 224 | 0;
}

function tflite__ops__micro__depthwise_conv__EvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0;
 $8 = __stack_pointer - 208 | 0;
 __stack_pointer = $8;
 HEAP32[$8 + 204 >> 2] = $0;
 HEAP32[$8 + 200 >> 2] = $1;
 HEAP32[$8 + 196 >> 2] = $2;
 HEAP32[$8 + 192 >> 2] = $3;
 HEAP32[$8 + 188 >> 2] = $4;
 HEAP32[$8 + 184 >> 2] = $5;
 HEAP32[$8 + 180 >> 2] = $6;
 HEAP32[$8 + 176 >> 2] = $7;
 HEAP32[$8 + 172 >> 2] = 0 - HEAP32[HEAP32[$8 + 192 >> 2] + 16 >> 2];
 HEAP32[$8 + 168 >> 2] = 0 - HEAP32[HEAP32[$8 + 192 >> 2] + 20 >> 2];
 HEAP32[$8 + 164 >> 2] = HEAP32[HEAP32[$8 + 192 >> 2] + 24 >> 2];
 HEAP8[$8 + 96 | 0] = 1;
 HEAP16[$8 + 98 >> 1] = HEAP32[HEAP32[$8 + 192 >> 2] >> 2];
 HEAP16[$8 + 100 >> 1] = HEAP32[HEAP32[$8 + 192 >> 2] + 4 >> 2];
 HEAP16[$8 + 106 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 4 >> 2];
 HEAP16[$8 + 108 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 8 >> 2];
 HEAP16[$8 + 110 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 20 >> 2];
 HEAP16[$8 + 112 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 24 >> 2];
 HEAP16[$8 + 114 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 12 >> 2];
 HEAP32[$8 + 136 >> 2] = HEAP32[HEAP32[$8 + 192 >> 2] + 44 >> 2];
 HEAP32[$8 + 140 >> 2] = HEAP32[HEAP32[$8 + 192 >> 2] + 48 >> 2];
 HEAP32[$8 + 116 >> 2] = HEAP32[$8 + 172 >> 2];
 HEAP32[$8 + 120 >> 2] = HEAP32[$8 + 168 >> 2];
 HEAP32[$8 + 124 >> 2] = HEAP32[$8 + 164 >> 2];
 HEAP32[$8 + 128 >> 2] = HEAP32[HEAP32[$8 + 192 >> 2] + 28 >> 2];
 HEAP32[$8 + 132 >> 2] = 0 - HEAP32[HEAP32[$8 + 192 >> 2] + 32 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 72 | 0, HEAP32[$8 + 188 >> 2]);
 $0 = unsigned_20char_20const__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 188 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 48 | 0, HEAP32[$8 + 184 >> 2]);
 $1 = unsigned_20char_20const__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 184 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 24 | 0, HEAP32[$8 + 180 >> 2]);
 $2 = int_20const__20tflite__micro__GetTensorData_int__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 180 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8, HEAP32[$8 + 176 >> 2]);
 tflite__reference_ops__DepthwiseConv_28tflite__DepthwiseParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($8 + 96 | 0, $8 + 72 | 0, $0, $8 + 48 | 0, $1, $8 + 24 | 0, $2, $8, unsigned_20char__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor__29(HEAP32[$8 + 176 >> 2]));
 tflite__RuntimeShape___RuntimeShape_28_29($8);
 tflite__RuntimeShape___RuntimeShape_28_29($8 + 24 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($8 + 48 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($8 + 72 | 0);
 __stack_pointer = $8 + 208 | 0;
}

function jswrap_graphics_quadraticBezier($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 160 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 152 >> 2] = $0;
 HEAP32[$3 + 148 >> 2] = $1;
 HEAP32[$3 + 144 >> 2] = $2;
 HEAP32[$3 + 140 >> 2] = jsvNewEmptyArray();
 label$1: {
  if (!HEAP32[$3 + 140 >> 2]) {
   HEAP32[$3 + 156 >> 2] = 0;
   break label$1;
  }
  if ((jsvGetArrayLength(HEAP32[$3 + 148 >> 2]) | 0) != 6) {
   HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 140 >> 2];
   break label$1;
  }
  HEAP32[$3 + 136 >> 2] = 5;
  HEAP32[$3 + 108 >> 2] = 0;
  jsvIteratorNew($3 + 48 | 0, HEAP32[$3 + 148 >> 2], 1);
  HEAP32[$3 + 44 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 44 >> 2] < 6) {
    $0 = jsvIteratorGetIntegerValue($3 + 48 | 0);
    HEAP32[($3 + 112 | 0) + (HEAP32[$3 + 44 >> 2] << 2) >> 2] = $0;
    jsvIteratorNext($3 + 48 | 0);
    HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 44 >> 2] + 1;
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 48 | 0);
  if (jsvIsObject(HEAP32[$3 + 144 >> 2]) & 1) {
   HEAP32[$3 + 108 >> 2] = jsvObjectGetIntegerChild(HEAP32[$3 + 144 >> 2], 117360);
  }
  HEAP32[$3 + 40 >> 2] = 4096;
  HEAP32[$3 + 36 >> 2] = 12;
  HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 112 >> 2] - HEAP32[$3 + 128 >> 2];
  if (HEAP32[$3 + 32 >> 2] < 0) {
   HEAP32[$3 + 32 >> 2] = 0 - HEAP32[$3 + 32 >> 2];
  }
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 116 >> 2] - HEAP32[$3 + 132 >> 2];
  if (HEAP32[$3 + 28 >> 2] < 0) {
   HEAP32[$3 + 28 >> 2] = 0 - HEAP32[$3 + 28 >> 2];
  }
  if (HEAP32[$3 + 32 >> 2] < HEAP32[$3 + 28 >> 2]) {
   $0 = HEAP32[$3 + 32 >> 2];
  } else {
   $0 = HEAP32[$3 + 28 >> 2];
  }
  HEAP32[$3 + 24 >> 2] = $0;
  if (!HEAP32[$3 + 24 >> 2]) {
   HEAP32[$3 + 24 >> 2] = 1;
  }
  HEAP32[$3 + 20 >> 2] = (HEAP32[$3 + 136 >> 2] << 12) / HEAP32[$3 + 24 >> 2];
  if (HEAP32[$3 + 20 >> 2] >= 4096) {
   HEAP32[$3 + 20 >> 2] = 1365;
  }
  if (HEAP32[$3 + 20 >> 2] < 409) {
   HEAP32[$3 + 20 >> 2] = 409;
  }
  if (HEAP32[$3 + 108 >> 2] > 0) {
   HEAP32[$3 + 20 >> 2] = 4096 / HEAP32[$3 + 108 >> 2];
  }
  jsvArrayPush2Int(HEAP32[$3 + 140 >> 2], HEAP32[$3 + 112 >> 2], HEAP32[$3 + 116 >> 2]);
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 20 >> 2];
  while (1) {
   if (HEAP32[$3 + 16 >> 2] <= 4096) {
    HEAP32[$3 + 12 >> 2] = Math_imul(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 16 >> 2]) >> 12;
    HEAP32[$3 + 8 >> 2] = Math_imul(4096 - HEAP32[$3 + 16 >> 2] | 0, 4096 - HEAP32[$3 + 16 >> 2] | 0) >> 12;
    HEAP32[$3 + 4 >> 2] = Math_imul(HEAP32[$3 + 16 >> 2], 4096 - HEAP32[$3 + 16 >> 2] << 1) >> 12;
    jsvArrayPush2Int(HEAP32[$3 + 140 >> 2], ((Math_imul(HEAP32[$3 + 112 >> 2], HEAP32[$3 + 8 >> 2]) + Math_imul(HEAP32[$3 + 120 >> 2], HEAP32[$3 + 4 >> 2]) | 0) + Math_imul(HEAP32[$3 + 128 >> 2], HEAP32[$3 + 12 >> 2]) | 0) + 2048 >> 12, ((Math_imul(HEAP32[$3 + 116 >> 2], HEAP32[$3 + 8 >> 2]) + Math_imul(HEAP32[$3 + 124 >> 2], HEAP32[$3 + 4 >> 2]) | 0) + Math_imul(HEAP32[$3 + 132 >> 2], HEAP32[$3 + 12 >> 2]) | 0) + 2048 >> 12);
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 20 >> 2] + HEAP32[$3 + 16 >> 2];
    continue;
   }
   break;
  }
  jsvArrayPush2Int(HEAP32[$3 + 140 >> 2], HEAP32[$3 + 128 >> 2], HEAP32[$3 + 132 >> 2]);
  HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 140 >> 2];
 }
 __stack_pointer = $3 + 160 | 0;
 return HEAP32[$3 + 156 >> 2];
}

function jswrap_pipe($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 if (!(!HEAP32[$3 + 44 >> 2] | !HEAP32[$3 + 40 >> 2])) {
  jsvLockAgain(HEAP32[$3 + 44 >> 2]);
  HEAP32[$3 + 32 >> 2] = jspNewObject(0, 132352);
  HEAP32[$3 + 28 >> 2] = pipeGetArray(1);
  if (!(!HEAP32[$3 + 32 >> 2] | !HEAP32[$3 + 28 >> 2])) {
   if (jsvIsString(HEAP32[$3 + 44 >> 2]) & 1) {
    HEAP32[$3 + 24 >> 2] = jspExecuteJSFunctionCode(120694, 113712, 0, 0, 1, $3 + 44 | 0);
    jsvUnLock(HEAP32[$3 + 44 >> 2]);
    HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 24 >> 2];
   }
   HEAP32[$3 + 20 >> 2] = jspGetNamedField(HEAP32[$3 + 44 >> 2], 134421, 0);
   HEAP32[$3 + 16 >> 2] = jspGetNamedField(HEAP32[$3 + 40 >> 2], 131969, 0);
   label$5: {
    if (jsvIsFunction(HEAP32[$3 + 20 >> 2]) & 1) {
     if (jsvIsFunction(HEAP32[$3 + 16 >> 2]) & 1) {
      HEAP32[$3 + 12 >> 2] = 64;
      HEAP8[$3 + 11 | 0] = 1;
      label$8: {
       if (jsvIsObject(HEAP32[$3 + 36 >> 2]) & 1) {
        HEAP32[$3 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 36 >> 2], 131978);
        if (HEAP32[$3 + 4 >> 2]) {
         jsvObjectSetChild(HEAP32[$3 + 32 >> 2], 131975, HEAP32[$3 + 4 >> 2]);
         jsvUnLock(HEAP32[$3 + 4 >> 2]);
        }
        HEAP32[$3 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 36 >> 2], 133229);
        if (HEAP32[$3 + 4 >> 2]) {
         HEAP8[$3 + 11 | 0] = jsvGetBoolAndUnLock(HEAP32[$3 + 4 >> 2]) & 1;
        }
        HEAP32[$3 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 36 >> 2], 131653);
        if (HEAP32[$3 + 4 >> 2]) {
         label$13: {
          label$14: {
           if (!(jsvIsNumeric(HEAP32[$3 + 4 >> 2]) & 1)) {
            break label$14;
           }
           if ((jsvGetInteger(HEAP32[$3 + 4 >> 2]) | 0) <= 0) {
            break label$14;
           }
           HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 4 >> 2]);
           break label$13;
          }
          jsExceptionHere(3, 140030, 0);
         }
         jsvUnLock(HEAP32[$3 + 4 >> 2]);
        }
        break label$8;
       }
       if (!(jsvIsUndefined(HEAP32[$3 + 36 >> 2]) & 1)) {
        jsExceptionHere(3, 133916, 0);
       }
      }
      jswrap_object_addEventListener(HEAP32[$3 + 44 >> 2], 132079, 629, 32768);
      jswrap_object_addEventListener(HEAP32[$3 + 40 >> 2], 128505, 630, 8);
      jswrap_object_addEventListener(HEAP32[$3 + 40 >> 2], 132079, 631, 32768);
      jsvObjectSetChildAndUnLock(HEAP32[$3 + 32 >> 2], 131653, jsvNewFromInteger(HEAP32[$3 + 12 >> 2]));
      jsvObjectSetChildAndUnLock(HEAP32[$3 + 32 >> 2], 133229, jsvNewFromBool(HEAP8[$3 + 11 | 0] & 1));
      jsvUnLock2(jsvAddNamedChild(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 44 >> 2], 132796), jsvAddNamedChild(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 40 >> 2], 128459));
      jsvArrayPush(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 32 >> 2]);
      break label$5;
     }
     jsExceptionHere(1, 133050, 0);
     break label$5;
    }
    jsExceptionHere(1, 133130, 0);
   }
   jsvUnLock2(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
  }
  jsvUnLock3(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 44 >> 2]);
 }
 __stack_pointer = $3 + 48 | 0;
}

function jsvSetValueOfName($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (jsvIsNameWithValue(HEAP32[$2 + 24 >> 2]) & 1) {
   label$3: {
    if (jsvIsString(HEAP32[$2 + 24 >> 2]) & 1) {
     $0 = HEAP32[$2 + 24 >> 2];
     $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 65472;
     $3 = jsvGetCharactersInVar(HEAP32[$2 + 24 >> 2]) + 23 | 0;
     $0 = HEAP32[$2 + 24 >> 2];
     $1 = $1 | $3;
     HEAP8[$0 + 12 | 0] = $1;
     HEAP8[$0 + 13 | 0] = $1 >>> 8;
     break label$3;
    }
    $0 = HEAP32[$2 + 24 >> 2];
    $1 = HEAP32[$2 + 24 >> 2];
    $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 65472 | 15;
    HEAP8[$0 + 12 | 0] = $1;
    HEAP8[$0 + 13 | 0] = $1 >>> 8;
   }
   jsvSetFirstChild(HEAP32[$2 + 24 >> 2], 0);
   break label$1;
  }
  if (jsvGetFirstChild(HEAP32[$2 + 24 >> 2]) & 65535) {
   jsvUnRefRef(jsvGetFirstChild(HEAP32[$2 + 24 >> 2]) & 65535);
  }
 }
 label$6: {
  if (HEAP32[$2 + 20 >> 2]) {
   label$8: {
    if (jsvIsInt(HEAP32[$2 + 24 >> 2]) & 1) {
     if (!(jsvIsInt(HEAP32[$2 + 20 >> 2]) & 1)) {
      if (!(jsvIsBoolean(HEAP32[$2 + 20 >> 2]) & 1)) {
       break label$8;
      }
     }
     if (jsvIsPin(HEAP32[$2 + 20 >> 2]) & 1) {
      break label$8;
     }
     $0 = HEAP32[$2 + 20 >> 2];
     HEAP32[$2 + 16 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
     if (!(HEAP32[$2 + 16 >> 2] < -8192 | HEAP32[$2 + 16 >> 2] > 8191)) {
      $0 = HEAP32[$2 + 24 >> 2];
      $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 65472;
      $3 = jsvIsInt(HEAP32[$2 + 20 >> 2]) & 1 ? 16 : 17;
      $0 = HEAP32[$2 + 24 >> 2];
      $1 = $1 | $3;
      HEAP8[$0 + 12 | 0] = $1;
      HEAP8[$0 + 13 | 0] = $1 >>> 8;
      jsvSetFirstChild(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 16 >> 2] & 65535);
      break label$6;
     }
     break label$8;
    }
    label$12: {
     if (!(jsvIsString(HEAP32[$2 + 24 >> 2]) & 1)) {
      break label$12;
     }
     if (jsvIsUTF8String(HEAP32[$2 + 24 >> 2]) & 1) {
      break label$12;
     }
     label$13: {
      if (!(jsvIsInt(HEAP32[$2 + 20 >> 2]) & 1)) {
       break label$13;
      }
      if (jsvIsPin(HEAP32[$2 + 20 >> 2]) & 1) {
       break label$13;
      }
      $0 = HEAP32[$2 + 20 >> 2];
      HEAP32[$2 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
      if (!(HEAP32[$2 + 12 >> 2] < -8192 | HEAP32[$2 + 12 >> 2] > 8191)) {
       $0 = HEAP32[$2 + 24 >> 2];
       $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 65472;
       $3 = jsvGetCharactersInVar(HEAP32[$2 + 24 >> 2]) + 18 | 0;
       $0 = HEAP32[$2 + 24 >> 2];
       $1 = $1 | $3;
       HEAP8[$0 + 12 | 0] = $1;
       HEAP8[$0 + 13 | 0] = $1 >>> 8;
       jsvSetFirstChild(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 12 >> 2] & 65535);
       break label$6;
      }
     }
    }
   }
   jsvSetFirstChild(HEAP32[$2 + 24 >> 2], jsvGetRef(jsvRef(HEAP32[$2 + 20 >> 2])) & 65535);
   break label$6;
  }
  jsvSetFirstChild(HEAP32[$2 + 24 >> 2], 0);
 }
 HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 24 >> 2];
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jsvGetString($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 80 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 72 >> 2] = $0;
 HEAP32[$3 + 68 >> 2] = $1;
 HEAP32[$3 + 64 >> 2] = $2;
 HEAP32[$3 + 60 >> 2] = jsvGetConstString(HEAP32[$3 + 72 >> 2]);
 label$1: {
  if (HEAP32[$3 + 60 >> 2]) {
   HEAP32[$3 + 64 >> 2] = HEAP32[$3 + 64 >> 2] - 1;
   HEAP32[$3 + 56 >> 2] = 0;
   while (1) {
    $0 = 0;
    $0 = HEAP8[HEAP32[$3 + 60 >> 2] + HEAP32[$3 + 56 >> 2] | 0] ? HEAPU32[$3 + 56 >> 2] < HEAPU32[$3 + 64 >> 2] : $0;
    if ($0) {
     HEAP8[HEAP32[$3 + 68 >> 2] + HEAP32[$3 + 56 >> 2] | 0] = HEAPU8[HEAP32[$3 + 60 >> 2] + HEAP32[$3 + 56 >> 2] | 0];
     HEAP32[$3 + 56 >> 2] = HEAP32[$3 + 56 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP8[HEAP32[$3 + 68 >> 2] + HEAP32[$3 + 56 >> 2] | 0] = 0;
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 56 >> 2];
   break label$1;
  }
  if (jsvIsInt(HEAP32[$3 + 72 >> 2]) & 1) {
   $0 = HEAP32[$3 + 72 >> 2];
   itostr(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), HEAP32[$3 + 68 >> 2], 10);
   HEAP32[$3 + 76 >> 2] = strlen(HEAP32[$3 + 68 >> 2]);
   break label$1;
  }
  if (jsvIsFloat(HEAP32[$3 + 72 >> 2]) & 1) {
   $0 = HEAP32[$3 + 72 >> 2];
   $1 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
   wasm2js_scratch_store_i32(0, HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
   wasm2js_scratch_store_i32(1, $1 | 0);
   ftoa_bounded(+wasm2js_scratch_load_f64(), HEAP32[$3 + 68 >> 2], HEAP32[$3 + 64 >> 2]);
   HEAP32[$3 + 76 >> 2] = strlen(HEAP32[$3 + 68 >> 2]);
   break label$1;
  }
  if (jsvHasCharacterData(HEAP32[$3 + 72 >> 2]) & 1) {
   HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 64 >> 2];
   jsvStringIteratorNew($3 + 16 | 0, HEAP32[$3 + 72 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar_1($3 + 16 | 0) & 1) {
     $0 = HEAP32[$3 + 52 >> 2];
     HEAP32[$3 + 52 >> 2] = $0 - 1;
     if ($0 >>> 0 <= 1) {
      HEAP8[HEAP32[$3 + 68 >> 2]] = 0;
      jsvStringIteratorFree_1($3 + 16 | 0);
      HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 64 >> 2];
      break label$1;
     } else {
      $1 = jsvStringIteratorGetChar_1($3 + 16 | 0);
      $0 = HEAP32[$3 + 68 >> 2];
      HEAP32[$3 + 68 >> 2] = $0 + 1;
      HEAP8[$0 | 0] = $1;
      jsvStringIteratorNext($3 + 16 | 0);
      continue;
     }
    }
    break;
   }
   jsvStringIteratorFree_1($3 + 16 | 0);
   HEAP8[HEAP32[$3 + 68 >> 2]] = 0;
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 64 >> 2] - HEAP32[$3 + 52 >> 2];
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvAsString(HEAP32[$3 + 72 >> 2]);
  if (HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 8 >> 2] = jsvGetStringChars(HEAP32[$3 + 12 >> 2], 0, HEAP32[$3 + 68 >> 2], HEAP32[$3 + 64 >> 2]);
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   if (HEAPU32[$3 + 8 >> 2] >= HEAPU32[$3 + 64 >> 2]) {
    HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 64 >> 2] - 1;
   }
   HEAP8[HEAP32[$3 + 68 >> 2] + HEAP32[$3 + 8 >> 2] | 0] = 0;
   HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 8 >> 2];
   break label$1;
  }
  HEAP8[HEAP32[$3 + 68 >> 2]] = 0;
  jsExceptionHere(4, 129732, 0);
  HEAP32[$3 + 76 >> 2] = 0;
 }
 __stack_pointer = $3 + 80 | 0;
 return HEAP32[$3 + 76 >> 2];
}

function mbedtls_sha1_finish($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 96 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 92 >> 2] = $0;
 HEAP32[$2 + 88 >> 2] = $1;
 HEAP32[$2 + 76 >> 2] = HEAP32[HEAP32[$2 + 92 >> 2] + 4 >> 2] << 3 | HEAP32[HEAP32[$2 + 92 >> 2] >> 2] >>> 29;
 HEAP32[$2 + 72 >> 2] = HEAP32[HEAP32[$2 + 92 >> 2] >> 2] << 3;
 HEAP8[$2 + 64 | 0] = HEAP32[$2 + 76 >> 2] >>> 24;
 HEAP8[$2 + 65 | 0] = HEAP32[$2 + 76 >> 2] >>> 16;
 HEAP8[$2 + 66 | 0] = HEAP32[$2 + 76 >> 2] >>> 8;
 HEAP8[$2 + 67 | 0] = HEAP32[$2 + 76 >> 2];
 HEAP8[$2 + 68 | 0] = HEAP32[$2 + 72 >> 2] >>> 24;
 HEAP8[$2 + 69 | 0] = HEAP32[$2 + 72 >> 2] >>> 16;
 HEAP8[$2 + 70 | 0] = HEAP32[$2 + 72 >> 2] >>> 8;
 HEAP8[$2 + 71 | 0] = HEAP32[$2 + 72 >> 2];
 HEAP32[$2 + 84 >> 2] = HEAP32[HEAP32[$2 + 92 >> 2] >> 2] & 63;
 if (HEAPU32[$2 + 84 >> 2] < 56) {
  $0 = 56 - HEAP32[$2 + 84 >> 2] | 0;
 } else {
  $0 = 120 - HEAP32[$2 + 84 >> 2] | 0;
 }
 HEAP32[$2 + 80 >> 2] = $0;
 HEAP32[$2 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP32[$2 + 56 >> 2] = 0;
 HEAP32[$2 + 60 >> 2] = 0;
 HEAP32[$2 + 48 >> 2] = 0;
 HEAP32[$2 + 52 >> 2] = 0;
 HEAP32[$2 + 40 >> 2] = 0;
 HEAP32[$2 + 44 >> 2] = 0;
 HEAP32[$2 + 32 >> 2] = 0;
 HEAP32[$2 + 36 >> 2] = 0;
 HEAP32[$2 + 24 >> 2] = 0;
 HEAP32[$2 + 28 >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = 0;
 HEAP8[$2 | 0] = 128;
 mbedtls_sha1_update(HEAP32[$2 + 92 >> 2], $2, HEAP32[$2 + 80 >> 2]);
 mbedtls_sha1_update(HEAP32[$2 + 92 >> 2], $2 - -64 | 0, 8);
 HEAP8[HEAP32[$2 + 88 >> 2]] = HEAP32[HEAP32[$2 + 92 >> 2] + 8 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 88 >> 2] + 1 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 8 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 88 >> 2] + 2 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 8 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 88 >> 2] + 3 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 8 >> 2];
 HEAP8[HEAP32[$2 + 88 >> 2] + 4 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 12 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 88 >> 2] + 5 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 12 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 88 >> 2] + 6 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 12 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 88 >> 2] + 7 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 12 >> 2];
 HEAP8[HEAP32[$2 + 88 >> 2] + 8 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 16 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 88 >> 2] + 9 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 16 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 88 >> 2] + 10 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 16 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 88 >> 2] + 11 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 16 >> 2];
 HEAP8[HEAP32[$2 + 88 >> 2] + 12 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 20 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 88 >> 2] + 13 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 20 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 88 >> 2] + 14 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 20 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 88 >> 2] + 15 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 20 >> 2];
 HEAP8[HEAP32[$2 + 88 >> 2] + 16 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 24 >> 2] >>> 24;
 HEAP8[HEAP32[$2 + 88 >> 2] + 17 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 24 >> 2] >>> 16;
 HEAP8[HEAP32[$2 + 88 >> 2] + 18 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 24 >> 2] >>> 8;
 HEAP8[HEAP32[$2 + 88 >> 2] + 19 | 0] = HEAP32[HEAP32[$2 + 92 >> 2] + 24 >> 2];
 __stack_pointer = $2 + 96 | 0;
}

function jsserialSoftwareFunc($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 76 >> 2] = $0;
 HEAP32[$2 + 72 >> 2] = $1;
 HEAP32[$2 + 68 >> 2] = HEAP32[$2 + 72 >> 2];
 if (jshIsPinValid(HEAPU8[HEAP32[$2 + 68 >> 2] + 5 | 0]) & 1) {
  HEAP32[$2 + 64 >> 2] = (1 << HEAPU8[HEAP32[$2 + 68 >> 2] + 10 | 0]) - 1;
  HEAP32[$2 + 60 >> 2] = HEAPU8[HEAP32[$2 + 68 >> 2] + 10 | 0];
  HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 76 >> 2] & (1 << HEAPU8[HEAP32[$2 + 68 >> 2] + 8 | 0]) - 1 | HEAP32[$2 + 64 >> 2] << HEAPU8[HEAP32[$2 + 68 >> 2] + 8 | 0];
  HEAP32[$2 + 60 >> 2] = HEAPU8[HEAP32[$2 + 68 >> 2] + 8 | 0] + HEAP32[$2 + 60 >> 2];
  HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 64 >> 2] << 1;
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 60 >> 2] + 1;
  HEAP32[$2 + 56 >> 2] = jstGetUtilTimerOffset();
  $0 = HEAP32[$2 + 68 >> 2];
  $3 = jshGetTimeFromMilliseconds(1e3 / +(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)));
  HEAP32[$2 + 48 >> 2] = $3;
  $0 = i64toi32_i32$HIGH_BITS;
  HEAP32[$2 + 52 >> 2] = $0;
  label$2: {
   if (jstGetLastPinTimerTask(HEAPU8[HEAP32[$2 + 68 >> 2] + 5 | 0], $2 + 8 | 0) & 1) {
    $0 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
    $3 = $0 >> 31;
    $5 = $3;
    $3 = HEAP32[$2 + 48 >> 2];
    $4 = $3;
    $1 = $0 + $3 | 0;
    $0 = HEAP32[$2 + 52 >> 2];
    $3 = $0;
    $0 = $5;
    $0 = $3 + $0 | 0;
    HEAP32[$2 + 40 >> 2] = $1;
    $0 = $1 >>> 0 < $4 >>> 0 ? $0 + 1 | 0 : $0;
    HEAP32[$2 + 44 >> 2] = $0;
    break label$2;
   }
   $0 = jshGetTimeFromMilliseconds(1);
   HEAP32[$2 + 40 >> 2] = $0;
   $1 = i64toi32_i32$HIGH_BITS;
   HEAP32[$2 + 44 >> 2] = $1;
  }
  HEAP32[$2 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 60 >> 2]) {
    HEAP8[$2 + 3 | 0] = HEAP32[$2 + 64 >> 2] & 1;
    HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 64 >> 2] >> 1;
    HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 60 >> 2] - 1;
    $1 = HEAP32[$2 + 40 >> 2];
    $0 = HEAP32[$2 + 44 >> 2];
    jstPinOutputAtTime($1, $0, $2 + 56 | 0, HEAP32[$2 + 68 >> 2] + 5 | 0, 1, HEAP8[$2 + 3 | 0] & 1);
    $1 = HEAP32[$2 + 52 >> 2];
    $5 = $1;
    $0 = HEAP32[$2 + 48 >> 2];
    $1 = HEAP32[$2 + 40 >> 2];
    $4 = $1;
    $3 = $0 + $1 | 0;
    $0 = HEAP32[$2 + 44 >> 2];
    $1 = $0;
    $0 = $5;
    $1 = $1 + $0 | 0;
    HEAP32[$2 + 40 >> 2] = $3;
    $1 = $3 >>> 0 < $4 >>> 0 ? $1 + 1 | 0 : $1;
    HEAP32[$2 + 44 >> 2] = $1;
    continue;
   }
   break;
  }
  $1 = HEAP32[$2 + 40 >> 2];
  $5 = $1;
  $0 = HEAP32[$2 + 44 >> 2];
  $3 = $0;
  $0 = HEAP32[$2 + 48 >> 2];
  $6 = $0;
  $1 = HEAP32[$2 + 52 >> 2];
  $4 = $1;
  $1 = HEAP32[$2 + 4 >> 2];
  $0 = $1 >> 31;
  $7 = $0;
  $0 = $4;
  $4 = $1;
  $1 = $7;
  $1 = __wasm_i64_mul($6, $0, $4, $1);
  $4 = $1;
  $0 = i64toi32_i32$HIGH_BITS;
  $1 = $0;
  $0 = $3;
  $3 = $0 + $1 | 0;
  $0 = $5;
  $1 = $4 + $0 | 0;
  $3 = $1 >>> 0 < $4 >>> 0 ? $3 + 1 | 0 : $3;
  HEAP32[$2 + 40 >> 2] = $1;
  HEAP32[$2 + 44 >> 2] = $3;
  $3 = HEAP32[$2 + 40 >> 2];
  $0 = HEAP32[$2 + 44 >> 2];
  jstPinOutputAtTime($3, $0, $2 + 56 | 0, HEAP32[$2 + 68 >> 2] + 5 | 0, 1, 1);
 }
 __stack_pointer = $2 + 80 | 0;
}

function tflite__ParseReshape_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 56 >> 2] = $0;
 HEAP32[$4 + 52 >> 2] = $1;
 HEAP32[$4 + 48 >> 2] = $2;
 HEAP32[$4 + 44 >> 2] = $3;
 tflite___28anonymous_20namespace_29__CheckParsePointerParams_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29(HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], HEAP32[$4 + 44 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($4 + 40 | 0, HEAP32[$4 + 48 >> 2]);
 std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteReshapeParams__28_29($4 + 32 | 0, $4 + 40 | 0);
 label$1: {
  if (!(bool_20std____2__operator___TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($4 + 32 | 0, 0) & 1)) {
   $0 = HEAP32[$4 + 52 >> 2];
   $1 = HEAP32[$4 + 52 >> 2];
   HEAP32[$4 >> 2] = 120702;
   tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($0, $1, 140586, $4);
   HEAP32[$4 + 60 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 24 >> 2] = tflite__Operator__builtin_options_as_ReshapeOptions_28_29_20const(HEAP32[$4 + 56 >> 2]);
  if (HEAP32[$4 + 24 >> 2]) {
   HEAP32[$4 + 20 >> 2] = tflite__ReshapeOptions__new_shape_28_29_20const(HEAP32[$4 + 24 >> 2]);
   if (HEAP32[$4 + 20 >> 2]) {
    HEAP32[$4 + 16 >> 2] = tflite___28anonymous_20namespace_29__FlatBufferIntVectorToArray_28int_2c_20flatbuffers__Vector_int__20const__2c_20int__2c_20tflite__ErrorReporter__2c_20char_20const__29(32, HEAP32[$4 + 20 >> 2], std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0), HEAP32[$4 + 52 >> 2], 132357);
    if (HEAP32[$4 + 16 >> 2]) {
     HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 16 >> 2];
     break label$1;
    }
    $0 = flatbuffers__Vector_int___size_28_29_20const(HEAP32[$4 + 20 >> 2]);
    HEAP32[std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 32 | 0) + 32 >> 2] = $0;
   }
  }
  $0 = std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($4 + 32 | 0);
  HEAP32[HEAP32[$4 + 44 >> 2] >> 2] = $0;
  HEAP32[$4 + 60 >> 2] = 0;
 }
 HEAP32[$4 + 28 >> 2] = 1;
 std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($4 + 32 | 0);
 __stack_pointer = $4 - -64 | 0;
 return HEAP32[$4 + 60 >> 2];
}

function tflite__ops__micro__reshape__ReshapeOutput_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 96 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP32[$2 + 84 >> 2] = $1;
 HEAP32[$2 + 80 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 88 >> 2], HEAP32[$2 + 84 >> 2], 0);
 HEAP32[$2 + 76 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 88 >> 2], HEAP32[$2 + 84 >> 2], 0);
 HEAP32[$2 + 72 >> 2] = tflite__NumElements_28TfLiteTensor_20const__29(HEAP32[$2 + 80 >> 2]);
 HEAP32[$2 + 68 >> 2] = HEAP32[HEAP32[$2 + 76 >> 2] + 20 >> 2];
 if (!((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 84 >> 2]) | 0) != 1 | HEAP32[HEAP32[$2 + 68 >> 2] >> 2] != 1 | HEAP32[HEAP32[$2 + 68 >> 2] + 4 >> 2])) {
  HEAP32[HEAP32[$2 + 68 >> 2] >> 2] = 0;
 }
 HEAP32[$2 + 64 >> 2] = 1;
 HEAP32[$2 + 60 >> 2] = -1;
 HEAP32[$2 + 56 >> 2] = 0;
 label$2: {
  while (1) {
   if (HEAP32[$2 + 56 >> 2] < HEAP32[HEAP32[$2 + 68 >> 2] >> 2]) {
    HEAP32[$2 + 52 >> 2] = HEAP32[(HEAP32[$2 + 68 >> 2] + 4 | 0) + (HEAP32[$2 + 56 >> 2] << 2) >> 2];
    label$5: {
     if (HEAP32[$2 + 52 >> 2] == -1) {
      if (HEAP32[$2 + 60 >> 2] != -1) {
       $0 = HEAP32[HEAP32[$2 + 88 >> 2] + 20 >> 2];
       $1 = HEAP32[$2 + 88 >> 2];
       $3 = HEAP32[$2 + 60 >> 2];
       HEAP32[$2 + 12 >> 2] = -1;
       HEAP32[$2 + 8 >> 2] = $3;
       HEAP32[$2 + 4 >> 2] = 139932;
       HEAP32[$2 >> 2] = 128691;
       FUNCTION_TABLE[$0 | 0]($1, 143305, $2);
       HEAP32[$2 + 92 >> 2] = 1;
       break label$2;
      }
      HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 56 >> 2];
      break label$5;
     }
     HEAP32[$2 + 64 >> 2] = Math_imul(HEAP32[$2 + 52 >> 2], HEAP32[$2 + 64 >> 2]);
    }
    HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 56 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[$2 + 60 >> 2] != -1) {
   HEAP32[(HEAP32[$2 + 68 >> 2] + 4 | 0) + (HEAP32[$2 + 60 >> 2] << 2) >> 2] = HEAP32[$2 + 72 >> 2] / HEAP32[$2 + 64 >> 2];
   HEAP32[$2 + 64 >> 2] = Math_imul(HEAP32[(HEAP32[$2 + 68 >> 2] + 4 | 0) + (HEAP32[$2 + 60 >> 2] << 2) >> 2], HEAP32[$2 + 64 >> 2]);
  }
  if (HEAP32[HEAP32[$2 + 80 >> 2] + 28 >> 2] != HEAP32[HEAP32[$2 + 76 >> 2] + 28 >> 2]) {
   $0 = HEAP32[HEAP32[$2 + 88 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 88 >> 2];
   $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 80 >> 2] + 28 >> 2]);
   HEAP32[$2 + 28 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 76 >> 2] + 28 >> 2]);
   HEAP32[$2 + 24 >> 2] = $3;
   HEAP32[$2 + 20 >> 2] = 132215;
   HEAP32[$2 + 16 >> 2] = 132228;
   FUNCTION_TABLE[$0 | 0]($1, 142883, $2 + 16 | 0);
   HEAP32[$2 + 92 >> 2] = 1;
   break label$2;
  }
  if (HEAP32[$2 + 72 >> 2] != HEAP32[$2 + 64 >> 2]) {
   $0 = HEAP32[HEAP32[$2 + 88 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 88 >> 2];
   $3 = HEAP32[$2 + 72 >> 2];
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 64 >> 2];
   HEAP32[$2 + 40 >> 2] = $3;
   HEAP32[$2 + 36 >> 2] = 119708;
   HEAP32[$2 + 32 >> 2] = 119728;
   FUNCTION_TABLE[$0 | 0]($1, 143305, $2 + 32 | 0);
   HEAP32[$2 + 92 >> 2] = 1;
   break label$2;
  }
  HEAP32[$2 + 92 >> 2] = 0;
 }
 __stack_pointer = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}

function tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer + -64 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 60 >> 2] = $0;
 HEAP32[$6 + 56 >> 2] = $1;
 HEAP32[$6 + 52 >> 2] = $2;
 HEAP32[$6 + 48 >> 2] = $3;
 HEAP32[$6 + 44 >> 2] = $4;
 HEAP32[$6 + 40 >> 2] = $5;
 HEAPF32[$6 + 36 >> 2] = HEAPF32[HEAP32[$6 + 48 >> 2] + 8 >> 2];
 HEAP32[$6 + 32 >> 2] = HEAP32[HEAP32[$6 + 48 >> 2] + 12 >> 2];
 HEAPF32[$6 + 24 >> 2] = HEAPF32[$6 + 36 >> 2];
 HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 32 >> 2];
 label$1: {
  if (HEAP32[$6 + 60 >> 2] == 1) {
   HEAP32[$6 + 20 >> 2] = tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29__$_0__operator_28_29_28float_29_20const($6 + 24 | 0, Math_fround(0));
   $0 = int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($6 + 56 | 0, $6 + 20 | 0);
   HEAP32[HEAP32[$6 + 44 >> 2] >> 2] = HEAP32[$0 >> 2];
   HEAP32[HEAP32[$6 + 40 >> 2] >> 2] = HEAP32[$6 + 52 >> 2];
   break label$1;
  }
  label$3: {
   if (HEAP32[$6 + 60 >> 2] == 3) {
    HEAP32[$6 + 16 >> 2] = tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29__$_0__operator_28_29_28float_29_20const($6 + 24 | 0, Math_fround(0));
    $0 = int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($6 + 56 | 0, $6 + 16 | 0);
    HEAP32[HEAP32[$6 + 44 >> 2] >> 2] = HEAP32[$0 >> 2];
    HEAP32[$6 + 12 >> 2] = tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29__$_0__operator_28_29_28float_29_20const($6 + 24 | 0, Math_fround(6));
    $0 = int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($6 + 52 | 0, $6 + 12 | 0);
    HEAP32[HEAP32[$6 + 40 >> 2] >> 2] = HEAP32[$0 >> 2];
    break label$3;
   }
   label$5: {
    if (HEAP32[$6 + 60 >> 2] == 2) {
     HEAP32[$6 + 8 >> 2] = tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29__$_0__operator_28_29_28float_29_20const($6 + 24 | 0, Math_fround(-1));
     $0 = int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($6 + 56 | 0, $6 + 8 | 0);
     HEAP32[HEAP32[$6 + 44 >> 2] >> 2] = HEAP32[$0 >> 2];
     HEAP32[$6 + 4 >> 2] = tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29__$_0__operator_28_29_28float_29_20const($6 + 24 | 0, Math_fround(1));
     $0 = int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($6 + 52 | 0, $6 + 4 | 0);
     HEAP32[HEAP32[$6 + 40 >> 2] >> 2] = HEAP32[$0 >> 2];
     break label$5;
    }
    HEAP32[HEAP32[$6 + 44 >> 2] >> 2] = HEAP32[$6 + 56 >> 2];
    HEAP32[HEAP32[$6 + 40 >> 2] >> 2] = HEAP32[$6 + 52 >> 2];
   }
  }
 }
 __stack_pointer = $6 - -64 | 0;
}

function graphicsDrawLine($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = __stack_pointer + -64 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 60 >> 2] = $0;
 HEAP32[$5 + 56 >> 2] = $1;
 HEAP32[$5 + 52 >> 2] = $2;
 HEAP32[$5 + 48 >> 2] = $3;
 HEAP32[$5 + 44 >> 2] = $4;
 graphicsToDeviceCoordinates(HEAP32[$5 + 60 >> 2], $5 + 56 | 0, $5 + 52 | 0);
 graphicsToDeviceCoordinates(HEAP32[$5 + 60 >> 2], $5 + 48 | 0, $5 + 44 | 0);
 HEAP32[$5 + 40 >> 2] = HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 56 >> 2];
 HEAP32[$5 + 36 >> 2] = HEAP32[$5 + 44 >> 2] - HEAP32[$5 + 52 >> 2];
 if (HEAP32[$5 + 40 >> 2] < 0) {
  HEAP32[$5 + 40 >> 2] = 0 - HEAP32[$5 + 40 >> 2];
 }
 if (HEAP32[$5 + 36 >> 2] < 0) {
  HEAP32[$5 + 36 >> 2] = 0 - HEAP32[$5 + 36 >> 2];
 }
 label$3: {
  if (HEAP32[$5 + 40 >> 2] > HEAP32[$5 + 36 >> 2]) {
   label$5: {
    if (HEAP32[$5 + 56 >> 2] > HEAP32[$5 + 48 >> 2]) {
     HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 56 >> 2];
     HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 48 >> 2];
     HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 32 >> 2];
     HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 52 >> 2];
     HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 44 >> 2];
     HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 32 >> 2];
     break label$5;
    }
    if (!HEAP32[$5 + 40 >> 2]) {
     HEAP32[$5 + 40 >> 2] = 1;
    }
   }
   HEAP32[$5 + 28 >> 2] = (HEAP32[$5 + 52 >> 2] << 8) + 128;
   HEAP32[$5 + 24 >> 2] = (HEAP32[$5 + 44 >> 2] - HEAP32[$5 + 52 >> 2] << 8) / HEAP32[$5 + 40 >> 2];
   HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 56 >> 2];
   while (1) {
    if (HEAP32[$5 + 20 >> 2] <= HEAP32[$5 + 48 >> 2]) {
     $0 = HEAP32[$5 + 60 >> 2];
     graphicsSetPixelDevice(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 28 >> 2] >> 8, HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
     HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 24 >> 2] + HEAP32[$5 + 28 >> 2];
     HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
     continue;
    }
    break;
   }
   break label$3;
  }
  label$10: {
   if (HEAP32[$5 + 52 >> 2] > HEAP32[$5 + 44 >> 2]) {
    HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 56 >> 2];
    HEAP32[$5 + 56 >> 2] = HEAP32[$5 + 48 >> 2];
    HEAP32[$5 + 48 >> 2] = HEAP32[$5 + 16 >> 2];
    HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 52 >> 2];
    HEAP32[$5 + 52 >> 2] = HEAP32[$5 + 44 >> 2];
    HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 16 >> 2];
    break label$10;
   }
   if (!HEAP32[$5 + 36 >> 2]) {
    HEAP32[$5 + 36 >> 2] = 1;
   }
  }
  HEAP32[$5 + 12 >> 2] = (HEAP32[$5 + 56 >> 2] << 8) + 128;
  HEAP32[$5 + 8 >> 2] = (HEAP32[$5 + 48 >> 2] - HEAP32[$5 + 56 >> 2] << 8) / HEAP32[$5 + 36 >> 2];
  HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 52 >> 2];
  while (1) {
   if (HEAP32[$5 + 4 >> 2] <= HEAP32[$5 + 44 >> 2]) {
    $0 = HEAP32[$5 + 60 >> 2];
    graphicsSetPixelDevice(HEAP32[$5 + 60 >> 2], HEAP32[$5 + 12 >> 2] >> 8, HEAP32[$5 + 4 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
    HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 8 >> 2] + HEAP32[$5 + 12 >> 2];
    HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] + 1;
    continue;
   }
   break;
  }
 }
 __stack_pointer = $5 - -64 | 0;
}

function tflite__ops__micro__fully_connected__Eval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1: {
  if (!HEAP32[HEAP32[$2 + 36 >> 2] + 12 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 32 >> 2] = HEAP32[HEAP32[$2 + 36 >> 2] + 12 >> 2];
 HEAP32[$2 + 28 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 0);
 HEAP32[$2 + 24 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 1);
 HEAP32[$2 + 20 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 2);
 HEAP32[$2 + 16 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 0);
 label$2: {
  if (!HEAP32[HEAP32[$2 + 36 >> 2] + 8 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 36 >> 2] + 8 >> 2];
 label$3: {
  label$4: {
   switch (HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2] - 1 | 0) {
   case 0:
    HEAP32[$2 + 44 >> 2] = tflite__ops__micro__fully_connected__EvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteFusedActivation_2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[HEAP32[$2 + 32 >> 2] >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
    break label$3;

   case 8:
    HEAP32[$2 + 44 >> 2] = tflite__ops__micro__fully_connected__EvalQuantizedInt8_28TfLiteContext__2c_20TfLiteNode__2c_20tflite__ops__micro__fully_connected___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
    break label$3;

   case 2:
    HEAP32[$2 + 44 >> 2] = tflite__ops__micro__fully_connected__EvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20tflite__ops__micro__fully_connected___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
    break label$3;

   default:
    break label$4;
   }
  }
  $0 = HEAP32[HEAP32[$2 + 40 >> 2] + 20 >> 2];
  $1 = HEAP32[$2 + 40 >> 2];
  $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2]);
  HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2];
  HEAP32[$2 >> 2] = $3;
  FUNCTION_TABLE[$0 | 0]($1, 140819, $2);
  HEAP32[$2 + 44 >> 2] = 1;
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function tflite__ops__micro__depthwise_conv__EvalQuantizedPerChannel_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0;
 $8 = __stack_pointer - 192 | 0;
 __stack_pointer = $8;
 HEAP32[$8 + 188 >> 2] = $0;
 HEAP32[$8 + 184 >> 2] = $1;
 HEAP32[$8 + 180 >> 2] = $2;
 HEAP32[$8 + 176 >> 2] = $3;
 HEAP32[$8 + 172 >> 2] = $4;
 HEAP32[$8 + 168 >> 2] = $5;
 HEAP32[$8 + 164 >> 2] = $6;
 HEAP32[$8 + 160 >> 2] = $7;
 HEAP8[$8 + 96 | 0] = 1;
 HEAP16[$8 + 98 >> 1] = HEAP32[HEAP32[$8 + 176 >> 2] >> 2];
 HEAP16[$8 + 100 >> 1] = HEAP32[HEAP32[$8 + 176 >> 2] + 4 >> 2];
 HEAP16[$8 + 106 >> 1] = HEAP32[HEAP32[$8 + 180 >> 2] + 4 >> 2];
 HEAP16[$8 + 108 >> 1] = HEAP32[HEAP32[$8 + 180 >> 2] + 8 >> 2];
 HEAP16[$8 + 110 >> 1] = HEAP32[HEAP32[$8 + 180 >> 2] + 20 >> 2];
 HEAP16[$8 + 112 >> 1] = HEAP32[HEAP32[$8 + 180 >> 2] + 24 >> 2];
 HEAP16[$8 + 114 >> 1] = HEAP32[HEAP32[$8 + 180 >> 2] + 12 >> 2];
 HEAP32[$8 + 116 >> 2] = 0 - HEAP32[HEAP32[$8 + 176 >> 2] + 16 >> 2];
 HEAP32[$8 + 120 >> 2] = 0;
 HEAP32[$8 + 124 >> 2] = HEAP32[HEAP32[$8 + 176 >> 2] + 24 >> 2];
 HEAP32[$8 + 136 >> 2] = std____2__numeric_limits_signed_20char___min_28_29() << 24 >> 24;
 HEAP32[$8 + 140 >> 2] = std____2__numeric_limits_signed_20char___max_28_29() << 24 >> 24;
 $0 = HEAP32[HEAP32[$8 + 176 >> 2] + 36 >> 2];
 $1 = HEAP32[HEAP32[$8 + 176 >> 2] + 40 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 72 | 0, HEAP32[$8 + 172 >> 2]);
 $2 = signed_20char_20const__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 172 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 48 | 0, HEAP32[$8 + 168 >> 2]);
 $3 = signed_20char_20const__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 168 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 24 | 0, HEAP32[$8 + 164 >> 2]);
 $4 = int_20const__20tflite__micro__GetTensorData_int__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 164 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8, HEAP32[$8 + 160 >> 2]);
 tflite__reference_integer_ops__DepthwiseConvPerChannel_28tflite__DepthwiseParams_20const__2c_20int_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($8 + 96 | 0, $0, $1, $8 + 72 | 0, $2, $8 + 48 | 0, $3, $8 + 24 | 0, $4, $8, signed_20char__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor__29(HEAP32[$8 + 160 >> 2]));
 tflite__RuntimeShape___RuntimeShape_28_29($8);
 tflite__RuntimeShape___RuntimeShape_28_29($8 + 24 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($8 + 48 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($8 + 72 | 0);
 __stack_pointer = $8 + 192 | 0;
}

function graphicsSetModifiedAndClip($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 48 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 44 >> 2] = $0;
 HEAP32[$6 + 40 >> 2] = $1;
 HEAP32[$6 + 36 >> 2] = $2;
 HEAP32[$6 + 32 >> 2] = $3;
 HEAP32[$6 + 28 >> 2] = $4;
 HEAP8[$6 + 27 | 0] = $5;
 HEAP8[$6 + 26 | 0] = 0;
 $0 = HEAP32[$6 + 44 >> 2];
 HEAP32[$6 + 20 >> 2] = HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8;
 $0 = HEAP32[$6 + 44 >> 2];
 HEAP32[$6 + 16 >> 2] = HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8;
 $0 = HEAP32[$6 + 44 >> 2];
 HEAP32[$6 + 12 >> 2] = HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8;
 $0 = HEAP32[$6 + 44 >> 2];
 HEAP32[$6 + 8 >> 2] = HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8;
 if (HEAP8[$6 + 27 | 0] & 1) {
  graphicsToDeviceCoordinates(HEAP32[$6 + 44 >> 2], $6 + 20 | 0, $6 + 16 | 0);
  graphicsToDeviceCoordinates(HEAP32[$6 + 44 >> 2], $6 + 12 | 0, $6 + 8 | 0);
  if (HEAP32[$6 + 12 >> 2] < HEAP32[$6 + 20 >> 2]) {
   HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 20 >> 2];
   HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 12 >> 2];
   HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 4 >> 2];
  }
  if (HEAP32[$6 + 8 >> 2] < HEAP32[$6 + 16 >> 2]) {
   HEAP32[$6 >> 2] = HEAP32[$6 + 16 >> 2];
   HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 8 >> 2];
   HEAP32[$6 + 8 >> 2] = HEAP32[$6 >> 2];
  }
 }
 if (HEAP32[HEAP32[$6 + 40 >> 2] >> 2] < HEAP32[$6 + 20 >> 2]) {
  HEAP32[HEAP32[$6 + 40 >> 2] >> 2] = HEAP32[$6 + 20 >> 2];
  HEAP8[$6 + 26 | 0] = 1;
 }
 if (HEAP32[HEAP32[$6 + 36 >> 2] >> 2] < HEAP32[$6 + 16 >> 2]) {
  HEAP32[HEAP32[$6 + 36 >> 2] >> 2] = HEAP32[$6 + 16 >> 2];
  HEAP8[$6 + 26 | 0] = 1;
 }
 if (HEAP32[HEAP32[$6 + 32 >> 2] >> 2] > HEAP32[$6 + 12 >> 2]) {
  HEAP32[HEAP32[$6 + 32 >> 2] >> 2] = HEAP32[$6 + 12 >> 2];
  HEAP8[$6 + 26 | 0] = 1;
 }
 if (HEAP32[HEAP32[$6 + 28 >> 2] >> 2] > HEAP32[$6 + 8 >> 2]) {
  HEAP32[HEAP32[$6 + 28 >> 2] >> 2] = HEAP32[$6 + 8 >> 2];
  HEAP8[$6 + 26 | 0] = 1;
 }
 $0 = HEAP32[$6 + 44 >> 2];
 if (HEAP32[HEAP32[$6 + 40 >> 2] >> 2] < (HEAPU8[$0 + 40 | 0] | HEAPU8[$0 + 41 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$6 + 44 >> 2];
  $1 = HEAP32[HEAP32[$6 + 40 >> 2] >> 2];
  HEAP8[$0 + 40 | 0] = $1;
  HEAP8[$0 + 41 | 0] = $1 >>> 8;
  HEAP8[$6 + 26 | 0] = 1;
 }
 $0 = HEAP32[$6 + 44 >> 2];
 if (HEAP32[HEAP32[$6 + 32 >> 2] >> 2] > (HEAPU8[$0 + 44 | 0] | HEAPU8[$0 + 45 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$6 + 44 >> 2];
  $1 = HEAP32[HEAP32[$6 + 32 >> 2] >> 2];
  HEAP8[$0 + 44 | 0] = $1;
  HEAP8[$0 + 45 | 0] = $1 >>> 8;
  HEAP8[$6 + 26 | 0] = 1;
 }
 $0 = HEAP32[$6 + 44 >> 2];
 if (HEAP32[HEAP32[$6 + 36 >> 2] >> 2] < (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$6 + 44 >> 2];
  $1 = HEAP32[HEAP32[$6 + 36 >> 2] >> 2];
  HEAP8[$0 + 42 | 0] = $1;
  HEAP8[$0 + 43 | 0] = $1 >>> 8;
  HEAP8[$6 + 26 | 0] = 1;
 }
 $0 = HEAP32[$6 + 44 >> 2];
 if (HEAP32[HEAP32[$6 + 28 >> 2] >> 2] > (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$6 + 44 >> 2];
  $1 = HEAP32[HEAP32[$6 + 28 >> 2] >> 2];
  HEAP8[$0 + 46 | 0] = $1;
  HEAP8[$0 + 47 | 0] = $1 >>> 8;
  HEAP8[$6 + 26 | 0] = 1;
 }
 __stack_pointer = $6 + 48 | 0;
 return HEAP8[$6 + 26 | 0] & 1;
}

function jsvReadConfigObject($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 56 >> 2] = $0;
 HEAP32[$3 + 52 >> 2] = $1;
 HEAP32[$3 + 48 >> 2] = $2;
 label$1: {
  if (jsvIsUndefined(HEAP32[$3 + 56 >> 2]) & 1) {
   HEAP8[$3 + 63 | 0] = 1;
   break label$1;
  }
  if (!(jsvIsObject(HEAP32[$3 + 56 >> 2]) & 1)) {
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 56 >> 2];
   jsExceptionHere(1, 119078, $3 + 16 | 0);
   HEAP8[$3 + 63 | 0] = 0;
   break label$1;
  }
  jsvObjectIteratorNew($3 + 40 | 0, HEAP32[$3 + 56 >> 2]);
  HEAP8[$3 + 39 | 0] = 1;
  while (1) {
   $0 = 0;
   if (HEAP8[$3 + 39 | 0] & 1) {
    $0 = jsvObjectIteratorHasValue($3 + 40 | 0);
   }
   if ($0 & 1) {
    HEAP32[$3 + 32 >> 2] = jsvObjectIteratorGetKey($3 + 40 | 0);
    HEAP8[$3 + 31 | 0] = 0;
    HEAP32[$3 + 24 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 24 >> 2] < HEAP32[$3 + 48 >> 2]) {
      if (jsvIsStringEqual(HEAP32[$3 + 32 >> 2], HEAP32[HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 24 >> 2], 12) >> 2]) & 1) {
       HEAP8[$3 + 31 | 0] = 1;
       if (HEAP32[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 24 >> 2], 12) | 0) + 8 >> 2]) {
        HEAP32[$3 + 20 >> 2] = jsvObjectIteratorGetValue($3 + 40 | 0);
        label$11: {
         label$12: {
          switch (HEAPU16[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 24 >> 2], 12) | 0) + 4 >> 1] - 3 | 0) {
          case 0:
          case 2:
          case 4:
          case 25:
           $0 = jsvLockAgain(HEAP32[$3 + 20 >> 2]);
           HEAP32[HEAP32[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 24 >> 2], 12) | 0) + 8 >> 2] >> 2] = $0;
           break label$11;

          case 10:
           $0 = jshGetPinFromVar(HEAP32[$3 + 20 >> 2]);
           HEAP8[HEAP32[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 24 >> 2], 12) | 0) + 8 >> 2]] = $0;
           break label$11;

          case 9:
           $0 = jsvGetBool(HEAP32[$3 + 20 >> 2]);
           HEAP8[HEAP32[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 24 >> 2], 12) | 0) + 8 >> 2]] = $0 & 1;
           break label$11;

          case 7:
           $0 = jsvGetInteger(HEAP32[$3 + 20 >> 2]);
           HEAP32[HEAP32[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 24 >> 2], 12) | 0) + 8 >> 2] >> 2] = $0;
           break label$11;

          case 8:
           break label$12;

          default:
           break label$11;
          }
         }
         $4 = jsvGetFloat(HEAP32[$3 + 20 >> 2]);
         HEAPF64[HEAP32[(HEAP32[$3 + 52 >> 2] + Math_imul(HEAP32[$3 + 24 >> 2], 12) | 0) + 8 >> 2] >> 3] = $4;
        }
        jsvUnLock(HEAP32[$3 + 20 >> 2]);
       }
      }
      HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] + 1;
      continue;
     }
     break;
    }
    if (!(HEAP8[$3 + 31 | 0] & 1)) {
     HEAP32[$3 >> 2] = HEAP32[$3 + 32 >> 2];
     jsExceptionHere(1, 121521, $3);
     HEAP8[$3 + 39 | 0] = 0;
    }
    jsvUnLock(HEAP32[$3 + 32 >> 2]);
    jsvObjectIteratorNext($3 + 40 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($3 + 40 | 0);
  HEAP8[$3 + 63 | 0] = HEAP8[$3 + 39 | 0] & 1;
 }
 __stack_pointer = $3 - -64 | 0;
 return HEAP8[$3 + 63 | 0] & 1;
}

function jswrap_graphics_createImage($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 96 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 88 >> 2] = $0;
 label$1: {
  if (!(jsvIsString(HEAP32[$1 + 88 >> 2]) & 1)) {
   jsExceptionHere(3, 129825, 0);
   HEAP32[$1 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 84 >> 2] = 0;
  HEAP32[$1 + 80 >> 2] = 0;
  HEAP32[$1 + 76 >> 2] = 0;
  HEAP32[$1 + 72 >> 2] = 0;
  HEAP32[$1 + 68 >> 2] = 0;
  jsvStringIteratorNew($1 + 32 | 0, HEAP32[$1 + 88 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar_12($1 + 32 | 0) & 1) {
    HEAP8[$1 + 31 | 0] = jsvStringIteratorGetCharAndNext($1 + 32 | 0);
    label$5: {
     if (HEAP8[$1 + 31 | 0] == 10) {
      if (!(HEAP32[$1 + 68 >> 2] | (HEAP32[$1 + 84 >> 2] | HEAP32[$1 + 80 >> 2]))) {
       HEAP32[$1 + 68 >> 2] = 1;
       break label$5;
      }
      HEAP32[$1 + 84 >> 2] = 0;
      HEAP32[$1 + 80 >> 2] = HEAP32[$1 + 80 >> 2] + 1;
      if (HEAP32[$1 + 72 >> 2] < (HEAP32[$1 + 80 >> 2] + 1 | 0)) {
       HEAP32[$1 + 72 >> 2] = HEAP32[$1 + 80 >> 2] + 1;
      }
      break label$5;
     }
     HEAP32[$1 + 84 >> 2] = HEAP32[$1 + 84 >> 2] + 1;
     if (HEAP32[$1 + 84 >> 2] > HEAP32[$1 + 76 >> 2]) {
      HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 84 >> 2];
     }
    }
    continue;
   }
   break;
  }
  if (!(!HEAP32[$1 + 72 >> 2] | HEAP8[$1 + 31 | 0] != 10)) {
   HEAP32[$1 + 72 >> 2] = HEAP32[$1 + 72 >> 2] - 1;
  }
  jsvStringIteratorFree_16($1 + 32 | 0);
  HEAP32[$1 + 24 >> 2] = jsvNewObject();
  if (!HEAP32[$1 + 24 >> 2]) {
   HEAP32[$1 + 92 >> 2] = 0;
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 24 >> 2], 129398, jsvNewFromInteger(HEAP32[$1 + 76 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 24 >> 2], 117745, jsvNewFromInteger(HEAP32[$1 + 72 >> 2]));
  HEAP32[$1 + 20 >> 2] = Math_imul(HEAP32[$1 + 76 >> 2], HEAP32[$1 + 72 >> 2]) + 7 >> 3;
  HEAP32[$1 + 16 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 20 >> 2], 0);
  if (!HEAP32[$1 + 16 >> 2]) {
   jsvUnLock(HEAP32[$1 + 24 >> 2]);
   HEAP32[$1 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 84 >> 2] = 0;
  HEAP32[$1 + 80 >> 2] = 0;
  jsvStringIteratorNew($1 + 32 | 0, HEAP32[$1 + 88 >> 2], HEAP32[$1 + 68 >> 2]);
  while (1) {
   if (jsvStringIteratorHasChar_12($1 + 32 | 0) & 1) {
    HEAP8[$1 + 15 | 0] = jsvStringIteratorGetCharAndNext($1 + 32 | 0);
    label$15: {
     if (HEAP8[$1 + 15 | 0] == 10) {
      HEAP32[$1 + 84 >> 2] = 0;
      HEAP32[$1 + 80 >> 2] = HEAP32[$1 + 80 >> 2] + 1;
      break label$15;
     }
     if (!(HEAP8[$1 + 15 | 0] == 32 | HEAP8[$1 + 15 | 0] == 46)) {
      HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 84 >> 2] + Math_imul(HEAP32[$1 + 80 >> 2], HEAP32[$1 + 76 >> 2]);
      jsvSetCharInString(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 8 >> 2] >>> 3 | 0, 128 >> (HEAP32[$1 + 8 >> 2] & 7) << 24 >> 24, 1);
     }
     HEAP32[$1 + 84 >> 2] = HEAP32[$1 + 84 >> 2] + 1;
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree_16($1 + 32 | 0);
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 24 >> 2], 121187, HEAP32[$1 + 16 >> 2]);
  HEAP32[$1 + 92 >> 2] = HEAP32[$1 + 24 >> 2];
 }
 __stack_pointer = $1 + 96 | 0;
 return HEAP32[$1 + 92 >> 2];
}

function jswGetSymbolListForObjectProto($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (jsvIsNativeFunction(HEAP32[$1 + 8 >> 2]) & 1) {
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 27) {
    HEAP32[$1 + 12 >> 2] = 159049;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 32) {
    HEAP32[$1 + 12 >> 2] = 159112;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 48) {
    HEAP32[$1 + 12 >> 2] = 159130;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 49) {
    HEAP32[$1 + 12 >> 2] = 159139;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 35) {
    HEAP32[$1 + 12 >> 2] = 159247;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 50) {
    HEAP32[$1 + 12 >> 2] = 159274;
    break label$1;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 37) {
    HEAP32[$1 + 12 >> 2] = 159292;
    break label$1;
   }
  }
  label$10: {
   if (jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1) {
    $0 = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAP32[$1 + 8 >> 2], 120855));
    break label$10;
   }
   $0 = 0;
  }
  HEAP32[$1 + 4 >> 2] = $0;
  label$12: {
   if (!HEAP32[$1 + 4 >> 2]) {
    break label$12;
   }
   if (!(jsvIsNativeFunction(HEAP32[$1 + 4 >> 2]) & 1)) {
    break label$12;
   }
   HEAP32[$1 >> 2] = jswGetSymbolListForConstructorProto(HEAP32[$1 + 4 >> 2]);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   if (HEAP32[$1 >> 2]) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
    break label$1;
   }
  }
  if (jsvIsPin(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 159049;
   break label$1;
  }
  if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 159112;
   break label$1;
  }
  if (!(!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1) | HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] != 129)) {
   HEAP32[$1 + 12 >> 2] = 159130;
   break label$1;
  }
  if (!(!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1) | HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 129)) {
   HEAP32[$1 + 12 >> 2] = 159139;
   break label$1;
  }
  if (jsvIsNumeric(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 159247;
   break label$1;
  }
  if (jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 159274;
   break label$1;
  }
  if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 159292;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 159256;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function mbedtls_aes_setkey_dec($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 320 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 316 >> 2] = $0;
 HEAP32[$3 + 312 >> 2] = $1;
 HEAP32[$3 + 308 >> 2] = $2;
 mbedtls_aes_init($3 + 16 | 0);
 $0 = HEAP32[$3 + 316 >> 2] + 8 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[HEAP32[$3 + 316 >> 2] + 4 >> 2] = $0;
 $0 = mbedtls_aes_setkey_enc($3 + 16 | 0, HEAP32[$3 + 312 >> 2], HEAP32[$3 + 308 >> 2]);
 HEAP32[$3 + 296 >> 2] = $0;
 if (!$0) {
  HEAP32[HEAP32[$3 + 316 >> 2] >> 2] = HEAP32[$3 + 16 >> 2];
  HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 16 >> 2] << 4);
  $0 = HEAP32[$3 + 8 >> 2];
  HEAP32[$3 + 8 >> 2] = $0 + 4;
  $1 = HEAP32[$0 >> 2];
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[$3 + 12 >> 2] = $0 + 4;
  HEAP32[$0 >> 2] = $1;
  $0 = HEAP32[$3 + 8 >> 2];
  HEAP32[$3 + 8 >> 2] = $0 + 4;
  $1 = HEAP32[$0 >> 2];
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[$3 + 12 >> 2] = $0 + 4;
  HEAP32[$0 >> 2] = $1;
  $0 = HEAP32[$3 + 8 >> 2];
  HEAP32[$3 + 8 >> 2] = $0 + 4;
  $1 = HEAP32[$0 >> 2];
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[$3 + 12 >> 2] = $0 + 4;
  HEAP32[$0 >> 2] = $1;
  $0 = HEAP32[$3 + 8 >> 2];
  HEAP32[$3 + 8 >> 2] = $0 + 4;
  $1 = HEAP32[$0 >> 2];
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[$3 + 12 >> 2] = $0 + 4;
  HEAP32[$0 >> 2] = $1;
  HEAP32[$3 + 304 >> 2] = HEAP32[HEAP32[$3 + 316 >> 2] >> 2] - 1;
  HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] - 32;
  while (1) {
   if (HEAP32[$3 + 304 >> 2] > 0) {
    HEAP32[$3 + 300 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 300 >> 2] < 4) {
      $1 = HEAP32[(HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] >> 2] >>> 24 | 0) + 171744 | 0] << 2) + 175072 >> 2];
      $2 = HEAP32[(HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] >> 2] >>> 16 & 255) + 171744 | 0] << 2) + 174048 >> 2] ^ (HEAP32[(HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] >> 2] & 255) + 171744 | 0] << 2) + 172e3 >> 2] ^ HEAP32[(HEAPU8[(HEAP32[HEAP32[$3 + 8 >> 2] >> 2] >>> 8 & 255) + 171744 | 0] << 2) + 173024 >> 2]);
      $0 = HEAP32[$3 + 12 >> 2];
      HEAP32[$3 + 12 >> 2] = $0 + 4;
      HEAP32[$0 >> 2] = $1 ^ $2;
      HEAP32[$3 + 300 >> 2] = HEAP32[$3 + 300 >> 2] + 1;
      HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + 4;
      continue;
     }
     break;
    }
    HEAP32[$3 + 304 >> 2] = HEAP32[$3 + 304 >> 2] - 1;
    HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] - 32;
    continue;
   }
   break;
  }
  $0 = HEAP32[$3 + 8 >> 2];
  HEAP32[$3 + 8 >> 2] = $0 + 4;
  $1 = HEAP32[$0 >> 2];
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[$3 + 12 >> 2] = $0 + 4;
  HEAP32[$0 >> 2] = $1;
  $0 = HEAP32[$3 + 8 >> 2];
  HEAP32[$3 + 8 >> 2] = $0 + 4;
  $1 = HEAP32[$0 >> 2];
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[$3 + 12 >> 2] = $0 + 4;
  HEAP32[$0 >> 2] = $1;
  $0 = HEAP32[$3 + 8 >> 2];
  HEAP32[$3 + 8 >> 2] = $0 + 4;
  $1 = HEAP32[$0 >> 2];
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[$3 + 12 >> 2] = $0 + 4;
  HEAP32[$0 >> 2] = $1;
  $0 = HEAP32[$3 + 8 >> 2];
  HEAP32[$3 + 8 >> 2] = $0 + 4;
  $1 = HEAP32[$0 >> 2];
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[$3 + 12 >> 2] = $0 + 4;
  HEAP32[$0 >> 2] = $1;
 }
 mbedtls_aes_free($3 + 16 | 0);
 __stack_pointer = $3 + 320 | 0;
 return HEAP32[$3 + 296 >> 2];
}

function jswrap_atob($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 128 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 120 >> 2] = $0;
 label$1: {
  if (!(jsvIsString(HEAP32[$1 + 120 >> 2]) & 1)) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 120 >> 2];
   jsExceptionHere(1, 118920, $1);
   HEAP32[$1 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 116 >> 2] = 0;
  jsvStringIteratorNew($1 + 80 | 0, HEAP32[$1 + 120 >> 2], 0);
  HEAP8[$1 + 79 | 0] = 0;
  HEAP8[$1 + 78 | 0] = 0;
  while (1) {
   if (jsvStringIteratorHasChar_6($1 + 80 | 0) & 1) {
    HEAP8[$1 + 77 | 0] = jsvStringIteratorGetChar_4($1 + 80 | 0);
    if (!(isWhitespace(HEAP8[$1 + 77 | 0]) & 1)) {
     HEAP8[$1 + 78 | 0] = HEAPU8[$1 + 79 | 0];
     HEAP8[$1 + 79 | 0] = HEAPU8[$1 + 77 | 0];
     HEAP32[$1 + 116 >> 2] = HEAP32[$1 + 116 >> 2] + 1;
    }
    jsvStringIteratorNext($1 + 80 | 0);
    continue;
   }
   break;
  }
  jsvStringIteratorFree_7($1 + 80 | 0);
  HEAP32[$1 + 72 >> 2] = Math_imul(HEAP32[$1 + 116 >> 2], 3) >>> 2;
  if (HEAP8[$1 + 79 | 0] == 61) {
   HEAP32[$1 + 72 >> 2] = HEAP32[$1 + 72 >> 2] - 1;
  }
  if (HEAP8[$1 + 78 | 0] == 61) {
   HEAP32[$1 + 72 >> 2] = HEAP32[$1 + 72 >> 2] - 1;
  }
  HEAP32[$1 + 68 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 72 >> 2], 0);
  if (!HEAP32[$1 + 68 >> 2]) {
   HEAP32[$1 + 124 >> 2] = 0;
   break label$1;
  }
  jsvStringIteratorNew($1 + 80 | 0, HEAP32[$1 + 120 >> 2], 0);
  jsvStringIteratorNew($1 + 32 | 0, HEAP32[$1 + 68 >> 2], 0);
  while (1) {
   $0 = 0;
   if (jsvStringIteratorHasChar_6($1 + 80 | 0) & 1) {
    $0 = jspIsInterrupted() ^ -1;
   }
   if ($0 & 1) {
    HEAP32[$1 + 28 >> 2] = 0;
    HEAP32[$1 + 20 >> 2] = 0;
    HEAP32[$1 + 24 >> 2] = 0;
    while (1) {
     if (HEAP32[$1 + 24 >> 2] < 4) {
      if (jsvStringIteratorHasChar_6($1 + 80 | 0) & 1) {
       HEAP8[$1 + 19 | 0] = 32;
       while (1) {
        $0 = 0;
        if (HEAP8[$1 + 19 | 0]) {
         $0 = isWhitespace(HEAP8[$1 + 19 | 0]);
        }
        if ($0 & 1) {
         HEAP8[$1 + 19 | 0] = jsvStringIteratorGetCharAndNext($1 + 80 | 0);
         continue;
        }
        break;
       }
       HEAP32[$1 + 12 >> 2] = jswrap_atob_decode(HEAP8[$1 + 19 | 0]);
       if (HEAP32[$1 + 12 >> 2] >= 0) {
        HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 28 >> 2] | HEAP32[$1 + 12 >> 2] << Math_imul(3 - HEAP32[$1 + 24 >> 2] | 0, 6);
        HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 24 >> 2];
       }
      }
      HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 24 >> 2] + 1;
      continue;
     }
     break;
    }
    if (HEAP32[$1 + 20 >> 2] > 0) {
     jsvStringIteratorSetCharAndNext($1 + 32 | 0, HEAP32[$1 + 28 >> 2] >>> 16 << 24 >> 24);
    }
    if (HEAP32[$1 + 20 >> 2] > 1) {
     jsvStringIteratorSetCharAndNext($1 + 32 | 0, HEAP32[$1 + 28 >> 2] >>> 8 << 24 >> 24);
    }
    if (HEAP32[$1 + 20 >> 2] > 2) {
     jsvStringIteratorSetCharAndNext($1 + 32 | 0, HEAP32[$1 + 28 >> 2] << 24 >> 24);
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree_7($1 + 80 | 0);
  jsvStringIteratorFree_7($1 + 32 | 0);
  HEAP32[$1 + 124 >> 2] = HEAP32[$1 + 68 >> 2];
 }
 __stack_pointer = $1 + 128 | 0;
 return HEAP32[$1 + 124 >> 2];
}

function jsspiSoftwareFunc($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 44 >> 2] = $0;
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 36 >> 2] = $2;
 HEAP32[$4 + 32 >> 2] = $3;
 HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 32 >> 2];
 HEAP8[$4 + 27 | 0] = HEAP8[HEAP32[$4 + 28 >> 2] + 8 | 0] & 1;
 HEAP8[$4 + 26 | 0] = (HEAPU8[HEAP32[$4 + 28 >> 2] + 8 | 0] & 2) != 0;
 HEAP32[$4 + 20 >> 2] = HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] & 1 ? -1 : 1;
 if (HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] & 1) {
  $0 = -1;
 } else {
  $0 = HEAP32[$4 + 28 >> 2];
  $0 = HEAPU8[$0 + 10 | 0] | HEAPU8[$0 + 11 | 0] << 8 | (HEAPU8[$0 + 12 | 0] << 16 | HEAPU8[$0 + 13 | 0] << 24);
 }
 HEAP32[$4 + 16 >> 2] = $0;
 HEAP32[$4 + 12 >> 2] = 0;
 while (1) {
  if (HEAPU32[$4 + 12 >> 2] < HEAPU32[$4 + 36 >> 2]) {
   HEAP32[$4 + 8 >> 2] = HEAPU8[HEAP32[$4 + 44 >> 2] + HEAP32[$4 + 12 >> 2] | 0];
   HEAP32[$4 + 4 >> 2] = 0;
   label$5: {
    if (HEAP8[HEAP32[$4 + 28 >> 2] + 9 | 0] & 1) {
     $0 = HEAP32[$4 + 28 >> 2];
     $0 = (HEAPU8[$0 + 10 | 0] | HEAPU8[$0 + 11 | 0] << 8 | (HEAPU8[$0 + 12 | 0] << 16 | HEAPU8[$0 + 13 | 0] << 24)) - 1 | 0;
     break label$5;
    }
    $0 = 0;
   }
   HEAP32[$4 >> 2] = $0;
   while (1) {
    if (HEAP32[$4 >> 2] != HEAP32[$4 + 16 >> 2]) {
     label$9: {
      if (!(HEAP8[$4 + 27 | 0] & 1)) {
       if (HEAPU8[HEAP32[$4 + 28 >> 2] + 7 | 0] != 255) {
        jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 7 | 0], HEAP32[$4 + 8 >> 2] >> HEAP32[$4 >> 2] & 1);
       }
       if (HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0] != 255) {
        jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0], (HEAPU8[$4 + 26 | 0] ^ -1) & 1);
       }
       if (HEAPU8[HEAP32[$4 + 28 >> 2] + 6 | 0] != 255) {
        HEAP32[$4 + 4 >> 2] = (jshPinGetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 6 | 0]) & 1) << HEAP32[$4 >> 2] | HEAP32[$4 + 4 >> 2];
       }
       if (HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0] != 255) {
        jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0], HEAP8[$4 + 26 | 0] & 1);
       }
       break label$9;
      }
      if (HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0] != 255) {
       jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0], (HEAPU8[$4 + 26 | 0] ^ -1) & 1);
      }
      if (HEAPU8[HEAP32[$4 + 28 >> 2] + 7 | 0] != 255) {
       jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 7 | 0], HEAP32[$4 + 8 >> 2] >> HEAP32[$4 >> 2] & 1);
      }
      if (HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0] != 255) {
       jshPinSetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 5 | 0], HEAP8[$4 + 26 | 0] & 1);
      }
      if (HEAPU8[HEAP32[$4 + 28 >> 2] + 6 | 0] != 255) {
       HEAP32[$4 + 4 >> 2] = (jshPinGetValue(HEAPU8[HEAP32[$4 + 28 >> 2] + 6 | 0]) & 1) << HEAP32[$4 >> 2] | HEAP32[$4 + 4 >> 2];
      }
     }
     HEAP32[$4 >> 2] = HEAP32[$4 + 20 >> 2] + HEAP32[$4 >> 2];
     continue;
    }
    break;
   }
   if (HEAP32[$4 + 40 >> 2]) {
    HEAP8[HEAP32[$4 + 40 >> 2] + HEAP32[$4 + 12 >> 2] | 0] = HEAP32[$4 + 4 >> 2];
   }
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $4 + 48 | 0;
}

function utilTimerRemoveTask($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 jshInterruptOff();
 HEAP8[$2 + 3 | 0] = HEAPU8[366353];
 label$1: {
  if (HEAPU8[$2 + 3 | 0] != HEAPU8[366354]) {
   HEAP8[$2 + 2 | 0] = HEAPU8[366354] + 15 & 15;
   HEAP8[$2 + 3 | 0] = HEAPU8[$2 + 3 | 0] + 15 & 15;
   while (1) {
    if (HEAPU8[$2 + 3 | 0] != HEAPU8[$2 + 2 | 0]) {
     if (FUNCTION_TABLE[HEAP32[$2 + 8 >> 2]](Math_imul(HEAPU8[$2 + 3 | 0], 25) + 366368 | 0, HEAP32[$2 + 4 >> 2]) & 1) {
      HEAP8[$2 + 1 | 0] = HEAPU8[$2 + 3 | 0] + 15 & 15;
      while (1) {
       if (HEAPU8[$2 + 1 | 0] != HEAPU8[$2 + 2 | 0]) {
        $3 = Math_imul(HEAPU8[$2 + 1 | 0], 25) + 366368 | 0;
        $0 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
        $4 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
        $5 = $0;
        $1 = Math_imul(HEAPU8[$2 + 3 | 0], 25) + 366368 | 0;
        $0 = $1;
        HEAP8[$0 | 0] = $5;
        HEAP8[$0 + 1 | 0] = $5 >>> 8;
        HEAP8[$0 + 2 | 0] = $5 >>> 16;
        HEAP8[$0 + 3 | 0] = $5 >>> 24;
        HEAP8[$0 + 4 | 0] = $4;
        HEAP8[$0 + 5 | 0] = $4 >>> 8;
        HEAP8[$0 + 6 | 0] = $4 >>> 16;
        HEAP8[$0 + 7 | 0] = $4 >>> 24;
        HEAP8[$0 + 24 | 0] = HEAPU8[$3 + 24 | 0];
        $0 = HEAPU8[$3 + 20 | 0] | HEAPU8[$3 + 21 | 0] << 8 | (HEAPU8[$3 + 22 | 0] << 16 | HEAPU8[$3 + 23 | 0] << 24);
        $4 = HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24);
        $5 = $4;
        $4 = $1;
        HEAP8[$4 + 16 | 0] = $5;
        HEAP8[$4 + 17 | 0] = $5 >>> 8;
        HEAP8[$4 + 18 | 0] = $5 >>> 16;
        HEAP8[$4 + 19 | 0] = $5 >>> 24;
        HEAP8[$4 + 20 | 0] = $0;
        HEAP8[$4 + 21 | 0] = $0 >>> 8;
        HEAP8[$4 + 22 | 0] = $0 >>> 16;
        HEAP8[$4 + 23 | 0] = $0 >>> 24;
        $4 = HEAPU8[$3 + 12 | 0] | HEAPU8[$3 + 13 | 0] << 8 | (HEAPU8[$3 + 14 | 0] << 16 | HEAPU8[$3 + 15 | 0] << 24);
        $0 = HEAPU8[$3 + 8 | 0] | HEAPU8[$3 + 9 | 0] << 8 | (HEAPU8[$3 + 10 | 0] << 16 | HEAPU8[$3 + 11 | 0] << 24);
        $5 = $0;
        $0 = $1;
        HEAP8[$0 + 8 | 0] = $5;
        HEAP8[$0 + 9 | 0] = $5 >>> 8;
        HEAP8[$0 + 10 | 0] = $5 >>> 16;
        HEAP8[$0 + 11 | 0] = $5 >>> 24;
        HEAP8[$0 + 12 | 0] = $4;
        HEAP8[$0 + 13 | 0] = $4 >>> 8;
        HEAP8[$0 + 14 | 0] = $4 >>> 16;
        HEAP8[$0 + 15 | 0] = $4 >>> 24;
        HEAP8[$2 + 3 | 0] = HEAPU8[$2 + 1 | 0];
        HEAP8[$2 + 1 | 0] = HEAPU8[$2 + 3 | 0] + 15 & 15;
        continue;
       }
       break;
      }
      HEAP8[366354] = HEAPU8[366354] + 1 & 15;
      jshInterruptOn();
      HEAP8[$2 + 15 | 0] = 1;
      break label$1;
     } else {
      HEAP8[$2 + 3 | 0] = HEAPU8[$2 + 3 | 0] + 15 & 15;
      continue;
     }
    }
    break;
   }
  }
  jshInterruptOn();
  HEAP8[$2 + 15 | 0] = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP8[$2 + 15 | 0] & 1;
}

function jswrap_typedarray_constructor($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 112 | 0;
 __stack_pointer = $4;
 HEAP8[$4 + 107 | 0] = $0;
 HEAP32[$4 + 100 >> 2] = $1;
 HEAP32[$4 + 96 >> 2] = $2;
 HEAP32[$4 + 92 >> 2] = $3;
 HEAP32[$4 + 88 >> 2] = 0;
 HEAP8[$4 + 87 | 0] = 0;
 label$1: {
  if (!(HEAP32[$4 + 96 >> 2] <= 65535 & HEAP32[$4 + 96 >> 2] >= 0)) {
   jsExceptionHere(1, 142998, 0);
   HEAP32[$4 + 108 >> 2] = 0;
   break label$1;
  }
  label$4: {
   if (!(!(jsvIsArrayBuffer(HEAP32[$4 + 100 >> 2]) & 1) | HEAPU8[HEAP32[$4 + 100 >> 2] + 5 | 0] != 129)) {
    HEAP32[$4 + 88 >> 2] = jsvLockAgain(HEAP32[$4 + 100 >> 2]);
    break label$4;
   }
   label$6: {
    if (jsvIsNumeric(HEAP32[$4 + 100 >> 2]) & 1) {
     HEAP32[$4 + 92 >> 2] = jsvGetInteger(HEAP32[$4 + 100 >> 2]);
     HEAP32[$4 + 96 >> 2] = 0;
     HEAP32[$4 + 88 >> 2] = jswrap_arraybuffer_constructor(Math_imul(HEAP32[$4 + 92 >> 2], HEAPU8[$4 + 107 | 0] & 15));
     break label$6;
    }
    label$8: {
     if (!(jsvIsArray(HEAP32[$4 + 100 >> 2]) & 1)) {
      if (!(jsvIsArrayBuffer(HEAP32[$4 + 100 >> 2]) & 1)) {
       break label$8;
      }
     }
     HEAP32[$4 + 92 >> 2] = jsvGetLength(HEAP32[$4 + 100 >> 2]);
     HEAP32[$4 + 96 >> 2] = 0;
     HEAP32[$4 + 88 >> 2] = jswrap_arraybuffer_constructor(Math_imul(HEAP32[$4 + 92 >> 2], HEAPU8[$4 + 107 | 0] & 15));
     HEAP8[$4 + 87 | 0] = 1;
    }
   }
  }
  if (!HEAP32[$4 + 88 >> 2]) {
   HEAP32[$4 >> 2] = HEAP32[$4 + 100 >> 2];
   jsExceptionHere(1, 119263, $4);
   HEAP32[$4 + 108 >> 2] = 0;
   break label$1;
  }
  if (!HEAP32[$4 + 92 >> 2]) {
   HEAP32[$4 + 92 >> 2] = (jsvGetArrayBufferLength(HEAP32[$4 + 88 >> 2]) - HEAP32[$4 + 96 >> 2] | 0) / (HEAPU8[$4 + 107 | 0] & 15);
   if (HEAP32[$4 + 92 >> 2] < 0) {
    HEAP32[$4 + 92 >> 2] = 0;
   }
  }
  HEAP32[$4 + 80 >> 2] = jsvNewWithFlags(4);
  if (HEAP32[$4 + 80 >> 2]) {
   HEAP8[HEAP32[$4 + 80 >> 2] + 5 | 0] = HEAPU8[$4 + 107 | 0];
   $0 = HEAP32[$4 + 80 >> 2];
   $1 = HEAP32[$4 + 96 >> 2];
   HEAP8[$0 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1 >>> 8;
   $0 = HEAP32[$4 + 80 >> 2];
   $1 = HEAP32[$4 + 92 >> 2];
   HEAP8[$0 + 2 | 0] = $1;
   HEAP8[$0 + 3 | 0] = $1 >>> 8;
   HEAP8[$0 + 4 | 0] = $1 >>> 16;
   jsvSetFirstChild(HEAP32[$4 + 80 >> 2], jsvGetRef(jsvRef(HEAP32[$4 + 88 >> 2])) & 65535);
   if (HEAP8[$4 + 87 | 0] & 1) {
    jsvIteratorNew($4 + 16 | 0, HEAP32[$4 + 100 >> 2], 0);
    while (1) {
     if (jsvIteratorHasElement($4 + 16 | 0) & 1) {
      HEAP32[$4 + 12 >> 2] = jsvIteratorGetKey($4 + 16 | 0);
      if (jsvIsInt(HEAP32[$4 + 12 >> 2]) & 1) {
       HEAP32[$4 + 8 >> 2] = jsvIteratorGetValue($4 + 16 | 0);
       jsvArrayBufferSet(HEAP32[$4 + 80 >> 2], jsvGetInteger(HEAP32[$4 + 12 >> 2]), HEAP32[$4 + 8 >> 2]);
       jsvUnLock(HEAP32[$4 + 8 >> 2]);
      }
      jsvUnLock(HEAP32[$4 + 12 >> 2]);
      jsvIteratorNext($4 + 16 | 0);
      continue;
     }
     break;
    }
    jsvIteratorFree($4 + 16 | 0);
   }
  }
  jsvUnLock(HEAP32[$4 + 88 >> 2]);
  HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 80 >> 2];
 }
 __stack_pointer = $4 + 112 | 0;
 return HEAP32[$4 + 108 >> 2];
}

function tflite__ops__micro__activations__SoftmaxQuantized_28TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20tflite__SoftmaxParams_20const__29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 160 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 156 >> 2] = $0;
 HEAP32[$3 + 152 >> 2] = $1;
 HEAP32[$3 + 148 >> 2] = $2;
 label$1: {
  if (HEAP32[HEAP32[$3 + 156 >> 2] + 8 >> 2] == 3) {
   $0 = HEAP32[$3 + 148 >> 2];
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3 + 120 | 0, HEAP32[$3 + 156 >> 2]);
   $1 = unsigned_20char_20const__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor_20const__29(HEAP32[$3 + 156 >> 2]);
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3 + 96 | 0, HEAP32[$3 + 152 >> 2]);
   void_20tflite__reference_ops__Softmax_unsigned_20char_2c_20unsigned_20char__28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $3 + 120 | 0, $1, $3 + 96 | 0, unsigned_20char__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor__29(HEAP32[$3 + 152 >> 2]));
   tflite__RuntimeShape___RuntimeShape_28_29($3 + 96 | 0);
   tflite__RuntimeShape___RuntimeShape_28_29($3 + 120 | 0);
   break label$1;
  }
  label$3: {
   if (HEAP32[HEAP32[$3 + 152 >> 2] + 8 >> 2] == 7) {
    $0 = HEAP32[$3 + 148 >> 2];
    tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3 + 72 | 0, HEAP32[$3 + 156 >> 2]);
    $1 = signed_20char_20const__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor_20const__29(HEAP32[$3 + 156 >> 2]);
    tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3 + 48 | 0, HEAP32[$3 + 152 >> 2]);
    void_20tflite__reference_ops__Softmax_signed_20char_2c_20short__28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20short__29($0, $3 + 72 | 0, $1, $3 + 48 | 0, short__20tflite__micro__GetTensorData_short__28TfLiteEvalTensor__29(HEAP32[$3 + 152 >> 2]));
    tflite__RuntimeShape___RuntimeShape_28_29($3 + 48 | 0);
    tflite__RuntimeShape___RuntimeShape_28_29($3 + 72 | 0);
    break label$3;
   }
   $0 = HEAP32[$3 + 148 >> 2];
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3 + 24 | 0, HEAP32[$3 + 156 >> 2]);
   $1 = signed_20char_20const__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor_20const__29(HEAP32[$3 + 156 >> 2]);
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3, HEAP32[$3 + 152 >> 2]);
   void_20tflite__reference_ops__Softmax_signed_20char_2c_20signed_20char__28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $3 + 24 | 0, $1, $3, signed_20char__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor__29(HEAP32[$3 + 152 >> 2]));
   tflite__RuntimeShape___RuntimeShape_28_29($3);
   tflite__RuntimeShape___RuntimeShape_28_29($3 + 24 | 0);
  }
 }
 __stack_pointer = $3 + 160 | 0;
}

function jslTokenAsString($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (!(HEAP32[$3 + 12 >> 2] <= 32 | HEAP32[$3 + 12 >> 2] >= 128)) {
   HEAP8[HEAP32[$3 + 8 >> 2]] = 39;
   HEAP8[HEAP32[$3 + 8 >> 2] + 1 | 0] = HEAP32[$3 + 12 >> 2];
   HEAP8[HEAP32[$3 + 8 >> 2] + 2 | 0] = 39;
   HEAP8[HEAP32[$3 + 8 >> 2] + 3 | 0] = 0;
   break label$1;
  }
  label$3: {
   label$4: {
    label$5: {
     label$6: {
      label$7: {
       label$8: {
        label$9: {
         label$10: {
          label$11: {
           label$12: {
            label$13: {
             label$14: {
              $0 = HEAP32[$3 + 12 >> 2];
              if ($0) {
               if (($0 | 0) == 128) {
                break label$14;
               }
               if (($0 | 0) == 129) {
                break label$13;
               }
               if (($0 | 0) == 130) {
                break label$12;
               }
               if (($0 | 0) == 131) {
                break label$11;
               }
               if (($0 | 0) == 132) {
                break label$10;
               }
               if (($0 | 0) == 133) {
                break label$9;
               }
               if (($0 | 0) == 134) {
                break label$8;
               }
               if (($0 | 0) == 135) {
                break label$7;
               }
               if (($0 | 0) == 136) {
                break label$6;
               }
               if (($0 | 0) == 137) {
                break label$5;
               }
               if (($0 | 0) == 255) {
                break label$4;
               }
               break label$3;
              }
              strcpy(HEAP32[$3 + 8 >> 2], 137666);
              break label$1;
             }
             strcpy(HEAP32[$3 + 8 >> 2], 138026);
             break label$1;
            }
            strcpy(HEAP32[$3 + 8 >> 2], 136635);
            break label$1;
           }
           strcpy(HEAP32[$3 + 8 >> 2], 136762);
           break label$1;
          }
          strcpy(HEAP32[$3 + 8 >> 2], 137627);
          break label$1;
         }
         strcpy(HEAP32[$3 + 8 >> 2], 137616);
         break label$1;
        }
        strcpy(HEAP32[$3 + 8 >> 2], 137409);
        break label$1;
       }
       strcpy(HEAP32[$3 + 8 >> 2], 137398);
       break label$1;
      }
      strcpy(HEAP32[$3 + 8 >> 2], 136460);
      break label$1;
     }
     strcpy(HEAP32[$3 + 8 >> 2], 136449);
     break label$1;
    }
    strcpy(HEAP32[$3 + 8 >> 2], 136639);
    break label$1;
   }
   strcpy(HEAP32[$3 + 8 >> 2], 136242);
   break label$1;
  }
  if (!(HEAP32[$3 + 12 >> 2] < 138 | HEAP32[$3 + 12 >> 2] > 208)) {
   strcpy(HEAP32[$3 + 8 >> 2], jslReservedWordAsString(HEAP32[$3 + 12 >> 2]));
   break label$1;
  }
  $0 = HEAP32[$3 + 8 >> 2];
  $1 = HEAP32[$3 + 4 >> 2];
  HEAP32[$3 >> 2] = HEAP32[$3 + 12 >> 2];
  espruino_snprintf($0, $1, 136219, $3);
 }
 __stack_pointer = $3 + 16 | 0;
}

function jsvFreePtr($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 if (!(jsvIsNameWithValue(HEAP32[$1 + 28 >> 2]) & 1)) {
  if (jsvHasSingleChild(HEAP32[$1 + 28 >> 2]) & 1) {
   if (jsvGetFirstChild(HEAP32[$1 + 28 >> 2]) & 65535) {
    if (jsuGetFreeStack() >>> 0 > 256) {
     HEAP32[$1 + 24 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$1 + 28 >> 2]) & 65535);
     jsvUnRef(HEAP32[$1 + 24 >> 2]);
     jsvUnLock(HEAP32[$1 + 24 >> 2]);
    }
   }
  }
 }
 label$5: {
  if (jsvIsUTF8String(HEAP32[$1 + 28 >> 2]) & 1) {
   jsvUnRefRef(jsvGetLastChild(HEAP32[$1 + 28 >> 2]) & 65535);
   jsvSetLastChild(HEAP32[$1 + 28 >> 2], 0);
   break label$5;
  }
  label$7: {
   if (jsvHasStringExt(HEAP32[$1 + 28 >> 2]) & 1) {
    jsvFreePtrStringExt(HEAP32[$1 + 28 >> 2]);
    break label$7;
   }
   if (jsvIsFlatString(HEAP32[$1 + 28 >> 2]) & 1) {
    HEAP32[$1 + 20 >> 2] = jsvGetFlatStringBlocks(HEAP32[$1 + 28 >> 2]);
    HEAP16[$1 + 18 >> 1] = (jsvGetRef(HEAP32[$1 + 28 >> 2]) & 65535) + HEAP32[$1 + 20 >> 2];
    jshInterruptOff();
    HEAP16[$1 + 16 >> 1] = HEAPU16[98162];
    HEAP16[$1 + 14 >> 1] = 0;
    while (1) {
     $0 = 0;
     $0 = HEAPU16[$1 + 16 >> 1] ? HEAPU16[$1 + 16 >> 1] < HEAPU16[$1 + 18 >> 1] : $0;
     if ($0) {
      HEAP16[$1 + 14 >> 1] = HEAPU16[$1 + 16 >> 1];
      HEAP16[$1 + 16 >> 1] = jsvGetNextSibling(jsvGetAddressOf(HEAPU16[$1 + 16 >> 1]));
      continue;
     }
     break;
    }
    while (1) {
     $0 = HEAP32[$1 + 20 >> 2];
     HEAP32[$1 + 20 >> 2] = $0 - 1;
     if ($0) {
      $0 = HEAPU16[$1 + 18 >> 1];
      HEAP16[$1 + 18 >> 1] = $0 - 1;
      HEAP32[$1 + 8 >> 2] = jsvGetAddressOf($0);
      $0 = HEAP32[$1 + 8 >> 2];
      HEAP8[$0 + 12 | 0] = 0;
      HEAP8[$0 + 13 | 0] = 0;
      jsvSetNextSibling(HEAP32[$1 + 8 >> 2], HEAPU16[$1 + 16 >> 1]);
      HEAP16[$1 + 16 >> 1] = jsvGetRef(HEAP32[$1 + 8 >> 2]);
      continue;
     }
     break;
    }
    label$15: {
     if (HEAPU16[$1 + 14 >> 1]) {
      jsvSetNextSibling(jsvGetAddressOf(HEAPU16[$1 + 14 >> 1]), HEAPU16[$1 + 16 >> 1]);
      break label$15;
     }
     HEAP16[98162] = HEAPU16[$1 + 16 >> 1];
    }
    HEAP8[196321] = 1;
    jshInterruptOn();
   }
  }
 }
 label$17: {
  if (jsvHasChildren(HEAP32[$1 + 28 >> 2]) & 1) {
   HEAP16[$1 + 6 >> 1] = jsvGetLastChild(HEAP32[$1 + 28 >> 2]);
   while (1) {
    if (HEAPU16[$1 + 6 >> 1]) {
     HEAP32[$1 >> 2] = jsvLock(HEAPU16[$1 + 6 >> 1]);
     HEAP16[$1 + 6 >> 1] = jsvGetPrevSibling(HEAP32[$1 >> 2]);
     jsvSetPrevSibling(HEAP32[$1 >> 2], 0);
     jsvSetNextSibling(HEAP32[$1 >> 2], 0);
     jsvUnRef(HEAP32[$1 >> 2]);
     jsvUnLock(HEAP32[$1 >> 2]);
     continue;
    }
    break;
   }
   break label$17;
  }
  if (jsvIsName(HEAP32[$1 + 28 >> 2]) & 1) {
   if (jsvGetNextSibling(HEAP32[$1 + 28 >> 2]) & 65535) {
    jsvUnRefRef(jsvGetNextSibling(HEAP32[$1 + 28 >> 2]) & 65535);
    jsvUnRefRef(jsvGetPrevSibling(HEAP32[$1 + 28 >> 2]) & 65535);
   }
  }
 }
 jsvFreePtrInternal(HEAP32[$1 + 28 >> 2]);
 __stack_pointer = $1 + 32 | 0;
}

function graphicsDrawChar4x6($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = __stack_pointer - 48 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 44 >> 2] = $0;
 HEAP32[$7 + 40 >> 2] = $1;
 HEAP32[$7 + 36 >> 2] = $2;
 HEAP8[$7 + 35 | 0] = $3;
 HEAP16[$7 + 32 >> 1] = $4;
 HEAP16[$7 + 30 >> 1] = $5;
 HEAP8[$7 + 29 | 0] = $6;
 HEAP32[$7 + 24 >> 2] = HEAPU8[$7 + 35 | 0] - 33;
 label$1: {
  if (!(HEAP32[$7 + 24 >> 2] < 100 & HEAP32[$7 + 24 >> 2] >= 0)) {
   if (HEAP8[$7 + 29 | 0] & 1) {
    $0 = HEAP32[$7 + 44 >> 2];
    graphicsFillRect(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2], HEAP32[$7 + 36 >> 2], HEAP32[$7 + 40 >> 2] + (HEAPU16[$7 + 32 >> 1] << 1) | 0, HEAP32[$7 + 36 >> 2] + Math_imul(HEAPU16[$7 + 30 >> 1], 5) | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
   }
   break label$1;
  }
  HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 24 >> 2] % 5;
  HEAP32[$7 + 24 >> 2] = Math_imul(HEAP32[$7 + 24 >> 2] / 5 | 0, 6);
  HEAP32[$7 + 16 >> 2] = 0;
  while (1) {
   if (HEAP32[$7 + 16 >> 2] < 6) {
    HEAP32[$7 + 12 >> 2] = HEAPU16[(HEAP32[$7 + 24 >> 2] + HEAP32[$7 + 16 >> 2] << 1) + 166448 >> 1] >> Math_imul(HEAP32[$7 + 20 >> 2], 3);
    HEAP32[$7 + 8 >> 2] = HEAP32[$7 + 36 >> 2] + Math_imul(HEAP32[$7 + 16 >> 2], HEAPU16[$7 + 30 >> 1]);
    HEAP32[$7 + 4 >> 2] = 0;
    while (1) {
     if (HEAP32[$7 + 4 >> 2] < 3) {
      HEAP8[$7 + 3 | 0] = (HEAP32[$7 + 12 >> 2] & 4) != 0;
      if (HEAP8[$7 + 3 | 0] & 1 ? 1 : HEAP8[$7 + 29 | 0] & 1) {
       $1 = HEAP32[$7 + 44 >> 2];
       $2 = HEAP32[$7 + 40 >> 2] + Math_imul(HEAP32[$7 + 4 >> 2], HEAPU16[$7 + 32 >> 1]) | 0;
       $3 = HEAP32[$7 + 8 >> 2];
       $4 = (HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], HEAP32[$7 + 4 >> 2] + 1 | 0) | 0) - 1 | 0;
       $5 = (HEAP32[$7 + 8 >> 2] + HEAPU16[$7 + 30 >> 1] | 0) - 1 | 0;
       label$11: {
        if (HEAP8[$7 + 3 | 0] & 1) {
         $0 = HEAP32[$7 + 44 >> 2];
         $0 = HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24);
         break label$11;
        }
        $0 = HEAP32[$7 + 44 >> 2];
        $0 = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
       }
       graphicsFillRect($1, $2, $3, $4, $5, $0);
      }
      HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 12 >> 2] << 1;
      HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] + 1;
      continue;
     }
     break;
    }
    HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] + 1;
    continue;
   }
   break;
  }
  if (!(HEAP8[$7 + 29 | 0] & 1)) {
   break label$1;
  }
  $0 = HEAP32[$7 + 44 >> 2];
  graphicsFillRect(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], 3) | 0, HEAP32[$7 + 36 >> 2], (HEAP32[$7 + 40 >> 2] + (HEAPU16[$7 + 32 >> 1] << 2) | 0) - 1 | 0, (HEAP32[$7 + 36 >> 2] + Math_imul(HEAPU16[$7 + 30 >> 1], 6) | 0) - 1 | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
 }
 __stack_pointer = $7 + 48 | 0;
}

function graphicsDrawChar6x8($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = __stack_pointer - 48 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 44 >> 2] = $0;
 HEAP32[$7 + 40 >> 2] = $1;
 HEAP32[$7 + 36 >> 2] = $2;
 HEAP8[$7 + 35 | 0] = $3;
 HEAP16[$7 + 32 >> 1] = $4;
 HEAP16[$7 + 30 >> 1] = $5;
 HEAP8[$7 + 29 | 0] = $6;
 HEAP32[$7 + 24 >> 2] = HEAPU8[$7 + 35 | 0] - 33;
 label$1: {
  if (!(HEAP32[$7 + 24 >> 2] < 223 & HEAP32[$7 + 24 >> 2] >= 0)) {
   if (HEAP8[$7 + 29 | 0] & 1) {
    $0 = HEAP32[$7 + 44 >> 2];
    graphicsFillRect(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2], HEAP32[$7 + 36 >> 2], HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], 5) | 0, HEAP32[$7 + 36 >> 2] + Math_imul(HEAPU16[$7 + 30 >> 1], 7) | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
   }
   break label$1;
  }
  HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 24 >> 2] % 6;
  HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 24 >> 2] / 6 << 3;
  HEAP32[$7 + 16 >> 2] = 0;
  while (1) {
   if (HEAP32[$7 + 16 >> 2] < 8) {
    HEAP32[$7 + 12 >> 2] = HEAP32[(HEAP32[$7 + 24 >> 2] + HEAP32[$7 + 16 >> 2] << 2) + 166688 >> 2] >>> Math_imul(HEAP32[$7 + 20 >> 2], 5);
    HEAP32[$7 + 8 >> 2] = HEAP32[$7 + 36 >> 2] + Math_imul(HEAP32[$7 + 16 >> 2], HEAPU16[$7 + 30 >> 1]);
    HEAP32[$7 + 4 >> 2] = 0;
    while (1) {
     if (HEAP32[$7 + 4 >> 2] < 5) {
      HEAP8[$7 + 3 | 0] = (HEAP32[$7 + 12 >> 2] & 16) != 0;
      if (HEAP8[$7 + 3 | 0] & 1 ? 1 : HEAP8[$7 + 29 | 0] & 1) {
       $1 = HEAP32[$7 + 44 >> 2];
       $2 = HEAP32[$7 + 40 >> 2] + Math_imul(HEAP32[$7 + 4 >> 2], HEAPU16[$7 + 32 >> 1]) | 0;
       $3 = HEAP32[$7 + 8 >> 2];
       $4 = (HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], HEAP32[$7 + 4 >> 2] + 1 | 0) | 0) - 1 | 0;
       $5 = (HEAP32[$7 + 8 >> 2] + HEAPU16[$7 + 30 >> 1] | 0) - 1 | 0;
       label$11: {
        if (HEAP8[$7 + 3 | 0] & 1) {
         $0 = HEAP32[$7 + 44 >> 2];
         $0 = HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24);
         break label$11;
        }
        $0 = HEAP32[$7 + 44 >> 2];
        $0 = HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
       }
       graphicsFillRect($1, $2, $3, $4, $5, $0);
      }
      HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 12 >> 2] << 1;
      HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] + 1;
      continue;
     }
     break;
    }
    HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] + 1;
    continue;
   }
   break;
  }
  if (!(HEAP8[$7 + 29 | 0] & 1)) {
   break label$1;
  }
  $0 = HEAP32[$7 + 44 >> 2];
  graphicsFillRect(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], 5) | 0, HEAP32[$7 + 36 >> 2], (HEAP32[$7 + 40 >> 2] + Math_imul(HEAPU16[$7 + 32 >> 1], 6) | 0) - 1 | 0, (HEAP32[$7 + 36 >> 2] + (HEAPU16[$7 + 30 >> 1] << 3) | 0) - 1 | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
 }
 __stack_pointer = $7 + 48 | 0;
}

function _jsvCountJsVarsUsedRecursive($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP8[$2 + 39 | 0] = $1;
 label$1: {
  if (!HEAP32[$2 + 40 >> 2]) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  label$3: {
   if (HEAP8[$2 + 39 | 0] & 1) {
    $0 = HEAP32[$2 + 40 >> 2];
    if (!((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 512)) {
     HEAP32[$2 + 44 >> 2] = 0;
     break label$1;
    }
    $0 = HEAP32[$2 + 40 >> 2];
    $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & -513;
    HEAP8[$0 + 12 | 0] = $1;
    HEAP8[$0 + 13 | 0] = $1 >>> 8;
    break label$3;
   }
   $0 = HEAP32[$2 + 40 >> 2];
   if ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 512) {
    HEAP32[$2 + 44 >> 2] = 0;
    break label$1;
   }
   $0 = HEAP32[$2 + 40 >> 2];
   $1 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8 | 512;
   HEAP8[$0 + 12 | 0] = $1;
   HEAP8[$0 + 13 | 0] = $1 >>> 8;
  }
  HEAP32[$2 + 32 >> 2] = 1;
  label$7: {
   label$8: {
    if (!(jsvHasSingleChild(HEAP32[$2 + 40 >> 2]) & 1)) {
     if (!(jsvHasChildren(HEAP32[$2 + 40 >> 2]) & 1)) {
      break label$8;
     }
    }
    HEAP16[$2 + 30 >> 1] = jsvGetFirstChild(HEAP32[$2 + 40 >> 2]);
    while (1) {
     if (HEAPU16[$2 + 30 >> 1]) {
      HEAP32[$2 + 24 >> 2] = jsvLock(HEAPU16[$2 + 30 >> 1]);
      HEAP32[$2 + 32 >> 2] = _jsvCountJsVarsUsedRecursive(HEAP32[$2 + 24 >> 2], HEAP8[$2 + 39 | 0] & 1) + HEAP32[$2 + 32 >> 2];
      label$12: {
       if (jsvHasChildren(HEAP32[$2 + 40 >> 2]) & 1) {
        HEAP16[$2 + 30 >> 1] = jsvGetNextSibling(HEAP32[$2 + 24 >> 2]);
        break label$12;
       }
       HEAP16[$2 + 30 >> 1] = 0;
      }
      jsvUnLock(HEAP32[$2 + 24 >> 2]);
      continue;
     }
     break;
    }
    break label$7;
   }
   if (jsvIsFlatString(HEAP32[$2 + 40 >> 2]) & 1) {
    HEAP32[$2 + 32 >> 2] = jsvGetFlatStringBlocks(HEAP32[$2 + 40 >> 2]) + HEAP32[$2 + 32 >> 2];
   }
  }
  if (jsvHasCharacterData(HEAP32[$2 + 40 >> 2]) & 1) {
   HEAP16[$2 + 22 >> 1] = jsvGetLastChild(HEAP32[$2 + 40 >> 2]);
   while (1) {
    if (HEAPU16[$2 + 22 >> 1]) {
     HEAP32[$2 + 16 >> 2] = jsvLock(HEAPU16[$2 + 22 >> 1]);
     HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 32 >> 2] + 1;
     HEAP16[$2 + 22 >> 1] = jsvGetLastChild(HEAP32[$2 + 16 >> 2]);
     jsvUnLock(HEAP32[$2 + 16 >> 2]);
     continue;
    }
    break;
   }
  }
  label$18: {
   if (!(jsvIsName(HEAP32[$2 + 40 >> 2]) & 1)) {
    break label$18;
   }
   if (jsvIsNameWithValue(HEAP32[$2 + 40 >> 2]) & 1) {
    break label$18;
   }
   if (!(jsvGetFirstChild(HEAP32[$2 + 40 >> 2]) & 65535)) {
    break label$18;
   }
   HEAP32[$2 + 12 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 40 >> 2]) & 65535);
   HEAP32[$2 + 32 >> 2] = _jsvCountJsVarsUsedRecursive(HEAP32[$2 + 12 >> 2], HEAP8[$2 + 39 | 0] & 1) + HEAP32[$2 + 32 >> 2];
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
  }
  HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function jswrap_regexp_exec($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $3 = __stack_pointer + -64 | 0;
 $2 = $3;
 __stack_pointer = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP32[$2 + 52 >> 2] = $1;
 HEAP32[$2 + 48 >> 2] = jsvAsString(HEAP32[$2 + 52 >> 2]);
 HEAP32[$2 + 44 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 56 >> 2], 116445);
 HEAP32[$2 + 40 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 56 >> 2], 129340);
 label$1: {
  if (HEAP32[$2 + 40 >> 2]) {
   HEAP32[$2 + 36 >> 2] = jsvGetStringLength(HEAP32[$2 + 52 >> 2]) - jsvGetStringLength(HEAP32[$2 + 40 >> 2]);
   label$3: {
    if (HEAP32[$2 + 44 >> 2] > HEAP32[$2 + 36 >> 2]) {
     break label$3;
    }
    if (jsvCompareString(HEAP32[$2 + 52 >> 2], HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 0, 1)) {
     break label$3;
    }
    HEAP32[$2 + 32 >> 2] = jsvNewEmptyArray();
    jsvSetArrayItem(HEAP32[$2 + 32 >> 2], 0, HEAP32[$2 + 40 >> 2]);
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 32 >> 2], 116439, jsvNewFromInteger(HEAP32[$2 + 36 >> 2]));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 32 >> 2], 117136, HEAP32[$2 + 48 >> 2]);
    jsvUnLock(HEAP32[$2 + 40 >> 2]);
    HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 32 >> 2];
    break label$1;
   }
   jsvUnLock(HEAP32[$2 + 40 >> 2]);
  }
  HEAP32[$2 + 28 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 56 >> 2], 132796);
  label$4: {
   if (jsvIsString(HEAP32[$2 + 28 >> 2]) & 1) {
    if (HEAP32[$2 + 44 >> 2] <= (jsvGetStringLength(HEAP32[$2 + 48 >> 2]) | 0)) {
     break label$4;
    }
   }
   jsvUnLock2(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 28 >> 2]);
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 24 >> 2] = jsvGetStringLength(HEAP32[$2 + 28 >> 2]);
  $3 = $3 - (HEAP32[$2 + 24 >> 2] + 16 & -16) | 0;
  __stack_pointer = $3;
  HEAP32[$2 + 20 >> 2] = $3;
  if (!HEAP32[$2 + 20 >> 2]) {
   jsvUnLock2(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 28 >> 2]);
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  jsvGetString(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 24 >> 2] + 1 | 0);
  jsvUnLock(HEAP32[$2 + 28 >> 2]);
  HEAP32[$2 + 16 >> 2] = match(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 48 >> 2], HEAP32[$2 + 44 >> 2], jswrap_regexp_hasFlag(HEAP32[$2 + 56 >> 2], 105) & 1);
  jsvUnLock(HEAP32[$2 + 48 >> 2]);
  label$7: {
   if (!HEAP32[$2 + 16 >> 2]) {
    HEAP32[$2 + 16 >> 2] = jsvNewWithFlags(2);
    HEAP32[$2 + 44 >> 2] = 0;
    break label$7;
   }
   label$9: {
    if (jswrap_regexp_hasFlag(HEAP32[$2 + 56 >> 2], 103) & 1) {
     HEAP32[$2 + 12 >> 2] = jsvGetArrayItem(HEAP32[$2 + 16 >> 2], 0);
     HEAP32[$2 + 44 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 16 >> 2], 116439) + jsvGetStringLength(HEAP32[$2 + 12 >> 2]);
     jsvUnLock(HEAP32[$2 + 12 >> 2]);
     break label$9;
    }
    HEAP32[$2 + 44 >> 2] = 0;
   }
  }
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 56 >> 2], 116445, jsvNewFromInteger(HEAP32[$2 + 44 >> 2]));
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 16 >> 2];
 }
 __stack_pointer = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}

function tflite__reference_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = Math_fround(0);
 $9 = __stack_pointer - 96 | 0;
 __stack_pointer = $9;
 HEAP32[$9 + 92 >> 2] = $0;
 HEAP32[$9 + 88 >> 2] = $1;
 HEAP32[$9 + 84 >> 2] = $2;
 HEAP32[$9 + 80 >> 2] = $3;
 HEAP32[$9 + 76 >> 2] = $4;
 HEAP32[$9 + 72 >> 2] = $5;
 HEAP32[$9 + 68 >> 2] = $6;
 HEAP32[$9 + 64 >> 2] = $7;
 HEAP32[$9 + 60 >> 2] = $8;
 HEAPF32[$9 + 56 >> 2] = HEAPF32[HEAP32[$9 + 92 >> 2] + 28 >> 2];
 HEAPF32[$9 + 52 >> 2] = HEAPF32[HEAP32[$9 + 92 >> 2] + 32 >> 2];
 HEAP32[$9 + 48 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 64 >> 2]);
 HEAP32[$9 + 44 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$9 + 80 >> 2]);
 HEAP32[$9 + 40 >> 2] = tflite__FlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 64 >> 2], HEAP32[$9 + 48 >> 2] - 1 | 0);
 HEAP32[$9 + 36 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$9 + 80 >> 2], HEAP32[$9 + 44 >> 2] - 2 | 0, HEAP32[$9 + 64 >> 2], HEAP32[$9 + 48 >> 2] - 1 | 0);
 HEAP32[$9 + 32 >> 2] = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$9 + 80 >> 2], HEAP32[$9 + 44 >> 2] - 1 | 0);
 HEAP32[$9 + 28 >> 2] = 0;
 while (1) {
  if (HEAP32[$9 + 28 >> 2] < HEAP32[$9 + 40 >> 2]) {
   HEAP32[$9 + 24 >> 2] = 0;
   while (1) {
    if (HEAP32[$9 + 24 >> 2] < HEAP32[$9 + 36 >> 2]) {
     HEAPF32[$9 + 20 >> 2] = 0;
     HEAP32[$9 + 16 >> 2] = 0;
     while (1) {
      if (HEAP32[$9 + 16 >> 2] < HEAP32[$9 + 32 >> 2]) {
       HEAPF32[$9 + 20 >> 2] = Math_fround(HEAPF32[HEAP32[$9 + 84 >> 2] + (HEAP32[$9 + 16 >> 2] + Math_imul(HEAP32[$9 + 28 >> 2], HEAP32[$9 + 32 >> 2]) << 2) >> 2] * HEAPF32[HEAP32[$9 + 76 >> 2] + (HEAP32[$9 + 16 >> 2] + Math_imul(HEAP32[$9 + 24 >> 2], HEAP32[$9 + 32 >> 2]) << 2) >> 2]) + HEAPF32[$9 + 20 >> 2];
       HEAP32[$9 + 16 >> 2] = HEAP32[$9 + 16 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAPF32[$9 + 12 >> 2] = 0;
     if (HEAP32[$9 + 68 >> 2]) {
      HEAPF32[$9 + 12 >> 2] = HEAPF32[HEAP32[$9 + 68 >> 2] + (HEAP32[$9 + 24 >> 2] << 2) >> 2];
     }
     $10 = float_20tflite__ActivationFunctionWithMinMax_float__28float_2c_20float_2c_20float_29(Math_fround(HEAPF32[$9 + 20 >> 2] + HEAPF32[$9 + 12 >> 2]), HEAPF32[$9 + 56 >> 2], HEAPF32[$9 + 52 >> 2]);
     HEAPF32[HEAP32[$9 + 60 >> 2] + (HEAP32[$9 + 24 >> 2] + Math_imul(HEAP32[$9 + 36 >> 2], HEAP32[$9 + 28 >> 2]) << 2) >> 2] = $10;
     HEAP32[$9 + 24 >> 2] = HEAP32[$9 + 24 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$9 + 28 >> 2] = HEAP32[$9 + 28 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $9 + 96 | 0;
}

function tflite__ops__micro__conv__EvalQuantizedPerChannel_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteConvParams__2c_20tflite__ops__micro__conv__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0;
 $9 = __stack_pointer - 192 | 0;
 __stack_pointer = $9;
 HEAP32[$9 + 188 >> 2] = $0;
 HEAP32[$9 + 184 >> 2] = $1;
 HEAP32[$9 + 180 >> 2] = $2;
 HEAP32[$9 + 176 >> 2] = $3;
 HEAP32[$9 + 172 >> 2] = $4;
 HEAP32[$9 + 168 >> 2] = $5;
 HEAP32[$9 + 164 >> 2] = $6;
 HEAP32[$9 + 160 >> 2] = $7;
 HEAP32[$9 + 156 >> 2] = $8;
 HEAP32[$9 + 116 >> 2] = 0 - HEAP32[HEAP32[$9 + 176 >> 2] + 16 >> 2];
 HEAP32[$9 + 124 >> 2] = HEAP32[HEAP32[$9 + 176 >> 2] + 24 >> 2];
 HEAP16[$9 + 108 >> 1] = HEAP32[HEAP32[$9 + 180 >> 2] + 8 >> 2];
 HEAP16[$9 + 106 >> 1] = HEAP32[HEAP32[$9 + 180 >> 2] + 4 >> 2];
 HEAP16[$9 + 112 >> 1] = HEAP32[HEAP32[$9 + 180 >> 2] + 20 >> 2];
 HEAP16[$9 + 110 >> 1] = HEAP32[HEAP32[$9 + 180 >> 2] + 16 >> 2];
 HEAP16[$9 + 100 >> 1] = HEAP32[HEAP32[$9 + 176 >> 2] + 4 >> 2];
 HEAP16[$9 + 98 >> 1] = HEAP32[HEAP32[$9 + 176 >> 2] >> 2];
 HEAP32[$9 + 136 >> 2] = HEAP32[HEAP32[$9 + 176 >> 2] + 44 >> 2];
 HEAP32[$9 + 140 >> 2] = HEAP32[HEAP32[$9 + 176 >> 2] + 48 >> 2];
 $0 = HEAP32[HEAP32[$9 + 176 >> 2] + 36 >> 2];
 $1 = HEAP32[HEAP32[$9 + 176 >> 2] + 40 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($9 + 72 | 0, HEAP32[$9 + 172 >> 2]);
 $2 = signed_20char_20const__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor_20const__29(HEAP32[$9 + 172 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($9 + 48 | 0, HEAP32[$9 + 168 >> 2]);
 $3 = signed_20char_20const__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor_20const__29(HEAP32[$9 + 168 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($9 + 24 | 0, HEAP32[$9 + 164 >> 2]);
 $4 = int_20const__20tflite__micro__GetTensorData_int__28TfLiteEvalTensor_20const__29(HEAP32[$9 + 164 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($9, HEAP32[$9 + 160 >> 2]);
 tflite__reference_integer_ops__ConvPerChannel_28tflite__ConvParams_20const__2c_20int_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($9 + 96 | 0, $0, $1, $9 + 72 | 0, $2, $9 + 48 | 0, $3, $9 + 24 | 0, $4, $9, signed_20char__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor__29(HEAP32[$9 + 160 >> 2]));
 tflite__RuntimeShape___RuntimeShape_28_29($9);
 tflite__RuntimeShape___RuntimeShape_28_29($9 + 24 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($9 + 48 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($9 + 72 | 0);
 __stack_pointer = $9 + 192 | 0;
}

function tflite__ops__micro__dequantize__Prepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 96 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP32[$2 + 84 >> 2] = $1;
 label$1: {
  if (!HEAP32[HEAP32[$2 + 84 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 80 >> 2] = HEAP32[HEAP32[$2 + 84 >> 2] + 8 >> 2];
 label$2: {
  if ((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 84 >> 2]) | 0) != 1) {
   $0 = HEAP32[HEAP32[$2 + 88 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 88 >> 2];
   $3 = tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 84 >> 2]);
   HEAP32[$2 + 12 >> 2] = 1;
   HEAP32[$2 + 8 >> 2] = $3;
   HEAP32[$2 + 4 >> 2] = 139997;
   HEAP32[$2 >> 2] = 143050;
   FUNCTION_TABLE[$0 | 0]($1, 143305, $2);
   HEAP32[$2 + 92 >> 2] = 1;
   break label$2;
  }
  if ((tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 84 >> 2]) | 0) != 1) {
   $0 = HEAP32[HEAP32[$2 + 88 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 88 >> 2];
   $3 = tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 84 >> 2]);
   HEAP32[$2 + 28 >> 2] = 1;
   HEAP32[$2 + 24 >> 2] = $3;
   HEAP32[$2 + 20 >> 2] = 139997;
   HEAP32[$2 + 16 >> 2] = 143033;
   FUNCTION_TABLE[$0 | 0]($1, 143305, $2 + 16 | 0);
   HEAP32[$2 + 92 >> 2] = 1;
   break label$2;
  }
  HEAP32[$2 + 76 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 88 >> 2], HEAP32[$2 + 84 >> 2], 0);
  HEAP32[$2 + 72 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 88 >> 2], HEAP32[$2 + 84 >> 2], 0);
  if (!(HEAP32[HEAP32[$2 + 76 >> 2] + 28 >> 2] == 3 | HEAP32[HEAP32[$2 + 76 >> 2] + 28 >> 2] == 9 | HEAP32[HEAP32[$2 + 76 >> 2] + 28 >> 2] == 7)) {
   $0 = HEAP32[HEAP32[$2 + 88 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 88 >> 2];
   HEAP32[$2 + 48 >> 2] = 139310;
   FUNCTION_TABLE[$0 | 0]($1, 140586, $2 + 48 | 0);
   HEAP32[$2 + 92 >> 2] = 1;
   break label$2;
  }
  if (!(HEAP32[HEAP32[$2 + 72 >> 2] + 28 >> 2] == 1 | HEAP32[HEAP32[$2 + 72 >> 2] + 28 >> 2] == 2)) {
   $0 = HEAP32[HEAP32[$2 + 88 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 88 >> 2];
   HEAP32[$2 + 32 >> 2] = 139647;
   FUNCTION_TABLE[$0 | 0]($1, 140586, $2 + 32 | 0);
   HEAP32[$2 + 92 >> 2] = 1;
   break label$2;
  }
  if (HEAP32[HEAP32[$2 + 72 >> 2] + 28 >> 2] == 2) {
   HEAPF64[$2 + 64 >> 3] = +HEAPF32[HEAP32[$2 + 76 >> 2] + 8 >> 2] / +HEAPF32[HEAP32[$2 + 72 >> 2] + 8 >> 2];
   tflite__QuantizeMultiplier_28double_2c_20int__2c_20int__29(HEAPF64[$2 + 64 >> 3], HEAP32[$2 + 80 >> 2] + 16 | 0, HEAP32[$2 + 80 >> 2] + 20 | 0);
  }
  HEAP32[HEAP32[$2 + 80 >> 2] + 8 >> 2] = HEAP32[HEAP32[$2 + 76 >> 2] + 12 >> 2];
  HEAPF64[HEAP32[$2 + 80 >> 2] >> 3] = HEAPF32[HEAP32[$2 + 76 >> 2] + 8 >> 2];
  HEAP32[HEAP32[$2 + 80 >> 2] + 24 >> 2] = HEAP32[HEAP32[$2 + 72 >> 2] + 12 >> 2];
  HEAP32[$2 + 92 >> 2] = 0;
 }
 __stack_pointer = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}

function atan2($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $2 = __DOUBLE_BITS_13($1);
 $4 = $2;
 $3 = i64toi32_i32$HIGH_BITS;
 $2 = $3 & 2147483647;
 $3 = $4;
 label$1: {
  if (!$3 & ($2 | 0) == 2146435072 | $2 >>> 0 < 2146435072) {
   $3 = __DOUBLE_BITS_13($0);
   $5 = $3;
   $2 = i64toi32_i32$HIGH_BITS;
   $3 = $2 & 2147483647;
   $2 = $5;
   if (!$2 & ($3 | 0) == 2146435072 | $3 >>> 0 < 2146435072) {
    break label$1;
   }
  }
  return $0 + $1;
 }
 wasm2js_scratch_store_f64(+$1);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 $5 = wasm2js_scratch_load_i32(0) | 0;
 $4 = $5;
 $6 = $2;
 $10 = $4;
 if (!($4 | $2 - 1072693248)) {
  return atan($0);
 }
 wasm2js_scratch_store_f64(+$0);
 $3 = wasm2js_scratch_load_i32(1) | 0;
 $5 = wasm2js_scratch_load_i32(0) | 0;
 $9 = $6 >>> 30 & 2;
 $7 = $9 | $3 >>> 31;
 $4 = $3;
 $3 = $5;
 $2 = $4;
 $4 = $2 & 2147483647;
 label$4: {
  if (!($3 | $4)) {
   label$6: {
    switch ($7 - 2 | 0) {
    case 0:
     return 3.141592653589793;

    case 1:
     break label$6;

    default:
     break label$4;
    }
   }
   return -3.141592653589793;
  }
  $6 = $6 & 2147483647;
  if (!($10 | $6)) {
   wasm2js_scratch_store_f64(1.5707963267948966);
   $2 = wasm2js_scratch_load_i32(1) | 0;
   $4 = wasm2js_scratch_load_i32(0) | 0;
   $5 = $4;
   $3 = $2 & 2147483647;
   $6 = $3;
   wasm2js_scratch_store_f64(+$0);
   $3 = wasm2js_scratch_load_i32(1) | 0;
   wasm2js_scratch_load_i32(0) | 0;
   $4 = $3 & -2147483648;
   $3 = $5;
   $5 = $11;
   wasm2js_scratch_store_i32(0, $3 | $5);
   $2 = $4;
   $4 = $6;
   $2 = $2 | $4;
   wasm2js_scratch_store_i32(1, $2 | 0);
   return +wasm2js_scratch_load_f64();
  }
  label$9: {
   if (($6 | 0) == 2146435072) {
    if (($4 | 0) != 2146435072) {
     break label$9;
    }
    return HEAPF64[($7 << 3) + 190240 >> 3];
   }
   if (!(($4 | 0) != 2146435072 & $6 + 67108864 >>> 0 >= $4 >>> 0)) {
    wasm2js_scratch_store_f64(1.5707963267948966);
    $2 = wasm2js_scratch_load_i32(1) | 0;
    $4 = wasm2js_scratch_load_i32(0) | 0;
    $5 = $4;
    $3 = $2 & 2147483647;
    $6 = $3;
    wasm2js_scratch_store_f64(+$0);
    $3 = wasm2js_scratch_load_i32(1) | 0;
    wasm2js_scratch_load_i32(0) | 0;
    $4 = $3 & -2147483648;
    $3 = $5;
    $5 = $11;
    wasm2js_scratch_store_i32(0, $3 | $5);
    $2 = $4;
    $4 = $6;
    $2 = $2 | $4;
    wasm2js_scratch_store_i32(1, $2 | 0);
    return +wasm2js_scratch_load_f64();
   }
   label$12: {
    if ($9) {
     $8 = 0;
     if ($4 + 67108864 >>> 0 < $6 >>> 0) {
      break label$12;
     }
    }
    $8 = atan(fabs($0 / $1));
   }
   $0 = $8;
   label$14: {
    switch ($7 | 0) {
    case 1:
     return -$0;

    case 2:
     return 3.141592653589793 - ($0 + -12246467991473532e-32);

    case 0:
     break label$4;

    default:
     break label$14;
    }
   }
   return $0 + -12246467991473532e-32 + -3.141592653589793;
  }
  $0 = HEAPF64[($7 << 3) + 190272 >> 3];
 }
 return $0;
}

function jswrap_arraybufferview_set($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 176 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 172 >> 2] = $0;
 HEAP32[$3 + 168 >> 2] = $1;
 HEAP32[$3 + 164 >> 2] = $2;
 label$1: {
  label$2: {
   if (jsvIsString(HEAP32[$3 + 168 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsArray(HEAP32[$3 + 168 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsArrayBuffer(HEAP32[$3 + 168 >> 2]) & 1) {
    break label$2;
   }
   HEAP32[$3 >> 2] = HEAP32[$3 + 168 >> 2];
   jsExceptionHere(1, 117955, $3);
   break label$1;
  }
  label$3: {
   if (!(jsvIsArrayBuffer(HEAP32[$3 + 172 >> 2]) & 1)) {
    break label$3;
   }
   if (!(jsvIsArrayBuffer(HEAP32[$3 + 168 >> 2]) & 1)) {
    break label$3;
   }
   HEAP32[$3 + 160 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$3 + 172 >> 2], 0);
   HEAP32[$3 + 156 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$3 + 168 >> 2], 0);
   if (HEAP32[$3 + 160 >> 2] == HEAP32[$3 + 156 >> 2]) {
    $0 = HEAP32[$3 + 172 >> 2];
    $1 = HEAP32[$3 + 168 >> 2];
    $4 = (Math_imul(HEAP32[$3 + 164 >> 2], HEAPU8[HEAP32[$3 + 172 >> 2] + 5 | 0] & 15) + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8) | 0) >= (HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8);
   }
   HEAP8[$3 + 155 | 0] = $4;
   jsvUnLock2(HEAP32[$3 + 160 >> 2], HEAP32[$3 + 156 >> 2]);
   if (HEAP8[$3 + 155 | 0] & 1) {
    HEAP32[$3 + 148 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 168 >> 2]);
    HEAP32[$3 + 144 >> 2] = HEAP32[$3 + 148 >> 2] - 1;
    while (1) {
     if (HEAP32[$3 + 144 >> 2] >= 0) {
      HEAP32[$3 + 140 >> 2] = jsvArrayBufferGet(HEAP32[$3 + 168 >> 2], HEAP32[$3 + 144 >> 2]);
      jsvArrayBufferSet(HEAP32[$3 + 172 >> 2], HEAP32[$3 + 164 >> 2] + HEAP32[$3 + 144 >> 2] | 0, HEAP32[$3 + 140 >> 2]);
      jsvUnLock(HEAP32[$3 + 140 >> 2]);
      HEAP32[$3 + 144 >> 2] = HEAP32[$3 + 144 >> 2] - 1;
      continue;
     }
     break;
    }
    break label$1;
   }
  }
  jsvIteratorNew($3 + 80 | 0, HEAP32[$3 + 168 >> 2], 1);
  jsvArrayBufferIteratorNew($3 + 24 | 0, HEAP32[$3 + 172 >> 2], HEAP32[$3 + 164 >> 2]);
  $0 = 1;
  if (HEAPU8[$3 + 60 | 0] & 32) {
   $0 = jsvIsString(HEAP32[$3 + 168 >> 2]);
  }
  HEAP8[$3 + 23 | 0] = $0 & 1;
  while (1) {
   $0 = 0;
   if (jsvIteratorHasElement($3 + 80 | 0) & 1) {
    $0 = jsvArrayBufferIteratorHasElement($3 + 24 | 0);
   }
   if ($0 & 1) {
    label$12: {
     if (HEAP8[$3 + 23 | 0] & 1) {
      jsvArrayBufferIteratorSetIntegerValue($3 + 24 | 0, jsvIteratorGetIntegerValue($3 + 80 | 0));
      break label$12;
     }
     HEAP32[$3 + 16 >> 2] = jsvIteratorGetValue($3 + 80 | 0);
     jsvArrayBufferIteratorSetValue($3 + 24 | 0, HEAP32[$3 + 16 >> 2], 0);
     jsvUnLock(HEAP32[$3 + 16 >> 2]);
    }
    jsvArrayBufferIteratorNext($3 + 24 | 0);
    jsvIteratorNext($3 + 80 | 0);
    continue;
   }
   break;
  }
  jsvArrayBufferIteratorFree($3 + 24 | 0);
  jsvIteratorFree($3 + 80 | 0);
 }
 __stack_pointer = $3 + 176 | 0;
}

function jsdGetEffectiveTimeZone($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 176 | 0;
 __stack_pointer = $3;
 HEAPF64[$3 + 160 >> 3] = $0;
 HEAP8[$3 + 159 | 0] = $1;
 HEAP32[$3 + 152 >> 2] = $2;
 HEAP32[$3 + 148 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 117339);
 label$1: {
  label$2: {
   label$3: {
    if (!HEAP32[$3 + 148 >> 2]) {
     break label$3;
    }
    if (!(jsvIsArrayBuffer(HEAP32[$3 + 148 >> 2]) & 1)) {
     break label$3;
    }
    if ((jsvGetLength(HEAP32[$3 + 148 >> 2]) | 0) != 12 | HEAPU8[HEAP32[$3 + 148 >> 2] + 5 | 0] != 18) {
     break label$3;
    }
    jsvArrayBufferIteratorNew($3 + 40 | 0, HEAP32[$3 + 148 >> 2], 0);
    HEAP32[$3 + 144 >> 2] = 0;
    while (1) {
     if (HEAP32[$3 + 144 >> 2] < 12) {
      $2 = jsvArrayBufferIteratorGetIntegerValue($3 + 40 | 0);
      $1 = HEAP32[$3 + 144 >> 2];
      HEAP32[$3 + 144 >> 2] = $1 + 1;
      HEAP32[($3 + 96 | 0) + ($1 << 2) >> 2] = $2;
      jsvArrayBufferIteratorNext($3 + 40 | 0);
      continue;
     }
     break;
    }
    jsvArrayBufferIteratorFree($3 + 40 | 0);
    jsvUnLock(HEAP32[$3 + 148 >> 2]);
    if (HEAP32[$3 + 96 >> 2]) {
     HEAPF64[$3 + 32 >> 3] = HEAPF64[$3 + 160 >> 3] / 1e3;
     $0 = HEAPF64[$3 + 32 >> 3] / 86400;
     label$7: {
      if (Math_abs($0) < 2147483648) {
       $1 = ~~$0;
       break label$7;
      }
      $1 = -2147483648;
     }
     getDateFromDayNumber($1, $3 + 144 | 0, 0, 0);
     HEAPF64[$3 + 24 >> 3] = getDstChangeTime(HEAP32[$3 + 144 >> 2], HEAP32[$3 + 104 >> 2], HEAP32[$3 + 108 >> 2], HEAP32[$3 + 112 >> 2], HEAP32[$3 + 116 >> 2], HEAP32[$3 + 120 >> 2], 1, HEAP32[$3 + 96 >> 2], HEAP32[$3 + 100 >> 2], HEAP8[$3 + 159 | 0] & 1);
     HEAPF64[$3 + 16 >> 3] = getDstChangeTime(HEAP32[$3 + 144 >> 2], HEAP32[$3 + 124 >> 2], HEAP32[$3 + 128 >> 2], HEAP32[$3 + 132 >> 2], HEAP32[$3 + 136 >> 2], HEAP32[$3 + 140 >> 2], 0, HEAP32[$3 + 96 >> 2], HEAP32[$3 + 100 >> 2], HEAP8[$3 + 159 | 0] & 1);
     label$9: {
      if (HEAPF64[$3 + 24 >> 3] < HEAPF64[$3 + 16 >> 3]) {
       $4 = HEAPF64[$3 + 32 >> 3] >= HEAPF64[$3 + 24 >> 3] ? HEAPF64[$3 + 32 >> 3] < HEAPF64[$3 + 16 >> 3] : $4;
       HEAP8[$3 + 15 | 0] = $4;
       break label$9;
      }
      $1 = 1;
      $1 = HEAPF64[$3 + 32 >> 3] < HEAPF64[$3 + 16 >> 3] ? $1 : HEAPF64[$3 + 32 >> 3] >= HEAPF64[$3 + 24 >> 3];
      HEAP8[$3 + 15 | 0] = $1;
     }
     if (HEAP32[$3 + 152 >> 2]) {
      HEAP8[HEAP32[$3 + 152 >> 2]] = HEAP8[$3 + 15 | 0] & 1;
     }
     if (HEAP8[$3 + 15 | 0] & 1) {
      $1 = HEAP32[$3 + 96 >> 2] + HEAP32[$3 + 100 >> 2] | 0;
     } else {
      $1 = HEAP32[$3 + 100 >> 2];
     }
     HEAP32[$3 + 172 >> 2] = $1;
     break label$1;
    }
    break label$2;
   }
   jsvUnLock(HEAP32[$3 + 148 >> 2]);
  }
  if (HEAP32[$3 + 152 >> 2]) {
   HEAP8[HEAP32[$3 + 152 >> 2]] = 0;
  }
  HEAP32[$3 + 172 >> 2] = jsvObjectGetIntegerChild(HEAP32[91087], 116073);
 }
 __stack_pointer = $3 + 176 | 0;
 return HEAP32[$3 + 172 >> 2];
}

function jswrap_string_removeAccents($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 112 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 104 >> 2] = $0;
 HEAP32[$1 + 96 >> 2] = jsvNewFromEmptyString_8();
 label$1: {
  if (!HEAP32[$1 + 96 >> 2]) {
   HEAP32[$1 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 92 >> 2] = jsvAsString(HEAP32[$1 + 104 >> 2]);
  jsvStringIteratorNew($1 + 56 | 0, HEAP32[$1 + 92 >> 2], 0);
  jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 96 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar_8($1 + 56 | 0) & 1) {
    HEAP8[$1 + 15 | 0] = jsvStringIteratorGetCharAndNext($1 + 56 | 0);
    label$5: {
     if (HEAPU8[$1 + 15 | 0] >= 224) {
      HEAP8[$1 + 103 | 0] = 1;
      HEAP8[$1 + 15 | 0] = HEAPU8[$1 + 15 | 0] - 32;
      break label$5;
     }
     HEAP8[$1 + 103 | 0] = 0;
    }
    if (HEAPU8[$1 + 15 | 0] >= 192) {
     label$8: {
      label$9: {
       switch (HEAPU8[$1 + 15 | 0] - 192 | 0) {
       case 0:
       case 1:
       case 2:
       case 3:
       case 4:
       case 5:
        HEAP8[$1 + 15 | 0] = 65;
        break label$8;

       case 6:
        jsvStringIteratorAppend($1 + 16 | 0, (HEAP8[$1 + 103 | 0] & 1 ? 97 : 65) << 24 >> 24);
        HEAP8[$1 + 15 | 0] = 69;
        break label$8;

       case 7:
        HEAP8[$1 + 15 | 0] = 67;
        break label$8;

       case 8:
       case 9:
       case 10:
       case 11:
        HEAP8[$1 + 15 | 0] = 69;
        break label$8;

       case 12:
       case 13:
       case 14:
       case 15:
        HEAP8[$1 + 15 | 0] = 73;
        break label$8;

       case 16:
        HEAP8[$1 + 15 | 0] = 68;
        break label$8;

       case 17:
        HEAP8[$1 + 15 | 0] = 78;
        break label$8;

       case 18:
       case 19:
       case 20:
       case 21:
       case 22:
       case 24:
        HEAP8[$1 + 15 | 0] = 79;
        break label$8;

       case 25:
       case 26:
       case 27:
       case 28:
        HEAP8[$1 + 15 | 0] = 85;
        break label$8;

       case 29:
        HEAP8[$1 + 15 | 0] = 89;
        break label$8;

       case 30:
        HEAP8[$1 + 15 | 0] = 80;
        break label$8;

       case 31:
        break label$9;

       default:
        break label$8;
       }
      }
      label$21: {
       if (HEAP8[$1 + 103 | 0] & 1) {
        HEAP8[$1 + 15 | 0] = 89;
        break label$21;
       }
       jsvStringIteratorAppend($1 + 16 | 0, 83);
       HEAP8[$1 + 15 | 0] = 83;
      }
     }
    }
    $2 = $1 + 16 | 0;
    if (HEAP8[$1 + 103 | 0] & 1) {
     $0 = HEAPU8[$1 + 15 | 0] + 32 | 0;
    } else {
     $0 = HEAPU8[$1 + 15 | 0];
    }
    jsvStringIteratorAppend($2, $0 << 24 >> 24);
    continue;
   }
   break;
  }
  jsvStringIteratorFree_10($1 + 56 | 0);
  jsvStringIteratorFree_10($1 + 16 | 0);
  jsvUnLock(HEAP32[$1 + 92 >> 2]);
  HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 96 >> 2];
 }
 __stack_pointer = $1 + 112 | 0;
 return HEAP32[$1 + 108 >> 2];
}

function _parse_time($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 $0 = stringToIntWithRadix(jslGetTokenValueAsString() + HEAP32[$2 + 36 >> 2] | 0, 10, 0, 0);
 HEAP32[HEAP32[$2 + 40 >> 2] + 16 >> 2] = $0;
 jslGetNextToken();
 label$1: {
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 58) {
   jslGetNextToken();
   if (HEAP16[HEAP32[49079] + 2 >> 1] == 129) {
    $0 = _parse_int();
    HEAP32[HEAP32[$2 + 40 >> 2] + 12 >> 2] = $0;
    jslGetNextToken();
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 58) {
     jslGetNextToken();
     if (!(HEAP16[HEAP32[49079] + 2 >> 1] != 129 & HEAP16[HEAP32[49079] + 2 >> 1] != 130)) {
      HEAPF64[$2 + 24 >> 3] = stringToFloat(jslGetTokenValueAsString());
      $1 = HEAP32[$2 + 40 >> 2];
      $3 = HEAPF64[$2 + 24 >> 3];
      label$7: {
       if (Math_abs($3) < 2147483648) {
        $0 = ~~$3;
        break label$7;
       }
       $0 = -2147483648;
      }
      HEAP32[$1 + 8 >> 2] = $0;
      $1 = HEAP32[$2 + 40 >> 2];
      $3 = HEAPF64[$2 + 24 >> 3] * 1e3;
      label$9: {
       if (Math_abs($3) < 2147483648) {
        $0 = ~~$3;
        break label$9;
       }
       $0 = -2147483648;
      }
      HEAP32[$1 + 4 >> 2] = ($0 | 0) % 1e3;
      jslGetNextToken();
      if (HEAP16[HEAP32[49079] + 2 >> 1] == 128) {
       HEAP32[$2 + 20 >> 2] = jslGetTokenValueAsString();
       label$12: {
        label$13: {
         if (strcmp(HEAP32[$2 + 20 >> 2], 136697)) {
          if (strcmp(HEAP32[$2 + 20 >> 2], 136301)) {
           break label$13;
          }
         }
         HEAP32[HEAP32[$2 + 40 >> 2] + 20 >> 2] = 0;
         jslGetNextToken();
         if (!HEAP16[HEAP32[49079] + 2 >> 1]) {
          HEAP8[$2 + 47 | 0] = 1;
          break label$1;
         }
         break label$12;
        }
        setCorrectTimeZone(HEAP32[$2 + 40 >> 2]);
       }
      }
      label$16: {
       if (!(HEAP16[HEAP32[49079] + 2 >> 1] != 43 & HEAP16[HEAP32[49079] + 2 >> 1] != 45)) {
        HEAP32[$2 + 16 >> 2] = HEAP16[HEAP32[49079] + 2 >> 1] == 43 ? 1 : -1;
        jslGetNextToken();
        label$19: {
         if (HEAP16[HEAP32[49079] + 2 >> 1] == 129) {
          HEAP32[$2 + 12 >> 2] = _parse_int();
          HEAP32[$2 + 12 >> 2] = Math_imul(HEAP32[$2 + 12 >> 2] / 100 | 0, 60) + (HEAP32[$2 + 12 >> 2] % 100 | 0);
          HEAP32[HEAP32[$2 + 40 >> 2] + 20 >> 2] = Math_imul(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2]);
          jslGetNextToken();
          break label$19;
         }
         setCorrectTimeZone(HEAP32[$2 + 40 >> 2]);
        }
        break label$16;
       }
       setCorrectTimeZone(HEAP32[$2 + 40 >> 2]);
      }
      HEAP8[$2 + 47 | 0] = 1;
      break label$1;
     }
    }
   }
  }
  setCorrectTimeZone(HEAP32[$2 + 40 >> 2]);
  HEAP8[$2 + 47 | 0] = 0;
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP8[$2 + 47 | 0] & 1;
}

function jslNewStringFromLexer($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 128 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 120 >> 2] = $0;
 HEAP32[$2 + 116 >> 2] = $1;
 HEAP32[$2 + 112 >> 2] = (HEAP32[$2 + 116 >> 2] + 1 | 0) - jsvStringIteratorGetIndex(HEAP32[$2 + 120 >> 2]);
 HEAP32[$2 + 108 >> 2] = 0;
 label$1: {
  if (HEAPU32[$2 + 112 >> 2] > 19) {
   HEAP32[$2 + 108 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 112 >> 2]);
   if (HEAP32[$2 + 108 >> 2]) {
    HEAP32[$2 + 104 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 108 >> 2]);
    $1 = HEAPU8[HEAP32[$2 + 120 >> 2] + 36 | 0];
    $0 = HEAP32[$2 + 104 >> 2];
    HEAP32[$2 + 104 >> 2] = $0 + 1;
    HEAP8[$0 | 0] = $1;
    jsvStringIteratorClone($2 - -64 | 0, HEAP32[$2 + 120 >> 2]);
    while (1) {
     $0 = 0;
     if (jsvStringIteratorHasChar($2 - -64 | 0) & 1) {
      $0 = HEAP32[$2 + 112 >> 2] - 1 | 0;
      HEAP32[$2 + 112 >> 2] = $0;
      $0 = ($0 | 0) != 0;
     }
     if ($0) {
      $1 = jsvStringIteratorGetCharAndNext($2 - -64 | 0);
      $0 = HEAP32[$2 + 104 >> 2];
      HEAP32[$2 + 104 >> 2] = $0 + 1;
      HEAP8[$0 | 0] = $1;
      continue;
     }
     break;
    }
    jsvStringIteratorFree($2 - -64 | 0);
    HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 108 >> 2];
    break label$1;
   }
  }
  HEAP32[$2 + 108 >> 2] = jsvNewFromEmptyString();
  if (!HEAP32[$2 + 108 >> 2]) {
   HEAP32[$2 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 60 >> 2] = jsvLockAgain(HEAP32[$2 + 108 >> 2]);
  HEAP8[HEAP32[$2 + 60 >> 2]] = HEAPU8[HEAP32[$2 + 120 >> 2] + 36 | 0];
  HEAP32[$2 + 56 >> 2] = 1;
  jsvStringIteratorClone($2 + 16 | 0, HEAP32[$2 + 120 >> 2]);
  while (1) {
   $0 = 0;
   if (jsvStringIteratorHasChar($2 + 16 | 0) & 1) {
    $0 = HEAP32[$2 + 112 >> 2] - 1 | 0;
    HEAP32[$2 + 112 >> 2] = $0;
    $0 = ($0 | 0) != 0;
   }
   label$10: {
    if (!$0) {
     break label$10;
    }
    HEAP8[$2 + 15 | 0] = jsvStringIteratorGetCharAndNext($2 + 16 | 0);
    if (HEAPU32[$2 + 56 >> 2] >= jsvGetMaxCharactersInVar(HEAP32[$2 + 60 >> 2]) >>> 0) {
     jsvSetCharactersInVar(HEAP32[$2 + 60 >> 2], HEAP32[$2 + 56 >> 2]);
     HEAP32[$2 + 8 >> 2] = jsvNewWithFlags(41);
     if (!HEAP32[$2 + 8 >> 2]) {
      break label$10;
     }
     jsvSetLastChild(HEAP32[$2 + 60 >> 2], jsvGetRef(HEAP32[$2 + 8 >> 2]) & 65535);
     jsvUnLock(HEAP32[$2 + 60 >> 2]);
     HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 8 >> 2];
     HEAP32[$2 + 56 >> 2] = 0;
    }
    $1 = HEAPU8[$2 + 15 | 0];
    $3 = HEAP32[$2 + 60 >> 2];
    $0 = HEAP32[$2 + 56 >> 2];
    HEAP32[$2 + 56 >> 2] = $0 + 1;
    HEAP8[$3 + $0 | 0] = $1;
    continue;
   }
   break;
  }
  jsvSetCharactersInVar(HEAP32[$2 + 60 >> 2], HEAP32[$2 + 56 >> 2]);
  jsvUnLock(HEAP32[$2 + 60 >> 2]);
  jsvStringIteratorFree($2 + 16 | 0);
  HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 108 >> 2];
 }
 __stack_pointer = $2 + 128 | 0;
 return HEAP32[$2 + 124 >> 2];
}

function tflite__ops__micro__depthwise_conv__EvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteDepthwiseConvParams__2c_20tflite__ops__micro__depthwise_conv___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0;
 $8 = __stack_pointer - 208 | 0;
 __stack_pointer = $8;
 HEAP32[$8 + 204 >> 2] = $0;
 HEAP32[$8 + 200 >> 2] = $1;
 HEAP32[$8 + 196 >> 2] = $2;
 HEAP32[$8 + 192 >> 2] = $3;
 HEAP32[$8 + 188 >> 2] = $4;
 HEAP32[$8 + 184 >> 2] = $5;
 HEAP32[$8 + 180 >> 2] = $6;
 HEAP32[$8 + 176 >> 2] = $7;
 void_20tflite__CalculateActivationRange_float__28TfLiteFusedActivation_2c_20float__2c_20float__29(HEAP32[HEAP32[$8 + 196 >> 2] + 16 >> 2], $8 + 172 | 0, $8 + 168 | 0);
 HEAP8[$8 + 104 | 0] = 1;
 HEAP16[$8 + 106 >> 1] = HEAP32[HEAP32[$8 + 192 >> 2] >> 2];
 HEAP16[$8 + 108 >> 1] = HEAP32[HEAP32[$8 + 192 >> 2] + 4 >> 2];
 HEAP16[$8 + 114 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 4 >> 2];
 HEAP16[$8 + 116 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 8 >> 2];
 HEAP16[$8 + 118 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 20 >> 2];
 HEAP16[$8 + 120 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 24 >> 2];
 HEAP16[$8 + 122 >> 1] = HEAP32[HEAP32[$8 + 196 >> 2] + 12 >> 2];
 HEAPF32[$8 + 152 >> 2] = HEAPF32[$8 + 172 >> 2];
 HEAPF32[$8 + 156 >> 2] = HEAPF32[$8 + 168 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 80 | 0, HEAP32[$8 + 188 >> 2]);
 $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 188 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 56 | 0, HEAP32[$8 + 184 >> 2]);
 $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 184 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 32 | 0, HEAP32[$8 + 180 >> 2]);
 $2 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$8 + 180 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($8 + 8 | 0, HEAP32[$8 + 176 >> 2]);
 tflite__reference_ops__DepthwiseConv_28tflite__DepthwiseParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($8 + 104 | 0, $8 + 80 | 0, $0, $8 + 56 | 0, $1, $8 + 32 | 0, $2, $8 + 8 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$8 + 176 >> 2]));
 tflite__RuntimeShape___RuntimeShape_28_29($8 + 8 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($8 + 32 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($8 + 56 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($8 + 80 | 0);
 __stack_pointer = $8 + 208 | 0;
}

function _jswrap_graphics_stringMetrics($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 208 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 204 >> 2] = $0;
 HEAP32[$4 + 200 >> 2] = $1;
 HEAP32[$4 + 196 >> 2] = $2;
 HEAP32[$4 + 192 >> 2] = $3;
 _jswrap_graphics_getFontInfo(HEAP32[$4 + 204 >> 2], $4 + 168 | 0);
 $0 = HEAP32[$4 + 192 >> 2];
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$4 + 164 >> 2] = _jswrap_graphics_getFontHeightInternal(HEAP32[$4 + 204 >> 2], $4 + 168 | 0);
 HEAP32[$4 + 160 >> 2] = jsvAsString(HEAP32[$4 + 200 >> 2]);
 jsvStringIteratorNewUTF8($4 + 120 | 0, HEAP32[$4 + 160 >> 2], HEAP32[$4 + 196 >> 2] < 0 ? 0 : HEAP32[$4 + 196 >> 2]);
 HEAP32[$4 + 116 >> 2] = 0;
 HEAP32[$4 + 112 >> 2] = HEAP32[$4 + 164 >> 2];
 HEAP32[$4 + 108 >> 2] = 0;
 while (1) {
  label$4: {
   if (!(jsvStringIteratorHasChar_12($4 + 120 | 0) & 1)) {
    break label$4;
   }
   HEAP32[$4 + 104 >> 2] = jsvStringIteratorGetUTF8CharAndNext($4 + 120 | 0);
   if (HEAP32[$4 + 104 >> 2] == 10) {
    if (HEAP32[$4 + 116 >> 2] > HEAP32[$4 + 108 >> 2]) {
     HEAP32[$4 + 108 >> 2] = HEAP32[$4 + 116 >> 2];
    }
    HEAP32[$4 + 116 >> 2] = 0;
    HEAP32[$4 + 112 >> 2] = HEAP32[$4 + 164 >> 2] + HEAP32[$4 + 112 >> 2];
    if (HEAP32[$4 + 196 >> 2] >= 0) {
     break label$4;
    }
   }
   if (!HEAP32[$4 + 104 >> 2]) {
    $0 = HEAP32[$4 + 192 >> 2];
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    HEAP32[$4 + 12 >> 2] = jsvConvertToUTF8Index(HEAP32[$4 + 160 >> 2], jsvStringIteratorGetIndex_6($4 + 120 | 0));
    if (_jswrap_graphics_parseImage(HEAP32[$4 + 204 >> 2], HEAP32[$4 + 160 >> 2], HEAP32[$4 + 12 >> 2], $4 + 16 | 0) & 1) {
     jsvStringIteratorGotoUTF8($4 + 120 | 0, HEAP32[$4 + 160 >> 2], HEAPU16[$4 + 66 >> 1] + (HEAP32[$4 + 12 >> 2] + HEAPU16[$4 + 64 >> 1] | 0) | 0);
     _jswrap_graphics_freeImageInfo($4 + 16 | 0);
     HEAP32[$4 + 116 >> 2] = HEAP32[$4 + 16 >> 2] + HEAP32[$4 + 116 >> 2];
     if (HEAP32[$4 + 20 >> 2] > HEAP32[HEAP32[$4 + 192 >> 2] + 16 >> 2]) {
      HEAP32[HEAP32[$4 + 192 >> 2] + 16 >> 2] = HEAP32[$4 + 20 >> 2];
     }
    }
    continue;
   }
   HEAP32[$4 + 8 >> 2] = _jswrap_graphics_getCharWidth($4 + 168 | 0, HEAP32[$4 + 104 >> 2]);
   HEAP32[$4 + 116 >> 2] = HEAP32[$4 + 8 >> 2] + HEAP32[$4 + 116 >> 2];
   if (!HEAP32[$4 + 8 >> 2]) {
    HEAP8[HEAP32[$4 + 192 >> 2] + 8 | 0] = 1;
   }
   continue;
  }
  break;
 }
 jsvStringIteratorFree_16($4 + 120 | 0);
 jsvUnLock(HEAP32[$4 + 160 >> 2]);
 $1 = HEAP32[$4 + 192 >> 2];
 if (HEAP32[$4 + 116 >> 2] > HEAP32[$4 + 108 >> 2]) {
  $0 = HEAP32[$4 + 116 >> 2];
 } else {
  $0 = HEAP32[$4 + 108 >> 2];
 }
 HEAP32[$1 >> 2] = $0;
 HEAP32[HEAP32[$4 + 192 >> 2] + 4 >> 2] = HEAP32[$4 + 112 >> 2];
 _jswrap_graphics_freeFontInfo($4 + 168 | 0);
 __stack_pointer = $4 + 208 | 0;
}

function jswrap_spi_send($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 304 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 296 >> 2] = $0;
 HEAP32[$3 + 292 >> 2] = $1;
 HEAP8[$3 + 291 | 0] = $2;
 label$1: {
  if (!(jsvIsObject(HEAP32[$3 + 296 >> 2]) & 1)) {
   HEAP32[$3 + 300 >> 2] = 0;
   break label$1;
  }
  HEAP8[$3 + 290 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 296 >> 2]);
  if (!(jsspiGetSendFunction(HEAP32[$3 + 296 >> 2], $3 + 200 | 0, $3 + 204 | 0) & 1)) {
   HEAP32[$3 + 300 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 196 >> 2] = 0;
  if (!(HEAPU8[$3 + 290 | 0] < 26 | HEAPU8[$3 + 290 | 0] > 26)) {
   jshSPISetReceive(HEAPU8[$3 + 290 | 0], 1);
  }
  if (HEAPU8[$3 + 291 | 0] != 255) {
   jshPinOutput(HEAPU8[$3 + 291 | 0], 0);
  }
  label$6: {
   if (jsvIsNumeric(HEAP32[$3 + 292 >> 2]) & 1) {
    HEAP8[$3 + 195 | 0] = jsvGetInteger(HEAP32[$3 + 292 >> 2]);
    $0 = $3 + 195 | 0;
    FUNCTION_TABLE[HEAP32[$3 + 200 >> 2]]($0, $0, 1, $3 + 204 | 0);
    HEAP32[$3 + 196 >> 2] = jsvNewFromInteger(HEAPU8[$3 + 195 | 0]);
    break label$6;
   }
   label$8: {
    if (jsvIsString(HEAP32[$3 + 292 >> 2]) & 1) {
     HEAP32[$3 + 196 >> 2] = jsvNewFromEmptyString_12();
     jsvStringIteratorNew($3 + 24 | 0, HEAP32[$3 + 292 >> 2], 0);
     while (1) {
      $0 = 0;
      if (jsvStringIteratorHasChar_11($3 + 24 | 0) & 1) {
       $0 = jspIsInterrupted() ^ -1;
      }
      if ($0 & 1) {
       jsvStringIteratorGetPtrAndNext($3 + 24 | 0, $3 + 20 | 0, $3 + 16 | 0);
       while (1) {
        if (HEAP32[$3 + 16 >> 2]) {
         HEAP32[$3 + 12 >> 2] = HEAPU32[$3 + 16 >> 2] > 128 ? 128 : HEAP32[$3 + 16 >> 2];
         FUNCTION_TABLE[HEAP32[$3 + 200 >> 2]](HEAP32[$3 + 20 >> 2], $3 - -64 | 0, HEAP32[$3 + 12 >> 2], $3 + 204 | 0);
         jsvAppendStringBuf(HEAP32[$3 + 196 >> 2], $3 - -64 | 0, HEAP32[$3 + 12 >> 2]);
         HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] - HEAP32[$3 + 12 >> 2];
         HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 12 >> 2] + HEAP32[$3 + 20 >> 2];
         continue;
        }
        break;
       }
       continue;
      }
      break;
     }
     jsvStringIteratorFree_14($3 + 24 | 0);
     break label$8;
    }
    HEAP32[$3 + 8 >> 2] = jsvIterateCallbackCount(HEAP32[$3 + 292 >> 2]);
    HEAP32[$3 + 196 >> 2] = jsvNewTypedArray(1, HEAP32[$3 + 8 >> 2]);
    if (HEAP32[$3 + 196 >> 2]) {
     HEAP32[$3 + 224 >> 2] = 0;
     HEAP32[$3 + 220 >> 2] = 0;
     jsvArrayBufferIteratorNew($3 + 228 | 0, HEAP32[$3 + 196 >> 2], 0);
     jsvIterateBufferCallback(HEAP32[$3 + 292 >> 2], 658, $3 + 200 | 0);
     jsvArrayBufferIteratorFree($3 + 228 | 0);
    }
   }
  }
  if (HEAPU8[$3 + 291 | 0] != 255) {
   jshPinOutput(HEAPU8[$3 + 291 | 0], 1);
  }
  HEAP32[$3 + 300 >> 2] = HEAP32[$3 + 196 >> 2];
 }
 __stack_pointer = $3 + 304 | 0;
 return HEAP32[$3 + 300 >> 2];
}

function jswrap_espruino_nativeCall($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 176 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 168 >> 2] = $0;
 HEAP32[$3 + 164 >> 2] = $1;
 HEAP32[$3 + 160 >> 2] = $2;
 HEAP32[$3 + 156 >> 2] = 0;
 label$1: {
  if (!(jsvIsUndefined(HEAP32[$3 + 164 >> 2]) & 1)) {
   label$3: {
    if (jsvIsString(HEAP32[$3 + 164 >> 2]) & 1) {
     HEAP32[$3 + 28 >> 2] = jslSetLex($3 + 32 | 0);
     jslInit(HEAP32[$3 + 164 >> 2]);
     HEAP8[$3 + 23 | 0] = 1;
     HEAP32[$3 + 16 >> 2] = 0;
     HEAP32[$3 + 24 >> 2] = nativeCallGetCType();
     label$5: {
      if (HEAP32[$3 + 24 >> 2] >= 0) {
       $1 = HEAP32[$3 + 24 >> 2];
       $0 = HEAP32[$3 + 16 >> 2];
       HEAP32[$3 + 16 >> 2] = $0 + 1;
       HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] | $1 << Math_imul($0, 3);
       break label$5;
      }
      HEAP8[$3 + 23 | 0] = 0;
     }
     if (HEAP8[$3 + 23 | 0] & 1) {
      HEAP8[$3 + 23 | 0] = jslMatch(40) & 1;
     }
     while (1) {
      $0 = 0;
      label$9: {
       if (!(HEAP8[$3 + 23 | 0] & 1)) {
        break label$9;
       }
       $0 = 0;
       if (!HEAP16[$3 + 34 >> 1]) {
        break label$9;
       }
       $0 = HEAP16[$3 + 34 >> 1] != 41;
      }
      if ($0) {
       HEAP32[$3 + 24 >> 2] = nativeCallGetCType();
       label$11: {
        if (HEAP32[$3 + 24 >> 2] >= 0) {
         $1 = HEAP32[$3 + 24 >> 2];
         $0 = HEAP32[$3 + 16 >> 2];
         HEAP32[$3 + 16 >> 2] = $0 + 1;
         HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] | $1 << Math_imul($0, 3);
         if (HEAP16[$3 + 34 >> 1] != 41) {
          HEAP8[$3 + 23 | 0] = jslMatch(44) & 1;
         }
         break label$11;
        }
        HEAP8[$3 + 23 | 0] = 0;
       }
       continue;
      }
      break;
     }
     if (HEAP8[$3 + 23 | 0] & 1) {
      HEAP8[$3 + 23 | 0] = jslMatch(41) & 1;
     }
     jslKill();
     jslSetLex(HEAP32[$3 + 28 >> 2]);
     if (HEAP32[$3 + 156 >> 2] & -65536) {
      HEAP8[$3 + 23 | 0] = 0;
     }
     if (!(HEAP8[$3 + 23 | 0] & 1)) {
      HEAP32[$3 >> 2] = HEAP32[$3 + 16 >> 2];
      jsExceptionHere(1, 134821, $3);
      HEAP32[$3 + 172 >> 2] = 0;
      break label$1;
     }
     break label$3;
    }
    jsExceptionHere(1, 132127, 0);
    HEAP32[$3 + 172 >> 2] = 0;
    break label$1;
   }
  }
  HEAP32[$3 + 12 >> 2] = jsvNewNativeFunction(HEAP32[$3 + 168 >> 2], HEAP32[$3 + 156 >> 2] & 65535);
  if (HEAP32[$3 + 160 >> 2]) {
   HEAP32[$3 + 8 >> 2] = jsvAsFlatString(HEAP32[$3 + 160 >> 2]);
   if (!HEAP32[$3 + 8 >> 2]) {
    jsvUnLock(HEAP32[$3 + 12 >> 2]);
    HEAP32[$3 + 172 >> 2] = 0;
    break label$1;
   }
   jsvAddNamedChildAndUnLock(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 133204);
  }
  HEAP32[$3 + 172 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 __stack_pointer = $3 + 176 | 0;
 return HEAP32[$3 + 172 >> 2];
}

function _jswrap_prombox_resolve_or_reject($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 HEAP8[$3 + 55 | 0] = $2;
 HEAP8[$3 + 54 | 0] = jsvObjectGetBoolChild(HEAP32[$3 + 60 >> 2], 128712) & 1;
 label$1: {
  if (HEAP8[$3 + 54 | 0] & 1) {
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$3 + 60 >> 2], 128712, jsvNewFromBool(1));
  HEAP32[$3 + 48 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 60 >> 2], 128686);
  if (!HEAP32[$3 + 48 >> 2]) {
   break label$1;
  }
  if (jsvIsEqual(HEAP32[$3 + 56 >> 2], HEAP32[$3 + 48 >> 2]) & 1) {
   jsExceptionHere(1, 130110, 0);
   jsvUnLock(HEAP32[$3 + 48 >> 2]);
   break label$1;
  }
  jsvObjectSetChild(HEAP32[$3 + 48 >> 2], 129e3, HEAP32[$3 + 56 >> 2]);
  label$3: {
   if (HEAP8[$3 + 55 | 0] & 1) {
    if (jsvIsObject(HEAP32[$3 + 56 >> 2]) & 1) {
     break label$3;
    }
   }
   _jswrap_promise_seal(HEAP32[$3 + 48 >> 2], HEAP32[$3 + 56 >> 2], HEAP8[$3 + 55 | 0] & 1);
   jsvUnLock(HEAP32[$3 + 48 >> 2]);
   break label$1;
  }
  HEAP8[$3 + 47 | 0] = _jswrap_promise_is_promise(HEAP32[$3 + 56 >> 2]) & 1;
  HEAP8[$3 + 46 | 0] = 0;
  HEAP32[$3 + 40 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 56 >> 2], 128541);
  if (jsvIsFunction(HEAP32[$3 + 40 >> 2]) & 1) {
   HEAP8[$3 + 46 | 0] = 1;
  }
  if (!(HEAP8[$3 + 46 | 0] & 1 | HEAP8[$3 + 47 | 0] & 1)) {
   _jswrap_promise_seal(HEAP32[$3 + 48 >> 2], HEAP32[$3 + 56 >> 2], HEAP8[$3 + 55 | 0] & 1);
   jsvUnLock2(HEAP32[$3 + 48 >> 2], HEAP32[$3 + 40 >> 2]);
   break label$1;
  }
  HEAP32[$3 + 36 >> 2] = jsvNewObject();
  HEAP32[$3 + 32 >> 2] = _jswrap_promise_native_with_prombox(650, HEAP32[$3 + 36 >> 2]);
  HEAP32[$3 + 28 >> 2] = _jswrap_promise_native_with_prombox(651, HEAP32[$3 + 36 >> 2]);
  if (HEAP32[$3 + 36 >> 2]) {
   jsvObjectSetChild(HEAP32[$3 + 36 >> 2], 128686, HEAP32[$3 + 48 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$3 + 36 >> 2], 128712, jsvNewFromBool(0));
   label$8: {
    if (HEAP8[$3 + 46 | 0] & 1) {
     HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 32 >> 2];
     HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 28 >> 2];
     HEAP32[$3 + 16 >> 2] = HEAP32[91094];
     jsvUnLock(jspeFunctionCall(HEAP32[$3 + 40 >> 2], 0, HEAP32[$3 + 56 >> 2], 0, 2, $3 + 20 | 0));
     HEAP32[91094] = HEAP32[$3 + 16 >> 2];
     HEAP32[$3 + 12 >> 2] = jspGetException();
     if (HEAP32[$3 + 12 >> 2]) {
      _jswrap_prombox_reject(HEAP32[$3 + 36 >> 2], HEAP32[$3 + 12 >> 2]);
      jsvUnLock(HEAP32[$3 + 12 >> 2]);
     }
     break label$8;
    }
    jsvUnLock(jswrap_promise_then(HEAP32[$3 + 56 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2]));
   }
   jsvUnLock3(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2], HEAP32[$3 + 36 >> 2]);
  }
  jsvUnLock2(HEAP32[$3 + 48 >> 2], HEAP32[$3 + 40 >> 2]);
 }
 __stack_pointer = $3 - -64 | 0;
}

function tflite__ops__micro__pooling___28anonymous_20namespace_29__AverageEvalQuantized_28TfLiteContext__2c_20TfLiteNode_20const__2c_20TfLitePoolParams_20const__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 176 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 172 >> 2] = $0;
 HEAP32[$6 + 168 >> 2] = $1;
 HEAP32[$6 + 164 >> 2] = $2;
 HEAP32[$6 + 160 >> 2] = $3;
 HEAP32[$6 + 156 >> 2] = $4;
 HEAP32[$6 + 152 >> 2] = $5;
 HEAP32[$6 + 116 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 8 >> 2];
 HEAP32[$6 + 120 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 4 >> 2];
 HEAP32[$6 + 124 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 16 >> 2];
 HEAP32[$6 + 128 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 12 >> 2];
 HEAP16[$6 + 108 >> 1] = HEAP32[HEAP32[$6 + 160 >> 2] + 4 >> 2];
 HEAP16[$6 + 106 >> 1] = HEAP32[HEAP32[$6 + 160 >> 2] >> 2];
 HEAP32[$6 + 132 >> 2] = HEAP32[HEAP32[$6 + 160 >> 2] + 16 >> 2];
 HEAP32[$6 + 136 >> 2] = HEAP32[HEAP32[$6 + 160 >> 2] + 20 >> 2];
 label$2: {
  if (HEAP32[HEAP32[$6 + 156 >> 2] + 8 >> 2] == 3) {
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 80 | 0, HEAP32[$6 + 156 >> 2]);
   $0 = unsigned_20char_20const__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor_20const__29(HEAP32[$6 + 156 >> 2]);
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 56 | 0, HEAP32[$6 + 152 >> 2]);
   tflite__reference_ops__AveragePool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($6 + 104 | 0, $6 + 80 | 0, $0, $6 + 56 | 0, unsigned_20char__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor__29(HEAP32[$6 + 152 >> 2]));
   tflite__RuntimeShape___RuntimeShape_28_29($6 + 56 | 0);
   tflite__RuntimeShape___RuntimeShape_28_29($6 + 80 | 0);
   break label$2;
  }
  tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 32 | 0, HEAP32[$6 + 156 >> 2]);
  $0 = signed_20char_20const__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor_20const__29(HEAP32[$6 + 156 >> 2]);
  tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 8 | 0, HEAP32[$6 + 152 >> 2]);
  tflite__reference_integer_ops__AveragePool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($6 + 104 | 0, $6 + 32 | 0, $0, $6 + 8 | 0, signed_20char__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor__29(HEAP32[$6 + 152 >> 2]));
  tflite__RuntimeShape___RuntimeShape_28_29($6 + 8 | 0);
  tflite__RuntimeShape___RuntimeShape_28_29($6 + 32 | 0);
 }
 __stack_pointer = $6 + 176 | 0;
}

function jsvFindChildFromString($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP8[$2 + 15 | 0] = 1;
 HEAP8[$2 + 16 | 0] = HEAPU8[HEAP32[$2 + 20 >> 2]];
 if (HEAPU8[HEAP32[$2 + 20 >> 2]]) {
  HEAP8[$2 + 17 | 0] = HEAPU8[HEAP32[$2 + 20 >> 2] + 1 | 0];
  if (HEAPU8[HEAP32[$2 + 20 >> 2] + 1 | 0]) {
   HEAP8[$2 + 18 | 0] = HEAPU8[HEAP32[$2 + 20 >> 2] + 2 | 0];
   if (HEAPU8[HEAP32[$2 + 20 >> 2] + 2 | 0]) {
    HEAP8[$2 + 19 | 0] = HEAPU8[HEAP32[$2 + 20 >> 2] + 3 | 0];
    if (HEAPU8[HEAP32[$2 + 20 >> 2] + 3 | 0]) {
     HEAP8[$2 + 15 | 0] = !HEAP8[HEAP32[$2 + 20 >> 2] + 4 | 0];
    }
   }
  }
 }
 HEAP16[$2 + 12 >> 1] = jsvGetFirstChild(HEAP32[$2 + 24 >> 2]);
 label$5: {
  label$6: {
   if (!(HEAP8[$2 + 15 | 0] & 1)) {
    while (1) {
     if (HEAPU16[$2 + 12 >> 1]) {
      HEAP32[$2 + 8 >> 2] = jsvGetAddressOf(HEAPU16[$2 + 12 >> 1]);
      label$10: {
       $0 = HEAP32[$2 + 8 >> 2];
       if ((HEAPU8[$2 + 16 | 0] | HEAPU8[$2 + 17 | 0] << 8 | (HEAPU8[$2 + 18 | 0] << 16 | HEAPU8[$2 + 19 | 0] << 24)) != (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
        break label$10;
       }
       if (!(jsvIsStringEqual(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 20 >> 2]) & 1)) {
        break label$10;
       }
       HEAP32[$2 + 28 >> 2] = jsvLockAgain(HEAP32[$2 + 8 >> 2]);
       break label$5;
      }
      HEAP16[$2 + 12 >> 1] = jsvGetNextSibling(HEAP32[$2 + 8 >> 2]);
      continue;
     }
     break;
    }
    break label$6;
   }
   HEAP32[$2 + 4 >> 2] = 0;
   while (1) {
    if (HEAPU8[HEAP32[$2 + 20 >> 2] + HEAP32[$2 + 4 >> 2] | 0]) {
     HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
     continue;
    }
    break;
   }
   while (1) {
    if (HEAPU16[$2 + 12 >> 1]) {
     HEAP32[$2 >> 2] = jsvGetAddressOf(HEAPU16[$2 + 12 >> 1]);
     label$15: {
      $0 = HEAP32[$2 >> 2];
      if ((HEAPU8[$2 + 16 | 0] | HEAPU8[$2 + 17 | 0] << 8 | (HEAPU8[$2 + 18 | 0] << 16 | HEAPU8[$2 + 19 | 0] << 24)) != (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
       break label$15;
      }
      $0 = HEAP32[$2 >> 2];
      if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) >>> 18 | 0) {
       break label$15;
      }
      if ((jsvGetCharactersInVar(HEAP32[$2 >> 2]) | 0) != HEAP32[$2 + 4 >> 2]) {
       break label$15;
      }
      HEAP32[$2 + 28 >> 2] = jsvLockAgain(HEAP32[$2 >> 2]);
      break label$5;
     }
     HEAP16[$2 + 12 >> 1] = jsvGetNextSibling(HEAP32[$2 >> 2]);
     continue;
    }
    break;
   }
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function tflite__reference_ops__Softmax_28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = Math_fround(0);
 $5 = __stack_pointer + -64 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 60 >> 2] = $0;
 HEAP32[$5 + 56 >> 2] = $1;
 HEAP32[$5 + 52 >> 2] = $2;
 HEAP32[$5 + 48 >> 2] = $3;
 HEAP32[$5 + 44 >> 2] = $4;
 HEAP32[$5 + 40 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 56 >> 2]) - 1;
 HEAP32[$5 + 36 >> 2] = tflite__MatchingFlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 56 >> 2], HEAP32[$5 + 40 >> 2], HEAP32[$5 + 48 >> 2]);
 HEAP32[$5 + 32 >> 2] = tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$5 + 56 >> 2], HEAP32[$5 + 40 >> 2], HEAP32[$5 + 48 >> 2], HEAP32[$5 + 40 >> 2]);
 HEAP32[$5 + 28 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 28 >> 2] < HEAP32[$5 + 36 >> 2]) {
   HEAPF32[$5 + 24 >> 2] = std____2__numeric_limits_float___lowest_28_29();
   HEAP32[$5 + 20 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 20 >> 2] < HEAP32[$5 + 32 >> 2]) {
     HEAPF32[$5 + 24 >> 2] = HEAPF32[float_20const__20std____2__max_float__28float_20const__2c_20float_20const__29($5 + 24 | 0, HEAP32[$5 + 52 >> 2] + (HEAP32[$5 + 20 >> 2] + Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 32 >> 2]) << 2) | 0) >> 2];
     HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAPF32[$5 + 16 >> 2] = 0;
   HEAP32[$5 + 12 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 12 >> 2] < HEAP32[$5 + 32 >> 2]) {
     $6 = exp_28float_29(Math_fround(Math_fround(HEAPF32[HEAP32[$5 + 52 >> 2] + (HEAP32[$5 + 12 >> 2] + Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 32 >> 2]) << 2) >> 2] - HEAPF32[$5 + 24 >> 2]) * Math_fround(HEAPF64[HEAP32[$5 + 60 >> 2] >> 3])));
     HEAPF32[$5 + 16 >> 2] = HEAPF32[$5 + 16 >> 2] + $6;
     HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 8 >> 2] = 0;
   while (1) {
    if (HEAP32[$5 + 8 >> 2] < HEAP32[$5 + 32 >> 2]) {
     $6 = exp_28float_29(Math_fround(Math_fround(HEAPF32[HEAP32[$5 + 52 >> 2] + (HEAP32[$5 + 8 >> 2] + Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 32 >> 2]) << 2) >> 2] - HEAPF32[$5 + 24 >> 2]) * Math_fround(HEAPF64[HEAP32[$5 + 60 >> 2] >> 3])));
     HEAPF32[HEAP32[$5 + 44 >> 2] + (HEAP32[$5 + 8 >> 2] + Math_imul(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 32 >> 2]) << 2) >> 2] = $6 / HEAPF32[$5 + 16 >> 2];
     HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 28 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 - -64 | 0;
}

function tflite__ops__micro__pooling___28anonymous_20namespace_29__MaxEvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20TfLitePoolParams__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 176 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 172 >> 2] = $0;
 HEAP32[$6 + 168 >> 2] = $1;
 HEAP32[$6 + 164 >> 2] = $2;
 HEAP32[$6 + 160 >> 2] = $3;
 HEAP32[$6 + 156 >> 2] = $4;
 HEAP32[$6 + 152 >> 2] = $5;
 HEAP32[$6 + 116 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 8 >> 2];
 HEAP32[$6 + 120 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 4 >> 2];
 HEAP32[$6 + 124 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 16 >> 2];
 HEAP32[$6 + 128 >> 2] = HEAP32[HEAP32[$6 + 164 >> 2] + 12 >> 2];
 HEAP16[$6 + 108 >> 1] = HEAP32[HEAP32[$6 + 160 >> 2] + 4 >> 2];
 HEAP16[$6 + 106 >> 1] = HEAP32[HEAP32[$6 + 160 >> 2] >> 2];
 HEAP32[$6 + 132 >> 2] = HEAP32[HEAP32[$6 + 160 >> 2] + 16 >> 2];
 HEAP32[$6 + 136 >> 2] = HEAP32[HEAP32[$6 + 160 >> 2] + 20 >> 2];
 label$1: {
  if (HEAP32[HEAP32[$6 + 156 >> 2] + 8 >> 2] == 3) {
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 80 | 0, HEAP32[$6 + 156 >> 2]);
   $0 = unsigned_20char_20const__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor_20const__29(HEAP32[$6 + 156 >> 2]);
   tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 56 | 0, HEAP32[$6 + 152 >> 2]);
   tflite__reference_ops__MaxPool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($6 + 104 | 0, $6 + 80 | 0, $0, $6 + 56 | 0, unsigned_20char__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor__29(HEAP32[$6 + 152 >> 2]));
   tflite__RuntimeShape___RuntimeShape_28_29($6 + 56 | 0);
   tflite__RuntimeShape___RuntimeShape_28_29($6 + 80 | 0);
   break label$1;
  }
  tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 32 | 0, HEAP32[$6 + 156 >> 2]);
  $0 = signed_20char_20const__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor_20const__29(HEAP32[$6 + 156 >> 2]);
  tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 8 | 0, HEAP32[$6 + 152 >> 2]);
  tflite__reference_integer_ops__MaxPool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($6 + 104 | 0, $6 + 32 | 0, $0, $6 + 8 | 0, signed_20char__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor__29(HEAP32[$6 + 152 >> 2]));
  tflite__RuntimeShape___RuntimeShape_28_29($6 + 8 | 0);
  tflite__RuntimeShape___RuntimeShape_28_29($6 + 32 | 0);
 }
 __stack_pointer = $6 + 176 | 0;
}

function stringToIntWithRadix($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 52 >> 2] = $0;
 HEAP32[$4 + 48 >> 2] = $1;
 HEAP32[$4 + 44 >> 2] = $2;
 HEAP32[$4 + 40 >> 2] = $3;
 while (1) {
  if (isWhitespace(HEAP8[HEAP32[$4 + 52 >> 2]]) & 1) {
   HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP8[$4 + 39 | 0] = 0;
 HEAP32[$4 + 24 >> 2] = 0;
 HEAP32[$4 + 28 >> 2] = 0;
 label$3: {
  if (HEAP8[HEAP32[$4 + 52 >> 2]] == 45) {
   HEAP8[$4 + 39 | 0] = 1;
   HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] + 1;
   break label$3;
  }
  if (HEAP8[HEAP32[$4 + 52 >> 2]] == 43) {
   HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] + 1;
  }
 }
 HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 52 >> 2];
 if (HEAP32[$4 + 40 >> 2]) {
  HEAP32[HEAP32[$4 + 40 >> 2] >> 2] = HEAP32[$4 + 52 >> 2];
 }
 if (HEAP32[$4 + 48 >> 2]) {
  $0 = HEAP32[$4 + 48 >> 2];
 } else {
  $0 = getRadix($4 + 52 | 0);
 }
 HEAP32[$4 + 16 >> 2] = $0;
 label$9: {
  if (!HEAP32[$4 + 16 >> 2]) {
   HEAP32[$4 + 56 >> 2] = 0;
   HEAP32[$4 + 60 >> 2] = 0;
   break label$9;
  }
  while (1) {
   label$12: {
    if (!HEAPU8[HEAP32[$4 + 52 >> 2]]) {
     break label$12;
    }
    HEAP32[$4 + 12 >> 2] = chtod(HEAP8[HEAP32[$4 + 52 >> 2]]);
    if (HEAP32[$4 + 12 >> 2] < 0 | HEAP32[$4 + 12 >> 2] >= HEAP32[$4 + 16 >> 2]) {
     break label$12;
    }
    $1 = HEAP32[$4 + 12 >> 2];
    $0 = $1 >> 31;
    $6 = $1;
    $2 = $0;
    $0 = HEAP32[$4 + 24 >> 2];
    $7 = $0;
    $1 = HEAP32[$4 + 28 >> 2];
    $3 = $1;
    $1 = HEAP32[$4 + 16 >> 2];
    $0 = $1 >> 31;
    $5 = $0;
    $0 = $3;
    $3 = $1;
    $1 = $5;
    $1 = __wasm_i64_mul($7, $0, $3, $1);
    $3 = $1;
    $5 = $1 + $6 | 0;
    $0 = i64toi32_i32$HIGH_BITS;
    $1 = $0;
    $0 = $2;
    $0 = $1 + $0 | 0;
    HEAP32[$4 + 24 >> 2] = $5;
    $0 = $5 >>> 0 < $3 >>> 0 ? $0 + 1 | 0 : $0;
    HEAP32[$4 + 28 >> 2] = $0;
    HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[$4 + 44 >> 2]) {
   HEAP8[HEAP32[$4 + 44 >> 2]] = HEAP32[$4 + 52 >> 2] == HEAP32[$4 + 20 >> 2];
  }
  if (HEAP32[$4 + 40 >> 2]) {
   HEAP32[HEAP32[$4 + 40 >> 2] >> 2] = HEAP32[$4 + 52 >> 2];
  }
  if (HEAP8[$4 + 39 | 0] & 1) {
   $2 = HEAP32[$4 + 28 >> 2];
   $0 = HEAP32[$4 + 24 >> 2];
   $3 = $0;
   $1 = 0 - $0 | 0;
   HEAP32[$4 + 56 >> 2] = $1;
   $0 = $2;
   $5 = $0 + (($3 | 0) != 0) | 0;
   $5 = 0 - $5 | 0;
   HEAP32[$4 + 60 >> 2] = $5;
   break label$9;
  }
  $0 = HEAP32[$4 + 28 >> 2];
  $5 = HEAP32[$4 + 24 >> 2];
  HEAP32[$4 + 56 >> 2] = $5;
  HEAP32[$4 + 60 >> 2] = $0;
 }
 __stack_pointer = $4 - -64 | 0;
 $5 = HEAP32[$4 + 60 >> 2];
 i64toi32_i32$HIGH_BITS = $5;
 $0 = HEAP32[$4 + 56 >> 2];
 return $0;
}

function jswrap_require($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 256 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 248 >> 2] = $0;
 label$1: {
  if (!(jsvIsString(HEAP32[$1 + 248 >> 2]) & 1)) {
   HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 248 >> 2];
   jsExceptionHere(3, 118878, $1 + 48 | 0);
   HEAP32[$1 + 252 >> 2] = 0;
   break label$1;
  }
  if (jsvGetString(HEAP32[$1 + 248 >> 2], $1 + 112 | 0, 128) >>> 0 >= 128) {
   jsExceptionHere(3, 142812, 0);
   HEAP32[$1 + 252 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 108 >> 2] = jswrap_modules_getModuleList();
  if (!HEAP32[$1 + 108 >> 2]) {
   HEAP32[$1 + 252 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 104 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAP32[$1 + 108 >> 2], $1 + 112 | 0));
  jsvUnLock(HEAP32[$1 + 108 >> 2]);
  if (HEAP32[$1 + 104 >> 2]) {
   HEAP32[$1 + 252 >> 2] = HEAP32[$1 + 104 >> 2];
   break label$1;
  }
  HEAP32[$1 + 100 >> 2] = jswGetBuiltInLibrary($1 + 112 | 0);
  if (HEAP32[$1 + 100 >> 2]) {
   HEAP32[$1 + 104 >> 2] = jsvNewNativeFunction(HEAP32[$1 + 100 >> 2], 0);
  }
  label$7: {
   if (HEAP32[$1 + 104 >> 2]) {
    break label$7;
   }
   if (strlen($1 + 112 | 0) >>> 0 > 28) {
    break label$7;
   }
   jsfNameFromString($1 + 72 | 0, $1 + 112 | 0);
   HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 96 >> 2];
   $2 = HEAP32[$1 + 92 >> 2];
   $0 = HEAP32[$1 + 88 >> 2];
   HEAP32[$1 + 32 >> 2] = $0;
   HEAP32[$1 + 36 >> 2] = $2;
   $0 = HEAP32[$1 + 84 >> 2];
   $2 = HEAP32[$1 + 80 >> 2];
   HEAP32[$1 + 24 >> 2] = $2;
   HEAP32[$1 + 28 >> 2] = $0;
   $2 = HEAP32[$1 + 76 >> 2];
   $0 = HEAP32[$1 + 72 >> 2];
   HEAP32[$1 + 16 >> 2] = $0;
   HEAP32[$1 + 20 >> 2] = $2;
   HEAP32[$1 + 68 >> 2] = jsfReadFile($1 + 16 | 0, 0, 0);
   if (HEAP32[$1 + 68 >> 2]) {
    HEAP32[$1 + 104 >> 2] = jspEvaluateModule(HEAP32[$1 + 68 >> 2]);
    jsvUnLock(HEAP32[$1 + 68 >> 2]);
   }
  }
  if (!HEAP32[$1 + 104 >> 2]) {
   HEAP32[$1 + 64 >> 2] = jswGetBuiltInJSLibrary($1 + 112 | 0);
   if (HEAP32[$1 + 64 >> 2]) {
    HEAP32[$1 + 60 >> 2] = jsvNewNativeString(HEAP32[$1 + 64 >> 2], strlen(HEAP32[$1 + 64 >> 2]));
    if (HEAP32[$1 + 60 >> 2]) {
     HEAP32[$1 + 104 >> 2] = jspEvaluateModule(HEAP32[$1 + 60 >> 2]);
     jsvUnLock(HEAP32[$1 + 60 >> 2]);
    }
   }
  }
  label$12: {
   if (HEAP32[$1 + 104 >> 2]) {
    HEAP32[$1 + 56 >> 2] = jswrap_modules_getModuleList();
    if (HEAP32[$1 + 56 >> 2]) {
     jsvObjectSetChild(HEAP32[$1 + 56 >> 2], $1 + 112 | 0, HEAP32[$1 + 104 >> 2]);
    }
    jsvUnLock(HEAP32[$1 + 56 >> 2]);
    break label$12;
   }
   HEAP32[$1 >> 2] = HEAP32[$1 + 248 >> 2];
   jsExceptionHere(1, 133209, $1);
  }
  HEAP32[$1 + 252 >> 2] = HEAP32[$1 + 104 >> 2];
 }
 __stack_pointer = $1 + 256 | 0;
 return HEAP32[$1 + 252 >> 2];
}

function lcdFillRect_ArrayBuffer_flat1($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = __stack_pointer - 80 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 76 >> 2] = $0;
 HEAP32[$6 + 72 >> 2] = $1;
 HEAP32[$6 + 68 >> 2] = $2;
 HEAP32[$6 + 64 >> 2] = $3;
 HEAP32[$6 + 60 >> 2] = $4;
 HEAP32[$6 + 56 >> 2] = $5;
 label$1: {
  if ((HEAP32[$6 + 64 >> 2] - HEAP32[$6 + 72 >> 2] | 0) < 8) {
   lcdFillRect_ArrayBuffer_flat(HEAP32[$6 + 76 >> 2], HEAP32[$6 + 72 >> 2], HEAP32[$6 + 68 >> 2], HEAP32[$6 + 64 >> 2], HEAP32[$6 + 60 >> 2], HEAP32[$6 + 56 >> 2]);
   break label$1;
  }
  $0 = HEAP32[$6 + 76 >> 2];
  HEAP32[$6 + 52 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
  HEAP32[$6 + 56 >> 2] = HEAP32[$6 + 56 >> 2] & 1;
  HEAP8[$6 + 51 | 0] = HEAP32[$6 + 56 >> 2] & 255 | HEAP32[$6 + 56 >> 2] << 1 & 255;
  HEAP8[$6 + 51 | 0] = HEAPU8[$6 + 51 | 0] | HEAPU8[$6 + 51 | 0] << 2;
  HEAP8[$6 + 51 | 0] = HEAPU8[$6 + 51 | 0] | HEAPU8[$6 + 51 | 0] << 4;
  HEAP32[$6 + 44 >> 2] = HEAP32[$6 + 68 >> 2];
  while (1) {
   if (HEAP32[$6 + 44 >> 2] > HEAP32[$6 + 60 >> 2]) {
    break label$1;
   }
   $0 = HEAP32[$6 + 76 >> 2];
   HEAP32[$6 + 40 >> 2] = Math_imul(HEAP32[$6 + 44 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
   HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 72 >> 2] + HEAP32[$6 + 40 >> 2];
   HEAP32[$6 + 32 >> 2] = HEAP32[$6 + 64 >> 2] + HEAP32[$6 + 40 >> 2];
   HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 52 >> 2] + (HEAP32[$6 + 36 >> 2] >> 3);
   if (HEAP32[$6 + 36 >> 2] & 7) {
    HEAP32[$6 + 24 >> 2] = 8 - (HEAP32[$6 + 36 >> 2] & 7);
    HEAP32[$6 + 20 >> 2] = 255 << HEAP32[$6 + 24 >> 2] ^ -1;
    HEAP8[HEAP32[$6 + 28 >> 2]] = HEAPU8[HEAP32[$6 + 28 >> 2]] & (HEAP32[$6 + 20 >> 2] ^ -1) | HEAPU8[$6 + 51 | 0] & HEAP32[$6 + 20 >> 2];
    HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 28 >> 2] + 1;
    HEAP32[$6 + 36 >> 2] = (HEAP32[$6 + 36 >> 2] & -8) + 8;
   }
   while (1) {
    if (HEAP32[$6 + 32 >> 2] >= (HEAP32[$6 + 36 >> 2] + 7 | 0)) {
     $1 = HEAPU8[$6 + 51 | 0];
     $0 = HEAP32[$6 + 28 >> 2];
     HEAP32[$6 + 28 >> 2] = $0 + 1;
     HEAP8[$0 | 0] = $1;
     HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 36 >> 2] + 8;
     continue;
    }
    break;
   }
   if (HEAP32[$6 + 36 >> 2] <= HEAP32[$6 + 32 >> 2]) {
    HEAP32[$6 + 16 >> 2] = (HEAP32[$6 + 32 >> 2] + 1 | 0) - HEAP32[$6 + 36 >> 2];
    HEAP32[$6 + 12 >> 2] = 255 >> HEAP32[$6 + 16 >> 2] ^ -1;
    HEAP8[HEAP32[$6 + 28 >> 2]] = HEAPU8[HEAP32[$6 + 28 >> 2]] & (HEAP32[$6 + 12 >> 2] ^ -1) | HEAPU8[$6 + 51 | 0] & HEAP32[$6 + 12 >> 2];
   }
   HEAP32[$6 + 44 >> 2] = HEAP32[$6 + 44 >> 2] + 1;
   continue;
  }
 }
 __stack_pointer = $6 + 80 | 0;
}

function jspGetVarNamedField($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 112 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 104 >> 2] = $0;
 HEAP32[$3 + 100 >> 2] = $1;
 HEAP8[$3 + 99 | 0] = $2;
 HEAP32[$3 + 92 >> 2] = 0;
 if (jsvHasChildren(HEAP32[$3 + 104 >> 2]) & 1) {
  HEAP32[$3 + 92 >> 2] = jsvFindChildFromVar(HEAP32[$3 + 104 >> 2], HEAP32[$3 + 100 >> 2], 0);
 }
 label$2: {
  if (!HEAP32[$3 + 92 >> 2]) {
   label$4: {
    label$5: {
     if (!(jsvIsArrayBuffer(HEAP32[$3 + 104 >> 2]) & 1)) {
      break label$5;
     }
     if (!(jsvIsInt(HEAP32[$3 + 100 >> 2]) & 1)) {
      break label$5;
     }
     HEAP32[$3 + 92 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(jsvGetInteger(HEAP32[$3 + 100 >> 2])), HEAP32[$3 + 104 >> 2]);
     if (HEAP32[$3 + 92 >> 2]) {
      $0 = HEAP32[$3 + 92 >> 2];
      $1 = HEAP32[$3 + 92 >> 2];
      $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & -64 | 14;
      HEAP8[$0 + 12 | 0] = $1;
      HEAP8[$0 + 13 | 0] = $1 >>> 8;
     }
     break label$4;
    }
    label$7: {
     label$8: {
      if (!(jsvIsString(HEAP32[$3 + 104 >> 2]) & 1)) {
       break label$8;
      }
      if (!(jsvIsInt(HEAP32[$3 + 100 >> 2]) & 1)) {
       break label$8;
      }
      HEAP32[$3 + 88 >> 2] = jsvGetInteger(HEAP32[$3 + 100 >> 2]);
      label$9: {
       if (HEAP32[$3 + 88 >> 2] < 0) {
        break label$9;
       }
       if (HEAP32[$3 + 88 >> 2] >= (jsvGetStringLength(HEAP32[$3 + 104 >> 2]) | 0)) {
        break label$9;
       }
       HEAP32[$3 + 108 >> 2] = jswrap_string_charAt_undefined(HEAP32[$3 + 104 >> 2], HEAP32[$3 + 88 >> 2]);
       break label$2;
      }
      if (HEAP8[$3 + 99 | 0] & 1) {
       HEAP32[$3 + 92 >> 2] = jsvCreateNewChild(HEAP32[$3 + 104 >> 2], HEAP32[$3 + 100 >> 2], 0);
      }
      break label$7;
     }
     jsvGetString(HEAP32[$3 + 100 >> 2], $3 + 16 | 0, 64);
     HEAP32[$3 + 92 >> 2] = jspGetNamedFieldInParents(HEAP32[$3 + 104 >> 2], $3 + 16 | 0, HEAP8[$3 + 99 | 0] & 1);
     label$11: {
      if (HEAP32[$3 + 92 >> 2]) {
       break label$11;
      }
      if (!(jsvIsFunction(HEAP32[$3 + 104 >> 2]) & 1)) {
       break label$11;
      }
      if (!(jsvIsStringEqual(HEAP32[$3 + 100 >> 2], 132159) & 1)) {
       break label$11;
      }
      HEAP32[$3 + 12 >> 2] = jsvNewObject();
      HEAP32[$3 + 92 >> 2] = jsvAddNamedChild(HEAP32[$3 + 104 >> 2], HEAP32[$3 + 12 >> 2], 132159);
      jsvUnLock(HEAP32[$3 + 12 >> 2]);
     }
    }
   }
  }
  if (HEAP8[$3 + 99 | 0] & 1) {
   HEAP32[$3 + 108 >> 2] = HEAP32[$3 + 92 >> 2];
   break label$2;
  }
  HEAP32[$3 + 108 >> 2] = jsvSkipNameAndUnLock(HEAP32[$3 + 92 >> 2]);
 }
 __stack_pointer = $3 + 112 | 0;
 return HEAP32[$3 + 108 >> 2];
}

function jsiDumpObjectState($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 60 >> 2] = $0;
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP32[$4 + 48 >> 2] = $3;
 HEAP32[$4 + 44 >> 2] = jsvGetInternalFunctionCheckerFor(HEAP32[$4 + 48 >> 2]);
 jsvObjectIteratorNew($4 + 40 | 0, HEAP32[$4 + 48 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue_3($4 + 40 | 0) & 1) {
   HEAP32[$4 + 36 >> 2] = jsvObjectIteratorGetKey_3($4 + 40 | 0);
   HEAP32[$4 + 32 >> 2] = jsvObjectIteratorGetValue_3($4 + 40 | 0);
   label$3: {
    if (HEAP32[$4 + 44 >> 2]) {
     if (FUNCTION_TABLE[HEAP32[$4 + 44 >> 2]](HEAP32[$4 + 36 >> 2]) & 1) {
      break label$3;
     }
    }
    label$5: {
     if (jsvIsStringEqual(HEAP32[$4 + 36 >> 2], 132159) & 1) {
      HEAP32[$4 + 28 >> 2] = jsvNewFromStringVarComplete(HEAP32[$4 + 52 >> 2]);
      if (HEAP32[$4 + 28 >> 2]) {
       jsvAppendString(HEAP32[$4 + 28 >> 2], 132158);
       jsiDumpObjectState(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2], HEAP32[$4 + 28 >> 2], HEAP32[$4 + 32 >> 2]);
       jsvUnLock(HEAP32[$4 + 28 >> 2]);
      }
      break label$5;
     }
     label$8: {
      if (jsvIsStringEqualOrStartsWith(HEAP32[$4 + 36 >> 2], 128471, 1) & 1) {
       if (jsvIsArray(HEAP32[$4 + 32 >> 2]) & 1) {
        jsvObjectIteratorNew($4 + 24 | 0, HEAP32[$4 + 32 >> 2]);
        while (1) {
         if (jsvObjectIteratorHasValue_3($4 + 24 | 0) & 1) {
          HEAP32[$4 + 20 >> 2] = jsvObjectIteratorGetValue_3($4 + 24 | 0);
          jsiDumpEvent(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 36 >> 2], HEAP32[$4 + 20 >> 2]);
          jsvUnLock(HEAP32[$4 + 20 >> 2]);
          jsvObjectIteratorNext($4 + 24 | 0);
          continue;
         }
         break;
        }
        jsvObjectIteratorFree_3($4 + 24 | 0);
        break label$8;
       }
       jsiDumpEvent(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 36 >> 2], HEAP32[$4 + 32 >> 2]);
       break label$8;
      }
      if (!(jsvIsNativeFunction(HEAP32[$4 + 32 >> 2]) & 1)) {
       $0 = HEAP32[$4 + 60 >> 2];
       $1 = HEAP32[$4 + 56 >> 2];
       $2 = HEAP32[$4 + 52 >> 2];
       HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 36 >> 2];
       HEAP32[$4 >> 2] = $2;
       cbprintf($0, $1, 146232, $4);
       jsiDumpJSON(HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2], HEAP32[$4 + 32 >> 2], 0);
       FUNCTION_TABLE[HEAP32[$4 + 60 >> 2]](147435, HEAP32[$4 + 56 >> 2]);
      }
     }
    }
   }
   jsvUnLock2(HEAP32[$4 + 32 >> 2], HEAP32[$4 + 36 >> 2]);
   jsvObjectIteratorNext($4 + 40 | 0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree_3($4 + 40 | 0);
 __stack_pointer = $4 - -64 | 0;
}

function jsserialEventCallbackIdle() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $0 = __stack_pointer + -64 | 0;
 __stack_pointer = $0;
 HEAP8[$0 + 62 | 0] = 0;
 HEAP32[$0 + 56 >> 2] = jsserialGetSerialList(0);
 label$1: {
  if (!HEAP32[$0 + 56 >> 2]) {
   HEAP8[$0 + 63 | 0] = 0;
   break label$1;
  }
  jsvObjectIteratorNew($0 + 48 | 0, HEAP32[$0 + 56 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_4($0 + 48 | 0) & 1) {
    HEAP32[$0 + 44 >> 2] = jsvObjectIteratorGetValue_4($0 + 48 | 0);
    HEAP32[$0 + 40 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 44 >> 2], 135840);
    HEAP32[$0 + 36 >> 2] = jsvGetFlatStringPointer(HEAP32[$0 + 40 >> 2]);
    if (HEAP32[$0 + 36 >> 2]) {
     if (HEAPU8[HEAP32[$0 + 36 >> 2] + 88 | 0]) {
      HEAP32[$0 + 24 >> 2] = jshGetSystemTime();
      HEAP32[$0 + 28 >> 2] = i64toi32_i32$HIGH_BITS;
      $5 = HEAP32[$0 + 28 >> 2];
      $2 = HEAP32[$0 + 36 >> 2];
      $3 = HEAP32[$2 + 72 >> 2];
      $1 = HEAP32[$2 + 76 >> 2];
      $2 = HEAP32[$0 + 24 >> 2];
      $1 = $1 + ($3 >>> 0 > $2 >>> 0) | 0;
      HEAP32[$0 + 16 >> 2] = $2 - $3;
      $1 = $5 - $1 | 0;
      HEAP32[$0 + 20 >> 2] = $1;
      $1 = HEAP32[$0 + 16 >> 2];
      $2 = HEAP32[$0 + 20 >> 2];
      $4 = jshGetMillisecondsFromTime($1, $2) * +HEAP32[HEAP32[$0 + 36 >> 2] + 80 >> 2] / 1e3 + .5;
      label$7: {
       if (Math_abs($4) < 2147483648) {
        $1 = ~~$4;
        break label$7;
       }
       $1 = -2147483648;
      }
      HEAP32[$0 + 12 >> 2] = $1;
      label$9: {
       if (HEAP32[$0 + 12 >> 2] > 10) {
        $1 = HEAP32[$0 + 36 >> 2];
        HEAP32[$1 + 84 >> 2] = HEAP32[$1 + 84 >> 2] | (1 << HEAP32[$0 + 12 >> 2]) - 1 << HEAPU8[HEAP32[$0 + 36 >> 2] + 88 | 0];
        $1 = HEAP32[$0 + 36 >> 2];
        HEAP8[$1 + 88 | 0] = HEAP32[$0 + 12 >> 2] + HEAPU8[$1 + 88 | 0];
        jsserialCheckForCharacter(HEAP32[$0 + 36 >> 2]);
        HEAP8[HEAP32[$0 + 36 >> 2] + 88 | 0] = 0;
        break label$9;
       }
       HEAP8[$0 + 62 | 0] = 1;
      }
     }
     if (HEAPU8[HEAP32[$0 + 36 >> 2] + 64 | 0]) {
      HEAP32[$0 + 8 >> 2] = jsvNewStringOfLength(HEAPU8[HEAP32[$0 + 36 >> 2] + 64 | 0], HEAP32[$0 + 36 >> 2]);
      HEAP8[HEAP32[$0 + 36 >> 2] + 64 | 0] = 0;
      if (HEAP32[$0 + 8 >> 2]) {
       jswrap_stream_pushData(HEAP32[$0 + 44 >> 2], HEAP32[$0 + 8 >> 2], 1);
       jsvUnLock(HEAP32[$0 + 8 >> 2]);
      }
     }
    }
    jsvUnLock2(HEAP32[$0 + 40 >> 2], HEAP32[$0 + 44 >> 2]);
    jsvObjectIteratorNext($0 + 48 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_4($0 + 48 | 0);
  jsvUnLock(HEAP32[$0 + 56 >> 2]);
  HEAP8[$0 + 63 | 0] = HEAP8[$0 + 62 | 0] & 1;
 }
 __stack_pointer = $0 - -64 | 0;
 return HEAP8[$0 + 63 | 0] & 1;
}

function jswrap_string_match($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1: {
  if (!(jsvIsString(HEAP32[$2 + 40 >> 2]) & 1)) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  if (jsvIsUndefined(HEAP32[$2 + 36 >> 2]) & 1) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  if (jsvIsInstanceOf(HEAP32[$2 + 36 >> 2], 121677) & 1) {
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 36 >> 2], 116445, jsvNewFromInteger(0));
   HEAP32[$2 + 32 >> 2] = jswrap_regexp_exec(HEAP32[$2 + 36 >> 2], HEAP32[$2 + 40 >> 2]);
   if (!(jswrap_regexp_hasFlag(HEAP32[$2 + 36 >> 2], 103) & 1)) {
    HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
    break label$1;
   }
   HEAP32[$2 + 28 >> 2] = jsvNewEmptyArray();
   if (!HEAP32[$2 + 28 >> 2]) {
    HEAP32[$2 + 44 >> 2] = 0;
    break label$1;
   }
   while (1) {
    $0 = 0;
    if (HEAP32[$2 + 32 >> 2]) {
     $0 = jsvIsNull(HEAP32[$2 + 32 >> 2]) ^ -1;
    }
    if ($0 & 1) {
     HEAP32[$2 + 24 >> 2] = jsvGetArrayItem(HEAP32[$2 + 32 >> 2], 0);
     HEAP32[$2 + 20 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 32 >> 2], 116439);
     HEAP32[$2 + 16 >> 2] = jsvGetStringLength(HEAP32[$2 + 24 >> 2]);
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 20 >> 2] + HEAP32[$2 + 16 >> 2];
     jsvArrayPushAndUnLock(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]);
     jsvUnLock(HEAP32[$2 + 32 >> 2]);
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 36 >> 2], 116445, jsvNewFromInteger(HEAP32[$2 + 12 >> 2] + !HEAP32[$2 + 16 >> 2] | 0));
     HEAP32[$2 + 32 >> 2] = jswrap_regexp_exec(HEAP32[$2 + 36 >> 2], HEAP32[$2 + 40 >> 2]);
     continue;
    }
    break;
   }
   jsvUnLock(HEAP32[$2 + 32 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 36 >> 2], 116445, jsvNewFromInteger(0));
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 28 >> 2];
   break label$1;
  }
  HEAP32[$2 + 36 >> 2] = jsvAsString(HEAP32[$2 + 36 >> 2]);
  HEAP32[$2 + 8 >> 2] = jswrap_string_indexOf(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], 0, 0);
  if (HEAP32[$2 + 8 >> 2] >= 0) {
   HEAP32[$2 + 4 >> 2] = jsvNewEmptyArray();
   if (!HEAP32[$2 + 4 >> 2]) {
    jsvUnLock(HEAP32[$2 + 36 >> 2]);
    HEAP32[$2 + 44 >> 2] = 0;
    break label$1;
   }
   jsvArrayPush(HEAP32[$2 + 4 >> 2], HEAP32[$2 + 36 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 4 >> 2], 116439, jsvNewFromInteger(HEAP32[$2 + 8 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 4 >> 2], 117136, HEAP32[$2 + 36 >> 2]);
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 4 >> 2];
   break label$1;
  }
  jsvUnLock(HEAP32[$2 + 36 >> 2]);
  HEAP32[$2 + 44 >> 2] = jsvNewNull();
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function jsfGetJSONForFunctionWithCallback($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 60 >> 2] = $0;
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP32[$4 + 48 >> 2] = $3;
 HEAP32[$4 + 44 >> 2] = 0;
 jsvObjectIteratorNew($4 + 40 | 0, HEAP32[$4 + 60 >> 2]);
 HEAP8[$4 + 39 | 0] = 1;
 cbprintf(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 145240, 0);
 while (1) {
  if (jsvObjectIteratorHasValue_8($4 + 40 | 0) & 1) {
   HEAP32[$4 + 32 >> 2] = jsvObjectIteratorGetKey_5($4 + 40 | 0);
   label$3: {
    if (jsvIsFunctionParameter(HEAP32[$4 + 32 >> 2]) & 1) {
     label$5: {
      if (HEAP8[$4 + 39 | 0] & 1) {
       HEAP8[$4 + 39 | 0] = 0;
       break label$5;
      }
      cbprintf(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 141344, 0);
     }
     HEAP32[$4 + 28 >> 2] = jsvNewFromStringVar(HEAP32[$4 + 32 >> 2], 1, 2147483647);
     $0 = HEAP32[$4 + 52 >> 2];
     $1 = HEAP32[$4 + 48 >> 2];
     HEAP32[$4 >> 2] = HEAP32[$4 + 28 >> 2];
     cbprintf($0, $1, 116903, $4);
     jsvUnLock(HEAP32[$4 + 28 >> 2]);
     break label$3;
    }
    label$7: {
     if (!(jsvIsString(HEAP32[$4 + 32 >> 2]) & 1)) {
      break label$7;
     }
     if (!(jsvIsStringEqual(HEAP32[$4 + 32 >> 2], 133204) & 1)) {
      break label$7;
     }
     HEAP32[$4 + 44 >> 2] = jsvObjectIteratorGetValue_8($4 + 40 | 0);
    }
   }
   jsvUnLock(HEAP32[$4 + 32 >> 2]);
   jsvObjectIteratorNext($4 + 40 | 0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree_8($4 + 40 | 0);
 cbprintf(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 146378, 0);
 label$8: {
  if (jsvIsNativeFunction(HEAP32[$4 + 60 >> 2]) & 1) {
   cbprintf(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 116045, 0);
   break label$8;
  }
  label$10: {
   if (HEAP32[$4 + 44 >> 2]) {
    if (HEAP32[$4 + 56 >> 2] & 8) {
     $0 = HEAP32[$4 + 52 >> 2];
     $1 = HEAP32[$4 + 48 >> 2];
     HEAP32[$4 + 16 >> 2] = HEAP32[48929];
     cbprintf($0, $1, 114581, $4 + 16 | 0);
     break label$10;
    }
    HEAP8[$4 + 27 | 0] = (jsvGetStringIndexOf(HEAP32[$4 + 44 >> 2], 10) | 0) >= 0;
    FUNCTION_TABLE[HEAP32[$4 + 52 >> 2]](HEAP8[$4 + 27 | 0] & 1 ? 146386 : 116071, HEAP32[$4 + 48 >> 2]);
    if (jsvIsFunctionReturn(HEAP32[$4 + 60 >> 2]) & 1) {
     FUNCTION_TABLE[HEAP32[$4 + 52 >> 2]](146094, HEAP32[$4 + 48 >> 2]);
    }
    jslPrintTokenisedString(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2]);
    FUNCTION_TABLE[HEAP32[$4 + 52 >> 2]](HEAP8[$4 + 27 | 0] & 1 ? 116063 : 116064, HEAP32[$4 + 48 >> 2]);
    break label$10;
   }
   cbprintf(HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 114578, 0);
  }
 }
 jsvUnLock(HEAP32[$4 + 44 >> 2]);
 __stack_pointer = $4 - -64 | 0;
}

function jsfLoadBootCodeFromFlash($0) {
 var $1 = 0, $2 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $1 = __stack_pointer - 160 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 158 | 0] = $0;
 if (!(wasm2js_i32$0 = jshPinGetValue(17) & 1, wasm2js_i32$1 = 1, wasm2js_i32$2 = HEAPU16[182206] & 4096, 
 wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1)) {
  jsfNameFromString($1 + 120 | 0, 128557);
  HEAP32[$1 + 64 >> 2] = HEAP32[$1 + 144 >> 2];
  $2 = HEAP32[$1 + 140 >> 2];
  $0 = HEAP32[$1 + 136 >> 2];
  HEAP32[$1 + 56 >> 2] = $0;
  HEAP32[$1 + 60 >> 2] = $2;
  $0 = HEAP32[$1 + 132 >> 2];
  $2 = HEAP32[$1 + 128 >> 2];
  HEAP32[$1 + 48 >> 2] = $2;
  HEAP32[$1 + 52 >> 2] = $0;
  $2 = HEAP32[$1 + 124 >> 2];
  $0 = HEAP32[$1 + 120 >> 2];
  HEAP32[$1 + 40 >> 2] = $0;
  HEAP32[$1 + 44 >> 2] = $2;
  HEAP32[$1 + 152 >> 2] = jsfReadFile($1 + 40 | 0, 0, 0);
  if (HEAP32[$1 + 152 >> 2]) {
   jsvUnLock2(jspEvaluateVar(HEAP32[$1 + 152 >> 2], 0, 0), HEAP32[$1 + 152 >> 2]);
  }
 }
 if (!(wasm2js_i32$0 = jshPinGetValue(17) & 1, wasm2js_i32$1 = 0, wasm2js_i32$2 = HEAPU16[182206] & 4096, 
 wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1)) {
  $0 = HEAPU8[136358] | HEAPU8[136359] << 8 | (HEAPU8[136360] << 16 | HEAPU8[136361] << 24);
  HEAP8[$1 + 115 | 0] = $0;
  HEAP8[$1 + 116 | 0] = $0 >>> 8;
  HEAP8[$1 + 117 | 0] = $0 >>> 16;
  HEAP8[$1 + 118 | 0] = $0 >>> 24;
  HEAP32[$1 + 112 >> 2] = HEAPU8[136355] | HEAPU8[136356] << 8 | (HEAPU8[136357] << 16 | HEAPU8[136358] << 24);
  HEAP32[$1 + 108 >> 2] = 0;
  while (1) {
   if (HEAP32[$1 + 108 >> 2] < 4) {
    HEAP8[$1 + 117 | 0] = HEAP32[$1 + 108 >> 2] + 48;
    jsfNameFromString($1 + 72 | 0, $1 + 112 | 0);
    HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 96 >> 2];
    $0 = HEAP32[$1 + 92 >> 2];
    $2 = HEAP32[$1 + 88 >> 2];
    HEAP32[$1 + 24 >> 2] = $2;
    HEAP32[$1 + 28 >> 2] = $0;
    $2 = HEAP32[$1 + 84 >> 2];
    $0 = HEAP32[$1 + 80 >> 2];
    HEAP32[$1 + 16 >> 2] = $0;
    HEAP32[$1 + 20 >> 2] = $2;
    $0 = HEAP32[$1 + 76 >> 2];
    $2 = HEAP32[$1 + 72 >> 2];
    HEAP32[$1 + 8 >> 2] = $2;
    HEAP32[$1 + 12 >> 2] = $0;
    HEAP32[$1 + 104 >> 2] = jsfReadFile($1 + 8 | 0, 0, 0);
    if (HEAP32[$1 + 104 >> 2]) {
     jsvUnLock2(jspEvaluateVar(HEAP32[$1 + 104 >> 2], 0, 0), HEAP32[$1 + 104 >> 2]);
    }
    HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 108 >> 2] + 1;
    continue;
   }
   break;
  }
 }
 HEAP32[$1 + 68 >> 2] = jsfGetBootCodeFromFlash(HEAP8[$1 + 158 | 0] & 1);
 label$9: {
  if (!HEAP32[$1 + 68 >> 2]) {
   HEAP8[$1 + 159 | 0] = 0;
   break label$9;
  }
  jsvUnLock2(jspEvaluateVar(HEAP32[$1 + 68 >> 2], 0, 0), HEAP32[$1 + 68 >> 2]);
  HEAP8[$1 + 159 | 0] = 1;
 }
 __stack_pointer = $1 + 160 | 0;
 return HEAP8[$1 + 159 | 0] & 1;
}

function _jswrap_drawImageLayerGetPixel($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 HEAP32[$2 + 32 >> 2] = HEAP32[HEAP32[$2 + 40 >> 2] + 180 >> 2];
 HEAP32[$2 + 28 >> 2] = HEAP32[HEAP32[$2 + 40 >> 2] + 184 >> 2];
 label$1: {
  if (!(HEAP32[HEAP32[$2 + 40 >> 2] + 156 >> 2] <= (HEAP32[$2 + 32 >> 2] & -256) | HEAP32[HEAP32[$2 + 40 >> 2] + 160 >> 2] <= (HEAP32[$2 + 28 >> 2] & -256) | (HEAP32[$2 + 32 >> 2] | HEAP32[$2 + 28 >> 2]) < 0)) {
   HEAP32[$2 + 24 >> 2] = 0;
   HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 32 >> 2] >> 8;
   HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 28 >> 2] >> 8;
   label$3: {
    if (HEAP32[HEAP32[$2 + 40 >> 2] + 44 >> 2] == 8) {
     jsvStringIteratorGoto(HEAP32[$2 + 40 >> 2] + 120 | 0, HEAP32[HEAP32[$2 + 40 >> 2] + 56 >> 2], (HEAP32[HEAP32[$2 + 40 >> 2] + 60 >> 2] + HEAP32[$2 + 20 >> 2] | 0) + Math_imul(HEAP32[$2 + 16 >> 2], HEAP32[HEAP32[$2 + 40 >> 2] + 80 >> 2]) | 0);
     HEAP32[$2 + 24 >> 2] = jsvStringIteratorGetChar_6(HEAP32[$2 + 40 >> 2] + 120 | 0) & 255;
     break label$3;
    }
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 20 >> 2] + Math_imul(HEAP32[$2 + 16 >> 2], HEAP32[HEAP32[$2 + 40 >> 2] + 36 >> 2]);
    HEAP32[$2 + 8 >> 2] = Math_imul(HEAP32[$2 + 12 >> 2], HEAP32[HEAP32[$2 + 40 >> 2] + 44 >> 2]);
    jsvStringIteratorGoto(HEAP32[$2 + 40 >> 2] + 120 | 0, HEAP32[HEAP32[$2 + 40 >> 2] + 56 >> 2], HEAP32[HEAP32[$2 + 40 >> 2] + 60 >> 2] + (HEAP32[$2 + 8 >> 2] >> 3) | 0);
    HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] & 7;
    HEAP32[$2 + 24 >> 2] = jsvStringIteratorGetChar_6(HEAP32[$2 + 40 >> 2] + 120 | 0) & 255;
    HEAP32[$2 + 4 >> 2] = 8 - (HEAP32[$2 + 8 >> 2] + HEAP32[HEAP32[$2 + 40 >> 2] + 44 >> 2] | 0);
    while (1) {
     if (HEAP32[$2 + 4 >> 2] < 0) {
      jsvStringIteratorNext(HEAP32[$2 + 40 >> 2] + 120 | 0);
      HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 24 >> 2] << 8 | jsvStringIteratorGetChar_6(HEAP32[$2 + 40 >> 2] + 120 | 0) & 255;
      HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 8;
      continue;
     }
     break;
    }
    HEAP32[$2 + 24 >> 2] = HEAP32[HEAP32[$2 + 40 >> 2] + 72 >> 2] & HEAP32[$2 + 24 >> 2] >>> HEAP32[$2 + 4 >> 2];
   }
   if (HEAP32[HEAP32[$2 + 40 >> 2] + 52 >> 2] != HEAP32[$2 + 24 >> 2]) {
    if (HEAP32[HEAP32[$2 + 40 >> 2] + 64 >> 2]) {
     HEAP32[$2 + 24 >> 2] = HEAPU16[HEAP32[HEAP32[$2 + 40 >> 2] + 64 >> 2] + ((HEAP32[$2 + 24 >> 2] & HEAP32[HEAP32[$2 + 40 >> 2] + 68 >> 2]) << 1) >> 1];
    }
    HEAP32[HEAP32[$2 + 36 >> 2] >> 2] = HEAP32[$2 + 24 >> 2];
    HEAP8[$2 + 47 | 0] = 1;
    break label$1;
   }
  }
  HEAP8[$2 + 47 | 0] = 0;
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP8[$2 + 47 | 0] & 1;
}

function lcdFillRect_ArrayBuffer_flat2($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = __stack_pointer - 80 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 76 >> 2] = $0;
 HEAP32[$6 + 72 >> 2] = $1;
 HEAP32[$6 + 68 >> 2] = $2;
 HEAP32[$6 + 64 >> 2] = $3;
 HEAP32[$6 + 60 >> 2] = $4;
 HEAP32[$6 + 56 >> 2] = $5;
 label$1: {
  if ((HEAP32[$6 + 64 >> 2] - HEAP32[$6 + 72 >> 2] | 0) < 4) {
   lcdFillRect_ArrayBuffer_flat(HEAP32[$6 + 76 >> 2], HEAP32[$6 + 72 >> 2], HEAP32[$6 + 68 >> 2], HEAP32[$6 + 64 >> 2], HEAP32[$6 + 60 >> 2], HEAP32[$6 + 56 >> 2]);
   break label$1;
  }
  $0 = HEAP32[$6 + 76 >> 2];
  HEAP32[$6 + 52 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
  HEAP32[$6 + 56 >> 2] = HEAP32[$6 + 56 >> 2] & 3;
  HEAP8[$6 + 51 | 0] = HEAP32[$6 + 56 >> 2] & 255 | HEAP32[$6 + 56 >> 2] << 2 & 255;
  HEAP8[$6 + 51 | 0] = HEAPU8[$6 + 51 | 0] | HEAPU8[$6 + 51 | 0] << 4;
  HEAP32[$6 + 44 >> 2] = HEAP32[$6 + 68 >> 2];
  while (1) {
   if (HEAP32[$6 + 44 >> 2] > HEAP32[$6 + 60 >> 2]) {
    break label$1;
   }
   $0 = HEAP32[$6 + 76 >> 2];
   HEAP32[$6 + 40 >> 2] = Math_imul(HEAP32[$6 + 44 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
   HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 72 >> 2] + HEAP32[$6 + 40 >> 2];
   HEAP32[$6 + 32 >> 2] = HEAP32[$6 + 64 >> 2] + HEAP32[$6 + 40 >> 2];
   HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 52 >> 2] + (HEAP32[$6 + 36 >> 2] >> 2);
   if (HEAP32[$6 + 36 >> 2] & 3) {
    HEAP32[$6 + 24 >> 2] = 4 - (HEAP32[$6 + 36 >> 2] & 3);
    HEAP32[$6 + 20 >> 2] = 255 << (HEAP32[$6 + 24 >> 2] << 1) ^ -1;
    HEAP8[HEAP32[$6 + 28 >> 2]] = HEAPU8[HEAP32[$6 + 28 >> 2]] & (HEAP32[$6 + 20 >> 2] ^ -1) | HEAPU8[$6 + 51 | 0] & HEAP32[$6 + 20 >> 2];
    HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 28 >> 2] + 1;
    HEAP32[$6 + 36 >> 2] = (HEAP32[$6 + 36 >> 2] & -4) + 4;
   }
   while (1) {
    if (HEAP32[$6 + 32 >> 2] >= (HEAP32[$6 + 36 >> 2] + 3 | 0)) {
     $1 = HEAPU8[$6 + 51 | 0];
     $0 = HEAP32[$6 + 28 >> 2];
     HEAP32[$6 + 28 >> 2] = $0 + 1;
     HEAP8[$0 | 0] = $1;
     HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 36 >> 2] + 4;
     continue;
    }
    break;
   }
   if (HEAP32[$6 + 36 >> 2] <= HEAP32[$6 + 32 >> 2]) {
    HEAP32[$6 + 16 >> 2] = (HEAP32[$6 + 32 >> 2] + 1 | 0) - HEAP32[$6 + 36 >> 2];
    HEAP32[$6 + 12 >> 2] = 255 >> (HEAP32[$6 + 16 >> 2] << 1) ^ -1;
    HEAP8[HEAP32[$6 + 28 >> 2]] = HEAPU8[HEAP32[$6 + 28 >> 2]] & (HEAP32[$6 + 12 >> 2] ^ -1) | HEAPU8[$6 + 51 | 0] & HEAP32[$6 + 12 >> 2];
   }
   HEAP32[$6 + 44 >> 2] = HEAP32[$6 + 44 >> 2] + 1;
   continue;
  }
 }
 __stack_pointer = $6 + 80 | 0;
}

function jsvAddName($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 24 >> 2] = jsvRef(HEAP32[$2 + 24 >> 2]);
 label$1: {
  if (!(jsvIsArray(HEAP32[$2 + 28 >> 2]) & 1)) {
   break label$1;
  }
  if (!(jsvIsInt(HEAP32[$2 + 24 >> 2]) & 1)) {
   break label$1;
  }
  $0 = HEAP32[$2 + 24 >> 2];
  HEAP32[$2 + 20 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
  if (HEAP32[$2 + 20 >> 2] >= (jsvGetArrayLength(HEAP32[$2 + 28 >> 2]) | 0)) {
   jsvSetArrayLength(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2] + 1 | 0, 0);
  }
 }
 label$3: {
  if (jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535) {
   HEAP32[$2 + 16 >> 2] = jsvLock(jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535);
   if (jsvIsArray(HEAP32[$2 + 28 >> 2]) & 1) {
    while (1) {
     $0 = 0;
     if (HEAP32[$2 + 16 >> 2]) {
      $0 = (jsvCompareInteger(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 16 >> 2]) | 0) < 0;
     }
     if ($0) {
      HEAP16[$2 + 14 >> 1] = jsvGetPrevSibling(HEAP32[$2 + 16 >> 2]);
      jsvUnLock(HEAP32[$2 + 16 >> 2]);
      HEAP32[$2 + 16 >> 2] = jsvLockSafe(HEAPU16[$2 + 14 >> 1]);
      continue;
     }
     break;
    }
   }
   label$9: {
    if (HEAP32[$2 + 16 >> 2]) {
     label$11: {
      if (jsvGetNextSibling(HEAP32[$2 + 16 >> 2]) & 65535) {
       HEAP32[$2 + 8 >> 2] = jsvLock(jsvGetNextSibling(HEAP32[$2 + 16 >> 2]) & 65535);
       jsvSetPrevSibling(HEAP32[$2 + 8 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
       jsvSetNextSibling(HEAP32[$2 + 24 >> 2], jsvGetRef(HEAP32[$2 + 8 >> 2]) & 65535);
       jsvUnLock(HEAP32[$2 + 8 >> 2]);
       break label$11;
      }
      jsvSetLastChild(HEAP32[$2 + 28 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
     }
     jsvSetNextSibling(HEAP32[$2 + 16 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
     jsvSetPrevSibling(HEAP32[$2 + 24 >> 2], jsvGetRef(HEAP32[$2 + 16 >> 2]) & 65535);
     jsvUnLock(HEAP32[$2 + 16 >> 2]);
     break label$9;
    }
    HEAP32[$2 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 28 >> 2]) & 65535);
    jsvSetPrevSibling(HEAP32[$2 + 4 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
    jsvUnLock(HEAP32[$2 + 4 >> 2]);
    jsvSetNextSibling(HEAP32[$2 + 24 >> 2], jsvGetFirstChild(HEAP32[$2 + 28 >> 2]) & 65535);
    jsvSetFirstChild(HEAP32[$2 + 28 >> 2], jsvGetRef(HEAP32[$2 + 24 >> 2]) & 65535);
   }
   break label$3;
  }
  HEAP16[$2 + 2 >> 1] = jsvGetRef(HEAP32[$2 + 24 >> 2]);
  jsvSetFirstChild(HEAP32[$2 + 28 >> 2], HEAPU16[$2 + 2 >> 1]);
  jsvSetLastChild(HEAP32[$2 + 28 >> 2], HEAPU16[$2 + 2 >> 1]);
 }
 __stack_pointer = $2 + 32 | 0;
}

function utilTimerGetLastTask($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 jshInterruptOff();
 HEAP8[$4 + 15 | 0] = HEAPU8[366353];
 label$1: {
  if (HEAPU8[$4 + 15 | 0] != HEAPU8[366354]) {
   HEAP8[$4 + 15 | 0] = HEAPU8[$4 + 15 | 0] + 15 & 15;
   while (1) {
    if (HEAPU8[$4 + 15 | 0] != (HEAPU8[366354] + 15 & 15)) {
     if (FUNCTION_TABLE[HEAP32[$4 + 24 >> 2]](Math_imul(HEAPU8[$4 + 15 | 0], 25) + 366368 | 0, HEAP32[$4 + 20 >> 2]) & 1) {
      $3 = Math_imul(HEAPU8[$4 + 15 | 0], 25) + 366368 | 0;
      $0 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
      $2 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
      $5 = $0;
      $1 = HEAP32[$4 + 16 >> 2];
      $0 = $1;
      HEAP8[$0 | 0] = $5;
      HEAP8[$0 + 1 | 0] = $5 >>> 8;
      HEAP8[$0 + 2 | 0] = $5 >>> 16;
      HEAP8[$0 + 3 | 0] = $5 >>> 24;
      HEAP8[$0 + 4 | 0] = $2;
      HEAP8[$0 + 5 | 0] = $2 >>> 8;
      HEAP8[$0 + 6 | 0] = $2 >>> 16;
      HEAP8[$0 + 7 | 0] = $2 >>> 24;
      HEAP8[$0 + 24 | 0] = HEAPU8[$3 + 24 | 0];
      $0 = HEAPU8[$3 + 20 | 0] | HEAPU8[$3 + 21 | 0] << 8 | (HEAPU8[$3 + 22 | 0] << 16 | HEAPU8[$3 + 23 | 0] << 24);
      $2 = HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24);
      $5 = $2;
      $2 = $1;
      HEAP8[$2 + 16 | 0] = $5;
      HEAP8[$2 + 17 | 0] = $5 >>> 8;
      HEAP8[$2 + 18 | 0] = $5 >>> 16;
      HEAP8[$2 + 19 | 0] = $5 >>> 24;
      HEAP8[$2 + 20 | 0] = $0;
      HEAP8[$2 + 21 | 0] = $0 >>> 8;
      HEAP8[$2 + 22 | 0] = $0 >>> 16;
      HEAP8[$2 + 23 | 0] = $0 >>> 24;
      $2 = HEAPU8[$3 + 12 | 0] | HEAPU8[$3 + 13 | 0] << 8 | (HEAPU8[$3 + 14 | 0] << 16 | HEAPU8[$3 + 15 | 0] << 24);
      $0 = HEAPU8[$3 + 8 | 0] | HEAPU8[$3 + 9 | 0] << 8 | (HEAPU8[$3 + 10 | 0] << 16 | HEAPU8[$3 + 11 | 0] << 24);
      $5 = $0;
      $0 = $1;
      HEAP8[$0 + 8 | 0] = $5;
      HEAP8[$0 + 9 | 0] = $5 >>> 8;
      HEAP8[$0 + 10 | 0] = $5 >>> 16;
      HEAP8[$0 + 11 | 0] = $5 >>> 24;
      HEAP8[$0 + 12 | 0] = $2;
      HEAP8[$0 + 13 | 0] = $2 >>> 8;
      HEAP8[$0 + 14 | 0] = $2 >>> 16;
      HEAP8[$0 + 15 | 0] = $2 >>> 24;
      jshInterruptOn();
      HEAP8[$4 + 31 | 0] = 1;
      break label$1;
     } else {
      HEAP8[$4 + 15 | 0] = HEAPU8[$4 + 15 | 0] + 15 & 15;
      continue;
     }
    }
    break;
   }
  }
  jshInterruptOn();
  HEAP8[$4 + 31 | 0] = 0;
 }
 __stack_pointer = $4 + 32 | 0;
 return HEAP8[$4 + 31 | 0] & 1;
}

function jslPrintTokenLineMarker($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 96 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 92 >> 2] = $0;
 HEAP32[$4 + 88 >> 2] = $1;
 HEAP32[$4 + 84 >> 2] = $2;
 HEAP32[$4 + 80 >> 2] = $3;
 HEAP32[$4 + 76 >> 2] = 1;
 HEAP32[$4 + 72 >> 2] = 1;
 jsvGetLineAndCol(HEAP32[HEAP32[49079] + 84 >> 2], HEAP32[$4 + 84 >> 2], $4 + 76 | 0, $4 + 72 | 0);
 HEAP32[$4 + 68 >> 2] = jsvGetIndexFromLineAndCol(HEAP32[HEAP32[49079] + 84 >> 2], HEAP32[$4 + 76 >> 2], 1);
 HEAP32[$4 + 64 >> 2] = jsvGetCharsOnLine(HEAP32[HEAP32[49079] + 84 >> 2], HEAP32[$4 + 76 >> 2]);
 HEAP32[$4 + 60 >> 2] = 0;
 if (HEAP32[$4 + 80 >> 2]) {
  FUNCTION_TABLE[HEAP32[$4 + 92 >> 2]](HEAP32[$4 + 80 >> 2], HEAP32[$4 + 88 >> 2]);
  HEAP32[$4 + 60 >> 2] = strlen(HEAP32[$4 + 80 >> 2]);
 }
 if (!(HEAPU32[$4 + 64 >> 2] <= 60 | HEAP32[$4 + 84 >> 2] - HEAP32[$4 + 68 >> 2] >>> 0 <= 30)) {
  cbprintf(HEAP32[$4 + 92 >> 2], HEAP32[$4 + 88 >> 2], 141032, 0);
  HEAP32[$4 + 56 >> 2] = (HEAP32[$4 + 84 >> 2] - 30 | 0) - HEAP32[$4 + 68 >> 2];
  HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 68 >> 2] + (HEAP32[$4 + 56 >> 2] + 3 | 0);
  label$3: {
   if (HEAPU32[$4 + 56 >> 2] <= HEAPU32[$4 + 72 >> 2]) {
    HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 72 >> 2] - HEAP32[$4 + 56 >> 2];
    break label$3;
   }
   HEAP32[$4 + 72 >> 2] = 0;
  }
  HEAP32[$4 + 64 >> 2] = HEAP32[$4 + 64 >> 2] - HEAP32[$4 + 56 >> 2];
 }
 HEAP32[$4 + 52 >> 2] = 0;
 jsvStringIteratorNew($4 + 16 | 0, HEAP32[HEAP32[49079] + 84 >> 2], HEAP32[$4 + 68 >> 2]);
 HEAP8[$4 + 15 | 0] = 0;
 while (1) {
  label$6: {
   $0 = 0;
   label$7: {
    if (!(jsvStringIteratorHasChar($4 + 16 | 0) & 1)) {
     break label$7;
    }
    $0 = 0;
    if (HEAPU32[$4 + 52 >> 2] >= 60) {
     break label$7;
    }
    $0 = HEAPU8[$4 + 15 | 0] != 255;
   }
   if (!$0) {
    break label$6;
   }
   if ((jsvStringIteratorGetChar($4 + 16 | 0) & 255) == 10) {
    break label$6;
   }
   jslPrintTokenisedChar($4 + 16 | 0, $4 + 15 | 0, $4 + 72 | 0, $4 + 52 | 0, HEAP32[$4 + 92 >> 2], HEAP32[$4 + 88 >> 2]);
   continue;
  }
  break;
 }
 jsvStringIteratorFree($4 + 16 | 0);
 if (HEAPU32[$4 + 64 >> 2] > 60) {
  FUNCTION_TABLE[HEAP32[$4 + 92 >> 2]](141032, HEAP32[$4 + 88 >> 2]);
 }
 FUNCTION_TABLE[HEAP32[$4 + 92 >> 2]](148266, HEAP32[$4 + 88 >> 2]);
 HEAP32[$4 + 72 >> 2] = HEAP32[$4 + 60 >> 2] + HEAP32[$4 + 72 >> 2];
 while (1) {
  $0 = HEAP32[$4 + 72 >> 2];
  HEAP32[$4 + 72 >> 2] = $0 - 1;
  if ($0 >>> 0 > 1) {
   FUNCTION_TABLE[HEAP32[$4 + 92 >> 2]](146437, HEAP32[$4 + 88 >> 2]);
   continue;
  }
  break;
 }
 FUNCTION_TABLE[HEAP32[$4 + 92 >> 2]](147289, HEAP32[$4 + 88 >> 2]);
 __stack_pointer = $4 + 96 | 0;
}

function jswrap_graphics_drawPoly_X($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 192 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 184 >> 2] = $0;
 HEAP32[$4 + 180 >> 2] = $1;
 HEAP8[$4 + 179 | 0] = $2;
 HEAP8[$4 + 178 | 0] = $3;
 label$1: {
  if (!(graphicsGetFromVar($4 + 104 | 0, HEAP32[$4 + 184 >> 2]) & 1)) {
   HEAP32[$4 + 188 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsIterable(HEAP32[$4 + 180 >> 2]) & 1)) {
   HEAP32[$4 + 188 >> 2] = 0;
   break label$1;
  }
  label$4: {
   if (HEAP8[$4 + 178 | 0] & 1) {
    HEAP32[$4 + 100 >> 2] = 16;
    HEAP32[$4 + 96 >> 2] = 665;
    break label$4;
   }
   HEAP32[$4 + 100 >> 2] = 1;
   HEAP32[$4 + 96 >> 2] = 666;
  }
  HEAP32[$4 + 76 >> 2] = 0;
  jsvIteratorNew($4 + 16 | 0, HEAP32[$4 + 180 >> 2], 1);
  while (1) {
   label$7: {
    if (!(jsvIteratorHasElement($4 + 16 | 0) & 1)) {
     break label$7;
    }
    $5 = jsvIteratorGetFloatValue($4 + 16 | 0) * +HEAP32[$4 + 100 >> 2] + .5;
    label$8: {
     if (Math_abs($5) < 2147483648) {
      $0 = ~~$5;
      break label$8;
     }
     $0 = -2147483648;
    }
    HEAP32[$4 + 12 >> 2] = $0;
    jsvIteratorNext($4 + 16 | 0);
    if (!(jsvIteratorHasElement($4 + 16 | 0) & 1)) {
     break label$7;
    }
    $5 = jsvIteratorGetFloatValue($4 + 16 | 0) * +HEAP32[$4 + 100 >> 2] + .5;
    label$10: {
     if (Math_abs($5) < 2147483648) {
      $0 = ~~$5;
      break label$10;
     }
     $0 = -2147483648;
    }
    HEAP32[$4 + 8 >> 2] = $0;
    jsvIteratorNext($4 + 16 | 0);
    label$12: {
     if (!HEAP32[$4 + 76 >> 2]) {
      HEAP32[$4 + 84 >> 2] = HEAP32[$4 + 12 >> 2];
      HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 8 >> 2];
      break label$12;
     }
     FUNCTION_TABLE[HEAP32[$4 + 96 >> 2]]($4 + 104 | 0, HEAP32[$4 + 92 >> 2], HEAP32[$4 + 88 >> 2], HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2]);
    }
    HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 12 >> 2];
    HEAP32[$4 + 88 >> 2] = HEAP32[$4 + 8 >> 2];
    HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 76 >> 2] + 1;
    continue;
   }
   break;
  }
  jsvIteratorFree($4 + 16 | 0);
  $0 = HEAP32[$4 + 92 >> 2] / HEAP32[$4 + 100 >> 2] | 0;
  HEAP8[$4 + 131 | 0] = $0;
  HEAP8[$4 + 132 | 0] = $0 >>> 8;
  $0 = HEAP32[$4 + 88 >> 2] / HEAP32[$4 + 100 >> 2] | 0;
  HEAP8[$4 + 133 | 0] = $0;
  HEAP8[$4 + 134 | 0] = $0 >>> 8;
  if (HEAP8[$4 + 179 | 0] & 1) {
   FUNCTION_TABLE[HEAP32[$4 + 96 >> 2]]($4 + 104 | 0, HEAP32[$4 + 92 >> 2], HEAP32[$4 + 88 >> 2], HEAP32[$4 + 84 >> 2], HEAP32[$4 + 80 >> 2]);
  }
  graphicsSetVar($4 + 104 | 0);
  HEAP32[$4 + 188 >> 2] = jsvLockAgain(HEAP32[$4 + 184 >> 2]);
 }
 __stack_pointer = $4 + 192 | 0;
 return HEAP32[$4 + 188 >> 2];
}

function tflite__ops__micro__fully_connected__EvalQuantizedInt8_28TfLiteContext__2c_20TfLiteNode__2c_20tflite__ops__micro__fully_connected___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = __stack_pointer - 176 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 172 >> 2] = $0;
 HEAP32[$7 + 168 >> 2] = $1;
 HEAP32[$7 + 164 >> 2] = $2;
 HEAP32[$7 + 160 >> 2] = $3;
 HEAP32[$7 + 156 >> 2] = $4;
 HEAP32[$7 + 152 >> 2] = $5;
 HEAP32[$7 + 148 >> 2] = $6;
 HEAP32[$7 + 104 >> 2] = 0 - HEAP32[HEAP32[$7 + 164 >> 2] + 20 >> 2];
 HEAP32[$7 + 108 >> 2] = 0 - HEAP32[HEAP32[$7 + 164 >> 2] + 24 >> 2];
 HEAP32[$7 + 112 >> 2] = HEAP32[HEAP32[$7 + 164 >> 2] + 28 >> 2];
 HEAP32[$7 + 116 >> 2] = HEAP32[HEAP32[$7 + 164 >> 2] >> 2];
 HEAP32[$7 + 120 >> 2] = 0 - HEAP32[HEAP32[$7 + 164 >> 2] + 4 >> 2];
 HEAP32[$7 + 124 >> 2] = HEAP32[HEAP32[$7 + 164 >> 2] + 8 >> 2];
 HEAP32[$7 + 128 >> 2] = HEAP32[HEAP32[$7 + 164 >> 2] + 12 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 80 | 0, HEAP32[$7 + 160 >> 2]);
 $0 = signed_20char_20const__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 160 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 56 | 0, HEAP32[$7 + 156 >> 2]);
 $1 = signed_20char_20const__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 156 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 32 | 0, HEAP32[$7 + 152 >> 2]);
 $2 = int_20const__20tflite__micro__GetTensorData_int__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 152 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 8 | 0, HEAP32[$7 + 148 >> 2]);
 tflite__reference_integer_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($7 + 104 | 0, $7 + 80 | 0, $0, $7 + 56 | 0, $1, $7 + 32 | 0, $2, $7 + 8 | 0, signed_20char__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor__29(HEAP32[$7 + 148 >> 2]));
 tflite__RuntimeShape___RuntimeShape_28_29($7 + 8 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($7 + 32 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($7 + 56 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($7 + 80 | 0);
 __stack_pointer = $7 + 176 | 0;
 return 0;
}

function jswrap_promise_all($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer + -64 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 label$1: {
  if (!(jsvIsIterable(HEAP32[$1 + 56 >> 2]) & 1)) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 56 >> 2];
   jsExceptionHere(3, 118982, $1);
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 48 >> 2] = jspromise_create_prombox($1 + 52 | 0);
  if (!HEAP32[$1 + 48 >> 2]) {
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$1 + 52 >> 2]) {
   HEAP32[$1 + 44 >> 2] = _jswrap_promise_native_with_prombox(654, HEAP32[$1 + 48 >> 2]);
   if (!HEAP32[$1 + 44 >> 2]) {
    HEAP32[$1 + 60 >> 2] = jsvLockAgainSafe(HEAP32[$1 + 52 >> 2]);
    break label$1;
   }
   HEAP32[$1 + 40 >> 2] = jsvNewEmptyArray();
   HEAP32[$1 + 36 >> 2] = 0;
   HEAP32[$1 + 32 >> 2] = 0;
   jsvObjectIteratorNew($1 + 24 | 0, HEAP32[$1 + 56 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_17($1 + 24 | 0) & 1) {
     HEAP32[$1 + 20 >> 2] = jsvObjectIteratorGetValue_16($1 + 24 | 0);
     label$8: {
      if (_jswrap_promise_is_promise(HEAP32[$1 + 20 >> 2]) & 1) {
       HEAP32[$1 + 16 >> 2] = jsvNewNativeFunction(655, 32840);
       HEAP32[$1 + 12 >> 2] = jsvNewFromInteger(HEAP32[$1 + 36 >> 2]);
       jsvAddFunctionParameter(HEAP32[$1 + 16 >> 2], 0, HEAP32[$1 + 12 >> 2]);
       jsvObjectSetChild(HEAP32[$1 + 16 >> 2], 120157, HEAP32[$1 + 48 >> 2]);
       jsvUnLock3(jswrap_promise_then(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2], HEAP32[$1 + 44 >> 2]), HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2]);
       break label$8;
      }
      jsvSetArrayItem(HEAP32[$1 + 40 >> 2], HEAP32[$1 + 36 >> 2], HEAP32[$1 + 20 >> 2]);
      HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 32 >> 2] + 1;
     }
     jsvUnLock(HEAP32[$1 + 20 >> 2]);
     HEAP32[$1 + 36 >> 2] = HEAP32[$1 + 36 >> 2] + 1;
     jsvObjectIteratorNext($1 + 24 | 0);
     continue;
    }
    break;
   }
   jsvObjectIteratorFree_17($1 + 24 | 0);
   label$10: {
    if (HEAP32[$1 + 32 >> 2] == HEAP32[$1 + 36 >> 2]) {
     HEAP32[$1 + 52 >> 2] = jswrap_promise_resolve(HEAP32[$1 + 40 >> 2]);
     jsvUnLock2(HEAP32[$1 + 52 >> 2], HEAP32[$1 + 40 >> 2]);
     break label$10;
    }
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 52 >> 2], 128058, jsvNewFromInteger(HEAP32[$1 + 36 >> 2] - HEAP32[$1 + 32 >> 2] | 0));
    jsvObjectSetChildAndUnLock(HEAP32[$1 + 52 >> 2], 120220, HEAP32[$1 + 40 >> 2]);
   }
   jsvUnLock2(HEAP32[$1 + 44 >> 2], HEAP32[$1 + 48 >> 2]);
  }
  HEAP32[$1 + 60 >> 2] = jsvLockAgainSafe(HEAP32[$1 + 52 >> 2]);
 }
 __stack_pointer = $1 - -64 | 0;
 return HEAP32[$1 + 60 >> 2];
}

function jspeTemplateLiteral() {
 var $0 = 0;
 $0 = __stack_pointer - 144 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 140 >> 2] = 0;
 if ((HEAP32[91094] & 63) == 1) {
  HEAP32[$0 + 136 >> 2] = jslGetTokenValueAsVar();
  HEAP32[$0 + 140 >> 2] = jsvNewFromEmptyString_3();
  if (!(!HEAP32[$0 + 140 >> 2] | !HEAP32[$0 + 136 >> 2])) {
   jsvStringIteratorNew($0 + 96 | 0, HEAP32[$0 + 136 >> 2], 0);
   jsvStringIteratorNew($0 + 56 | 0, HEAP32[$0 + 140 >> 2], 0);
   while (1) {
    label$4: {
     if (!(jsvStringIteratorHasChar_4($0 + 96 | 0) & 1)) {
      break label$4;
     }
     HEAP8[$0 + 55 | 0] = jsvStringIteratorGetCharAndNext($0 + 96 | 0);
     label$5: {
      if (HEAP8[$0 + 55 | 0] == 36) {
       HEAP8[$0 + 55 | 0] = jsvStringIteratorGetChar_3($0 + 96 | 0);
       label$7: {
        if (HEAP8[$0 + 55 | 0] == 123) {
         jsvStringIteratorNext($0 + 96 | 0);
         HEAP32[$0 + 48 >> 2] = 1;
         HEAP32[$0 + 44 >> 2] = jsvNewFromEmptyString_3();
         if (!HEAP32[$0 + 44 >> 2]) {
          break label$4;
         }
         jsvStringIteratorNew($0 + 8 | 0, HEAP32[$0 + 44 >> 2], 0);
         while (1) {
          label$10: {
           if (!(jsvStringIteratorHasChar_4($0 + 96 | 0) & 1)) {
            break label$10;
           }
           HEAP8[$0 + 55 | 0] = jsvStringIteratorGetCharAndNext($0 + 96 | 0);
           if (HEAP8[$0 + 55 | 0] == 123) {
            HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 48 >> 2] + 1;
           }
           if (HEAP8[$0 + 55 | 0] == 125) {
            HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 48 >> 2] - 1;
            if (!HEAP32[$0 + 48 >> 2]) {
             break label$10;
            }
           }
           jsvStringIteratorAppend($0 + 8 | 0, HEAP8[$0 + 55 | 0]);
           continue;
          }
          break;
         }
         jsvStringIteratorFree_4($0 + 8 | 0);
         HEAP32[$0 + 4 >> 2] = jspEvaluateExpressionVar(HEAP32[$0 + 44 >> 2]);
         jsvUnLock(HEAP32[$0 + 44 >> 2]);
         HEAP32[$0 + 4 >> 2] = jsvAsStringAndUnLock(HEAP32[$0 + 4 >> 2]);
         jsvStringIteratorAppendString($0 + 56 | 0, HEAP32[$0 + 4 >> 2], 0, 2147483647);
         jsvUnLock(HEAP32[$0 + 4 >> 2]);
         break label$7;
        }
        jsvStringIteratorAppend($0 + 56 | 0, 36);
       }
       break label$5;
      }
      jsvStringIteratorAppend($0 + 56 | 0, HEAP8[$0 + 55 | 0]);
     }
     continue;
    }
    break;
   }
   jsvStringIteratorFree_4($0 + 96 | 0);
   jsvStringIteratorFree_4($0 + 56 | 0);
  }
  jsvUnLock(HEAP32[$0 + 136 >> 2]);
 }
 jslGetNextToken();
 __stack_pointer = $0 + 144 | 0;
 return HEAP32[$0 + 140 >> 2];
}

function jswrap_btoa($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 144 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 136 >> 2] = $0;
 label$1: {
  if (!(jsvIsIterable(HEAP32[$1 + 136 >> 2]) & 1)) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 136 >> 2];
   jsExceptionHere(1, 118343, $1);
   HEAP32[$1 + 140 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 132 >> 2] = jsvGetLength(HEAP32[$1 + 136 >> 2]);
  HEAP32[$1 + 128 >> 2] = (HEAP32[$1 + 132 >> 2] + 2 >>> 0) / 3 << 2;
  HEAP32[$1 + 124 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 128 >> 2], 0);
  if (!HEAP32[$1 + 124 >> 2]) {
   HEAP32[$1 + 140 >> 2] = 0;
   break label$1;
  }
  jsvIteratorNew($1 - -64 | 0, HEAP32[$1 + 136 >> 2], 1);
  jsvStringIteratorNew($1 + 24 | 0, HEAP32[$1 + 124 >> 2], 0);
  HEAP32[$1 + 20 >> 2] = 0;
  while (1) {
   $0 = 0;
   if (jsvIteratorHasElement($1 - -64 | 0) & 1) {
    $0 = jspIsInterrupted() ^ -1;
   }
   if ($0 & 1) {
    HEAP32[$1 + 16 >> 2] = jsvIteratorGetIntegerValue($1 - -64 | 0) & 255;
    jsvIteratorNext($1 - -64 | 0);
    HEAP32[$1 + 12 >> 2] = 0;
    HEAP32[$1 + 8 >> 2] = 0;
    label$7: {
     if (jsvIteratorHasElement($1 - -64 | 0) & 1) {
      HEAP32[$1 + 12 >> 2] = jsvIteratorGetIntegerValue($1 - -64 | 0) & 255;
      jsvIteratorNext($1 - -64 | 0);
      label$9: {
       if (jsvIteratorHasElement($1 - -64 | 0) & 1) {
        HEAP32[$1 + 8 >> 2] = jsvIteratorGetIntegerValue($1 - -64 | 0) & 255;
        jsvIteratorNext($1 - -64 | 0);
        HEAP32[$1 + 20 >> 2] = 0;
        break label$9;
       }
       HEAP32[$1 + 20 >> 2] = 1;
      }
      break label$7;
     }
     HEAP32[$1 + 20 >> 2] = 2;
    }
    HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 8 >> 2] + ((HEAP32[$1 + 16 >> 2] << 16) + (HEAP32[$1 + 12 >> 2] << 8) | 0);
    jsvStringIteratorSetCharAndNext($1 + 24 | 0, jswrap_btoa_encode(HEAP32[$1 + 4 >> 2] >> 18) << 24 >> 24);
    jsvStringIteratorSetCharAndNext($1 + 24 | 0, jswrap_btoa_encode(HEAP32[$1 + 4 >> 2] >> 12) << 24 >> 24);
    $2 = $1 + 24 | 0;
    if (HEAP32[$1 + 20 >> 2] > 1) {
     $0 = 61;
    } else {
     $0 = jswrap_btoa_encode(HEAP32[$1 + 4 >> 2] >> 6);
    }
    jsvStringIteratorSetCharAndNext($2, $0 << 24 >> 24);
    $2 = $1 + 24 | 0;
    if (HEAP32[$1 + 20 >> 2] > 0) {
     $0 = 61;
    } else {
     $0 = jswrap_btoa_encode(HEAP32[$1 + 4 >> 2]);
    }
    jsvStringIteratorSetCharAndNext($2, $0 << 24 >> 24);
    continue;
   }
   break;
  }
  jsvIteratorFree($1 - -64 | 0);
  jsvStringIteratorFree_7($1 + 24 | 0);
  HEAP32[$1 + 140 >> 2] = HEAP32[$1 + 124 >> 2];
 }
 __stack_pointer = $1 + 144 | 0;
 return HEAP32[$1 + 140 >> 2];
}

function jspeStatementTry() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 32 | 0;
 __stack_pointer = $0;
 jslGetNextToken();
 HEAP8[$0 + 27 | 0] = (HEAP32[91094] & 63) == 1;
 jspeBlock();
 $1 = HEAP8[$0 + 27 | 0] & 1 ? (HEAP32[91094] & 32) != 0 : $1;
 HEAP8[$0 + 26 | 0] = $1;
 HEAP8[$0 + 25 | 0] = 0;
 label$2: {
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 178) {
   jslGetNextToken();
   HEAP8[$0 + 25 | 0] = 1;
   HEAP32[$0 + 20 >> 2] = 0;
   HEAP32[$0 + 16 >> 2] = 0;
   label$4: {
    if (HEAP8[$0 + 27 | 0] & 1) {
     $1 = jspGetException();
     break label$4;
    }
    $1 = 0;
   }
   HEAP32[$0 + 12 >> 2] = $1;
   if (HEAP16[HEAP32[49079] + 2 >> 1] == 40) {
    if (!(jslMatch(40) & 1)) {
     break label$2;
    }
    if (HEAP8[$0 + 26 | 0] & 1) {
     HEAP32[$0 + 16 >> 2] = jsvNewObject();
     if (HEAP32[$0 + 16 >> 2]) {
      HEAP32[$0 + 20 >> 2] = jsvFindOrAddChildFromString(HEAP32[$0 + 16 >> 2], jslGetTokenValueAsString());
     }
    }
    if (!(jslMatch(128) & 1)) {
     jsvUnLock2(HEAP32[$0 + 16 >> 2], HEAP32[$0 + 20 >> 2]);
     break label$2;
    }
    if (!(jslMatch(41) & 1)) {
     jsvUnLock2(HEAP32[$0 + 16 >> 2], HEAP32[$0 + 20 >> 2]);
     break label$2;
    }
    if (HEAP32[$0 + 20 >> 2]) {
     if (HEAP32[$0 + 12 >> 2]) {
      jsvSetValueOfName(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 12 >> 2]);
     }
     jsvUnLock(HEAP32[$0 + 20 >> 2]);
    }
   }
   if (HEAP8[$0 + 27 | 0] & 1) {
    HEAP32[91094] = HEAP32[91094] & -161;
    jsvUnLock(HEAP32[$0 + 12 >> 2]);
   }
   label$15: {
    if (!(!(HEAP8[$0 + 27 | 0] & 1) | HEAP8[$0 + 26 | 0] & 1)) {
     HEAP32[$0 + 8 >> 2] = HEAP32[91094];
     jspSetNoExecute();
     jspeBlock();
     HEAP32[91094] = HEAP32[91094] & -1664 | HEAP32[$0 + 8 >> 2] & 1663;
     break label$15;
    }
    label$17: {
     if (HEAP32[$0 + 16 >> 2]) {
      if (!(jspeiAddScope(HEAP32[$0 + 16 >> 2]) & 1)) {
       break label$17;
      }
     }
     jspeBlock();
     if (HEAP32[$0 + 16 >> 2]) {
      jspeiRemoveScope();
     }
    }
   }
   jsvUnLock(HEAP32[$0 + 16 >> 2]);
  }
  if (!(HEAP8[$0 + 25 | 0] & 1 | HEAP32[91094] & 80 ? HEAP16[HEAP32[49079] + 2 >> 1] != 179 : 0)) {
   if (!(jslMatch(179) & 1)) {
    break label$2;
   }
   HEAP32[$0 + 4 >> 2] = HEAP32[91094];
   if (HEAP8[$0 + 27 | 0] & 1) {
    HEAP32[91094] = HEAP32[91094] & -47 | 1;
   }
   jspeBlock();
   HEAP32[91094] = HEAP32[$0 + 4 >> 2];
   if (!(!(HEAP8[$0 + 26 | 0] & 1) | HEAP8[$0 + 25 | 0] & 1)) {
    HEAP32[91094] = HEAP32[91094] | 32;
   }
  }
 }
 HEAP32[$0 + 28 >> 2] = 0;
 __stack_pointer = $0 + 32 | 0;
 return HEAP32[$0 + 28 >> 2];
}

function jsvCopyNameOnly($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP8[$3 + 23 | 0] = $1;
 HEAP8[$3 + 22 | 0] = $2;
 $0 = HEAP32[$3 + 24 >> 2];
 HEAP16[$3 + 20 >> 1] = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8;
 HEAP32[$3 + 16 >> 2] = 0;
 label$1: {
  if (!(HEAP8[$3 + 22 | 0] & 1)) {
   $0 = HEAP32[$3 + 24 >> 2];
   HEAP16[$3 + 14 >> 1] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
   label$3: {
    if (!(HEAPU16[$3 + 14 >> 1] < 15 | HEAPU16[$3 + 14 >> 1] > 17)) {
     HEAP16[$3 + 20 >> 1] = HEAPU16[$3 + 20 >> 1] & -64 | 10;
     break label$3;
    }
    label$5: {
     if (jsvGetLastChild(HEAP32[$3 + 24 >> 2]) & 65535) {
      HEAP32[$3 + 16 >> 2] = jsvNewFromStringVarComplete(HEAP32[$3 + 24 >> 2]);
      if (!HEAP32[$3 + 16 >> 2]) {
       HEAP32[$3 + 28 >> 2] = 0;
       break label$1;
      }
      break label$5;
     }
     HEAP16[$3 + 20 >> 1] = HEAPU16[$3 + 20 >> 1] & 65472 | jsvGetCharactersInVar(HEAP32[$3 + 24 >> 2]) + 28;
    }
   }
  }
  if (!HEAP32[$3 + 16 >> 2]) {
   HEAP32[$3 + 16 >> 2] = jsvNewWithFlags(HEAPU16[$3 + 20 >> 1] & 255);
   if (!HEAP32[$3 + 16 >> 2]) {
    HEAP32[$3 + 28 >> 2] = 0;
    break label$1;
   }
   $0 = HEAP32[$3 + 16 >> 2];
   $1 = HEAP32[$3 + 24 >> 2];
   $1 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
   HEAP8[$0 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1 >>> 8;
   HEAP8[$0 + 2 | 0] = $1 >>> 16;
   HEAP8[$0 + 3 | 0] = $1 >>> 24;
   if (jsvHasStringExt(HEAP32[$3 + 24 >> 2]) & 1) {
    if (jsvGetLastChild(HEAP32[$3 + 24 >> 2]) & 65535) {
     HEAP32[$3 + 8 >> 2] = jsvLock(jsvGetLastChild(HEAP32[$3 + 24 >> 2]) & 65535);
     HEAP32[$3 + 4 >> 2] = jsvCopy(HEAP32[$3 + 8 >> 2], 1);
     if (HEAP32[$3 + 4 >> 2]) {
      jsvSetLastChild(HEAP32[$3 + 16 >> 2], jsvGetRef(HEAP32[$3 + 4 >> 2]) & 65535);
      jsvUnLock(HEAP32[$3 + 4 >> 2]);
     }
     jsvUnLock(HEAP32[$3 + 8 >> 2]);
    }
   }
  }
  label$13: {
   if (!(HEAP8[$3 + 23 | 0] & 1)) {
    break label$13;
   }
   if (!(jsvGetFirstChild(HEAP32[$3 + 24 >> 2]) & 65535)) {
    break label$13;
   }
   label$14: {
    if (jsvIsNameWithValue(HEAP32[$3 + 24 >> 2]) & 1) {
     jsvSetFirstChild(HEAP32[$3 + 16 >> 2], jsvGetFirstChild(HEAP32[$3 + 24 >> 2]) & 65535);
     break label$14;
    }
    jsvSetFirstChild(HEAP32[$3 + 16 >> 2], jsvRefRef(jsvGetFirstChild(HEAP32[$3 + 24 >> 2]) & 65535) & 65535);
   }
  }
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 16 >> 2];
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function tflite__ParseSoftmax_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = Math_fround(0);
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 tflite___28anonymous_20namespace_29__CheckParsePointerParams_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29(HEAP32[$4 + 40 >> 2], HEAP32[$4 + 36 >> 2], HEAP32[$4 + 32 >> 2], HEAP32[$4 + 28 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($4 + 24 | 0, HEAP32[$4 + 32 >> 2]);
 std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteSoftmaxParams__28_29($4 + 16 | 0, $4 + 24 | 0);
 label$1: {
  if (!(bool_20std____2__operator___TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($4 + 16 | 0, 0) & 1)) {
   $0 = HEAP32[$4 + 36 >> 2];
   $1 = HEAP32[$4 + 36 >> 2];
   HEAP32[$4 >> 2] = 120702;
   tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($0, $1, 140586, $4);
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 8 >> 2] = tflite__Operator__builtin_options_as_SoftmaxOptions_28_29_20const(HEAP32[$4 + 40 >> 2]);
  if (HEAP32[$4 + 8 >> 2]) {
   $5 = tflite__SoftmaxOptions__beta_28_29_20const(HEAP32[$4 + 8 >> 2]);
   HEAPF32[std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($4 + 16 | 0) >> 2] = $5;
  }
  $0 = std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($4 + 16 | 0);
  HEAP32[HEAP32[$4 + 28 >> 2] >> 2] = $0;
  HEAP32[$4 + 44 >> 2] = 0;
 }
 HEAP32[$4 + 12 >> 2] = 1;
 std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($4 + 16 | 0);
 __stack_pointer = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}

function tflite__ops__micro__fully_connected__Prepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP32[$2 + 52 >> 2] = $1;
 label$1: {
  if (!HEAP32[HEAP32[$2 + 52 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (!HEAP32[HEAP32[$2 + 52 >> 2] + 12 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 48 >> 2] = HEAP32[HEAP32[$2 + 52 >> 2] + 8 >> 2];
 HEAP32[$2 + 44 >> 2] = HEAP32[HEAP32[$2 + 52 >> 2] + 12 >> 2];
 HEAP32[$2 + 40 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2], 0);
 HEAP32[$2 + 36 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2], 1);
 HEAP32[$2 + 32 >> 2] = tflite__GetOptionalInputTensor_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2], 2);
 HEAP32[$2 + 28 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2], 0);
 label$3: {
  if (HEAP32[HEAP32[$2 + 40 >> 2] + 28 >> 2] != HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2]) {
   $0 = HEAP32[HEAP32[$2 + 56 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 56 >> 2];
   $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 40 >> 2] + 28 >> 2]);
   HEAP32[$2 + 12 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 28 >> 2] + 28 >> 2]);
   HEAP32[$2 + 8 >> 2] = $3;
   HEAP32[$2 + 4 >> 2] = 132215;
   HEAP32[$2 >> 2] = 132228;
   FUNCTION_TABLE[$0 | 0]($1, 142883, $2);
   HEAP32[$2 + 60 >> 2] = 1;
   break label$3;
  }
  if (HEAP32[HEAP32[$2 + 40 >> 2] + 28 >> 2] != HEAP32[HEAP32[$2 + 36 >> 2] + 28 >> 2]) {
   FUNCTION_TABLE[HEAP32[HEAP32[$2 + 56 >> 2] + 20 >> 2]](HEAP32[$2 + 56 >> 2], 140427, 0);
   HEAP32[$2 + 60 >> 2] = 1;
   break label$3;
  }
  HEAP32[$2 + 60 >> 2] = tflite__ops__micro__fully_connected___28anonymous_20namespace_29__CalculateOpData_28TfLiteContext__2c_20TfLiteFusedActivation_2c_20TfLiteType_2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20tflite__ops__micro__fully_connected___28anonymous_20namespace_29__OpData__29(HEAP32[$2 + 56 >> 2], HEAP32[HEAP32[$2 + 44 >> 2] >> 2], HEAP32[HEAP32[$2 + 40 >> 2] + 28 >> 2], HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 32 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 48 >> 2]);
 }
 __stack_pointer = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}

function jswrap_graphics_createCallback($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 128 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 120 >> 2] = $0;
 HEAP32[$4 + 116 >> 2] = $1;
 HEAP32[$4 + 112 >> 2] = $2;
 HEAP32[$4 + 108 >> 2] = $3;
 label$1: {
  label$2: {
   if (!(HEAP32[$4 + 120 >> 2] <= 0 | HEAP32[$4 + 116 >> 2] <= 0 | HEAP32[$4 + 120 >> 2] > 32767)) {
    if (HEAP32[$4 + 116 >> 2] <= 32767) {
     break label$2;
    }
   }
   jsExceptionHere(1, 131663, 0);
   HEAP32[$4 + 124 >> 2] = 0;
   break label$1;
  }
  if (!(isValidBPP(HEAP32[$4 + 112 >> 2]) & 1)) {
   jsExceptionHere(1, 136950, 0);
   HEAP32[$4 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 104 >> 2] = 0;
  HEAP32[$4 + 100 >> 2] = 0;
  label$5: {
   if (jsvIsObject(HEAP32[$4 + 108 >> 2]) & 1) {
    jsvUnLock(HEAP32[$4 + 104 >> 2]);
    HEAP32[$4 + 104 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 108 >> 2], 128742);
    HEAP32[$4 + 100 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 108 >> 2], 117910);
    break label$5;
   }
   HEAP32[$4 + 104 >> 2] = jsvLockAgain(HEAP32[$4 + 108 >> 2]);
  }
  if (!(jsvIsFunction(HEAP32[$4 + 104 >> 2]) & 1)) {
   HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 104 >> 2];
   jsExceptionHere(1, 118200, $4 + 16 | 0);
   jsvUnLock2(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2]);
   HEAP32[$4 + 124 >> 2] = 0;
   break label$1;
  }
  label$8: {
   if (jsvIsUndefined(HEAP32[$4 + 100 >> 2]) & 1) {
    break label$8;
   }
   if (jsvIsFunction(HEAP32[$4 + 100 >> 2]) & 1) {
    break label$8;
   }
   HEAP32[$4 >> 2] = HEAP32[$4 + 100 >> 2];
   jsExceptionHere(1, 118200, $4);
   jsvUnLock2(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2]);
   HEAP32[$4 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 96 >> 2] = jspNewObject(0, 120477);
  if (!HEAP32[$4 + 96 >> 2]) {
   HEAP32[$4 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP8[$4 + 28 | 0] = 1;
  HEAP8[$4 + 29 | 0] = 0;
  HEAP8[$4 + 30 | 0] = 0;
  HEAP8[$4 + 31 | 0] = 0;
  graphicsStructInit($4 + 24 | 0, HEAP32[$4 + 120 >> 2], HEAP32[$4 + 116 >> 2], HEAP32[$4 + 112 >> 2]);
  $0 = HEAP32[$4 + 96 >> 2];
  HEAP8[$4 + 24 | 0] = $0;
  HEAP8[$4 + 25 | 0] = $0 >>> 8;
  HEAP8[$4 + 26 | 0] = $0 >>> 16;
  HEAP8[$4 + 27 | 0] = $0 >>> 24;
  lcdInit_JS($4 + 24 | 0, HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2]);
  graphicsSetVarInitial($4 + 24 | 0);
  jsvUnLock2(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2]);
  HEAP32[$4 + 124 >> 2] = HEAP32[$4 + 96 >> 2];
 }
 __stack_pointer = $4 + 128 | 0;
 return HEAP32[$4 + 124 >> 2];
}

function jswrap_graphics_setRotation($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 96 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP8[$3 + 83 | 0] = $2;
 label$1: {
  if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  $0 = (HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24)) & -113;
  HEAP8[$3 + 16 | 0] = $0;
  HEAP8[$3 + 17 | 0] = $0 >>> 8;
  HEAP8[$3 + 18 | 0] = $0 >>> 16;
  HEAP8[$3 + 19 | 0] = $0 >>> 24;
  label$3: {
   label$4: {
    switch (HEAP32[$3 + 84 >> 2] - 1 | 0) {
    case 0:
     $0 = HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24) | 48;
     HEAP8[$3 + 16 | 0] = $0;
     HEAP8[$3 + 17 | 0] = $0 >>> 8;
     HEAP8[$3 + 18 | 0] = $0 >>> 16;
     HEAP8[$3 + 19 | 0] = $0 >>> 24;
     break label$3;

    case 1:
     $0 = HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24) | 96;
     HEAP8[$3 + 16 | 0] = $0;
     HEAP8[$3 + 17 | 0] = $0 >>> 8;
     HEAP8[$3 + 18 | 0] = $0 >>> 16;
     HEAP8[$3 + 19 | 0] = $0 >>> 24;
     break label$3;

    case 2:
     break label$4;

    default:
     break label$3;
    }
   }
   $0 = HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24) | 80;
   HEAP8[$3 + 16 | 0] = $0;
   HEAP8[$3 + 17 | 0] = $0 >>> 8;
   HEAP8[$3 + 18 | 0] = $0 >>> 16;
   HEAP8[$3 + 19 | 0] = $0 >>> 24;
  }
  if (HEAP8[$3 + 83 | 0] & 1) {
   label$8: {
    if ((HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24)) & 16) {
     $0 = (HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24)) ^ 64;
     HEAP8[$3 + 16 | 0] = $0;
     HEAP8[$3 + 17 | 0] = $0 >>> 8;
     HEAP8[$3 + 18 | 0] = $0 >>> 16;
     HEAP8[$3 + 19 | 0] = $0 >>> 24;
     break label$8;
    }
    $0 = (HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24)) ^ 32;
    HEAP8[$3 + 16 | 0] = $0;
    HEAP8[$3 + 17 | 0] = $0 >>> 8;
    HEAP8[$3 + 18 | 0] = $0 >>> 16;
    HEAP8[$3 + 19 | 0] = $0 >>> 24;
   }
  }
  graphicsSetVar($3 + 8 | 0);
  HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
 }
 __stack_pointer = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}

function jsfBankListFilesHandleFile($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = __stack_pointer - 80 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 76 >> 2] = $0;
 HEAP32[$7 + 72 >> 2] = $1;
 HEAP32[$7 + 68 >> 2] = $2;
 HEAP32[$7 + 64 >> 2] = $3;
 HEAP32[$7 + 60 >> 2] = $4;
 HEAP32[$7 + 56 >> 2] = $5;
 HEAP32[$7 + 52 >> 2] = $6;
 HEAP32[$7 + 48 >> 2] = jsfGetFileFlags(HEAP32[$7 + 68 >> 2]);
 label$1: {
  if (!(!HEAP32[$7 + 60 >> 2] | HEAP32[$7 + 60 >> 2] & HEAP32[$7 + 48 >> 2]) | HEAP32[$7 + 56 >> 2] & HEAP32[$7 + 48 >> 2]) {
   break label$1;
  }
  if (HEAP32[$7 + 48 >> 2] & 64) {
   HEAP32[$7 + 44 >> 2] = 0;
   while (1) {
    $0 = 0;
    $0 = (HEAP32[$7 + 44 >> 2] + 1 | 0) < 28 ? HEAP8[(HEAP32[$7 + 68 >> 2] + HEAP32[$7 + 44 >> 2] | 0) + 5 | 0] != 0 : $0;
    if ($0) {
     HEAP32[$7 + 44 >> 2] = HEAP32[$7 + 44 >> 2] + 1;
     continue;
    }
    break;
   }
   if (HEAP8[HEAP32[$7 + 44 >> 2] + (HEAP32[$7 + 68 >> 2] + 4 | 0) | 0] != 1) {
    break label$1;
   }
   if (HEAP32[$7 + 60 >> 2] & 64) {
    HEAP8[HEAP32[$7 + 44 >> 2] + (HEAP32[$7 + 68 >> 2] + 4 | 0) | 0] = 0;
   }
  }
  $1 = HEAP32[$7 + 68 >> 2];
  HEAP32[$7 + 24 >> 2] = HEAP32[$1 + 28 >> 2];
  $0 = HEAP32[$1 + 20 >> 2];
  $2 = HEAP32[$1 + 24 >> 2];
  HEAP32[$7 + 16 >> 2] = $0;
  HEAP32[$7 + 20 >> 2] = $2;
  $0 = HEAP32[$1 + 16 >> 2];
  $2 = HEAP32[$1 + 12 >> 2];
  HEAP32[$7 + 8 >> 2] = $2;
  HEAP32[$7 + 12 >> 2] = $0;
  $2 = HEAP32[$1 + 8 >> 2];
  $0 = HEAP32[$1 + 4 >> 2];
  HEAP32[$7 >> 2] = $0;
  HEAP32[$7 + 4 >> 2] = $2;
  HEAP32[$7 + 40 >> 2] = jsfVarFromName($7);
  HEAP8[$7 + 39 | 0] = 1;
  if (HEAP32[$7 + 64 >> 2]) {
   HEAP32[$7 + 32 >> 2] = jswrap_string_match(HEAP32[$7 + 40 >> 2], HEAP32[$7 + 64 >> 2]);
   $0 = 1;
   if (!(jsvIsUndefined(HEAP32[$7 + 32 >> 2]) & 1)) {
    $0 = jsvIsNull(HEAP32[$7 + 32 >> 2]);
   }
   HEAP8[$7 + 39 | 0] = ($0 ^ -1) & 1;
   jsvUnLock(HEAP32[$7 + 32 >> 2]);
  }
  if (!(!HEAP32[$7 + 52 >> 2] | !(HEAP8[$7 + 39 | 0] & 1))) {
   HEAP32[HEAP32[$7 + 52 >> 2] >> 2] = HEAP32[HEAP32[$7 + 52 >> 2] >> 2] << 1 | HEAP32[HEAP32[$7 + 52 >> 2] >> 2] >>> 31;
   $0 = HEAP32[HEAP32[$7 + 52 >> 2] >> 2] ^ HEAP32[$7 + 72 >> 2];
   $1 = jsvGetIntegerAndUnLock(jswrap_espruino_CRC32(HEAP32[$7 + 40 >> 2]));
   HEAP32[HEAP32[$7 + 52 >> 2] >> 2] = $0 ^ $1;
  }
  if (!(!(HEAP8[$7 + 39 | 0] & 1) | !HEAP32[$7 + 76 >> 2])) {
   jsvArrayPushAndUnLock(HEAP32[$7 + 76 >> 2], HEAP32[$7 + 40 >> 2]);
   break label$1;
  }
  jsvUnLock(HEAP32[$7 + 40 >> 2]);
 }
 __stack_pointer = $7 + 80 | 0;
}

function jspGetNamedFieldInParents($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP8[$3 + 39 | 0] = $2;
 HEAP32[$3 + 32 >> 2] = jspeiFindChildFromStringInParents(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2]);
 if (!HEAP32[$3 + 32 >> 2]) {
  HEAP32[$3 + 32 >> 2] = jswFindBuiltInFunction(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2]);
 }
 if (!(!HEAP32[$3 + 32 >> 2] | !(HEAP8[$3 + 39 | 0] & 1))) {
  if (jsvIsName(HEAP32[$3 + 32 >> 2]) & 1) {
   HEAP32[$3 + 28 >> 2] = jsvGetValueOfName(HEAP32[$3 + 32 >> 2]);
   jsvUnLock(HEAP32[$3 + 32 >> 2]);
   HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 28 >> 2];
  }
  HEAP32[$3 + 24 >> 2] = jsvNewNameFromString(HEAP32[$3 + 40 >> 2]);
  HEAP32[$3 + 20 >> 2] = jsvCreateNewChild(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 32 >> 2]);
  jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 32 >> 2]);
  HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 20 >> 2];
  label$4: {
   if (!HEAP32[$3 + 32 >> 2]) {
    break label$4;
   }
   if (!(jsvIsArray(HEAP32[$3 + 44 >> 2]) & 1)) {
    break label$4;
   }
   if (strcmp(HEAP32[$3 + 40 >> 2], 129363)) {
    break label$4;
   }
   $0 = HEAP32[$3 + 32 >> 2];
   $1 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8 | 64;
   HEAP8[$0 + 12 | 0] = $1;
   HEAP8[$0 + 13 | 0] = $1 >>> 8;
  }
 }
 if (!HEAP32[$3 + 32 >> 2]) {
  label$6: {
   label$7: {
    if (!(jsvIsFunction(HEAP32[$3 + 44 >> 2]) & 1)) {
     break label$7;
    }
    if (strcmp(HEAP32[$3 + 40 >> 2], 132159)) {
     break label$7;
    }
    HEAP32[$3 + 16 >> 2] = jsvNewObject();
    jsvObjectSetChild(HEAP32[$3 + 16 >> 2], 120855, HEAP32[$3 + 44 >> 2]);
    HEAP32[$3 + 32 >> 2] = jsvAddNamedChild(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 16 >> 2], 132159);
    jspEnsureIsPrototype(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2]);
    jsvUnLock(HEAP32[$3 + 16 >> 2]);
    break label$6;
   }
   if (!strcmp(HEAP32[$3 + 40 >> 2], 135865)) {
    HEAP32[$3 + 12 >> 2] = jswGetBasicObjectName(HEAP32[$3 + 44 >> 2]);
    if (HEAP32[$3 + 12 >> 2]) {
     HEAP32[$3 + 8 >> 2] = jsvSkipNameAndUnLock(jspNewPrototype(HEAP32[$3 + 12 >> 2], 0));
     HEAP32[$3 + 4 >> 2] = jsvNewNameFromString(135865);
     if (HEAP32[$3 + 8 >> 2]) {
      HEAP32[$3 + 32 >> 2] = jsvCreateNewChild(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$3 + 8 >> 2]);
     }
     jsvUnLock2(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
    }
   }
  }
 }
 __stack_pointer = $3 + 48 | 0;
 return HEAP32[$3 + 32 >> 2];
}

function jswrap_waveform_constructor($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 HEAP32[$2 + 32 >> 2] = 0;
 HEAP32[$2 + 28 >> 2] = 0;
 label$1: {
  label$2: {
   if (jsvIsIntegerish(HEAP32[$2 + 40 >> 2]) & 1) {
    HEAP32[$2 + 32 >> 2] = jsvGetInteger(HEAP32[$2 + 40 >> 2]);
    if (HEAP32[$2 + 32 >> 2] <= 0) {
     jsExceptionHere(1, 139999, 0);
     HEAP32[$2 + 44 >> 2] = 0;
     break label$1;
    }
    break label$2;
   }
   label$5: {
    if (jsvIsArrayBuffer(HEAP32[$2 + 40 >> 2]) & 1) {
     HEAP32[$2 + 28 >> 2] = jsvLockAgain(HEAP32[$2 + 40 >> 2]);
     HEAP32[$2 + 32 >> 2] = jsvGetLength(HEAP32[$2 + 28 >> 2]);
     break label$5;
    }
    jsExceptionHere(1, 121264, 0);
    HEAP32[$2 + 44 >> 2] = 0;
    break label$1;
   }
  }
  HEAP8[$2 + 27 | 0] = 0;
  HEAP8[$2 + 26 | 0] = 0;
  label$7: {
   if (jsvIsObject(HEAP32[$2 + 36 >> 2]) & 1) {
    HEAP8[$2 + 27 | 0] = jsvObjectGetBoolChild(HEAP32[$2 + 36 >> 2], 121343) & 1;
    HEAP32[$2 + 20 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 36 >> 2], 119849);
    if (!(!HEAP32[$2 + 20 >> 2] | HEAP32[$2 + 20 >> 2] == 8 | HEAP32[$2 + 20 >> 2] == 16)) {
     jsExceptionHere(1, 119831, 0);
     HEAP32[$2 + 44 >> 2] = 0;
     break label$1;
    }
    if (HEAP32[$2 + 20 >> 2] == 16) {
     HEAP8[$2 + 26 | 0] = 1;
    }
    break label$7;
   }
   if (!(jsvIsUndefined(HEAP32[$2 + 36 >> 2]) & 1)) {
    HEAP32[$2 >> 2] = HEAP32[$2 + 36 >> 2];
    jsExceptionHere(1, 117992, $2);
   }
  }
  HEAP8[$2 + 19 | 0] = HEAP8[$2 + 26 | 0] & 1 ? 2 : 1;
  if (!HEAP32[$2 + 28 >> 2]) {
   HEAP32[$2 + 28 >> 2] = jsvNewTypedArray(HEAPU8[$2 + 19 | 0], HEAP32[$2 + 32 >> 2]);
  }
  HEAP32[$2 + 12 >> 2] = 0;
  if (HEAP8[$2 + 27 | 0] & 1) {
   HEAP32[$2 + 12 >> 2] = jsvNewTypedArray(HEAPU8[$2 + 19 | 0], HEAP32[$2 + 32 >> 2]);
  }
  HEAP32[$2 + 8 >> 2] = jspNewObject(0, 128600);
  if (HEAP32[$2 + 12 >> 2] | !(HEAP8[$2 + 27 | 0] & 1) ? !HEAP32[$2 + 8 >> 2] | !HEAP32[$2 + 28 >> 2] : 1) {
   jsvUnLock3(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 12 >> 2]);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 121187, HEAP32[$2 + 28 >> 2]);
  if (HEAP32[$2 + 12 >> 2]) {
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 139553, HEAP32[$2 + 12 >> 2]);
  }
  HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 8 >> 2];
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function jswrap_graphics_fillPoly_X($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 192 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 184 >> 2] = $0;
 HEAP32[$3 + 180 >> 2] = $1;
 HEAP8[$3 + 179 | 0] = $2;
 label$1: {
  if (!(graphicsGetFromVar($3 + 104 | 0, HEAP32[$3 + 184 >> 2]) & 1)) {
   HEAP32[$3 + 188 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsIterable(HEAP32[$3 + 180 >> 2]) & 1)) {
   HEAP32[$3 + 188 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 100 >> 2] = 128;
  HEAP32[$3 + 96 >> 2] = $3;
  $0 = $3 - 256 | 0;
  __stack_pointer = $0;
  HEAP32[$3 + 92 >> 2] = 0;
  jsvIteratorNew($3 + 32 | 0, HEAP32[$3 + 180 >> 2], 1);
  while (1) {
   $1 = 0;
   if (jsvIteratorHasElement($3 + 32 | 0) & 1) {
    $1 = HEAP32[$3 + 92 >> 2] < 128;
   }
   if ($1) {
    $4 = jsvIteratorGetFloatValue($3 + 32 | 0) * 16 + .5;
    label$7: {
     if (Math_abs($4) < 2147483648) {
      $1 = ~~$4;
      break label$7;
     }
     $1 = -2147483648;
    }
    HEAP32[$3 + 28 >> 2] = $1;
    if (HEAP32[$3 + 28 >> 2] < -32768) {
     HEAP32[$3 + 28 >> 2] = -32768;
    }
    if (HEAP32[$3 + 28 >> 2] > 32767) {
     HEAP32[$3 + 28 >> 2] = 32767;
    }
    $1 = HEAP32[$3 + 28 >> 2];
    $2 = HEAP32[$3 + 92 >> 2];
    HEAP32[$3 + 92 >> 2] = $2 + 1;
    HEAP16[($2 << 1) + $0 >> 1] = $1;
    jsvIteratorNext($3 + 32 | 0);
    continue;
   }
   break;
  }
  if (jsvIteratorHasElement($3 + 32 | 0) & 1) {
   HEAP32[$3 >> 2] = 64;
   jsExceptionHere(1, 116154, $3);
  }
  jsvIteratorFree($3 + 32 | 0);
  if (HEAP8[$3 + 179 | 0] & 1) {
   HEAP32[$3 + 24 >> 2] = HEAP16[(HEAP32[$3 + 92 >> 2] - 2 << 1) + $0 >> 1];
   HEAP32[$3 + 20 >> 2] = HEAP16[(HEAP32[$3 + 92 >> 2] - 1 << 1) + $0 >> 1];
   HEAP32[$3 + 16 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 16 >> 2] < HEAP32[$3 + 92 >> 2]) {
     HEAP32[$3 + 12 >> 2] = HEAP16[(HEAP32[$3 + 16 >> 2] << 1) + $0 >> 1];
     HEAP32[$3 + 8 >> 2] = HEAP16[(HEAP32[$3 + 16 >> 2] + 1 << 1) + $0 >> 1];
     graphicsDrawLineAA($3 + 104 | 0, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
     HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 12 >> 2];
     HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 8 >> 2];
     HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 2;
     continue;
    }
    break;
   }
  }
  graphicsFillPoly($3 + 104 | 0, HEAP32[$3 + 92 >> 2] / 2 | 0, $0);
  graphicsSetVar($3 + 104 | 0);
  HEAP32[$3 + 188 >> 2] = jsvLockAgain(HEAP32[$3 + 184 >> 2]);
 }
 __stack_pointer = $3 + 192 | 0;
 return HEAP32[$3 + 188 >> 2];
}

function jsfFindFile($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 112 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 104 >> 2] = $1;
 jsfStripDriveFromName($0, 1);
 $5 = HEAP32[$2 + 104 >> 2];
 HEAP32[$2 + 56 >> 2] = HEAP32[$0 + 24 >> 2];
 $4 = $0;
 $1 = HEAP32[$4 + 16 >> 2];
 $3 = HEAP32[$4 + 20 >> 2];
 HEAP32[$2 + 48 >> 2] = $1;
 HEAP32[$2 + 52 >> 2] = $3;
 $1 = HEAP32[$4 + 12 >> 2];
 $3 = HEAP32[$4 + 8 >> 2];
 HEAP32[$2 + 40 >> 2] = $3;
 HEAP32[$2 + 44 >> 2] = $1;
 $3 = HEAP32[$4 + 4 >> 2];
 $1 = HEAP32[$4 >> 2];
 HEAP32[$2 + 32 >> 2] = $1;
 HEAP32[$2 + 36 >> 2] = $3;
 HEAP32[$2 + 100 >> 2] = jsfCacheFind($2 + 32 | 0, $5);
 if (HEAP32[$2 + 100 >> 2] == -1) {
  HEAP32[$2 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
  $3 = HEAP32[$0 + 16 >> 2];
  $1 = HEAP32[$4 + 20 >> 2];
  HEAP32[$2 + 16 >> 2] = $3;
  HEAP32[$2 + 20 >> 2] = $1;
  $3 = HEAP32[$4 + 12 >> 2];
  $1 = HEAP32[$4 + 8 >> 2];
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 12 >> 2] = $3;
  $1 = HEAP32[$4 + 4 >> 2];
  $3 = HEAP32[$4 >> 2];
  HEAP32[$2 >> 2] = $3;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 100 >> 2] = jsfBankFindFile(134217728, 142606336, $2, $2 - -64 | 0);
  if (!HEAP32[$2 + 100 >> 2]) {
   $1 = HEAP32[$0 >> 2];
   $3 = HEAP32[$4 + 4 >> 2];
   $5 = $1;
   $0 = $2 - -64 | 0;
   $1 = $0;
   HEAP32[$1 + 4 >> 2] = $5;
   HEAP32[$1 + 8 >> 2] = $3;
   HEAP32[$1 + 28 >> 2] = HEAP32[$4 + 24 >> 2];
   $1 = HEAP32[$4 + 20 >> 2];
   $3 = HEAP32[$4 + 16 >> 2];
   $5 = $3;
   $3 = $0;
   HEAP32[$3 + 20 >> 2] = $5;
   HEAP32[$3 + 24 >> 2] = $1;
   $3 = HEAP32[$4 + 12 >> 2];
   $1 = HEAP32[$4 + 8 >> 2];
   $4 = $1;
   $1 = $0;
   HEAP32[$1 + 12 >> 2] = $4;
   HEAP32[$1 + 16 >> 2] = $3;
  }
  jsfCachePut($2 - -64 | 0, HEAP32[$2 + 100 >> 2]);
  if (HEAP32[$2 + 104 >> 2]) {
   $1 = HEAP32[$2 + 68 >> 2];
   $3 = HEAP32[$2 + 64 >> 2];
   $4 = $3;
   $0 = HEAP32[$2 + 104 >> 2];
   $3 = $0;
   HEAP32[$3 >> 2] = $4;
   HEAP32[$3 + 4 >> 2] = $1;
   $3 = HEAP32[$2 + 92 >> 2];
   $1 = HEAP32[$2 + 88 >> 2];
   $4 = $1;
   $1 = $0;
   HEAP32[$1 + 24 >> 2] = $4;
   HEAP32[$1 + 28 >> 2] = $3;
   $1 = HEAP32[$2 + 84 >> 2];
   $3 = HEAP32[$2 + 80 >> 2];
   $4 = $3;
   $3 = $0;
   HEAP32[$3 + 16 >> 2] = $4;
   HEAP32[$3 + 20 >> 2] = $1;
   $3 = HEAP32[$2 + 76 >> 2];
   $1 = HEAP32[$2 + 72 >> 2];
   $4 = $1;
   $1 = $0;
   HEAP32[$1 + 8 >> 2] = $4;
   HEAP32[$1 + 12 >> 2] = $3;
  }
 }
 HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 100 >> 2];
 __stack_pointer = $2 + 112 | 0;
 return HEAP32[$2 + 108 >> 2];
}

function tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 $5 = HEAP32[$4 + 40 >> 2];
 label$1: {
  if (HEAP32[$4 + 36 >> 2] == 32) {
   if (HEAP32[$5 + 372 >> 2]) {
    tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$5 + 372 >> 2], 140476, 0);
   }
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  if (FUNCTION_TABLE[HEAP32[HEAP32[$5 >> 2] + 20 >> 2]]($5, HEAP32[$4 + 36 >> 2]) | 0) {
   if (HEAP32[$5 + 372 >> 2]) {
    $0 = HEAP32[$5 + 372 >> 2];
    HEAP32[$4 >> 2] = HEAP32[$4 + 36 >> 2];
    tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 141103, $4);
   }
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  if (HEAPU32[$5 + 292 >> 2] >= 9) {
   if (HEAP32[$5 + 372 >> 2]) {
    $0 = HEAP32[$5 + 372 >> 2];
    $1 = HEAP32[$4 + 36 >> 2];
    HEAP32[$4 + 20 >> 2] = 9;
    HEAP32[$4 + 16 >> 2] = $1;
    tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 141036, $4 + 16 | 0);
   }
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  $6 = HEAP32[$4 + 32 >> 2];
  $0 = HEAP32[$6 >> 2];
  $1 = HEAP32[$6 + 4 >> 2];
  $3 = $0;
  $2 = ($5 + 4 | 0) + (HEAP32[$5 + 292 >> 2] << 5) | 0;
  $0 = $2;
  HEAP32[$0 >> 2] = $3;
  HEAP32[$0 + 4 >> 2] = $1;
  $0 = HEAP32[$6 + 28 >> 2];
  $1 = HEAP32[$6 + 24 >> 2];
  $3 = $1;
  $1 = $2;
  HEAP32[$1 + 24 >> 2] = $3;
  HEAP32[$1 + 28 >> 2] = $0;
  $1 = HEAP32[$6 + 20 >> 2];
  $0 = HEAP32[$6 + 16 >> 2];
  $3 = $0;
  $0 = $2;
  HEAP32[$0 + 16 >> 2] = $3;
  HEAP32[$0 + 20 >> 2] = $1;
  $0 = HEAP32[$6 + 12 >> 2];
  $1 = HEAP32[$6 + 8 >> 2];
  $3 = $1;
  $1 = $2;
  HEAP32[$1 + 8 >> 2] = $3;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[(($5 + 4 | 0) + (HEAP32[$5 + 292 >> 2] << 5) | 0) + 20 >> 2] = HEAP32[$4 + 36 >> 2];
  HEAP32[$5 + 292 >> 2] = HEAP32[$5 + 292 >> 2] + 1;
  HEAP32[($5 + 296 | 0) + (HEAP32[$5 + 368 >> 2] << 2) >> 2] = HEAP32[$4 + 36 >> 2];
  HEAP32[($5 + 332 | 0) + (HEAP32[$5 + 368 >> 2] << 2) >> 2] = HEAP32[$4 + 28 >> 2];
  HEAP32[$5 + 368 >> 2] = HEAP32[$5 + 368 >> 2] + 1;
  HEAP32[$4 + 44 >> 2] = 0;
 }
 __stack_pointer = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}

function jswrap_graphics_setClipRect($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = __stack_pointer - 112 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 104 >> 2] = $0;
 HEAP32[$5 + 100 >> 2] = $1;
 HEAP32[$5 + 96 >> 2] = $2;
 HEAP32[$5 + 92 >> 2] = $3;
 HEAP32[$5 + 88 >> 2] = $4;
 label$1: {
  if (!(graphicsGetFromVar($5 + 16 | 0, HEAP32[$5 + 104 >> 2]) & 1)) {
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  graphicsToDeviceCoordinates($5 + 16 | 0, $5 + 100 | 0, $5 + 96 | 0);
  graphicsToDeviceCoordinates($5 + 16 | 0, $5 + 92 | 0, $5 + 88 | 0);
  if (HEAP32[$5 + 100 >> 2] < 0) {
   HEAP32[$5 + 100 >> 2] = 0;
  }
  if (HEAP32[$5 + 96 >> 2] < 0) {
   HEAP32[$5 + 96 >> 2] = 0;
  }
  if (HEAP32[$5 + 92 >> 2] < 0) {
   HEAP32[$5 + 92 >> 2] = 0;
  }
  if (HEAP32[$5 + 88 >> 2] < 0) {
   HEAP32[$5 + 88 >> 2] = 0;
  }
  if (HEAP32[$5 + 100 >> 2] >= (HEAPU8[$5 + 28 | 0] | HEAPU8[$5 + 29 | 0] << 8)) {
   HEAP32[$5 + 100 >> 2] = (HEAPU8[$5 + 28 | 0] | HEAPU8[$5 + 29 | 0] << 8) - 1;
  }
  if (HEAP32[$5 + 96 >> 2] >= (HEAPU8[$5 + 30 | 0] | HEAPU8[$5 + 31 | 0] << 8)) {
   HEAP32[$5 + 96 >> 2] = (HEAPU8[$5 + 30 | 0] | HEAPU8[$5 + 31 | 0] << 8) - 1;
  }
  if (HEAP32[$5 + 92 >> 2] >= (HEAPU8[$5 + 28 | 0] | HEAPU8[$5 + 29 | 0] << 8)) {
   HEAP32[$5 + 92 >> 2] = (HEAPU8[$5 + 28 | 0] | HEAPU8[$5 + 29 | 0] << 8) - 1;
  }
  if (HEAP32[$5 + 88 >> 2] >= (HEAPU8[$5 + 30 | 0] | HEAPU8[$5 + 31 | 0] << 8)) {
   HEAP32[$5 + 88 >> 2] = (HEAPU8[$5 + 30 | 0] | HEAPU8[$5 + 31 | 0] << 8) - 1;
  }
  if (HEAP32[$5 + 100 >> 2] > HEAP32[$5 + 92 >> 2]) {
   HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 100 >> 2];
   HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 92 >> 2];
   HEAP32[$5 + 92 >> 2] = HEAP32[$5 + 12 >> 2];
  }
  if (HEAP32[$5 + 96 >> 2] > HEAP32[$5 + 88 >> 2]) {
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 96 >> 2];
   HEAP32[$5 + 96 >> 2] = HEAP32[$5 + 88 >> 2];
   HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 8 >> 2];
  }
  $0 = HEAP32[$5 + 100 >> 2];
  HEAP8[$5 + 48 | 0] = $0;
  HEAP8[$5 + 49 | 0] = $0 >>> 8;
  $0 = HEAP32[$5 + 96 >> 2];
  HEAP8[$5 + 50 | 0] = $0;
  HEAP8[$5 + 51 | 0] = $0 >>> 8;
  $0 = HEAP32[$5 + 92 >> 2];
  HEAP8[$5 + 52 | 0] = $0;
  HEAP8[$5 + 53 | 0] = $0 >>> 8;
  $0 = HEAP32[$5 + 88 >> 2];
  HEAP8[$5 + 54 | 0] = $0;
  HEAP8[$5 + 55 | 0] = $0 >>> 8;
  graphicsSetVar($5 + 16 | 0);
  HEAP32[$5 + 108 >> 2] = jsvLockAgain(HEAP32[$5 + 104 >> 2]);
 }
 __stack_pointer = $5 + 112 | 0;
 return HEAP32[$5 + 108 >> 2];
}

function jswrap_array_slice($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 112 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 104 >> 2] = $0;
 HEAP32[$3 + 100 >> 2] = $1;
 HEAP32[$3 + 96 >> 2] = $2;
 HEAP32[$3 + 92 >> 2] = jsvGetLength(HEAP32[$3 + 104 >> 2]);
 HEAP32[$3 + 88 >> 2] = HEAP32[$3 + 92 >> 2];
 if (!(jsvIsUndefined(HEAP32[$3 + 96 >> 2]) & 1)) {
  HEAP32[$3 + 88 >> 2] = jsvGetInteger(HEAP32[$3 + 96 >> 2]);
 }
 HEAP32[$3 + 84 >> 2] = 0;
 HEAP32[$3 + 80 >> 2] = HEAP32[$3 + 92 >> 2];
 HEAP32[$3 + 76 >> 2] = jsvNewEmptyArray();
 label$2: {
  if (!HEAP32[$3 + 76 >> 2]) {
   HEAP32[$3 + 108 >> 2] = 0;
   break label$2;
  }
  label$4: {
   if (HEAP32[$3 + 100 >> 2] < 0) {
    if ((HEAP32[$3 + 92 >> 2] + HEAP32[$3 + 100 >> 2] | 0) > 0) {
     $0 = HEAP32[$3 + 92 >> 2] + HEAP32[$3 + 100 >> 2] | 0;
    } else {
     $0 = 0;
    }
    HEAP32[$3 + 84 >> 2] = $0;
    break label$4;
   }
   if (HEAP32[$3 + 100 >> 2] < HEAP32[$3 + 92 >> 2]) {
    $0 = HEAP32[$3 + 100 >> 2];
   } else {
    $0 = HEAP32[$3 + 92 >> 2];
   }
   HEAP32[$3 + 84 >> 2] = $0;
  }
  label$10: {
   if (HEAP32[$3 + 88 >> 2] < 0) {
    if ((HEAP32[$3 + 92 >> 2] + HEAP32[$3 + 88 >> 2] | 0) > 0) {
     $0 = HEAP32[$3 + 92 >> 2] + HEAP32[$3 + 88 >> 2] | 0;
    } else {
     $0 = 0;
    }
    HEAP32[$3 + 80 >> 2] = $0;
    break label$10;
   }
   if (HEAP32[$3 + 88 >> 2] < HEAP32[$3 + 92 >> 2]) {
    $0 = HEAP32[$3 + 88 >> 2];
   } else {
    $0 = HEAP32[$3 + 92 >> 2];
   }
   HEAP32[$3 + 80 >> 2] = $0;
  }
  HEAP8[$3 + 75 | 0] = 0;
  jsvIteratorNew($3 + 8 | 0, HEAP32[$3 + 104 >> 2], 1);
  while (1) {
   $0 = 0;
   if (jsvIteratorHasElement($3 + 8 | 0) & 1) {
    $0 = HEAPU8[$3 + 75 | 0] ^ -1;
   }
   if ($0 & 1) {
    HEAP32[$3 + 4 >> 2] = jsvGetIntegerAndUnLock(jsvIteratorGetKey($3 + 8 | 0));
    label$19: {
     if (HEAP32[$3 + 4 >> 2] < HEAP32[$3 + 84 >> 2]) {
      jsvIteratorNext($3 + 8 | 0);
      break label$19;
     }
     label$21: {
      if (HEAP32[$3 + 84 >> 2] < HEAP32[$3 + 80 >> 2]) {
       jsvArrayPushAndUnLock(HEAP32[$3 + 76 >> 2], jsvIteratorGetValue($3 + 8 | 0));
       jsvIteratorNext($3 + 8 | 0);
       HEAP32[$3 + 84 >> 2] = HEAP32[$3 + 84 >> 2] + 1;
       break label$21;
      }
      HEAP8[$3 + 75 | 0] = 1;
     }
    }
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 8 | 0);
  HEAP32[$3 + 108 >> 2] = HEAP32[$3 + 76 >> 2];
 }
 __stack_pointer = $3 + 112 | 0;
 return HEAP32[$3 + 108 >> 2];
}

function lcdMemLCD_fillRect($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = __stack_pointer - 80 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 76 >> 2] = $0;
 HEAP32[$6 + 72 >> 2] = $1;
 HEAP32[$6 + 68 >> 2] = $2;
 HEAP32[$6 + 64 >> 2] = $3;
 HEAP32[$6 + 60 >> 2] = $4;
 HEAP32[$6 + 56 >> 2] = $5;
 lcdMemLCD_waitForSendComplete();
 label$1: {
  if (!(HEAP32[$6 + 72 >> 2] | HEAP32[$6 + 64 >> 2] != 175 | (HEAP32[$6 + 56 >> 2] != 65535 ? HEAP32[$6 + 56 >> 2] : 0))) {
   HEAP32[$6 + 52 >> 2] = Math_imul(HEAP32[$6 + 68 >> 2], 68) + 2;
   HEAP32[$6 + 48 >> 2] = HEAP32[$6 + 68 >> 2];
   while (1) {
    if (HEAP32[$6 + 48 >> 2] <= HEAP32[$6 + 60 >> 2]) {
     memset(HEAP32[$6 + 52 >> 2] + 378848 | 0, HEAP32[$6 + 56 >> 2] ? 255 : 0, 66);
     HEAP32[$6 + 52 >> 2] = HEAP32[$6 + 52 >> 2] + 68;
     HEAP32[$6 + 48 >> 2] = HEAP32[$6 + 48 >> 2] + 1;
     continue;
    }
    break;
   }
   break label$1;
  }
  HEAP32[$6 + 32 >> 2] = lcdMemLCD_convert16toLCD(HEAP32[$6 + 56 >> 2], 0, 0);
  HEAP32[$6 + 36 >> 2] = lcdMemLCD_convert16toLCD(HEAP32[$6 + 56 >> 2], 1, 0);
  HEAP32[$6 + 40 >> 2] = lcdMemLCD_convert16toLCD(HEAP32[$6 + 56 >> 2], 0, 1);
  HEAP32[$6 + 44 >> 2] = lcdMemLCD_convert16toLCD(HEAP32[$6 + 56 >> 2], 1, 1);
  HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 68 >> 2];
  while (1) {
   if (HEAP32[$6 + 28 >> 2] <= HEAP32[$6 + 60 >> 2]) {
    HEAP32[$6 + 24 >> 2] = ($6 + 32 | 0) + ((HEAP32[$6 + 28 >> 2] & 1) << 3);
    HEAP32[$6 + 20 >> 2] = (Math_imul(HEAP32[$6 + 72 >> 2], 3) + 16 | 0) + (Math_imul(HEAP32[$6 + 28 >> 2], 68) << 3);
    HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 72 >> 2];
    while (1) {
     if (HEAP32[$6 + 16 >> 2] <= HEAP32[$6 + 64 >> 2]) {
      HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 20 >> 2] & 7;
      $0 = HEAP32[$6 + 20 >> 2] >> 3;
      HEAP16[$6 + 10 >> 1] = HEAPU8[$0 + 378848 | 0] | HEAPU8[$0 + 378849 | 0] << 8;
      $0 = HEAP32[$6 + 20 >> 2] >> 3;
      $1 = HEAPU16[$6 + 10 >> 1] & (7 << HEAP32[$6 + 12 >> 2] ^ -1) | HEAP32[HEAP32[$6 + 24 >> 2] + ((HEAP32[$6 + 16 >> 2] & 1) << 2) >> 2] << HEAP32[$6 + 12 >> 2];
      HEAP8[$0 + 378848 | 0] = $1;
      HEAP8[$0 + 378849 | 0] = $1 >>> 8;
      HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 20 >> 2] + 3;
      HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 16 >> 2] + 1;
      continue;
     }
     break;
    }
    HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 28 >> 2] + 1;
    continue;
   }
   break;
  }
 }
 __stack_pointer = $6 + 80 | 0;
}

function heatshrink_encoder_poll($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 label$1: {
  if (HEAP32[$4 + 28 >> 2] ? !HEAP32[$4 + 40 >> 2] | !HEAP32[$4 + 36 >> 2] : 1) {
   HEAP32[$4 + 44 >> 2] = -1;
   break label$1;
  }
  if (!HEAP32[$4 + 32 >> 2]) {
   HEAP32[$4 + 44 >> 2] = -2;
   break label$1;
  }
  HEAP32[HEAP32[$4 + 28 >> 2] >> 2] = 0;
  HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 36 >> 2];
  HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 32 >> 2];
  HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 28 >> 2];
  while (1) {
   HEAP8[$4 + 15 | 0] = HEAPU8[HEAP32[$4 + 40 >> 2] + 12 | 0];
   label$6: {
    label$7: {
     switch (HEAPU8[$4 + 15 | 0]) {
     case 0:
      HEAP32[$4 + 44 >> 2] = 0;
      break label$1;

     case 1:
      do_indexing(HEAP32[$4 + 40 >> 2]);
      HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = 2;
      break label$6;

     case 2:
      $0 = st_step_search(HEAP32[$4 + 40 >> 2]);
      HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = $0;
      break label$6;

     case 3:
      $0 = st_yield_tag_bit(HEAP32[$4 + 40 >> 2], $4 + 16 | 0);
      HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = $0;
      break label$6;

     case 4:
      $0 = st_e_yield_literal(HEAP32[$4 + 40 >> 2], $4 + 16 | 0);
      HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = $0;
      break label$6;

     case 5:
      $0 = st_yield_br_index(HEAP32[$4 + 40 >> 2], $4 + 16 | 0);
      HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = $0;
      break label$6;

     case 6:
      $0 = st_yield_br_length(HEAP32[$4 + 40 >> 2], $4 + 16 | 0);
      HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = $0;
      break label$6;

     case 7:
      $0 = st_save_backlog(HEAP32[$4 + 40 >> 2]);
      HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = $0;
      break label$6;

     case 8:
      $0 = st_flush_bit_buffer(HEAP32[$4 + 40 >> 2], $4 + 16 | 0);
      HEAP8[HEAP32[$4 + 40 >> 2] + 12 | 0] = $0;
      HEAP32[$4 + 44 >> 2] = 0;
      break label$1;

     case 9:
      HEAP32[$4 + 44 >> 2] = 0;
      break label$1;

     default:
      break label$7;
     }
    }
    HEAP32[$4 + 44 >> 2] = -2;
    break label$1;
   }
   if (!(HEAPU8[HEAP32[$4 + 40 >> 2] + 12 | 0] == HEAPU8[$4 + 15 | 0] & HEAP32[HEAP32[$4 + 28 >> 2] >> 2] == HEAP32[$4 + 32 >> 2])) {
    continue;
   }
   break;
  }
  HEAP32[$4 + 44 >> 2] = 1;
 }
 __stack_pointer = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}

function jswrap_array_includes($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 112 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 104 >> 2] = $0;
 HEAP32[$3 + 100 >> 2] = $1;
 HEAP32[$3 + 96 >> 2] = $2;
 if (HEAP32[$3 + 96 >> 2] < 0) {
  HEAP32[$3 + 96 >> 2] = jsvGetLength(HEAP32[$3 + 104 >> 2]) + HEAP32[$3 + 96 >> 2];
 }
 if (HEAP32[$3 + 96 >> 2] < 0) {
  HEAP32[$3 + 96 >> 2] = 0;
 }
 if (jsvIsFloat(HEAP32[$3 + 100 >> 2]) & 1) {
  $0 = __DOUBLE_BITS_3(jsvGetFloat(HEAP32[$3 + 100 >> 2]));
  $2 = $0;
  $1 = i64toi32_i32$HIGH_BITS;
  $0 = $1 & 2147483647;
  $1 = $2;
  $4 = ($0 | 0) == 2146435072 & ($1 | 0) != 0 | $0 >>> 0 > 2146435072;
 }
 HEAP8[$3 + 95 | 0] = $4;
 label$4: {
  if (!(jsvIsIterable(HEAP32[$3 + 104 >> 2]) & 1)) {
   HEAP8[$3 + 111 | 0] = 0;
   break label$4;
  }
  jsvIteratorNew($3 + 32 | 0, HEAP32[$3 + 104 >> 2], jsvIsUndefined(HEAP32[$3 + 100 >> 2]) & 1);
  while (1) {
   if (jsvIteratorHasElement($3 + 32 | 0) & 1) {
    HEAP32[$3 + 28 >> 2] = jsvIteratorGetKey($3 + 32 | 0);
    label$8: {
     if (!(jsvIsInt(HEAP32[$3 + 28 >> 2]) & 1)) {
      break label$8;
     }
     if ((jsvGetInteger(HEAP32[$3 + 28 >> 2]) | 0) < HEAP32[$3 + 96 >> 2]) {
      break label$8;
     }
     HEAP32[$3 + 24 >> 2] = jsvIteratorGetValue($3 + 32 | 0);
     label$9: {
      label$10: {
       if (HEAP32[$3 + 24 >> 2] == HEAP32[$3 + 100 >> 2]) {
        break label$10;
       }
       if (jsvMathsOpTypeEqual(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 100 >> 2]) & 1) {
        break label$10;
       }
       if (!(HEAP8[$3 + 95 | 0] & 1)) {
        break label$9;
       }
       if (!(jsvIsFloat(HEAP32[$3 + 24 >> 2]) & 1)) {
        break label$9;
       }
       $1 = __DOUBLE_BITS_3(jsvGetFloat(HEAP32[$3 + 24 >> 2]));
       $2 = $1;
       $0 = i64toi32_i32$HIGH_BITS;
       $1 = $0 & 2147483647;
       $0 = $2;
       if (($1 | 0) == 2146435072 & ($0 | 0) != 0 | $1 >>> 0 > 2146435072) {
        break label$10;
       }
       break label$9;
      }
      jsvUnLock2(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
      jsvIteratorFree($3 + 32 | 0);
      HEAP8[$3 + 111 | 0] = 1;
      break label$4;
     }
     jsvUnLock(HEAP32[$3 + 24 >> 2]);
    }
    jsvUnLock(HEAP32[$3 + 28 >> 2]);
    jsvIteratorNext($3 + 32 | 0);
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 32 | 0);
  HEAP8[$3 + 111 | 0] = 0;
 }
 __stack_pointer = $3 + 112 | 0;
 return HEAP8[$3 + 111 | 0] & 1;
}

function lcdScroll_ArrayBuffer_flat($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 var $7 = 0;
 $7 = __stack_pointer + -64 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 60 >> 2] = $0;
 HEAP32[$7 + 56 >> 2] = $1;
 HEAP32[$7 + 52 >> 2] = $2;
 HEAP32[$7 + 48 >> 2] = $3;
 HEAP32[$7 + 44 >> 2] = $4;
 HEAP32[$7 + 40 >> 2] = $5;
 HEAP32[$7 + 36 >> 2] = $6;
 label$1: {
  label$2: {
   if (HEAP32[$7 + 48 >> 2]) {
    break label$2;
   }
   $0 = HEAP32[$7 + 60 >> 2];
   if (HEAP32[$7 + 56 >> 2] | HEAP32[$7 + 40 >> 2] != ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - 1 | 0)) {
    break label$2;
   }
   $0 = HEAP32[$7 + 60 >> 2];
   if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 11) {
    break label$2;
   }
   HEAP32[$7 + 32 >> 2] = ((HEAP32[$7 + 36 >> 2] + 1 | 0) - HEAP32[$7 + 44 >> 2] | 0) - abs(HEAP32[$7 + 52 >> 2]);
   HEAP32[$7 + 28 >> 2] = Math_imul(HEAP32[$7 + 32 >> 2], (HEAP32[$7 + 40 >> 2] + 1 | 0) - HEAP32[$7 + 48 >> 2] | 0);
   if (HEAP32[$7 + 52 >> 2] < 0) {
    $0 = 0 - HEAP32[$7 + 52 >> 2] | 0;
   } else {
    $0 = 0;
   }
   HEAP32[$7 + 24 >> 2] = $0 + HEAP32[$7 + 44 >> 2];
   if (HEAP32[$7 + 52 >> 2] > 0) {
    $0 = HEAP32[$7 + 52 >> 2];
   } else {
    $0 = 0;
   }
   HEAP32[$7 + 20 >> 2] = $0 + HEAP32[$7 + 44 >> 2];
   HEAP32[$7 + 16 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$7 + 60 >> 2], HEAP32[$7 + 48 >> 2], HEAP32[$7 + 24 >> 2], HEAP32[$7 + 28 >> 2]);
   HEAP32[$7 + 12 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$7 + 60 >> 2], HEAP32[$7 + 48 >> 2], HEAP32[$7 + 20 >> 2], HEAP32[$7 + 28 >> 2]);
   HEAP32[$7 + 8 >> 2] = Math_imul(HEAP32[$7 + 28 >> 2], HEAPU8[HEAP32[$7 + 60 >> 2] + 16 | 0]);
   if (!(HEAP32[$7 + 8 >> 2] & 7 | (HEAP32[$7 + 16 >> 2] & 7 | HEAP32[$7 + 12 >> 2] & 7))) {
    $0 = HEAP32[$7 + 60 >> 2];
    HEAP32[$7 + 4 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
    memmove(HEAP32[$7 + 4 >> 2] + (HEAP32[$7 + 12 >> 2] >>> 3 | 0) | 0, HEAP32[$7 + 4 >> 2] + (HEAP32[$7 + 16 >> 2] >>> 3 | 0) | 0, HEAP32[$7 + 8 >> 2] >>> 3 | 0);
    break label$1;
   }
  }
  graphicsFallbackScroll(HEAP32[$7 + 60 >> 2], HEAP32[$7 + 56 >> 2], HEAP32[$7 + 52 >> 2], HEAP32[$7 + 48 >> 2], HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2], HEAP32[$7 + 36 >> 2]);
 }
 __stack_pointer = $7 - -64 | 0;
}

function jswrap_banglejs_appRect() {
 var $0 = 0;
 $0 = __stack_pointer - 48 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 40 >> 2] = jsvNewObject();
 label$1: {
  if (!HEAP32[$0 + 40 >> 2]) {
   HEAP32[$0 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[91086], 136768);
  HEAP32[$0 + 32 >> 2] = 0;
  HEAP32[$0 + 28 >> 2] = 0;
  if (jsvIsObject(HEAP32[$0 + 36 >> 2]) & 1) {
   jsvObjectIteratorNew($0 + 24 | 0, HEAP32[$0 + 36 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_5($0 + 24 | 0) & 1) {
     HEAP32[$0 + 20 >> 2] = jsvObjectIteratorGetValue_5($0 + 24 | 0);
     HEAP32[$0 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 20 >> 2], 135848);
     HEAP32[$0 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 20 >> 2], 129398);
     label$6: {
      if (!(jsvIsString(HEAP32[$0 + 16 >> 2]) & 1)) {
       break label$6;
      }
      if (!(jsvIsNumeric(HEAP32[$0 + 12 >> 2]) & 1)) {
       break label$6;
      }
      HEAP8[$0 + 11 | 0] = jsvGetCharInString(HEAP32[$0 + 16 >> 2], 0);
      HEAP32[$0 + 4 >> 2] = jsvGetIntegerAndUnLock(HEAP32[$0 + 12 >> 2]);
      if (!(HEAP8[$0 + 11 | 0] != 116 | HEAP32[$0 + 4 >> 2] <= 0)) {
       HEAP32[$0 + 32 >> 2] = 24;
      }
      if (!(HEAP8[$0 + 11 | 0] != 98 | HEAP32[$0 + 4 >> 2] <= 0)) {
       HEAP32[$0 + 28 >> 2] = 24;
      }
     }
     jsvUnLock2(HEAP32[$0 + 16 >> 2], HEAP32[$0 + 20 >> 2]);
     jsvObjectIteratorNext($0 + 24 | 0);
     continue;
    }
    break;
   }
   jsvObjectIteratorFree_5($0 + 24 | 0);
  }
  jsvUnLock(HEAP32[$0 + 36 >> 2]);
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 40 >> 2], 116522, jsvNewFromInteger(0));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 40 >> 2], 116397, jsvNewFromInteger(HEAP32[$0 + 32 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 40 >> 2], 116775, jsvNewFromInteger(HEAPU8[366812] | HEAPU8[366813] << 8));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 40 >> 2], 129676, jsvNewFromInteger((HEAPU8[366814] | HEAPU8[366815] << 8) - (HEAP32[$0 + 32 >> 2] + HEAP32[$0 + 28 >> 2] | 0) | 0));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 40 >> 2], 139550, jsvNewFromInteger((HEAPU8[366812] | HEAPU8[366813] << 8) - 1 | 0));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 40 >> 2], 139547, jsvNewFromInteger((HEAPU8[366814] | HEAPU8[366815] << 8) - (HEAP32[$0 + 28 >> 2] + 1 | 0) | 0));
  HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 40 >> 2];
 }
 __stack_pointer = $0 + 48 | 0;
 return HEAP32[$0 + 44 >> 2];
}

function tflite__ops__micro__activations__SoftmaxPrepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP32[$2 + 52 >> 2] = $1;
 HEAP32[$2 + 48 >> 2] = HEAP32[HEAP32[$2 + 52 >> 2] + 12 >> 2];
 label$1: {
  if ((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 52 >> 2]) | 0) != 1) {
   $0 = HEAP32[HEAP32[$2 + 56 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 56 >> 2];
   $3 = tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 52 >> 2]);
   HEAP32[$2 + 12 >> 2] = 1;
   HEAP32[$2 + 8 >> 2] = $3;
   HEAP32[$2 + 4 >> 2] = 139997;
   HEAP32[$2 >> 2] = 143050;
   FUNCTION_TABLE[$0 | 0]($1, 143305, $2);
   HEAP32[$2 + 60 >> 2] = 1;
   break label$1;
  }
  if ((tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 52 >> 2]) | 0) != 1) {
   $0 = HEAP32[HEAP32[$2 + 56 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 56 >> 2];
   $3 = tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 52 >> 2]);
   HEAP32[$2 + 28 >> 2] = 1;
   HEAP32[$2 + 24 >> 2] = $3;
   HEAP32[$2 + 20 >> 2] = 139997;
   HEAP32[$2 + 16 >> 2] = 143033;
   FUNCTION_TABLE[$0 | 0]($1, 143305, $2 + 16 | 0);
   HEAP32[$2 + 60 >> 2] = 1;
   break label$1;
  }
  HEAP32[$2 + 44 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2], 0);
  if ((tflite__NumDimensions_28TfLiteTensor_20const__29(HEAP32[$2 + 44 >> 2]) | 0) <= 0) {
   $0 = HEAP32[HEAP32[$2 + 56 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 56 >> 2];
   HEAP32[$2 + 32 >> 2] = 139935;
   FUNCTION_TABLE[$0 | 0]($1, 140586, $2 + 32 | 0);
   HEAP32[$2 + 60 >> 2] = 1;
   break label$1;
  }
  HEAP32[$2 + 40 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2], 0);
  label$5: {
   if (!HEAP32[HEAP32[$2 + 52 >> 2] + 8 >> 2]) {
    break label$5;
   }
  }
  HEAP32[$2 + 36 >> 2] = HEAP32[HEAP32[$2 + 52 >> 2] + 8 >> 2];
  HEAP32[$2 + 60 >> 2] = tflite__ops__micro__activations___28anonymous_20namespace_29__CalculateSoftmaxParams_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20TfLiteSoftmaxParams_20const__2c_20tflite__SoftmaxParams__29(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 44 >> 2], HEAP32[$2 + 40 >> 2], HEAP32[$2 + 48 >> 2], HEAP32[$2 + 36 >> 2]);
 }
 __stack_pointer = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}

function handlePipe($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 56 >> 2] = $0;
 HEAP32[$3 + 52 >> 2] = $1;
 HEAP32[$3 + 48 >> 2] = $2;
 HEAP8[$3 + 47 | 0] = jsvObjectGetBoolChild(HEAP32[$3 + 48 >> 2], 117690) & 1;
 label$1: {
  if (HEAP8[$3 + 47 | 0] & 1) {
   HEAP8[$3 + 63 | 0] = 0;
   break label$1;
  }
  HEAP32[$3 + 40 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 48 >> 2], 131653);
  HEAP32[$3 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 48 >> 2], 132796);
  HEAP32[$3 + 32 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 48 >> 2], 128459);
  HEAP8[$3 + 31 | 0] = 0;
  if (!(!HEAP32[$3 + 40 >> 2] | (!HEAP32[$3 + 36 >> 2] | !HEAP32[$3 + 32 >> 2]))) {
   HEAP32[$3 + 24 >> 2] = jspGetNamedField(HEAP32[$3 + 36 >> 2], 134421, 0);
   HEAP32[$3 + 20 >> 2] = jspGetNamedField(HEAP32[$3 + 32 >> 2], 131969, 0);
   label$4: {
    label$5: {
     if (!(jsvIsFunction(HEAP32[$3 + 24 >> 2]) & 1)) {
      break label$5;
     }
     if (!(jsvIsFunction(HEAP32[$3 + 20 >> 2]) & 1)) {
      break label$5;
     }
     HEAP32[$3 + 16 >> 2] = jspExecuteFunction(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 36 >> 2], 1, $3 + 40 | 0);
     if (HEAP32[$3 + 16 >> 2]) {
      HEAP32[$3 + 12 >> 2] = jsvGetLength(HEAP32[$3 + 16 >> 2]);
      if (HEAP32[$3 + 12 >> 2] > 0) {
       HEAP32[$3 + 8 >> 2] = jspExecuteFunction(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 32 >> 2], 1, $3 + 16 | 0);
       label$8: {
        if (!(jsvIsBoolean(HEAP32[$3 + 8 >> 2]) & 1)) {
         break label$8;
        }
        if (jsvGetBool(HEAP32[$3 + 8 >> 2]) & 1) {
         break label$8;
        }
        jsvObjectSetChildAndUnLock(HEAP32[$3 + 48 >> 2], 117690, jsvNewFromBool(1));
       }
       jsvUnLock(HEAP32[$3 + 8 >> 2]);
      }
      jsvUnLock(HEAP32[$3 + 16 >> 2]);
      HEAP8[$3 + 31 | 0] = 1;
     }
     break label$4;
    }
    if (!(jsvIsFunction(HEAP32[$3 + 24 >> 2]) & 1)) {
     jsExceptionHere(1, 132984, 0);
    }
    if (!(jsvIsFunction(HEAP32[$3 + 20 >> 2]) & 1)) {
     jsExceptionHere(1, 132912, 0);
    }
   }
   jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
  }
  if (!(HEAP8[$3 + 31 | 0] & 1)) {
   handlePipeClose(HEAP32[$3 + 56 >> 2], HEAP32[$3 + 52 >> 2], HEAP32[$3 + 48 >> 2]);
  }
  jsvUnLock3(HEAP32[$3 + 36 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 40 >> 2]);
  HEAP8[$3 + 63 | 0] = HEAP8[$3 + 31 | 0] & 1;
 }
 __stack_pointer = $3 - -64 | 0;
 return HEAP8[$3 + 63 | 0] & 1;
}

function lcdGetPixel_ArrayBuffer($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 112 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 108 >> 2] = $0;
 HEAP32[$3 + 104 >> 2] = $1;
 HEAP32[$3 + 100 >> 2] = $2;
 HEAP32[$3 + 96 >> 2] = 0;
 $0 = HEAP32[$3 + 108 >> 2];
 HEAP32[$3 + 92 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
 HEAP32[$3 + 88 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$3 + 108 >> 2], HEAP32[$3 + 104 >> 2], HEAP32[$3 + 100 >> 2], 1);
 jsvArrayBufferIteratorNew($3 + 32 | 0, HEAP32[$3 + 92 >> 2], HEAP32[$3 + 88 >> 2] >>> 3 | 0);
 label$1: {
  if (HEAPU8[HEAP32[$3 + 108 >> 2] + 16 | 0] & 7) {
   HEAP32[$3 + 88 >> 2] = HEAP32[$3 + 88 >> 2] & 7;
   HEAP32[$3 + 28 >> 2] = (1 << HEAPU8[HEAP32[$3 + 108 >> 2] + 16 | 0]) - 1;
   HEAP32[$3 + 24 >> 2] = jsvArrayBufferIteratorGetIntegerValue($3 + 32 | 0);
   $0 = HEAP32[$3 + 108 >> 2];
   if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
    $0 = 8 - (HEAP32[$3 + 88 >> 2] + HEAPU8[HEAP32[$3 + 108 >> 2] + 16 | 0] | 0) | 0;
   } else {
    $0 = HEAP32[$3 + 88 >> 2];
   }
   HEAP32[$3 + 20 >> 2] = $0;
   HEAP32[$3 + 96 >> 2] = HEAP32[$3 + 28 >> 2] & HEAP32[$3 + 24 >> 2] >>> HEAP32[$3 + 20 >> 2];
   break label$1;
  }
  $0 = HEAP32[$3 + 108 >> 2];
  label$5: {
   if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
    HEAP32[$3 + 16 >> 2] = HEAPU8[HEAP32[$3 + 108 >> 2] + 16 | 0] - 8;
    while (1) {
     if (HEAP32[$3 + 16 >> 2] >= 0) {
      HEAP32[$3 + 96 >> 2] = jsvArrayBufferIteratorGetIntegerValue($3 + 32 | 0) << HEAP32[$3 + 16 >> 2] | HEAP32[$3 + 96 >> 2];
      jsvArrayBufferIteratorNext($3 + 32 | 0);
      HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] - 8;
      continue;
     }
     break;
    }
    break label$5;
   }
   HEAP32[$3 + 12 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 12 >> 2] < HEAPU8[HEAP32[$3 + 108 >> 2] + 16 | 0]) {
     HEAP32[$3 + 96 >> 2] = jsvArrayBufferIteratorGetIntegerValue($3 + 32 | 0) << HEAP32[$3 + 12 >> 2] | HEAP32[$3 + 96 >> 2];
     jsvArrayBufferIteratorNext($3 + 32 | 0);
     HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 8;
     continue;
    }
    break;
   }
  }
 }
 jsvArrayBufferIteratorFree($3 + 32 | 0);
 __stack_pointer = $3 + 112 | 0;
 return HEAP32[$3 + 96 >> 2];
}

function jswrap_espruino_toStringX($0, $1) {
 var $2 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP8[$2 + 55 | 0] = $1;
 label$1: {
  if ((jsvGetArrayLength(HEAP32[$2 + 56 >> 2]) | 0) == 1) {
   HEAP32[$2 + 48 >> 2] = jsvGetArrayItem(HEAP32[$2 + 56 >> 2], 0);
   label$3: {
    if (!(wasm2js_i32$0 = 0, wasm2js_i32$1 = jsvIsString(HEAP32[$2 + 48 >> 2]) & 1, 
    wasm2js_i32$2 = HEAP8[$2 + 55 | 0] & 1, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1)) {
     if (!(jsvIsFlatString(HEAP32[$2 + 48 >> 2]) & 1)) {
      break label$3;
     }
    }
    HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 48 >> 2];
    break label$1;
   }
   label$6: {
    if (!(jsvIsArrayBuffer(HEAP32[$2 + 48 >> 2]) & 1) | (HEAPU8[HEAP32[$2 + 48 >> 2] + 5 | 0] & 15) != 1) {
     break label$6;
    }
    $0 = HEAP32[$2 + 48 >> 2];
    if (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8) {
     break label$6;
    }
    HEAP32[$2 + 44 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$2 + 48 >> 2], 0);
    label$7: {
     if (!(HEAP8[$2 + 55 | 0] & 1 ? 0 : HEAP32[$2 + 44 >> 2])) {
      if (!(jsvIsFlatString(HEAP32[$2 + 44 >> 2]) & 1)) {
       break label$7;
      }
     }
     $1 = jsvGetLength(HEAP32[$2 + 44 >> 2]);
     $0 = HEAP32[$2 + 48 >> 2];
     if (($1 | 0) != (HEAPU8[$0 + 4 | 0] << 16 | (HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8))) {
      break label$7;
     }
     jsvUnLock(HEAP32[$2 + 48 >> 2]);
     HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 44 >> 2];
     break label$1;
    }
    jsvUnLock(HEAP32[$2 + 44 >> 2]);
   }
   jsvUnLock(HEAP32[$2 + 48 >> 2]);
  }
  HEAP32[$2 + 40 >> 2] = jsvIterateCallbackCount(HEAP32[$2 + 56 >> 2]);
  label$10: {
   if (HEAP8[$2 + 55 | 0] & 1) {
    $0 = jsvNewFlatStringOfLength(HEAP32[$2 + 40 >> 2]);
    break label$10;
   }
   $0 = jsvNewStringOfLength(HEAP32[$2 + 40 >> 2], 0);
  }
  HEAP32[$2 + 36 >> 2] = $0;
  if (!(HEAP32[$2 + 36 >> 2] | !(HEAP8[$2 + 55 | 0] & 1))) {
   jsvDefragment();
   HEAP32[$2 + 36 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 40 >> 2]);
  }
  if (!HEAP32[$2 + 36 >> 2]) {
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  jsvStringIteratorNew($2, HEAP32[$2 + 36 >> 2], 0);
  jsvIterateCallback(HEAP32[$2 + 56 >> 2], 626, $2);
  jsvStringIteratorFree_11($2);
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 36 >> 2];
 }
 __stack_pointer = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}

function jshFromDeviceString($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (HEAP8[HEAP32[$1 + 8 >> 2]] == 76) {
   if (!strcmp(HEAP32[$1 + 8 >> 2] + 1 | 0, 138202)) {
    HEAP8[$1 + 15 | 0] = 17;
    break label$1;
   }
   if (!strcmp(HEAP32[$1 + 8 >> 2] + 1 | 0, 138144)) {
    HEAP8[$1 + 15 | 0] = 18;
    break label$1;
   }
  }
  if (!(HEAP8[HEAP32[$1 + 8 >> 2]] != 85 | HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] != 83 | (HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] | HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] != 66))) {
   HEAP8[$1 + 15 | 0] = 21;
   break label$1;
  }
  label$6: {
   if (HEAP8[HEAP32[$1 + 8 >> 2]] == 84) {
    if (!strcmp(HEAP32[$1 + 8 >> 2] + 1 | 0, 129059)) {
     HEAP8[$1 + 15 | 0] = 20;
     break label$1;
    }
    break label$6;
   }
   label$9: {
    if (HEAP8[HEAP32[$1 + 8 >> 2]] == 83) {
     label$11: {
      if (HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] != 101 | HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] != 114 | (HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] != 105 | HEAP8[HEAP32[$1 + 8 >> 2] + 4 | 0] != 97)) {
       break label$11;
      }
      if (HEAP8[HEAP32[$1 + 8 >> 2] + 5 | 0] != 108 | HEAP8[HEAP32[$1 + 8 >> 2] + 6 | 0] < 49 | (HEAP8[HEAP32[$1 + 8 >> 2] + 7 | 0] | (HEAP8[HEAP32[$1 + 8 >> 2] + 6 | 0] - 49 | 0) > 0)) {
       break label$11;
      }
      HEAP8[$1 + 15 | 0] = HEAP8[HEAP32[$1 + 8 >> 2] + 6 | 0] - 27;
      break label$1;
     }
     label$12: {
      if (HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] != 80 | HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] != 73 | (HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] < 49 | (HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] - 49 | 0) > 0)) {
       break label$12;
      }
      if (HEAP8[HEAP32[$1 + 8 >> 2] + 4 | 0]) {
       break label$12;
      }
      HEAP8[$1 + 15 | 0] = HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] - 23;
      break label$1;
     }
     break label$9;
    }
    label$13: {
     if (HEAP8[HEAP32[$1 + 8 >> 2]] != 73 | HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] != 50 | (HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] != 67 | HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] < 49)) {
      break label$13;
     }
     if (HEAP8[HEAP32[$1 + 8 >> 2] + 4 | 0] | (HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] - 49 | 0) > 0) {
      break label$13;
     }
     HEAP8[$1 + 15 | 0] = HEAP8[HEAP32[$1 + 8 >> 2] + 3 | 0] - 22;
     break label$1;
    }
   }
  }
  HEAP8[$1 + 15 | 0] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAPU8[$1 + 15 | 0];
}

function tflite__MicroAllocator__AllocateTfLiteEvalTensors_28tflite__Model_20const__2c_20TfLiteEvalTensor___29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 56 >> 2] = $0;
 HEAP32[$3 + 52 >> 2] = $1;
 HEAP32[$3 + 48 >> 2] = $2;
 $0 = HEAP32[$3 + 56 >> 2];
 label$1: {
  if (!HEAP32[$3 + 48 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$3 + 44 >> 2] = tflite__MicroAllocator__GetSubGraphFromModel_28tflite__Model_20const__29($0, HEAP32[$3 + 52 >> 2]);
 label$2: {
  if (!HEAP32[$3 + 44 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$3 + 40 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor____size_28_29_20const(tflite__SubGraph__tensors_28_29_20const(HEAP32[$3 + 44 >> 2]));
 $1 = HEAP32[$0 + 4 >> 2];
 HEAP32[$3 + 36 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$1 >> 2] + 12 >> 2]]($1, Math_imul(HEAP32[$3 + 40 >> 2], 12), 4);
 label$3: {
  if (!HEAP32[$3 + 36 >> 2]) {
   $0 = HEAP32[$0 + 8 >> 2];
   HEAP32[$3 >> 2] = Math_imul(HEAP32[$3 + 40 >> 2], 12);
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 133664, $3);
   HEAP32[$3 + 60 >> 2] = 1;
   break label$3;
  }
  HEAP32[$3 + 32 >> 2] = 0;
  while (1) {
   if (HEAPU32[$3 + 32 >> 2] < HEAPU32[$3 + 40 >> 2]) {
    HEAP32[$3 + 28 >> 2] = tflite__internal__InitializeTfLiteEvalTensorFromFlatbuffer_28tflite__SimpleMemoryAllocator__2c_20tflite__Tensor_20const__2c_20flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer___20const__2c_20tflite__ErrorReporter__2c_20TfLiteEvalTensor__29(HEAP32[$0 + 4 >> 2], flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor____Get_28unsigned_20int_29_20const(tflite__SubGraph__tensors_28_29_20const(HEAP32[$3 + 44 >> 2]), HEAP32[$3 + 32 >> 2]), tflite__Model__buffers_28_29_20const(HEAP32[$3 + 52 >> 2]), HEAP32[$0 + 8 >> 2], HEAP32[$3 + 36 >> 2] + Math_imul(HEAP32[$3 + 32 >> 2], 12) | 0);
    if (HEAP32[$3 + 28 >> 2]) {
     $0 = HEAP32[$0 + 8 >> 2];
     HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 32 >> 2];
     tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 134779, $3 + 16 | 0);
     HEAP32[$3 + 60 >> 2] = 1;
     break label$3;
    } else {
     HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] + 1;
     continue;
    }
   }
   break;
  }
  HEAP32[HEAP32[$3 + 48 >> 2] >> 2] = HEAP32[$3 + 36 >> 2];
  HEAP32[$3 + 60 >> 2] = 0;
 }
 __stack_pointer = $3 - -64 | 0;
 return HEAP32[$3 + 60 >> 2];
}

function handlePipeClose($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 jsiQueueObjectCallbacks(HEAP32[$3 + 36 >> 2], 131975, $3 + 36 | 0, 1);
 HEAP32[$3 + 32 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 36 >> 2], 132796);
 HEAP32[$3 + 28 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 36 >> 2], 128459);
 if (!(!HEAP32[$3 + 32 >> 2] | !HEAP32[$3 + 28 >> 2])) {
  HEAP32[$3 + 24 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 32 >> 2], 130086);
  label$2: {
   if (!HEAP32[$3 + 24 >> 2]) {
    break label$2;
   }
   if (!jsvGetStringLength(HEAP32[$3 + 24 >> 2])) {
    break label$2;
   }
   jsvObjectRemoveChild(HEAP32[$3 + 32 >> 2], 130086);
   HEAP32[$3 + 20 >> 2] = jspGetNamedField(HEAP32[$3 + 28 >> 2], 131969, 0);
   if (jsvIsFunction(HEAP32[$3 + 20 >> 2]) & 1) {
    jsvUnLock(jspExecuteFunction(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 28 >> 2], 1, $3 + 24 | 0));
   }
   jsvUnLock(HEAP32[$3 + 20 >> 2]);
  }
  jsvUnLock(HEAP32[$3 + 24 >> 2]);
 }
 if (jsvObjectGetBoolChild(HEAP32[$3 + 36 >> 2], 133229) & 1) {
  if (HEAP32[$3 + 28 >> 2]) {
   jswrap_object_removeAllListeners_cstr(HEAP32[$3 + 28 >> 2], 128505);
   jswrap_object_removeAllListeners_cstr(HEAP32[$3 + 28 >> 2], 132079);
   HEAP32[$3 + 16 >> 2] = jspGetNamedField(HEAP32[$3 + 28 >> 2], 133229, 0);
   if (jsvIsFunction(HEAP32[$3 + 16 >> 2]) & 1) {
    jsvUnLock(jspExecuteFunction(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 28 >> 2], 0, 0));
   }
   jsvUnLock(HEAP32[$3 + 16 >> 2]);
   HEAP32[$3 + 12 >> 2] = jspGetNamedField(HEAP32[$3 + 28 >> 2], 132079, 0);
   if (jsvIsFunction(HEAP32[$3 + 12 >> 2]) & 1) {
    jsvUnLock(jspExecuteFunction(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 28 >> 2], 0, 0));
   }
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
  }
  if (HEAP32[$3 + 32 >> 2]) {
   jswrap_object_removeAllListeners_cstr(HEAP32[$3 + 32 >> 2], 132079);
   HEAP32[$3 + 8 >> 2] = jspGetNamedField(HEAP32[$3 + 32 >> 2], 132079, 0);
   if (jsvIsFunction(HEAP32[$3 + 8 >> 2]) & 1) {
    jsvUnLock(jspExecuteFunction(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 32 >> 2], 0, 0));
   }
   jsvUnLock(HEAP32[$3 + 8 >> 2]);
  }
 }
 jsvUnLock2(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2]);
 HEAP32[$3 + 4 >> 2] = jsvObjectIteratorGetKey_9(HEAP32[$3 + 40 >> 2]);
 jsvRemoveChildAndUnLock(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 48 | 0;
}

function jswrap_regexp_constructor($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 128 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 120 >> 2] = $0;
 HEAP32[$2 + 116 >> 2] = $1;
 label$1: {
  if (!(jsvIsString(HEAP32[$2 + 120 >> 2]) & 1)) {
   HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 120 >> 2];
   jsExceptionHere(3, 118377, $2 + 16 | 0);
   HEAP32[$2 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 112 >> 2] = jspNewObject(0, 121677);
  jsvObjectSetChild(HEAP32[$2 + 112 >> 2], 132796, HEAP32[$2 + 120 >> 2]);
  if (!(jsvIsUndefined(HEAP32[$2 + 116 >> 2]) & 1)) {
   label$4: {
    if (!(jsvIsString(HEAP32[$2 + 116 >> 2]) & 1)) {
     HEAP32[$2 >> 2] = HEAP32[$2 + 120 >> 2];
     jsExceptionHere(3, 118377, $2);
     break label$4;
    }
    jsvObjectSetChild(HEAP32[$2 + 112 >> 2], 120167, HEAP32[$2 + 116 >> 2]);
   }
  }
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 112 >> 2], 116445, jsvNewFromInteger(0));
  jsvStringIteratorNew($2 + 72 | 0, HEAP32[$2 + 120 >> 2], 0);
  HEAP8[$2 + 71 | 0] = 0;
  HEAP8[$2 + 70 | 0] = 1;
  HEAP32[$2 + 28 >> 2] = 0;
  while (1) {
   if (jsvStringIteratorHasChar_7($2 + 72 | 0) & 1) {
    HEAP8[$2 + 27 | 0] = HEAP8[$2 + 71 | 0] == 92;
    label$8: {
     if (!HEAP8[$2 + 71 | 0]) {
      break label$8;
     }
     if (!strchr(145493, HEAP8[$2 + 71 | 0])) {
      break label$8;
     }
     HEAP8[$2 + 70 | 0] = 0;
    }
    HEAP8[$2 + 71 | 0] = jsvStringIteratorGetCharAndNext($2 + 72 | 0);
    if (HEAP8[$2 + 27 | 0] & 1) {
     if (!strchr(136257, HEAP8[$2 + 71 | 0])) {
      HEAP8[$2 + 70 | 0] = 0;
      HEAP8[$2 + 71 | 0] = 0;
     }
    }
    if (!(!HEAP8[$2 + 71 | 0] | !(HEAP8[$2 + 27 | 0] & 1) & HEAP8[$2 + 71 | 0] == 92 | HEAPU32[$2 + 28 >> 2] >= 32)) {
     $1 = HEAPU8[$2 + 71 | 0];
     $0 = HEAP32[$2 + 28 >> 2];
     HEAP32[$2 + 28 >> 2] = $0 + 1;
     HEAP8[($2 + 32 | 0) + $0 | 0] = $1;
    }
    if (HEAP8[$2 + 27 | 0] & 1) {
     HEAP8[$2 + 71 | 0] = 0;
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree_9($2 + 72 | 0);
  if (!(!(HEAP8[$2 + 70 | 0] & 1) | HEAP8[$2 + 71 | 0] != 36 | HEAPU32[$2 + 28 >> 2] >= 32)) {
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 28 >> 2] - 1;
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 112 >> 2], 129340, jsvNewStringOfLength(HEAP32[$2 + 28 >> 2], $2 + 32 | 0));
  }
  HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 112 >> 2];
 }
 __stack_pointer = $2 + 128 | 0;
 return HEAP32[$2 + 124 >> 2];
}

function jspeStatementVar() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = __stack_pointer - 32 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 24 >> 2] = 0;
 label$1: {
  if (HEAP16[HEAP32[49079] + 2 >> 1] != 173) {
   $1 = 0;
   if (HEAP16[HEAP32[49079] + 2 >> 1] != 174) {
    break label$1;
   }
  }
  $1 = HEAPU8[364364] != 0;
 }
 HEAP8[$0 + 23 | 0] = $1;
 HEAP8[$0 + 22 | 0] = HEAP16[HEAP32[49079] + 2 >> 1] == 174;
 jslGetNextToken();
 HEAP8[$0 + 21 | 0] = 1;
 while (1) {
  $1 = 0;
  label$4: {
   if (!(HEAP8[$0 + 21 | 0] & 1)) {
    break label$4;
   }
   $1 = 0;
   if (HEAP16[HEAP32[49079] + 2 >> 1] != 128) {
    break label$4;
   }
   $1 = jspIsInterrupted() ^ -1;
  }
  if ($1 & 1) {
   label$6: {
    HEAP32[$0 + 16 >> 2] = 0;
    if ((HEAP32[91094] & 63) == 1) {
     HEAP32[$0 + 12 >> 2] = jslGetTokenValueAsString();
     label$8: {
      if (HEAP8[$0 + 23 | 0] & 1) {
       if (!HEAP32[91090]) {
        HEAP32[91090] = jsvNewObject();
        jspeiAddScope(HEAP32[91090]);
       }
       HEAP32[$0 + 16 >> 2] = jsvFindOrAddChildFromString(HEAP32[91090], HEAP32[$0 + 12 >> 2]);
       break label$8;
      }
      HEAP32[$0 + 16 >> 2] = jsvFindOrAddChildFromString(HEAP32[91089], HEAP32[$0 + 12 >> 2]);
     }
     if (!HEAP32[$0 + 16 >> 2]) {
      jspSetError(0);
      break label$6;
     }
    }
    if (!(jslMatch(128) & 1)) {
     jsvUnLock(HEAP32[$0 + 16 >> 2]);
     break label$6;
    }
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 61) {
     if (!(jslMatch(61) & 1)) {
      jsvUnLock(HEAP32[$0 + 16 >> 2]);
      break label$6;
     }
     HEAP32[$0 + 8 >> 2] = jsvSkipNameAndUnLock(jspeAssignmentExpression());
     if ((HEAP32[91094] & 63) == 1) {
      jsvReplaceWith(HEAP32[$0 + 16 >> 2], HEAP32[$0 + 8 >> 2]);
     }
     jsvUnLock(HEAP32[$0 + 8 >> 2]);
    }
    if (HEAP8[$0 + 22 | 0] & 1 & (HEAP32[91094] & 63) == 1) {
     $2 = HEAP32[$0 + 16 >> 2];
     $1 = HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8 | 64;
     HEAP8[$2 + 12 | 0] = $1;
     HEAP8[$2 + 13 | 0] = $1 >>> 8;
    }
    jsvUnLock(HEAP32[$0 + 24 >> 2]);
    HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 16 >> 2];
    HEAP8[$0 + 21 | 0] = HEAP16[HEAP32[49079] + 2 >> 1] == 44;
    if (HEAP8[$0 + 21 | 0] & 1) {
     if (!(jslMatch(44) & 1)) {
      break label$6;
     }
    }
    continue;
   }
  }
  break;
 }
 HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
 __stack_pointer = $0 + 32 | 0;
 return HEAP32[$0 + 28 >> 2];
}

function jsvGetFloat($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 96 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 84 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 84 >> 2]) {
   HEAPF64[$1 + 88 >> 3] = nan;
   break label$1;
  }
  if (jsvIsFloat(HEAP32[$1 + 84 >> 2]) & 1) {
   $0 = HEAP32[$1 + 84 >> 2];
   $2 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
   wasm2js_scratch_store_i32(0, HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
   wasm2js_scratch_store_i32(1, $2 | 0);
   HEAPF64[$1 + 88 >> 3] = wasm2js_scratch_load_f64();
   break label$1;
  }
  if (jsvIsIntegerish(HEAP32[$1 + 84 >> 2]) & 1) {
   $0 = HEAP32[$1 + 84 >> 2];
   HEAPF64[$1 + 88 >> 3] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   break label$1;
  }
  label$5: {
   if (!(jsvIsArray(HEAP32[$1 + 84 >> 2]) & 1)) {
    if (!(jsvIsArrayBuffer(HEAP32[$1 + 84 >> 2]) & 1)) {
     break label$5;
    }
   }
   HEAP32[$1 + 80 >> 2] = jsvGetLength(HEAP32[$1 + 84 >> 2]);
   if (!HEAP32[$1 + 80 >> 2]) {
    HEAPF64[$1 + 88 >> 3] = 0;
    break label$1;
   }
   if (HEAP32[$1 + 80 >> 2] == 1) {
    if (jsvIsArrayBuffer(HEAP32[$1 + 84 >> 2]) & 1) {
     HEAPF64[$1 + 88 >> 3] = jsvGetFloatAndUnLock(jsvArrayBufferGet(HEAP32[$1 + 84 >> 2], 0));
     break label$1;
    }
    HEAPF64[$1 + 88 >> 3] = jsvGetFloatAndUnLock(jsvSkipNameAndUnLock(jsvGetArrayItem(HEAP32[$1 + 84 >> 2], 0)));
    break label$1;
   }
  }
  if (jsvIsString(HEAP32[$1 + 84 >> 2]) & 1) {
   label$11: {
    if ((jsvGetString(HEAP32[$1 + 84 >> 2], $1 + 16 | 0, 64) | 0) == 64) {
     jsExceptionHere(1, 121368, 0);
     break label$11;
    }
    if (!HEAP8[$1 + 16 | 0]) {
     HEAPF64[$1 + 88 >> 3] = 0;
     break label$1;
    }
    if (!strcmp($1 + 16 | 0, 116119)) {
     HEAPF64[$1 + 88 >> 3] = infinity;
     break label$1;
    }
    if (!strcmp($1 + 16 | 0, 116118)) {
     HEAPF64[$1 + 88 >> 3] = -infinity;
     break label$1;
    }
    HEAP32[$1 + 12 >> 2] = 0;
    HEAPF64[$1 >> 3] = stringToFloatWithRadix($1 + 16 | 0, 0, $1 + 12 | 0);
    if (!HEAP8[HEAP32[$1 + 12 >> 2]]) {
     HEAPF64[$1 + 88 >> 3] = HEAPF64[$1 >> 3];
     break label$1;
    }
   }
  }
  HEAPF64[$1 + 88 >> 3] = nan;
 }
 __stack_pointer = $1 + 96 | 0;
 return +HEAPF64[$1 + 88 >> 3];
}

function _jswrap_interface_setTimeoutOrInterval($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 56 >> 2] = $0;
 HEAPF64[$4 + 48 >> 3] = $1;
 HEAP32[$4 + 44 >> 2] = $2;
 HEAP8[$4 + 43 | 0] = $3;
 label$1: {
  label$2: {
   if (jsvIsFunction(HEAP32[$4 + 56 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsString(HEAP32[$4 + 56 >> 2]) & 1) {
    break label$2;
   }
   jsExceptionHere(1, 145837, 0);
   HEAP32[$4 + 60 >> 2] = 0;
   break label$1;
  }
  $0 = __DOUBLE_BITS_8(HEAPF64[$4 + 48 >> 3]);
  $6 = $0;
  $2 = i64toi32_i32$HIGH_BITS;
  $0 = $2 & 2147483647;
  $2 = $6;
  if (!(HEAPF64[$4 + 48 >> 3] < .1 ? 0 : !$2 & ($0 | 0) == 2146435072 | $0 >>> 0 < 2146435072)) {
   HEAPF64[$4 + 48 >> 3] = .1;
  }
  if (HEAPF64[$4 + 48 >> 3] > 31536000001e3) {
   jsExceptionHere(1, 142849, 0);
   HEAP32[$4 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 36 >> 2] = jsvNewObject();
  if (!HEAP32[$4 + 36 >> 2]) {
   HEAP32[$4 + 60 >> 2] = 0;
   break label$1;
  }
  $2 = jshGetTimeFromMilliseconds(HEAPF64[$4 + 48 >> 3]);
  HEAP32[$4 + 24 >> 2] = $2;
  $0 = i64toi32_i32$HIGH_BITS;
  HEAP32[$4 + 28 >> 2] = $0;
  $7 = HEAP32[$4 + 36 >> 2];
  $0 = jshGetSystemTime();
  $3 = $0;
  $2 = i64toi32_i32$HIGH_BITS;
  $8 = $2;
  $0 = HEAP32[91119];
  $9 = $0;
  $2 = HEAP32[91118];
  $6 = $2;
  $5 = $3 - $2 | 0;
  $10 = $5;
  $0 = $8;
  $2 = $9;
  $0 = $0 - ($2 + ($6 >>> 0 > $3 >>> 0) | 0) | 0;
  $3 = HEAP32[$4 + 28 >> 2];
  $2 = $3;
  $3 = $0;
  $5 = $2 + $3 | 0;
  $0 = $10;
  $6 = HEAP32[$4 + 24 >> 2];
  $2 = $0 + $6 | 0;
  $5 = $2 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  jsvObjectSetChildAndUnLock($7, 132372, jsvNewFromLongInteger($2, $5));
  if (!(HEAP8[$4 + 43 | 0] & 1)) {
   $5 = HEAP32[$4 + 24 >> 2];
   $0 = HEAP32[$4 + 28 >> 2];
   jsvObjectSetChildAndUnLock(HEAP32[$4 + 36 >> 2], 120745, jsvNewFromLongInteger($5, $0));
  }
  jsvObjectSetChild(HEAP32[$4 + 36 >> 2], 135710, HEAP32[$4 + 56 >> 2]);
  if (jsvGetArrayLength(HEAP32[$4 + 44 >> 2])) {
   jsvObjectSetChild(HEAP32[$4 + 36 >> 2], 120162, HEAP32[$4 + 44 >> 2]);
  }
  HEAP32[$4 + 20 >> 2] = jsvNewFromInteger(jsiTimerAdd(HEAP32[$4 + 36 >> 2]));
  jsvUnLock(HEAP32[$4 + 36 >> 2]);
  jsiTimersChanged();
  HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 20 >> 2];
 }
 __stack_pointer = $4 - -64 | 0;
 return HEAP32[$4 + 60 >> 2];
}

function touchHandlerInternal($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 if (!(HEAP32[97749] & 262144)) {
  deviceToGraphicsCoordinates(366800, $4 + 28 | 0, $4 + 24 | 0);
  HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 28 >> 2] - HEAP16[195521];
  HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 24 >> 2] - HEAP16[195522];
  HEAP16[195521] = HEAP32[$4 + 28 >> 2];
  HEAP16[195522] = HEAP32[$4 + 24 >> 2];
  HEAP8[391046] = HEAP32[$4 + 20 >> 2] != 0;
  HEAP32[$4 + 4 >> 2] = HEAP32[97752];
  if (HEAP32[$4 + 16 >> 2] != HEAP32[97762]) {
   label$3: {
    label$4: {
     switch (HEAP32[$4 + 16 >> 2] - 1 | 0) {
     case 0:
      HEAP32[97763] = touchSwipeRotate(4);
      HEAP32[97752] = HEAP32[97752] | 524288;
      break label$3;

     case 1:
      HEAP32[97763] = touchSwipeRotate(3);
      HEAP32[97752] = HEAP32[97752] | 524288;
      break label$3;

     case 2:
      HEAP32[97763] = touchSwipeRotate(1);
      HEAP32[97752] = HEAP32[97752] | 524288;
      break label$3;

     case 3:
      HEAP32[97763] = touchSwipeRotate(2);
      HEAP32[97752] = HEAP32[97752] | 524288;
      break label$3;

     case 4:
      label$11: {
       if (HEAP16[195521] < 80) {
        HEAP32[97752] = HEAP32[97752] | 1048576;
        break label$11;
       }
       HEAP32[97752] = HEAP32[97752] | 2097152;
      }
      HEAP8[391056] = 0;
      break label$3;

     case 10:
      label$13: {
       if (HEAP16[195521] < 80) {
        HEAP32[97752] = HEAP32[97752] | 1048576;
        break label$13;
       }
       HEAP32[97752] = HEAP32[97752] | 2097152;
      }
      HEAP8[391056] = 1;
      break label$3;

     case 11:
      break label$4;

     default:
      break label$3;
     }
    }
    label$15: {
     if (HEAP16[195521] < 80) {
      HEAP32[97752] = HEAP32[97752] | 1048576;
      break label$15;
     }
     HEAP32[97752] = HEAP32[97752] | 2097152;
    }
    HEAP8[391056] = 2;
   }
  }
  if (!(!((HEAP8[391046] & 1) != (HEAP8[391057] & 1) | HEAP16[195529] != HEAP16[195521]) & HEAP16[195530] == HEAP16[195522])) {
   HEAP32[97752] = HEAP32[97752] | 4194304;
  }
  if (HEAP32[$4 + 4 >> 2] != HEAP32[97752]) {
   jshHadEvent();
   HEAP16[195510] = 0;
  }
  HEAP32[97762] = HEAP32[$4 + 16 >> 2];
 }
 __stack_pointer = $4 + 32 | 0;
}

function jsvSkipNameWithParent($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP8[$3 + 39 | 0] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 label$1: {
  if (!HEAP32[$3 + 40 >> 2]) {
   HEAP32[$3 + 44 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$3 + 40 >> 2];
  HEAP16[$3 + 30 >> 1] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  if (HEAPU16[$3 + 30 >> 1] == 14) {
   HEAP32[$3 + 44 >> 2] = jsvArrayBufferGetFromName(HEAP32[$3 + 40 >> 2]);
   break label$1;
  }
  if (!((HEAPU16[$3 + 30 >> 1] < 18 | HEAPU16[$3 + 30 >> 1] > 22) & HEAPU16[$3 + 30 >> 1] != 16)) {
   HEAP32[$3 + 44 >> 2] = jsvNewFromInteger(jsvGetFirstChildSigned(HEAP32[$3 + 40 >> 2]) << 16 >> 16);
   break label$1;
  }
  if (HEAPU16[$3 + 30 >> 1] == 17) {
   HEAP32[$3 + 44 >> 2] = jsvNewFromBool((jsvGetFirstChild(HEAP32[$3 + 40 >> 2]) & 65535) != 0);
   break label$1;
  }
  HEAP32[$3 + 24 >> 2] = jsvLockAgain(HEAP32[$3 + 40 >> 2]);
  while (1) {
   $0 = 0;
   label$9: {
    $0 = HEAPU16[$3 + 30 >> 1] >= 14 ? HEAPU16[$3 + 30 >> 1] <= 27 : $0;
    if (!$0) {
     break label$9;
    }
    HEAP16[$3 + 22 >> 1] = jsvGetFirstChild(HEAP32[$3 + 24 >> 2]);
    jsvUnLock(HEAP32[$3 + 24 >> 2]);
    if (!HEAPU16[$3 + 22 >> 1]) {
     if (HEAP32[$3 + 24 >> 2] == HEAP32[$3 + 40 >> 2]) {
      jsvCheckReferenceError(HEAP32[$3 + 40 >> 2]);
     }
     HEAP32[$3 + 44 >> 2] = 0;
     break label$1;
    }
    HEAP32[$3 + 24 >> 2] = jsvLock(HEAPU16[$3 + 22 >> 1]);
    $0 = HEAP32[$3 + 24 >> 2];
    HEAP16[$3 + 30 >> 1] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
    if (!(HEAP8[$3 + 39 | 0] & 1)) {
     break label$9;
    }
    continue;
   }
   break;
  }
  if (jsvIsGetterOrSetter(HEAP32[$3 + 24 >> 2]) & 1) {
   label$13: {
    if (jsvIsNewChild(HEAP32[$3 + 40 >> 2]) & 1) {
     $0 = jsvLock(jsvGetNextSibling(HEAP32[$3 + 40 >> 2]) & 65535);
     break label$13;
    }
    $0 = 0;
   }
   HEAP32[$3 + 16 >> 2] = $0;
   if (HEAP32[$3 + 16 >> 2]) {
    $0 = HEAP32[$3 + 16 >> 2];
   } else {
    $0 = HEAP32[$3 + 32 >> 2];
   }
   HEAP32[$3 + 12 >> 2] = jsvExecuteGetter($0, HEAP32[$3 + 24 >> 2]);
   jsvUnLock2(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 24 >> 2]);
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 12 >> 2];
  }
  HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 24 >> 2];
 }
 __stack_pointer = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}

function jswrap_graphics_setFontCustom($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = __stack_pointer - 112 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 104 >> 2] = $0;
 HEAP32[$5 + 100 >> 2] = $1;
 HEAP32[$5 + 96 >> 2] = $2;
 HEAP32[$5 + 92 >> 2] = $3;
 HEAP32[$5 + 88 >> 2] = $4;
 label$1: {
  if (!(graphicsGetFromVar($5 + 16 | 0, HEAP32[$5 + 104 >> 2]) & 1)) {
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsString(HEAP32[$5 + 100 >> 2]) & 1)) {
   jsExceptionHere(1, 129919, 0);
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  if (!(HEAP32[$5 + 96 >> 2] <= 255 & HEAP32[$5 + 96 >> 2] >= 0)) {
   jsExceptionHere(1, 132632, 0);
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  label$6: {
   if (jsvIsString(HEAP32[$5 + 92 >> 2]) & 1) {
    break label$6;
   }
   if (jsvIsInt(HEAP32[$5 + 92 >> 2]) & 1) {
    break label$6;
   }
   jsExceptionHere(1, 121126, 0);
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 88 >> 2] >> 8 & 255;
  if (HEAP32[$5 + 12 >> 2] <= 0) {
   HEAP32[$5 + 12 >> 2] = 1;
  }
  HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 88 >> 2] >> 16;
  if (HEAP32[$5 + 8 >> 2] <= 0) {
   HEAP32[$5 + 8 >> 2] = 1;
  }
  label$9: {
   if (HEAP32[$5 + 8 >> 2] == 1) {
    HEAP32[$5 + 4 >> 2] = 32768;
    break label$9;
   }
   label$11: {
    if (HEAP32[$5 + 8 >> 2] == 2) {
     HEAP32[$5 + 4 >> 2] = 40960;
     break label$11;
    }
    label$13: {
     if (HEAP32[$5 + 8 >> 2] == 4) {
      HEAP32[$5 + 4 >> 2] = 49152;
      break label$13;
     }
     jsExceptionHere(1, 133538, 0);
     HEAP32[$5 + 108 >> 2] = 0;
     break label$1;
    }
   }
  }
  HEAP32[$5 + 88 >> 2] = HEAP32[$5 + 88 >> 2] & 255;
  jsvObjectSetChild(HEAP32[$5 + 104 >> 2], 138138, HEAP32[$5 + 100 >> 2]);
  jsvObjectSetChild(HEAP32[$5 + 104 >> 2], 136497, HEAP32[$5 + 92 >> 2]);
  jsvObjectSetChildAndUnLock(HEAP32[$5 + 104 >> 2], 137559, jsvNewFromInteger(HEAP32[$5 + 88 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$5 + 104 >> 2], 139860, jsvNewFromInteger(HEAP32[$5 + 96 >> 2]));
  $0 = HEAP32[$5 + 12 >> 2] + HEAP32[$5 + 4 >> 2] | 0;
  HEAP8[$5 + 41 | 0] = $0;
  HEAP8[$5 + 42 | 0] = $0 >>> 8;
  graphicsSetVar($5 + 16 | 0);
  HEAP32[$5 + 108 >> 2] = jsvLockAgain(HEAP32[$5 + 104 >> 2]);
 }
 __stack_pointer = $5 + 112 | 0;
 return HEAP32[$5 + 108 >> 2];
}

function jspEvaluateModule($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer + -64 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 label$1: {
  label$2: {
   if (jsvIsFunction(HEAP32[$1 + 56 >> 2]) & 1) {
    HEAP32[$1 + 56 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 56 >> 2], 133204);
    if (!(jsvIsString(HEAP32[$1 + 56 >> 2]) & 1)) {
     jsvUnLock(HEAP32[$1 + 56 >> 2]);
     HEAP32[$1 + 60 >> 2] = 0;
     break label$1;
    }
    break label$2;
   }
   jsvLockAgain(HEAP32[$1 + 56 >> 2]);
  }
  HEAP32[$1 + 52 >> 2] = jsvNewObject();
  HEAP32[$1 + 48 >> 2] = jsvNewObject();
  if (!(HEAP32[$1 + 48 >> 2] ? HEAP32[$1 + 52 >> 2] : 0)) {
   jsvUnLock3(HEAP32[$1 + 52 >> 2], HEAP32[$1 + 48 >> 2], HEAP32[$1 + 56 >> 2]);
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 44 >> 2] = jsvAddNamedChild(HEAP32[$1 + 52 >> 2], HEAP32[$1 + 48 >> 2], 119579);
  jsvUnLock2(HEAP32[$1 + 48 >> 2], jsvAddNamedChild(HEAP32[$1 + 52 >> 2], HEAP32[$1 + 52 >> 2], 132403));
  HEAP32[$1 + 40 >> 2] = HEAP32[91094];
  $0 = HEAP32[91093];
  $2 = HEAP32[91092];
  HEAP32[$1 + 32 >> 2] = $2;
  HEAP32[$1 + 36 >> 2] = $0;
  $2 = HEAP32[91091];
  $0 = HEAP32[91090];
  HEAP32[$1 + 24 >> 2] = $0;
  HEAP32[$1 + 28 >> 2] = $2;
  $0 = HEAP32[91089];
  $2 = HEAP32[91088];
  HEAP32[$1 + 16 >> 2] = $2;
  HEAP32[$1 + 20 >> 2] = $0;
  $2 = HEAP32[91087];
  $0 = HEAP32[91086];
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 12 >> 2] = $2;
  HEAP32[91089] = HEAP32[$1 + 48 >> 2];
  HEAP32[91090] = 0;
  HEAP8[364364] = 0;
  HEAP32[91092] = HEAP32[$1 + 48 >> 2];
  jsvUnLock(jspEvaluateVar(HEAP32[$1 + 56 >> 2], HEAP32[$1 + 52 >> 2], 0));
  HEAP32[$1 + 4 >> 2] = HEAP32[91094] & 112;
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = HEAP32[$1 + 8 >> 2];
  HEAP32[91086] = $2;
  HEAP32[91087] = $0;
  HEAP32[91094] = HEAP32[$1 + 40 >> 2];
  $2 = HEAP32[$1 + 36 >> 2];
  $0 = HEAP32[$1 + 32 >> 2];
  HEAP32[91092] = $0;
  HEAP32[91093] = $2;
  $0 = HEAP32[$1 + 28 >> 2];
  $2 = HEAP32[$1 + 24 >> 2];
  HEAP32[91090] = $2;
  HEAP32[91091] = $0;
  $2 = HEAP32[$1 + 20 >> 2];
  $0 = HEAP32[$1 + 16 >> 2];
  HEAP32[91088] = $0;
  HEAP32[91089] = $2;
  HEAP32[91094] = HEAP32[$1 + 4 >> 2] | HEAP32[91094];
  jsvUnLock2(HEAP32[$1 + 56 >> 2], HEAP32[$1 + 52 >> 2]);
  HEAP32[$1 + 60 >> 2] = jsvSkipNameAndUnLock(HEAP32[$1 + 44 >> 2]);
 }
 __stack_pointer = $1 - -64 | 0;
 return HEAP32[$1 + 60 >> 2];
}

function tf_create($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 40 >> 2];
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$0 >> 2] = 0;
 tflite__EspruinoErrorReporter__EspruinoErrorReporter_28_29($0);
 HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 28 >> 2];
 HEAP32[$3 + 20 >> 2] = tflite__GetModel_28void_20const__29(HEAP32[$3 + 32 >> 2]);
 label$1: {
  if ((tflite__Model__version_28_29_20const(HEAP32[$3 + 20 >> 2]) | 0) != 3) {
   $0 = HEAP32[$3 + 24 >> 2];
   $1 = tflite__Model__version_28_29_20const(HEAP32[$3 + 20 >> 2]);
   HEAP32[$3 + 4 >> 2] = 3;
   HEAP32[$3 >> 2] = $1;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 140954, $3);
   HEAP8[$3 + 47 | 0] = 0;
   break label$1;
  }
  tflite__MicroMutableOpResolver_9u___MicroMutableOpResolver_28tflite__ErrorReporter__29(HEAP32[$3 + 28 >> 2] + 16 | 0, 0);
  tflite__MicroMutableOpResolver_9u___AddDepthwiseConv2D_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddConv2D_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddAveragePool2D_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddMaxPool2D_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddFullyConnected_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddSoftmax_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddQuantize_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddDequantize_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroMutableOpResolver_9u___AddReshape_28_29(HEAP32[$3 + 28 >> 2] + 16 | 0);
  tflite__MicroInterpreter__MicroInterpreter_28tflite__Model_20const__2c_20tflite__MicroOpResolver_20const__2c_20unsigned_20char__2c_20unsigned_20long_2c_20tflite__ErrorReporter__2c_20tflite__Profiler__29(HEAP32[$3 + 28 >> 2] + 400 | 0, HEAP32[$3 + 20 >> 2], HEAP32[$3 + 28 >> 2] + 16 | 0, HEAP32[$3 + 28 >> 2] + 560 | 0, HEAP32[$3 + 36 >> 2], HEAP32[$3 + 24 >> 2], 0);
  tflite__MicroInterpreter__AllocateTensors_28_29(HEAP32[$3 + 28 >> 2] + 400 | 0);
  HEAP8[$3 + 47 | 0] = 1;
 }
 __stack_pointer = $3 + 48 | 0;
 return HEAP8[$3 + 47 | 0] & 1;
}

function jswrap_io_shiftOut($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 96 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 92 >> 2] = $0;
 HEAP32[$3 + 88 >> 2] = $1;
 HEAP32[$3 + 84 >> 2] = $2;
 HEAP32[$3 + 76 >> 2] = 0;
 HEAP8[$3 + 72 | 0] = 255;
 HEAP8[$3 + 73 | 0] = 0;
 HEAP32[$3 + 80 >> 2] = 1;
 HEAP32[$3 + 16 >> 2] = 129105;
 HEAP16[$3 + 20 >> 1] = 13;
 HEAP32[$3 + 24 >> 2] = $3 + 72;
 HEAP32[$3 + 28 >> 2] = 128722;
 HEAP16[$3 + 32 >> 1] = 12;
 HEAP32[$3 + 36 >> 2] = $3 + 73;
 HEAP32[$3 + 40 >> 2] = 117940;
 HEAP16[$3 + 44 >> 1] = 10;
 HEAP32[$3 + 48 >> 2] = $3 + 80;
 label$1: {
  if (!(jsvReadConfigObject(HEAP32[$3 + 88 >> 2], $3 + 16 | 0, 3) & 1)) {
   break label$1;
  }
  HEAP8[$3 + 73 | 0] = HEAP8[$3 + 73 | 0] & 1;
  if (HEAP32[$3 + 80 >> 2] <= 0) {
   HEAP32[$3 + 80 >> 2] = 1;
  }
  label$3: {
   if (jsvIsArray(HEAP32[$3 + 92 >> 2]) & 1) {
    jsvObjectIteratorNew($3 + 8 | 0, HEAP32[$3 + 92 >> 2]);
    while (1) {
     if (jsvObjectIteratorHasValue_15($3 + 8 | 0) & 1) {
      if (HEAP32[$3 + 76 >> 2] >= 8) {
       HEAP32[$3 >> 2] = 8;
       jsExceptionHere(1, 128574, $3);
       break label$1;
      } else {
       $0 = jshGetPinFromVarAndUnLock(jsvObjectIteratorGetValue_14($3 + 8 | 0));
       HEAP8[HEAP32[$3 + 76 >> 2] + ($3 - -64 | 0) | 0] = $0;
       HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
       jsvObjectIteratorNext($3 + 8 | 0);
       continue;
      }
     }
     break;
    }
    jsvObjectIteratorFree_15($3 + 8 | 0);
    break label$3;
   }
   $1 = jshGetPinFromVar(HEAP32[$3 + 92 >> 2]);
   $0 = HEAP32[$3 + 76 >> 2];
   HEAP32[$3 + 76 >> 2] = $0 + 1;
   HEAP8[($3 - -64 | 0) + $0 | 0] = $1;
  }
  HEAP32[$3 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 4 >> 2] < HEAP32[$3 + 76 >> 2]) {
    if (jshIsPinValid(HEAPU8[HEAP32[$3 + 4 >> 2] + ($3 - -64 | 0) | 0]) & 1) {
     if (!(jshGetPinStateIsManual(HEAPU8[HEAP32[$3 + 4 >> 2] + ($3 - -64 | 0) | 0]) & 1)) {
      jshPinSetState(HEAPU8[HEAP32[$3 + 4 >> 2] + ($3 - -64 | 0) | 0], 1);
     }
    }
    HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 1;
    continue;
   }
   break;
  }
  if (jshIsPinValid(HEAPU8[$3 + 72 | 0]) & 1) {
   jshPinSetState(HEAPU8[$3 + 72 | 0], 1);
  }
  jsvIterateCallback(HEAP32[$3 + 84 >> 2], 628, $3 - -64 | 0);
 }
 __stack_pointer = $3 + 96 | 0;
}

function jswrap_waveform_idle() {
 var $0 = 0;
 $0 = __stack_pointer + -64 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 60 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 131709);
 if (HEAP32[$0 + 60 >> 2]) {
  jsvObjectIteratorNew($0 + 56 | 0, HEAP32[$0 + 60 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_18($0 + 56 | 0) & 1) {
    HEAP32[$0 + 52 >> 2] = jsvObjectIteratorGetValue_17($0 + 56 | 0);
    HEAP8[$0 + 51 | 0] = jsvObjectGetBoolChild(HEAP32[$0 + 52 >> 2], 129992) & 1;
    if (HEAP8[$0 + 51 | 0] & 1) {
     HEAP32[$0 + 44 >> 2] = jswrap_waveform_getBuffer(HEAP32[$0 + 52 >> 2], 0, 0);
     label$5: {
      if (!(jstGetLastBufferTimerTask(HEAP32[$0 + 44 >> 2], $0 + 16 | 0) & 1)) {
       HEAP32[$0 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 52 >> 2], 121187);
       jsiQueueObjectCallbacks(HEAP32[$0 + 52 >> 2], 129404, $0 + 12 | 0, 1);
       jsvUnLock(HEAP32[$0 + 12 >> 2]);
       HEAP8[$0 + 51 | 0] = 0;
       jsvObjectSetChildAndUnLock(HEAP32[$0 + 52 >> 2], 129992, jsvNewFromBool(HEAP8[$0 + 51 | 0] & 1));
       break label$5;
      }
      if (!(!(HEAPU8[$0 + 30 | 0] | HEAPU8[$0 + 31 | 0] << 8) | (HEAPU8[$0 + 30 | 0] | HEAPU8[$0 + 31 | 0] << 8) == (HEAPU8[$0 + 28 | 0] | HEAPU8[$0 + 29 | 0] << 8))) {
       HEAP32[$0 + 8 >> 2] = (jsvGetRef(HEAP32[$0 + 44 >> 2]) & 65535) != (HEAPU8[$0 + 28 | 0] | HEAPU8[$0 + 29 | 0] << 8);
       HEAP32[$0 + 4 >> 2] = jsvGetIntegerAndUnLock(jsvObjectGetChild(HEAP32[$0 + 52 >> 2], 121329, 10));
       if (HEAP32[$0 + 4 >> 2] != HEAP32[$0 + 8 >> 2]) {
        jsvObjectSetChildAndUnLock(HEAP32[$0 + 52 >> 2], 121329, jsvNewFromInteger(HEAP32[$0 + 8 >> 2]));
        HEAP32[$0 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 52 >> 2], HEAP32[$0 + 8 >> 2] ? 121187 : 139553);
        jsiQueueObjectCallbacks(HEAP32[$0 + 52 >> 2], 121176, $0, 1);
        jsvUnLock(HEAP32[$0 >> 2]);
       }
      }
     }
     jsvUnLock(HEAP32[$0 + 44 >> 2]);
    }
    jsvUnLock(HEAP32[$0 + 52 >> 2]);
    label$9: {
     if (!(HEAP8[$0 + 51 | 0] & 1)) {
      jsvObjectIteratorRemoveAndGotoNext($0 + 56 | 0, HEAP32[$0 + 60 >> 2]);
      break label$9;
     }
     jsvObjectIteratorNext($0 + 56 | 0);
    }
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_18($0 + 56 | 0);
  jsvUnLock(HEAP32[$0 + 60 >> 2]);
 }
 __stack_pointer = $0 - -64 | 0;
 return 0;
}

function jsiHandleNewLine($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 31 | 0] = $0;
 label$1: {
  if (jsiAtEndOfInputLine() & 1) {
   label$3: {
    if (!(HEAP8[$1 + 31 | 0] & 1)) {
     break label$3;
    }
    if ((jsiCountBracketsInInput() | 0) > 0) {
     break label$3;
    }
    if (jsiShowInputLine() & 1) {
     jsiConsolePrintString(148266);
    }
    if (!(HEAPU16[182206] & 2)) {
     HEAP8[364420] = 1;
    }
    HEAP32[$1 + 24 >> 2] = jsvStringTrimRight(HEAP32[91104]);
    jsiClearInputLine(0);
    HEAP32[$1 + 20 >> 2] = jspEvaluateVar(HEAP32[$1 + 24 >> 2], 0, HEAPU16[182217]);
    HEAP8[$1 + 19 | 0] = jsvIsEmptyString(HEAP32[$1 + 24 >> 2]) & 1;
    label$6: {
     if (HEAP8[$1 + 19 | 0] & 1) {
      break label$6;
     }
     if (!(jsiEcho() & 1)) {
      break label$6;
     }
     jsiHistoryAddLine(HEAP32[$1 + 24 >> 2]);
    }
    jsvUnLock(HEAP32[$1 + 24 >> 2]);
    HEAP16[182217] = 0;
    label$7: {
     if (!(jsiEcho() & 1)) {
      break label$7;
     }
     if (jspHasError() & 1 | HEAP8[$1 + 19 | 0] & 1) {
      break label$7;
     }
     jsiConsolePrintChar(61);
     jsfPrintJSON(HEAP32[$1 + 20 >> 2], 813);
     jsiConsolePrintString(148266);
    }
    jsvUnLock(HEAP32[$1 + 20 >> 2]);
    jsiCheckErrors();
    HEAP16[182206] = HEAPU16[182206] & -3;
    break label$1;
   }
   if (jsiShowInputLine() & 1) {
    jsiConsolePrintString(139034);
   }
   jsiIsAboutToEditInputLine();
   jsiAppendToInputLine(10);
   HEAP32[91106] = HEAP32[91106] + 1;
   break label$1;
  }
  jsiIsAboutToEditInputLine();
  if (jsiShowInputLine() & 1) {
   jsiConsoleEraseAfterCursor();
  }
  HEAP32[$1 + 12 >> 2] = jsvNewFromEmptyString_5();
  if (HEAP32[91106]) {
   jsvAppendStringVar(HEAP32[$1 + 12 >> 2], HEAP32[91104], 0, HEAP32[91106]);
  }
  jsvAppendCharacter_1(HEAP32[$1 + 12 >> 2], 10);
  jsvAppendStringVar(HEAP32[$1 + 12 >> 2], HEAP32[91104], HEAP32[91106], 2147483647);
  jsiInputLineCursorMoved();
  jsvUnLock(HEAP32[91104]);
  HEAP32[91104] = HEAP32[$1 + 12 >> 2];
  if (jsiShowInputLine() & 1) {
   jsiConsolePrintStringVarWithNewLineChar(HEAP32[91104], HEAP32[91106], 58);
   jsiMoveCursorChar(HEAP32[91104], jsvGetStringLength(HEAP32[91104]), HEAP32[91106] + 1 | 0);
  }
  HEAP32[91106] = HEAP32[91106] + 1;
 }
 __stack_pointer = $1 + 32 | 0;
}

function graphicsStructResetState($0) {
 var $1 = 0, $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 label$1: {
  label$2: {
   $0 = HEAP32[$2 + 12 >> 2];
   if (!(HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24))) {
    break label$2;
   }
   $0 = HEAP32[$2 + 12 >> 2];
   if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) == 1) {
    break label$2;
   }
   $0 = HEAP32[$2 + 12 >> 2];
   $1 = HEAPU8[366785] | HEAPU8[366786] << 8;
   HEAP8[$0 + 17 | 0] = $1;
   HEAP8[$0 + 18 | 0] = $1 >>> 8;
   HEAP8[$0 + 19 | 0] = $1 >>> 16;
   HEAP8[$0 + 20 | 0] = $1 >>> 24;
   $0 = HEAP32[$2 + 12 >> 2];
   $1 = HEAPU8[366787] | HEAPU8[366788] << 8;
   HEAP8[$0 + 21 | 0] = $1;
   HEAP8[$0 + 22 | 0] = $1 >>> 8;
   HEAP8[$0 + 23 | 0] = $1 >>> 16;
   HEAP8[$0 + 24 | 0] = $1 >>> 24;
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  $1 = HEAPU8[HEAP32[$2 + 12 >> 2] + 16 | 0] >= 32 ? -1 : (1 << HEAPU8[HEAP32[$2 + 12 >> 2] + 16 | 0]) - 1 | 0;
  HEAP8[$0 + 17 | 0] = $1;
  HEAP8[$0 + 18 | 0] = $1 >>> 8;
  HEAP8[$0 + 19 | 0] = $1 >>> 16;
  HEAP8[$0 + 20 | 0] = $1 >>> 24;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP8[$0 + 21 | 0] = 0;
  HEAP8[$0 + 22 | 0] = 0;
  HEAP8[$0 + 23 | 0] = 0;
  HEAP8[$0 + 24 | 0] = 0;
 }
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 25 | 0] = 1;
 HEAP8[$0 + 26 | 0] = 32;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 31 | 0] = HEAPU8[$0 + 31 | 0] | 3;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 31 | 0] = HEAPU8[$0 + 31 | 0] | 12;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 31 | 0] = HEAPU8[$0 + 31 | 0] & -49;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 32 | 0] = 0;
 HEAP8[$0 + 33 | 0] = 0;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 34 | 0] = 0;
 HEAP8[$0 + 35 | 0] = 0;
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = HEAP32[$2 + 12 >> 2];
 $1 = (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) - 1 | 0;
 HEAP8[$0 + 36 | 0] = $1;
 HEAP8[$0 + 37 | 0] = $1 >>> 8;
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = HEAP32[$2 + 12 >> 2];
 $1 = (HEAPU8[$1 + 14 | 0] | HEAPU8[$1 + 15 | 0] << 8) - 1 | 0;
 HEAP8[$0 + 38 | 0] = $1;
 HEAP8[$0 + 39 | 0] = $1 >>> 8;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 27 | 0] = 0;
 HEAP8[$0 + 28 | 0] = 0;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP8[$0 + 29 | 0] = 0;
 HEAP8[$0 + 30 | 0] = 0;
}

function lcdGetPixel_ArrayBuffer_flat($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 HEAP32[$3 + 32 >> 2] = 0;
 $0 = HEAP32[$3 + 44 >> 2];
 HEAP32[$3 + 28 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
 HEAP32[$3 + 24 >> 2] = lcdGetPixelIndex_ArrayBuffer(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2], HEAP32[$3 + 36 >> 2], 1);
 HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 24 >> 2] >>> 3 | 0);
 label$1: {
  if (HEAPU8[HEAP32[$3 + 44 >> 2] + 16 | 0] & 7) {
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] & 7;
   HEAP32[$3 + 20 >> 2] = (1 << HEAPU8[HEAP32[$3 + 44 >> 2] + 16 | 0]) - 1;
   HEAP32[$3 + 16 >> 2] = HEAPU8[HEAP32[$3 + 28 >> 2]];
   $0 = HEAP32[$3 + 44 >> 2];
   if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
    $0 = 8 - (HEAP32[$3 + 24 >> 2] + HEAPU8[HEAP32[$3 + 44 >> 2] + 16 | 0] | 0) | 0;
   } else {
    $0 = HEAP32[$3 + 24 >> 2];
   }
   HEAP32[$3 + 12 >> 2] = $0;
   HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 20 >> 2] & HEAP32[$3 + 16 >> 2] >>> HEAP32[$3 + 12 >> 2];
   break label$1;
  }
  $0 = HEAP32[$3 + 44 >> 2];
  label$5: {
   if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 4) {
    HEAP32[$3 + 8 >> 2] = HEAPU8[HEAP32[$3 + 44 >> 2] + 16 | 0] - 8;
    while (1) {
     if (HEAP32[$3 + 8 >> 2] >= 0) {
      HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] | HEAPU8[HEAP32[$3 + 28 >> 2]] << HEAP32[$3 + 8 >> 2];
      HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] + 1;
      HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] - 8;
      continue;
     }
     break;
    }
    break label$5;
   }
   HEAP32[$3 + 4 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 4 >> 2] < HEAPU8[HEAP32[$3 + 44 >> 2] + 16 | 0]) {
     HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] | HEAPU8[HEAP32[$3 + 28 >> 2]] << HEAP32[$3 + 4 >> 2];
     HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] + 1;
     HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 8;
     continue;
    }
    break;
   }
  }
 }
 __stack_pointer = $3 + 48 | 0;
 return HEAP32[$3 + 32 >> 2];
}

function jswrap_object_defineProperty($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 56 >> 2] = $0;
 HEAP32[$3 + 52 >> 2] = $1;
 HEAP32[$3 + 48 >> 2] = $2;
 label$1: {
  label$2: {
   if (jsvIsObject(HEAP32[$3 + 56 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsFunction(HEAP32[$3 + 56 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsArray(HEAP32[$3 + 56 >> 2]) & 1) {
    break label$2;
   }
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 56 >> 2];
   jsExceptionHere(1, 118286, $3 + 16 | 0);
   HEAP32[$3 + 60 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsObject(HEAP32[$3 + 48 >> 2]) & 1)) {
   HEAP32[$3 >> 2] = HEAP32[$3 + 48 >> 2];
   jsExceptionHere(1, 118560, $3);
   HEAP32[$3 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 44 >> 2] = jsvAsArrayIndex(HEAP32[$3 + 52 >> 2]);
  HEAP32[$3 + 40 >> 2] = 0;
  HEAP32[$3 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 48 >> 2], 117892);
  HEAP32[$3 + 32 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 48 >> 2], 117878);
  if (HEAP32[$3 + 32 >> 2] ? 1 : HEAP32[$3 + 36 >> 2]) {
   HEAP32[$3 + 40 >> 2] = jsvNewWithFlags(6);
   if (HEAP32[$3 + 40 >> 2]) {
    if (HEAP32[$3 + 36 >> 2]) {
     jsvObjectSetChild(HEAP32[$3 + 40 >> 2], 117892, HEAP32[$3 + 36 >> 2]);
    }
    if (HEAP32[$3 + 32 >> 2]) {
     jsvObjectSetChild(HEAP32[$3 + 40 >> 2], 117878, HEAP32[$3 + 32 >> 2]);
    }
   }
   jsvUnLock2(HEAP32[$3 + 36 >> 2], HEAP32[$3 + 32 >> 2]);
  }
  if (!HEAP32[$3 + 40 >> 2]) {
   HEAP32[$3 + 40 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 48 >> 2], 131830);
  }
  jsvObjectSetChildVar(HEAP32[$3 + 56 >> 2], HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2]);
  HEAP32[$3 + 28 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 48 >> 2], 132508);
  label$10: {
   if (jsvIsUndefined(HEAP32[$3 + 28 >> 2]) & 1) {
    break label$10;
   }
   if (jsvGetBoolAndUnLock(HEAP32[$3 + 28 >> 2]) & 1) {
    break label$10;
   }
   $0 = HEAP32[$3 + 44 >> 2];
   $1 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8 | 64;
   HEAP8[$0 + 12 | 0] = $1;
   HEAP8[$0 + 13 | 0] = $1 >>> 8;
  }
  jsvUnLock2(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2]);
  HEAP32[$3 + 60 >> 2] = jsvLockAgain(HEAP32[$3 + 56 >> 2]);
 }
 __stack_pointer = $3 - -64 | 0;
 return HEAP32[$3 + 60 >> 2];
}

function jswrap_function_apply_or_call($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $4 = __stack_pointer - 128 | 0;
 $3 = $4;
 __stack_pointer = $3;
 HEAP32[$3 + 120 >> 2] = $0;
 HEAP32[$3 + 116 >> 2] = $1;
 HEAP32[$3 + 112 >> 2] = $2;
 HEAP32[$3 + 104 >> 2] = 0;
 HEAP32[$3 + 100 >> 2] = 0;
 label$1: {
  label$2: {
   if (jsvIsIterable(HEAP32[$3 + 112 >> 2]) & 1) {
    HEAP32[$3 + 100 >> 2] = jsvGetLength(HEAP32[$3 + 112 >> 2]);
    if (HEAPU32[$3 + 100 >> 2] > 256) {
     HEAP32[$3 >> 2] = HEAP32[$3 + 100 >> 2];
     jsExceptionHere(1, 134600, $3);
     HEAP32[$3 + 124 >> 2] = 0;
     break label$1;
    }
    $4 = $4 - ((HEAP32[$3 + 100 >> 2] << 2) + 15 & -16) | 0;
    __stack_pointer = $4;
    HEAP32[$3 + 104 >> 2] = $4;
    HEAP32[$3 + 108 >> 2] = 0;
    while (1) {
     if (HEAPU32[$3 + 108 >> 2] < HEAPU32[$3 + 100 >> 2]) {
      HEAP32[HEAP32[$3 + 104 >> 2] + (HEAP32[$3 + 108 >> 2] << 2) >> 2] = 0;
      HEAP32[$3 + 108 >> 2] = HEAP32[$3 + 108 >> 2] + 1;
      continue;
     }
     break;
    }
    jsvIteratorNew($3 + 40 | 0, HEAP32[$3 + 112 >> 2], 1);
    while (1) {
     if (jsvIteratorHasElement($3 + 40 | 0) & 1) {
      HEAP32[$3 + 36 >> 2] = jsvIteratorGetKey($3 + 40 | 0);
      if (jsvIsIntegerish(HEAP32[$3 + 36 >> 2]) & 1) {
       HEAP32[$3 + 32 >> 2] = jsvGetInteger(HEAP32[$3 + 36 >> 2]);
       if (!(HEAP32[$3 + 32 >> 2] < 0 | HEAP32[$3 + 32 >> 2] >= HEAP32[$3 + 100 >> 2])) {
        $0 = jsvIteratorGetValue($3 + 40 | 0);
        HEAP32[HEAP32[$3 + 104 >> 2] + (HEAP32[$3 + 32 >> 2] << 2) >> 2] = $0;
       }
      }
      jsvUnLock(HEAP32[$3 + 36 >> 2]);
      jsvIteratorNext($3 + 40 | 0);
      continue;
     }
     break;
    }
    jsvIteratorFree($3 + 40 | 0);
    break label$2;
   }
   if (!(jsvIsUndefined(HEAP32[$3 + 112 >> 2]) & 1)) {
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 112 >> 2];
    jsExceptionHere(1, 119019, $3 + 16 | 0);
    HEAP32[$3 + 124 >> 2] = 0;
    break label$1;
   }
  }
  HEAP32[$3 + 28 >> 2] = jspeFunctionCall(HEAP32[$3 + 120 >> 2], 0, HEAP32[$3 + 116 >> 2], 0, HEAP32[$3 + 100 >> 2], HEAP32[$3 + 104 >> 2]);
  jsvUnLockMany(HEAP32[$3 + 100 >> 2], HEAP32[$3 + 104 >> 2]);
  HEAP32[$3 + 124 >> 2] = HEAP32[$3 + 28 >> 2];
 }
 __stack_pointer = $3 + 128 | 0;
 return HEAP32[$3 + 124 >> 2];
}

function jsvNewFromStringVar($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1: {
  label$2: {
   if (!(jsvIsNativeString(HEAP32[$3 + 24 >> 2]) & 1)) {
    if (!(jsvIsFlashString(HEAP32[$3 + 24 >> 2]) & 1)) {
     break label$2;
    }
   }
   HEAP32[$3 + 12 >> 2] = jsvGetStringLength(HEAP32[$3 + 24 >> 2]);
   if (HEAPU32[$3 + 20 >> 2] > HEAPU32[$3 + 12 >> 2]) {
    HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 12 >> 2];
   }
   if (HEAPU32[$3 + 12 >> 2] < HEAP32[$3 + 20 >> 2] + HEAP32[$3 + 16 >> 2] >>> 0) {
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 12 >> 2] - HEAP32[$3 + 20 >> 2];
   }
   $0 = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 8 >> 2] = jsvNewWithFlags((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63);
   $0 = HEAP32[$3 + 8 >> 2];
   $1 = HEAP32[$3 + 24 >> 2];
   $1 = HEAP32[$3 + 20 >> 2] + (HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24)) | 0;
   HEAP8[$0 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1 >>> 8;
   HEAP8[$0 + 2 | 0] = $1 >>> 16;
   HEAP8[$0 + 3 | 0] = $1 >>> 24;
   $0 = HEAP32[$3 + 8 >> 2];
   $1 = HEAP32[$3 + 16 >> 2];
   HEAP8[$0 + 4 | 0] = $1;
   HEAP8[$0 + 5 | 0] = $1 >>> 8;
   HEAP8[$0 + 6 | 0] = $1 >>> 16;
   HEAP8[$0 + 7 | 0] = $1 >>> 24;
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 8 >> 2];
   break label$1;
  }
  if (jsvIsFlatString(HEAP32[$3 + 24 >> 2]) & 1) {
   HEAP32[$3 + 4 >> 2] = jsvGetCharactersInVar(HEAP32[$3 + 24 >> 2]);
   label$7: {
    if (HEAPU32[$3 + 20 >> 2] >= HEAPU32[$3 + 4 >> 2]) {
     HEAP32[$3 + 4 >> 2] = 0;
     break label$7;
    }
    HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] - HEAP32[$3 + 20 >> 2];
   }
   if (HEAPU32[$3 + 4 >> 2] > HEAPU32[$3 + 16 >> 2]) {
    HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 16 >> 2];
   }
   if (HEAPU32[$3 + 4 >> 2] > 19) {
    HEAP32[$3 >> 2] = jsvNewFlatStringFromStringVar(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 4 >> 2]);
    if (HEAP32[$3 >> 2]) {
     HEAP32[$3 + 28 >> 2] = HEAP32[$3 >> 2];
     break label$1;
    }
   }
  }
  HEAP32[$3 + 28 >> 2] = jsvNewWritableStringFromStringVar(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function tflite__ops__micro__pooling__AverageEval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (!HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 16 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2];
 label$2: {
  if (!HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2];
 HEAP32[$2 + 8 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0);
 HEAP32[$2 + 4 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0);
 label$3: {
  label$4: {
   label$5: {
    switch (HEAP32[HEAP32[$2 + 8 >> 2] + 8 >> 2] - 1 | 0) {
    case 0:
     tflite__ops__micro__pooling___28anonymous_20namespace_29__AverageEvalFloat_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20TfLitePoolParams_20const__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
     break label$4;

    case 2:
    case 8:
     tflite__ops__micro__pooling___28anonymous_20namespace_29__AverageEvalQuantized_28TfLiteContext__2c_20TfLiteNode_20const__2c_20TfLitePoolParams_20const__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
     break label$4;

    default:
     break label$5;
    }
   }
   $0 = HEAP32[HEAP32[$2 + 24 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 24 >> 2];
   HEAP32[$2 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 8 >> 2] + 8 >> 2]);
   FUNCTION_TABLE[$0 | 0]($1, 133394, $2);
   HEAP32[$2 + 28 >> 2] = 1;
   break label$3;
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jsvGetArrayIndex($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP16[$2 + 18 >> 1] = jsvGetLastChild(HEAP32[$2 + 24 >> 2]);
 HEAP32[$2 + 12 >> 2] = 0;
 label$1: {
  while (1) {
   if (HEAPU16[$2 + 18 >> 1]) {
    HEAP32[$2 + 8 >> 2] = jsvLock(HEAPU16[$2 + 18 >> 1]);
    if (jsvIsInt(HEAP32[$2 + 8 >> 2]) & 1) {
     $0 = HEAP32[$2 + 8 >> 2];
     HEAP32[$2 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
     if (HEAP32[$2 + 12 >> 2] == HEAP32[$2 + 20 >> 2]) {
      HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 8 >> 2];
      break label$1;
     }
     jsvUnLock(HEAP32[$2 + 8 >> 2]);
    } else {
     HEAP16[$2 + 18 >> 1] = jsvGetPrevSibling(HEAP32[$2 + 8 >> 2]);
     jsvUnLock(HEAP32[$2 + 8 >> 2]);
     continue;
    }
   }
   break;
  }
  if (HEAP32[$2 + 20 >> 2] > HEAP32[$2 + 12 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  label$8: {
   if (HEAP32[$2 + 20 >> 2] > (HEAP32[$2 + 12 >> 2] / 2 | 0)) {
    while (1) {
     if (HEAPU16[$2 + 18 >> 1]) {
      HEAP32[$2 + 4 >> 2] = jsvLock(HEAPU16[$2 + 18 >> 1]);
      $0 = HEAP32[$2 + 4 >> 2];
      if (HEAP32[$2 + 20 >> 2] == (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
       HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 4 >> 2];
       break label$1;
      } else {
       HEAP16[$2 + 18 >> 1] = jsvGetPrevSibling(HEAP32[$2 + 4 >> 2]);
       jsvUnLock(HEAP32[$2 + 4 >> 2]);
       continue;
      }
     }
     break;
    }
    break label$8;
   }
   HEAP16[$2 + 18 >> 1] = jsvGetFirstChild(HEAP32[$2 + 24 >> 2]);
   while (1) {
    if (HEAPU16[$2 + 18 >> 1]) {
     HEAP32[$2 >> 2] = jsvLock(HEAPU16[$2 + 18 >> 1]);
     $0 = HEAP32[$2 >> 2];
     if (HEAP32[$2 + 20 >> 2] == (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
      HEAP32[$2 + 28 >> 2] = HEAP32[$2 >> 2];
      break label$1;
     } else {
      HEAP16[$2 + 18 >> 1] = jsvGetNextSibling(HEAP32[$2 >> 2]);
      jsvUnLock(HEAP32[$2 >> 2]);
      continue;
     }
    }
    break;
   }
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function btnHandlerCommon($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP8[$3 + 11 | 0] = $1;
 HEAP8[$3 + 10 | 0] = $2;
 label$1: {
  if (HEAP32[97754] ? 1 : HEAP32[97751] | HEAP32[97753]) {
   if (!(!((HEAP32[$3 + 12 >> 2] == 1 ? HEAP32[97749] & 2 : 0) | (HEAP32[$3 + 12 >> 2] == 2 ? HEAP32[97749] & 4 : 0)) & (!(HEAP32[97749] & 8) | HEAP32[$3 + 12 >> 2] != 3))) {
    if (HEAP8[$3 + 11 | 0] & 1) {
     HEAP8[$3 + 9 | 0] = wakeUpBangle(128091) & 1;
     if (HEAP8[$3 + 9 | 0] & 1) {
      HEAP16[195510] = 0;
      HEAP8[391026] = HEAP32[$3 + 12 >> 2];
      $4 = jshGetSystemTime();
      $2 = i64toi32_i32$HIGH_BITS;
      $0 = $2;
      $2 = jshGetTimeFromMilliseconds(100);
      $1 = $2;
      $4 = $2 + $4 | 0;
      $2 = i64toi32_i32$HIGH_BITS;
      $0 = $2 + $0 | 0;
      HEAP32[97758] = $4;
      $0 = $4 >>> 0 < $1 >>> 0 ? $0 + 1 | 0 : $0;
      HEAP32[97759] = $0;
      break label$1;
     }
    }
   }
  }
  HEAP8[$3 + 8 | 0] = 1;
  label$10: {
   if (HEAP32[97749] & 262144) {
    HEAP8[$3 + 8 | 0] = 0;
    break label$10;
   }
   HEAP16[195510] = 0;
  }
  if (HEAP32[$3 + 12 >> 2] == 1) {
   HEAP16[195520] = 0;
  }
  $0 = jshGetSystemTime();
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = i64toi32_i32$HIGH_BITS;
  if (HEAP32[$3 + 12 >> 2] == HEAP8[391026]) {
   $0 = HEAP32[$3 + 4 >> 2];
   $2 = $0;
   $0 = HEAP32[97758];
   $1 = $0;
   $0 = HEAP32[97759];
   label$14: {
    if (!(HEAP8[$3 + 11 | 0] & 1 & (($0 | 0) <= ($2 | 0) & $1 >>> 0 <= HEAPU32[$3 >> 2] | ($0 | 0) < ($2 | 0)))) {
     $1 = HEAP32[$3 >> 2];
     $2 = HEAP32[$3 + 4 >> 2];
     $0 = jshGetTimeFromMilliseconds(100);
     $4 = i64toi32_i32$HIGH_BITS + $2 | 0;
     $2 = $1 + $0 | 0;
     $4 = $2 >>> 0 < $0 >>> 0 ? $4 + 1 | 0 : $4;
     HEAP32[97758] = $2;
     HEAP32[97759] = $4;
     HEAP8[$3 + 10 | 0] = HEAPU8[$3 + 10 | 0] | 64;
     $1 = 391032;
     break label$14;
    }
    HEAP8[391026] = 0;
    HEAP32[97758] = 0;
    HEAP32[97759] = 0;
    $1 = 391032;
   }
  }
  if (!(HEAP8[$3 + 8 | 0] & 1)) {
   break label$1;
  }
  $4 = HEAP32[$3 >> 2];
  $1 = HEAP32[$3 + 4 >> 2];
  jshPushIOEvent((HEAPU8[$3 + 10 | 0] | (HEAP8[$3 + 11 | 0] & 1 ? 32 : 0)) & 255, $4, $1);
 }
 __stack_pointer = $3 + 16 | 0;
}

function tflite__GetRegistrationFromOpCode_28tflite__OperatorCode_20const__2c_20tflite__OpResolver_20const__2c_20tflite__ErrorReporter__2c_20TfLiteRegistration_20const___29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 60 >> 2] = $0;
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP32[$4 + 48 >> 2] = $3;
 HEAP32[$4 + 44 >> 2] = 0;
 HEAP32[HEAP32[$4 + 48 >> 2] >> 2] = 0;
 HEAP32[$4 + 40 >> 2] = tflite__OperatorCode__builtin_code_28_29_20const(HEAP32[$4 + 60 >> 2]);
 HEAP32[$4 + 36 >> 2] = tflite__OperatorCode__version_28_29_20const(HEAP32[$4 + 60 >> 2]);
 label$1: {
  if (!(HEAP32[$4 + 40 >> 2] <= 126 & HEAP32[$4 + 40 >> 2] >= 0)) {
   $0 = HEAP32[$4 + 52 >> 2];
   HEAP32[$4 >> 2] = HEAP32[$4 + 40 >> 2];
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 138219, $4);
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  label$4: {
   if (HEAP32[$4 + 40 >> 2] != 32) {
    $0 = HEAP32[$4 + 56 >> 2];
    $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] >> 2]]($0, HEAP32[$4 + 40 >> 2], HEAP32[$4 + 36 >> 2]) | 0;
    HEAP32[HEAP32[$4 + 48 >> 2] >> 2] = $0;
    if (!HEAP32[HEAP32[$4 + 48 >> 2] >> 2]) {
     $0 = HEAP32[$4 + 52 >> 2];
     $1 = tflite__EnumNameBuiltinOperator_28tflite__BuiltinOperator_29(HEAP32[$4 + 40 >> 2]);
     HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 36 >> 2];
     HEAP32[$4 + 16 >> 2] = $1;
     tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 148144, $4 + 16 | 0);
     HEAP32[$4 + 44 >> 2] = 1;
    }
    break label$4;
   }
   label$7: {
    if (!tflite__OperatorCode__custom_code_28_29_20const(HEAP32[$4 + 60 >> 2])) {
     tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$4 + 52 >> 2], 147755, 0);
     HEAP32[$4 + 44 >> 2] = 1;
     break label$7;
    }
    HEAP32[$4 + 32 >> 2] = flatbuffers__String__c_str_28_29_20const(tflite__OperatorCode__custom_code_28_29_20const(HEAP32[$4 + 60 >> 2]));
    $0 = HEAP32[$4 + 56 >> 2];
    $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 4 >> 2]]($0, HEAP32[$4 + 32 >> 2], HEAP32[$4 + 36 >> 2]) | 0;
    HEAP32[HEAP32[$4 + 48 >> 2] >> 2] = $0;
    if (!HEAP32[HEAP32[$4 + 48 >> 2] >> 2]) {
     HEAP32[$4 + 44 >> 2] = 1;
    }
   }
  }
 }
 __stack_pointer = $4 - -64 | 0;
 return HEAP32[$4 + 44 >> 2];
}

function jswrap_io_pinMode($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP8[$3 + 15 | 0] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 label$1: {
  if (!(jshIsPinValid(HEAPU8[$3 + 15 | 0]) & 1)) {
   jsExceptionHere(1, 128480, 0);
   break label$1;
  }
  HEAP8[$3 + 6 | 0] = 0;
  if (jsvIsString(HEAP32[$3 + 8 >> 2]) & 1) {
   label$4: {
    if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 129682) & 1) {
     HEAP8[$3 + 6 | 0] = 7;
     break label$4;
    }
    label$6: {
     if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 117136) & 1) {
      HEAP8[$3 + 6 | 0] = 4;
      break label$6;
     }
     label$8: {
      if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 121684) & 1) {
       HEAP8[$3 + 6 | 0] = 5;
       break label$8;
      }
      label$10: {
       if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 128061) & 1) {
        HEAP8[$3 + 6 | 0] = 6;
        break label$10;
       }
       label$12: {
        if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 117129) & 1) {
         HEAP8[$3 + 6 | 0] = 1;
         break label$12;
        }
        label$14: {
         if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 128501) & 1) {
          HEAP8[$3 + 6 | 0] = 2;
          break label$14;
         }
         label$16: {
          if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 121697) & 1) {
           HEAP8[$3 + 6 | 0] = 3;
           break label$16;
          }
          label$18: {
           if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 117126) & 1) {
            HEAP8[$3 + 6 | 0] = 8;
            break label$18;
           }
           if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 128498) & 1) {
            HEAP8[$3 + 6 | 0] = 9;
           }
          }
         }
        }
       }
      }
     }
    }
   }
  }
  if (HEAPU8[$3 + 6 | 0]) {
   jshSetPinStateIsManual(HEAPU8[$3 + 15 | 0], (HEAPU8[$3 + 7 | 0] ^ -1) & 1);
   jshPinSetState(HEAPU8[$3 + 15 | 0], HEAPU8[$3 + 6 | 0]);
   break label$1;
  }
  jshSetPinStateIsManual(HEAPU8[$3 + 15 | 0], 0);
  label$22: {
   if (jsvIsUndefined(HEAP32[$3 + 8 >> 2]) & 1) {
    break label$22;
   }
   if (jsvIsStringEqual(HEAP32[$3 + 8 >> 2], 128025) & 1) {
    break label$22;
   }
   jsExceptionHere(1, 132770, 0);
  }
 }
 __stack_pointer = $3 + 16 | 0;
}

function graphicsBlendColor($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 80 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 72 >> 2] = $0;
 HEAP32[$4 + 68 >> 2] = $1;
 HEAP32[$4 + 64 >> 2] = $2;
 HEAP32[$4 + 60 >> 2] = $3;
 if (HEAP32[$4 + 60 >> 2] > 0) {
  $0 = HEAP32[$4 + 60 >> 2];
 } else {
  $0 = 0;
 }
 HEAP32[$4 + 56 >> 2] = $0;
 if (HEAPU32[$4 + 56 >> 2] > 256) {
  HEAP32[$4 + 56 >> 2] = 256;
 }
 label$4: {
  if (!(!(HEAPU8[HEAP32[$4 + 72 >> 2] + 16 | 0] == 2 | HEAPU8[HEAP32[$4 + 72 >> 2] + 16 | 0] == 4) & HEAPU8[HEAP32[$4 + 72 >> 2] + 16 | 0] != 8)) {
   HEAP32[$4 + 76 >> 2] = (Math_imul(HEAP32[$4 + 64 >> 2], 256 - HEAP32[$4 + 56 >> 2] | 0) + Math_imul(HEAP32[$4 + 68 >> 2], HEAP32[$4 + 56 >> 2]) | 0) + 127 >>> 8;
   break label$4;
  }
  if (HEAPU8[HEAP32[$4 + 72 >> 2] + 16 | 0] == 16) {
   HEAP32[$4 + 76 >> 2] = graphicsBlendColorRGB565(HEAP32[$4 + 68 >> 2] & 65535, HEAP32[$4 + 64 >> 2] & 65535, HEAP32[$4 + 60 >> 2]) & 65535;
   break label$4;
  }
  if (HEAPU8[HEAP32[$4 + 72 >> 2] + 16 | 0] == 24) {
   HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 64 >> 2];
   HEAP32[$4 + 48 >> 2] = HEAP32[$4 + 52 >> 2] >>> 16 & 255;
   HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 52 >> 2] >>> 8 & 255;
   HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 52 >> 2] & 255;
   HEAP32[$4 + 36 >> 2] = HEAP32[$4 + 68 >> 2];
   HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 36 >> 2] >>> 16 & 255;
   HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 36 >> 2] >>> 8 & 255;
   HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 36 >> 2] & 255;
   HEAP32[$4 + 20 >> 2] = Math_imul(HEAP32[$4 + 48 >> 2], 256 - HEAP32[$4 + 56 >> 2] | 0) + Math_imul(HEAP32[$4 + 32 >> 2], HEAP32[$4 + 56 >> 2]) >>> 8;
   HEAP32[$4 + 16 >> 2] = Math_imul(HEAP32[$4 + 44 >> 2], 256 - HEAP32[$4 + 56 >> 2] | 0) + Math_imul(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 56 >> 2]) >>> 8;
   HEAP32[$4 + 12 >> 2] = Math_imul(HEAP32[$4 + 40 >> 2], 256 - HEAP32[$4 + 56 >> 2] | 0) + Math_imul(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 56 >> 2]) >>> 8;
   HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 12 >> 2] | HEAP32[$4 + 16 >> 2] << 8 | HEAP32[$4 + 20 >> 2] << 16;
   break label$4;
  }
  if (HEAPU32[$4 + 56 >> 2] >= 128) {
   $0 = HEAP32[$4 + 68 >> 2];
  } else {
   $0 = HEAP32[$4 + 64 >> 2];
  }
  HEAP32[$4 + 76 >> 2] = $0;
 }
 __stack_pointer = $4 + 80 | 0;
 return HEAP32[$4 + 76 >> 2];
}

function jswrap_string_indexOf($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP8[$4 + 31 | 0] = $3;
 label$1: {
  if (!(jsvIsString(HEAP32[$4 + 40 >> 2]) & 1)) {
   HEAP32[$4 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 36 >> 2] = jsvAsString(HEAP32[$4 + 36 >> 2]);
  if (!HEAP32[$4 + 36 >> 2]) {
   HEAP32[$4 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 24 >> 2] = jsvGetStringLength(HEAP32[$4 + 40 >> 2]);
  HEAP32[$4 + 20 >> 2] = jsvGetStringLength(HEAP32[$4 + 36 >> 2]);
  if (HEAP32[$4 + 20 >> 2] > HEAP32[$4 + 24 >> 2]) {
   jsvUnLock(HEAP32[$4 + 36 >> 2]);
   HEAP32[$4 + 44 >> 2] = -1;
   break label$1;
  }
  HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 24 >> 2] - HEAP32[$4 + 20 >> 2];
  label$5: {
   if (!(HEAP8[$4 + 31 | 0] & 1)) {
    HEAP32[$4 + 8 >> 2] = 1;
    HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 16 >> 2] + 1;
    HEAP32[$4 + 12 >> 2] = 0;
    if (jsvIsNumeric(HEAP32[$4 + 32 >> 2]) & 1) {
     HEAP32[$4 + 12 >> 2] = jsvGetInteger(HEAP32[$4 + 32 >> 2]);
     if (HEAP32[$4 + 12 >> 2] < 0) {
      HEAP32[$4 + 12 >> 2] = 0;
     }
     if (HEAP32[$4 + 12 >> 2] > HEAP32[$4 + 4 >> 2]) {
      HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 4 >> 2];
     }
    }
    break label$5;
   }
   HEAP32[$4 + 8 >> 2] = -1;
   HEAP32[$4 + 4 >> 2] = -1;
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 16 >> 2];
   if (jsvIsNumeric(HEAP32[$4 + 32 >> 2]) & 1) {
    HEAP32[$4 + 12 >> 2] = jsvGetInteger(HEAP32[$4 + 32 >> 2]);
    if (HEAP32[$4 + 12 >> 2] < 0) {
     HEAP32[$4 + 12 >> 2] = 0;
    }
    if (HEAP32[$4 + 12 >> 2] > HEAP32[$4 + 16 >> 2]) {
     HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 16 >> 2];
    }
   }
  }
  while (1) {
   if (HEAP32[$4 + 12 >> 2] != HEAP32[$4 + 4 >> 2]) {
    if (jsvCompareString(HEAP32[$4 + 40 >> 2], HEAP32[$4 + 36 >> 2], HEAP32[$4 + 12 >> 2], 0, 1)) {
     HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 8 >> 2] + HEAP32[$4 + 12 >> 2];
     continue;
    } else {
     jsvUnLock(HEAP32[$4 + 36 >> 2]);
     HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 12 >> 2];
     break label$1;
    }
   }
   break;
  }
  jsvUnLock(HEAP32[$4 + 36 >> 2]);
  HEAP32[$4 + 44 >> 2] = -1;
 }
 __stack_pointer = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}

function jsfStripDriveFromName($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 8 >> 2] = $0;
 HEAP8[$3 + 7 | 0] = $1;
 label$1: {
  if (HEAP8[HEAP32[$3 + 8 >> 2] + 1 | 0] == 58) {
   HEAP8[$3 + 6 | 0] = HEAPU8[HEAP32[$3 + 8 >> 2]];
   $2 = HEAP32[$3 + 8 >> 2];
   $1 = HEAPU8[$2 + 10 | 0] | HEAPU8[$2 + 11 | 0] << 8 | (HEAPU8[$2 + 12 | 0] << 16 | HEAPU8[$2 + 13 | 0] << 24);
   $4 = $1;
   $0 = HEAPU8[$2 + 14 | 0] | HEAPU8[$2 + 15 | 0] << 8 | (HEAPU8[$2 + 16 | 0] << 16 | HEAPU8[$2 + 17 | 0] << 24);
   $7 = $0;
   $0 = HEAPU8[$2 + 18 | 0] | HEAPU8[$2 + 19 | 0] << 8 | (HEAPU8[$2 + 20 | 0] << 16 | HEAPU8[$2 + 21 | 0] << 24);
   $5 = $0;
   $1 = HEAPU8[$2 + 22 | 0] | HEAPU8[$2 + 23 | 0] << 8 | (HEAPU8[$2 + 24 | 0] << 16 | HEAPU8[$2 + 25 | 0] << 24);
   $8 = $1;
   $1 = HEAPU8[$2 + 2 | 0] | HEAPU8[$2 + 3 | 0] << 8 | (HEAPU8[$2 + 4 | 0] << 16 | HEAPU8[$2 + 5 | 0] << 24);
   $6 = $1;
   $0 = HEAPU8[$2 + 6 | 0] | HEAPU8[$2 + 7 | 0] << 8 | (HEAPU8[$2 + 8 | 0] << 16 | HEAPU8[$2 + 9 | 0] << 24);
   $9 = $0;
   $1 = HEAP32[$3 + 8 >> 2];
   $0 = HEAPU8[$2 + 26 | 0] | HEAPU8[$2 + 27 | 0] << 8;
   HEAP8[$1 + 24 | 0] = $0;
   HEAP8[$1 + 25 | 0] = $0 >>> 8;
   HEAP8[$1 + 16 | 0] = $5;
   HEAP8[$1 + 17 | 0] = $5 >>> 8;
   HEAP8[$1 + 18 | 0] = $5 >>> 16;
   HEAP8[$1 + 19 | 0] = $5 >>> 24;
   $0 = $8;
   HEAP8[$1 + 20 | 0] = $0;
   HEAP8[$1 + 21 | 0] = $0 >>> 8;
   HEAP8[$1 + 22 | 0] = $0 >>> 16;
   HEAP8[$1 + 23 | 0] = $0 >>> 24;
   HEAP8[$1 + 8 | 0] = $4;
   HEAP8[$1 + 9 | 0] = $4 >>> 8;
   HEAP8[$1 + 10 | 0] = $4 >>> 16;
   HEAP8[$1 + 11 | 0] = $4 >>> 24;
   $0 = $7;
   HEAP8[$1 + 12 | 0] = $0;
   HEAP8[$1 + 13 | 0] = $0 >>> 8;
   HEAP8[$1 + 14 | 0] = $0 >>> 16;
   HEAP8[$1 + 15 | 0] = $0 >>> 24;
   HEAP8[$1 | 0] = $6;
   HEAP8[$1 + 1 | 0] = $6 >>> 8;
   HEAP8[$1 + 2 | 0] = $6 >>> 16;
   HEAP8[$1 + 3 | 0] = $6 >>> 24;
   $0 = $9;
   HEAP8[$1 + 4 | 0] = $0;
   HEAP8[$1 + 5 | 0] = $0 >>> 8;
   HEAP8[$1 + 6 | 0] = $0 >>> 16;
   HEAP8[$1 + 7 | 0] = $0 >>> 24;
   HEAP8[HEAP32[$3 + 8 >> 2] + 26 | 0] = 0;
   HEAP8[HEAP32[$3 + 8 >> 2] + 27 | 0] = 0;
   HEAP8[$3 + 15 | 0] = HEAPU8[$3 + 6 | 0];
   break label$1;
  }
  HEAP8[$3 + 15 | 0] = 0;
 }
 return HEAP8[$3 + 15 | 0];
}

function heatshrink_encode_cb($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 832 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 828 >> 2] = $0;
 HEAP32[$4 + 824 >> 2] = $1;
 HEAP32[$4 + 820 >> 2] = $2;
 HEAP32[$4 + 816 >> 2] = $3;
 heatshrink_encoder_reset($4 + 288 | 0);
 HEAP32[$4 + 24 >> 2] = 0;
 HEAP32[$4 + 20 >> 2] = 0;
 HEAP32[$4 + 16 >> 2] = 0;
 HEAP32[$4 + 12 >> 2] = 0;
 HEAP32[$4 + 8 >> 2] = 0;
 while (1) {
  $0 = 1;
  $0 = HEAP32[$4 + 16 >> 2] < 0 ? HEAP32[$4 + 12 >> 2] != 0 : $0;
  if ($0) {
   if (!HEAP32[$4 + 12 >> 2]) {
    HEAP32[$4 + 8 >> 2] = 0;
    while (1) {
     $0 = 0;
     $0 = HEAPU32[$4 + 12 >> 2] < 128 ? HEAP32[$4 + 16 >> 2] >= 0 : $0;
     if ($0) {
      HEAP32[$4 + 16 >> 2] = FUNCTION_TABLE[HEAP32[$4 + 828 >> 2]](HEAP32[$4 + 824 >> 2]);
      if (HEAP32[$4 + 16 >> 2] >= 0) {
       $1 = HEAP32[$4 + 16 >> 2];
       $0 = HEAP32[$4 + 12 >> 2];
       HEAP32[$4 + 12 >> 2] = $0 + 1;
       HEAP8[($4 + 160 | 0) + $0 | 0] = $1;
      }
      continue;
     }
     break;
    }
   }
   HEAP8[$4 + 7 | 0] = (heatshrink_encoder_sink($4 + 288 | 0, HEAP32[$4 + 8 >> 2] + ($4 + 160 | 0) | 0, HEAP32[$4 + 12 >> 2], $4 + 24 | 0) | 0) >= 0;
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] - HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 8 >> 2];
   if (!(HEAP32[$4 + 12 >> 2] | HEAP32[$4 + 16 >> 2] >= 0)) {
    heatshrink_encoder_finish($4 + 288 | 0);
   }
   while (1) {
    HEAP32[$4 >> 2] = heatshrink_encoder_poll($4 + 288 | 0, $4 + 32 | 0, 128, $4 + 24 | 0);
    if (HEAP32[$4 + 820 >> 2]) {
     HEAP32[$4 + 28 >> 2] = 0;
     while (1) {
      if (HEAPU32[$4 + 28 >> 2] < HEAPU32[$4 + 24 >> 2]) {
       FUNCTION_TABLE[HEAP32[$4 + 820 >> 2]](HEAPU8[HEAP32[$4 + 28 >> 2] + ($4 + 32 | 0) | 0], HEAP32[$4 + 816 >> 2]);
       HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 28 >> 2] + 1;
       continue;
      }
      break;
     }
    }
    HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 20 >> 2];
    if (HEAP32[$4 >> 2] == 1) {
     continue;
    }
    break;
   }
   if (!(HEAP32[$4 + 12 >> 2] | HEAP32[$4 + 16 >> 2] >= 0)) {
    heatshrink_encoder_finish($4 + 288 | 0);
   }
   continue;
  }
  break;
 }
 __stack_pointer = $4 + 832 | 0;
 return HEAP32[$4 + 20 >> 2];
}

function lcdFillRect_ArrayBuffer_flat4($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = __stack_pointer + -64 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 60 >> 2] = $0;
 HEAP32[$6 + 56 >> 2] = $1;
 HEAP32[$6 + 52 >> 2] = $2;
 HEAP32[$6 + 48 >> 2] = $3;
 HEAP32[$6 + 44 >> 2] = $4;
 HEAP32[$6 + 40 >> 2] = $5;
 label$1: {
  if ((HEAP32[$6 + 48 >> 2] - HEAP32[$6 + 56 >> 2] | 0) < 2) {
   lcdFillRect_ArrayBuffer_flat(HEAP32[$6 + 60 >> 2], HEAP32[$6 + 56 >> 2], HEAP32[$6 + 52 >> 2], HEAP32[$6 + 48 >> 2], HEAP32[$6 + 44 >> 2], HEAP32[$6 + 40 >> 2]);
   break label$1;
  }
  $0 = HEAP32[$6 + 60 >> 2];
  HEAP32[$6 + 36 >> 2] = HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24);
  HEAP32[$6 + 40 >> 2] = HEAP32[$6 + 40 >> 2] & 15;
  HEAP8[$6 + 35 | 0] = HEAP32[$6 + 40 >> 2] & 255 | HEAP32[$6 + 40 >> 2] << 4 & 255;
  HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 52 >> 2];
  while (1) {
   if (HEAP32[$6 + 28 >> 2] > HEAP32[$6 + 44 >> 2]) {
    break label$1;
   }
   $0 = HEAP32[$6 + 60 >> 2];
   HEAP32[$6 + 24 >> 2] = Math_imul(HEAP32[$6 + 28 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
   HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 56 >> 2] + HEAP32[$6 + 24 >> 2];
   HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 48 >> 2] + HEAP32[$6 + 24 >> 2];
   HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 36 >> 2] + (HEAP32[$6 + 20 >> 2] >> 1);
   if (HEAP32[$6 + 20 >> 2] & 1) {
    HEAP8[HEAP32[$6 + 12 >> 2]] = HEAP32[$6 + 40 >> 2] | HEAPU8[HEAP32[$6 + 12 >> 2]] & 240;
    HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 12 >> 2] + 1;
    HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 20 >> 2] + 1;
   }
   while (1) {
    if (HEAP32[$6 + 16 >> 2] >= (HEAP32[$6 + 20 >> 2] + 1 | 0)) {
     $1 = HEAPU8[$6 + 35 | 0];
     $0 = HEAP32[$6 + 12 >> 2];
     HEAP32[$6 + 12 >> 2] = $0 + 1;
     HEAP8[$0 | 0] = $1;
     HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 20 >> 2] + 2;
     continue;
    }
    break;
   }
   if (HEAP32[$6 + 20 >> 2] <= HEAP32[$6 + 16 >> 2]) {
    HEAP8[HEAP32[$6 + 12 >> 2]] = HEAPU8[HEAP32[$6 + 12 >> 2]] & 15 | HEAP32[$6 + 40 >> 2] << 4;
   }
   HEAP32[$6 + 28 >> 2] = HEAP32[$6 + 28 >> 2] + 1;
   continue;
  }
 }
 __stack_pointer = $6 - -64 | 0;
}

function jswrap_arraybufferview_map($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 176 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 168 >> 2] = $0;
 HEAP32[$3 + 164 >> 2] = $1;
 HEAP32[$3 + 160 >> 2] = $2;
 label$1: {
  if (!(jsvIsArrayBuffer(HEAP32[$3 + 168 >> 2]) & 1)) {
   jsExceptionHere(1, 116727, 0);
   HEAP32[$3 + 172 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsFunction(HEAP32[$3 + 164 >> 2]) & 1)) {
   jsExceptionHere(1, 128290, 0);
   HEAP32[$3 + 172 >> 2] = 0;
   break label$1;
  }
  label$4: {
   if (jsvIsUndefined(HEAP32[$3 + 160 >> 2]) & 1) {
    break label$4;
   }
   if (jsvIsObject(HEAP32[$3 + 160 >> 2]) & 1) {
    break label$4;
   }
   jsExceptionHere(1, 133829, 0);
   HEAP32[$3 + 172 >> 2] = 0;
   break label$1;
  }
  HEAP8[$3 + 159 | 0] = HEAPU8[HEAP32[$3 + 168 >> 2] + 5 | 0];
  HEAP32[$3 + 152 >> 2] = jsvNewTypedArray(HEAPU8[$3 + 159 | 0], jsvGetArrayBufferLength(HEAP32[$3 + 168 >> 2]));
  if (!HEAP32[$3 + 152 >> 2]) {
   HEAP32[$3 + 172 >> 2] = 0;
   break label$1;
  }
  jsvIteratorNew($3 + 88 | 0, HEAP32[$3 + 168 >> 2], 1);
  jsvArrayBufferIteratorNew($3 + 32 | 0, HEAP32[$3 + 152 >> 2], 0);
  while (1) {
   if (jsvIteratorHasElement($3 + 88 | 0) & 1) {
    HEAP32[$3 + 28 >> 2] = jsvIteratorGetKey($3 + 88 | 0);
    if (jsvIsInt(HEAP32[$3 + 28 >> 2]) & 1) {
     HEAP32[$3 + 24 >> 2] = jsvGetInteger(HEAP32[$3 + 28 >> 2]);
     HEAP32[$3 + 12 >> 2] = jsvIteratorGetValue($3 + 88 | 0);
     HEAP32[$3 + 16 >> 2] = jsvNewFromInteger(HEAP32[$3 + 24 >> 2]);
     HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 168 >> 2];
     HEAP32[$3 + 8 >> 2] = jspeFunctionCall(HEAP32[$3 + 164 >> 2], 0, HEAP32[$3 + 160 >> 2], 0, 3, $3 + 12 | 0);
     jsvUnLockMany(2, $3 + 12 | 0);
     if (HEAP32[$3 + 8 >> 2]) {
      jsvArrayBufferIteratorSetValue($3 + 32 | 0, HEAP32[$3 + 8 >> 2], 0);
      jsvUnLock(HEAP32[$3 + 8 >> 2]);
     }
    }
    jsvUnLock(HEAP32[$3 + 28 >> 2]);
    jsvIteratorNext($3 + 88 | 0);
    jsvArrayBufferIteratorNext($3 + 32 | 0);
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 88 | 0);
  jsvArrayBufferIteratorFree($3 + 32 | 0);
  HEAP32[$3 + 172 >> 2] = HEAP32[$3 + 152 >> 2];
 }
 __stack_pointer = $3 + 176 | 0;
 return HEAP32[$3 + 172 >> 2];
}

function tflite__ops__micro__fully_connected__EvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLiteFusedActivation_2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = __stack_pointer - 176 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 172 >> 2] = $0;
 HEAP32[$7 + 168 >> 2] = $1;
 HEAP32[$7 + 164 >> 2] = $2;
 HEAP32[$7 + 160 >> 2] = $3;
 HEAP32[$7 + 156 >> 2] = $4;
 HEAP32[$7 + 152 >> 2] = $5;
 HEAP32[$7 + 148 >> 2] = $6;
 void_20tflite__CalculateActivationRange_float__28TfLiteFusedActivation_2c_20float__2c_20float__29(HEAP32[$7 + 164 >> 2], $7 + 144 | 0, $7 + 140 | 0);
 HEAPF32[$7 + 124 >> 2] = HEAPF32[$7 + 144 >> 2];
 HEAPF32[$7 + 128 >> 2] = HEAPF32[$7 + 140 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 72 | 0, HEAP32[$7 + 160 >> 2]);
 $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 160 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 48 | 0, HEAP32[$7 + 156 >> 2]);
 $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 156 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7 + 24 | 0, HEAP32[$7 + 152 >> 2]);
 $2 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$7 + 152 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($7, HEAP32[$7 + 148 >> 2]);
 tflite__reference_ops__FullyConnected_28tflite__FullyConnectedParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($7 + 96 | 0, $7 + 72 | 0, $0, $7 + 48 | 0, $1, $7 + 24 | 0, $2, $7, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$7 + 148 >> 2]));
 tflite__RuntimeShape___RuntimeShape_28_29($7);
 tflite__RuntimeShape___RuntimeShape_28_29($7 + 24 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($7 + 48 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($7 + 72 | 0);
 __stack_pointer = $7 + 176 | 0;
 return 0;
}

function tflite__ops__micro__pooling__MaxEval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (!HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 16 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2];
 label$2: {
  if (!HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2];
 HEAP32[$2 + 8 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0);
 HEAP32[$2 + 4 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0);
 label$3: {
  label$4: {
   label$5: {
    switch (HEAP32[HEAP32[$2 + 8 >> 2] + 8 >> 2] - 1 | 0) {
    case 0:
     tflite__ops__micro__pooling___28anonymous_20namespace_29__MaxEvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLitePoolParams__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
     break label$4;

    case 2:
    case 8:
     tflite__ops__micro__pooling___28anonymous_20namespace_29__MaxEvalQuantized_28TfLiteContext__2c_20TfLiteNode__2c_20TfLitePoolParams__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
     break label$4;

    default:
     break label$5;
    }
   }
   $0 = HEAP32[HEAP32[$2 + 24 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 24 >> 2];
   HEAP32[$2 >> 2] = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 8 >> 2] + 8 >> 2]);
   FUNCTION_TABLE[$0 | 0]($1, 140751, $2);
   HEAP32[$2 + 28 >> 2] = 1;
   break label$3;
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function heatshrink_decode_cb($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 608 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 604 >> 2] = $0;
 HEAP32[$4 + 600 >> 2] = $1;
 HEAP32[$4 + 596 >> 2] = $2;
 HEAP32[$4 + 592 >> 2] = $3;
 heatshrink_decoder_reset($4 + 288 | 0);
 HEAP32[$4 + 24 >> 2] = 0;
 HEAP32[$4 + 20 >> 2] = 0;
 HEAP32[$4 + 16 >> 2] = 0;
 HEAP32[$4 + 12 >> 2] = 0;
 HEAP32[$4 + 8 >> 2] = 0;
 while (1) {
  $0 = 1;
  $0 = HEAP32[$4 + 16 >> 2] < 0 ? HEAP32[$4 + 12 >> 2] != 0 : $0;
  if ($0) {
   if (!HEAP32[$4 + 12 >> 2]) {
    HEAP32[$4 + 8 >> 2] = 0;
    while (1) {
     $0 = 0;
     $0 = HEAPU32[$4 + 12 >> 2] < 128 ? HEAP32[$4 + 16 >> 2] >= 0 : $0;
     if ($0) {
      HEAP32[$4 + 16 >> 2] = FUNCTION_TABLE[HEAP32[$4 + 604 >> 2]](HEAP32[$4 + 600 >> 2]);
      if (HEAP32[$4 + 16 >> 2] >= 0) {
       $1 = HEAP32[$4 + 16 >> 2];
       $0 = HEAP32[$4 + 12 >> 2];
       HEAP32[$4 + 12 >> 2] = $0 + 1;
       HEAP8[($4 + 160 | 0) + $0 | 0] = $1;
      }
      continue;
     }
     break;
    }
   }
   HEAP8[$4 + 7 | 0] = (heatshrink_decoder_sink($4 + 288 | 0, HEAP32[$4 + 8 >> 2] + ($4 + 160 | 0) | 0, HEAP32[$4 + 12 >> 2], $4 + 24 | 0) | 0) >= 0;
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] - HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 8 >> 2];
   if (!(HEAP32[$4 + 12 >> 2] | HEAP32[$4 + 16 >> 2] >= 0)) {
    heatshrink_decoder_finish($4 + 288 | 0);
   }
   while (1) {
    HEAP32[$4 >> 2] = heatshrink_decoder_poll($4 + 288 | 0, $4 + 32 | 0, 128, $4 + 24 | 0);
    if (HEAP32[$4 + 596 >> 2]) {
     HEAP32[$4 + 28 >> 2] = 0;
     while (1) {
      if (HEAPU32[$4 + 28 >> 2] < HEAPU32[$4 + 24 >> 2]) {
       FUNCTION_TABLE[HEAP32[$4 + 596 >> 2]](HEAPU8[HEAP32[$4 + 28 >> 2] + ($4 + 32 | 0) | 0], HEAP32[$4 + 592 >> 2]);
       HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 28 >> 2] + 1;
       continue;
      }
      break;
     }
    }
    HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 20 >> 2];
    if (HEAP32[$4 >> 2] == 1) {
     continue;
    }
    break;
   }
   if (HEAP32[$4 + 16 >> 2] < 0) {
    heatshrink_decoder_finish($4 + 288 | 0);
   }
   continue;
  }
  break;
 }
 __stack_pointer = $4 + 608 | 0;
 return HEAP32[$4 + 20 >> 2];
}

function jswrap_spi_send8bit($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = __stack_pointer - 112 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 108 >> 2] = $0;
 HEAP32[$5 + 104 >> 2] = $1;
 HEAP32[$5 + 100 >> 2] = $2;
 HEAP32[$5 + 96 >> 2] = $3;
 HEAP8[$5 + 95 | 0] = $4;
 label$1: {
  if (!(jsvIsObject(HEAP32[$5 + 108 >> 2]) & 1)) {
   break label$1;
  }
  HEAP8[$5 + 94 | 0] = jsiGetDeviceFromClass(HEAP32[$5 + 108 >> 2]);
  if (!(HEAPU8[$5 + 94 | 0] <= 26 & HEAPU8[$5 + 94 | 0] >= 26)) {
   jsExceptionHere(1, 137479, 0);
   break label$1;
  }
  jshSPISet16(HEAPU8[$5 + 94 | 0], 1);
  if (!(HEAP32[$5 + 100 >> 2] | HEAP32[$5 + 96 >> 2])) {
   HEAP32[$5 + 100 >> 2] = 3;
   HEAP32[$5 + 96 >> 2] = 15;
  }
  HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 100 >> 2] & 255;
  HEAP32[$5 + 96 >> 2] = HEAP32[$5 + 96 >> 2] & 255;
  if (!(jshIsDeviceInitialised(HEAPU8[$5 + 94 | 0]) & 1)) {
   jshSPIInitInfo($5 + 80 | 0);
   jshSPISetup(HEAPU8[$5 + 94 | 0], $5 + 80 | 0);
  }
  jshSPISetReceive(HEAPU8[$5 + 94 | 0], 0);
  if (HEAPU8[$5 + 95 | 0] != 255) {
   jshPinOutput(HEAPU8[$5 + 95 | 0], 0);
  }
  label$7: {
   if (jsvIsNumeric(HEAP32[$5 + 104 >> 2]) & 1) {
    jsspiSend8bit(HEAPU8[$5 + 94 | 0], jsvGetInteger(HEAP32[$5 + 104 >> 2]) & 255, HEAP32[$5 + 100 >> 2], HEAP32[$5 + 96 >> 2]);
    break label$7;
   }
   label$9: {
    if (jsvIsIterable(HEAP32[$5 + 104 >> 2]) & 1) {
     jshInterruptOff();
     jsvIteratorNew($5 + 16 | 0, HEAP32[$5 + 104 >> 2], 1);
     while (1) {
      if (jsvIteratorHasElement($5 + 16 | 0) & 1) {
       HEAP8[$5 + 15 | 0] = jsvIteratorGetIntegerValue($5 + 16 | 0);
       jsspiSend8bit(HEAPU8[$5 + 94 | 0], HEAPU8[$5 + 15 | 0], HEAP32[$5 + 100 >> 2], HEAP32[$5 + 96 >> 2]);
       jsvIteratorNext($5 + 16 | 0);
       continue;
      }
      break;
     }
     jsvIteratorFree($5 + 16 | 0);
     jshInterruptOn();
     break label$9;
    }
    HEAP32[$5 >> 2] = HEAP32[$5 + 104 >> 2];
    jsExceptionHere(1, 128409, $5);
   }
  }
  jshSPIWait(HEAPU8[$5 + 94 | 0]);
  if (HEAPU8[$5 + 95 | 0] != 255) {
   jshPinOutput(HEAPU8[$5 + 95 | 0], 1);
  }
  jshSPISet16(HEAPU8[$5 + 94 | 0], 0);
 }
 __stack_pointer = $5 + 112 | 0;
}

function jswrap_spi_send4bit($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = __stack_pointer - 112 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 108 >> 2] = $0;
 HEAP32[$5 + 104 >> 2] = $1;
 HEAP32[$5 + 100 >> 2] = $2;
 HEAP32[$5 + 96 >> 2] = $3;
 HEAP8[$5 + 95 | 0] = $4;
 label$1: {
  if (!(jsvIsObject(HEAP32[$5 + 108 >> 2]) & 1)) {
   break label$1;
  }
  HEAP8[$5 + 94 | 0] = jsiGetDeviceFromClass(HEAP32[$5 + 108 >> 2]);
  if (!(HEAPU8[$5 + 94 | 0] <= 26 & HEAPU8[$5 + 94 | 0] >= 26)) {
   jsExceptionHere(1, 137519, 0);
   break label$1;
  }
  jshSPISet16(HEAPU8[$5 + 94 | 0], 1);
  if (!(HEAP32[$5 + 100 >> 2] | HEAP32[$5 + 96 >> 2])) {
   HEAP32[$5 + 100 >> 2] = 1;
   HEAP32[$5 + 96 >> 2] = 3;
  }
  HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 100 >> 2] & 15;
  HEAP32[$5 + 96 >> 2] = HEAP32[$5 + 96 >> 2] & 15;
  if (!(jshIsDeviceInitialised(HEAPU8[$5 + 94 | 0]) & 1)) {
   jshSPIInitInfo($5 + 80 | 0);
   jshSPISetup(HEAPU8[$5 + 94 | 0], $5 + 80 | 0);
  }
  jshSPISetReceive(HEAPU8[$5 + 94 | 0], 0);
  if (HEAPU8[$5 + 95 | 0] != 255) {
   jshPinOutput(HEAPU8[$5 + 95 | 0], 0);
  }
  label$7: {
   if (jsvIsNumeric(HEAP32[$5 + 104 >> 2]) & 1) {
    jsspiSend4bit(HEAPU8[$5 + 94 | 0], jsvGetInteger(HEAP32[$5 + 104 >> 2]) & 255, HEAP32[$5 + 100 >> 2], HEAP32[$5 + 96 >> 2]);
    break label$7;
   }
   label$9: {
    if (jsvIsIterable(HEAP32[$5 + 104 >> 2]) & 1) {
     jshInterruptOff();
     jsvIteratorNew($5 + 16 | 0, HEAP32[$5 + 104 >> 2], 1);
     while (1) {
      if (jsvIteratorHasElement($5 + 16 | 0) & 1) {
       HEAP8[$5 + 15 | 0] = jsvIteratorGetIntegerValue($5 + 16 | 0);
       jsspiSend4bit(HEAPU8[$5 + 94 | 0], HEAPU8[$5 + 15 | 0], HEAP32[$5 + 100 >> 2], HEAP32[$5 + 96 >> 2]);
       jsvIteratorNext($5 + 16 | 0);
       continue;
      }
      break;
     }
     jsvIteratorFree($5 + 16 | 0);
     jshInterruptOn();
     break label$9;
    }
    HEAP32[$5 >> 2] = HEAP32[$5 + 104 >> 2];
    jsExceptionHere(1, 128409, $5);
   }
  }
  jshSPIWait(HEAPU8[$5 + 94 | 0]);
  if (HEAPU8[$5 + 95 | 0] != 255) {
   jshPinOutput(HEAPU8[$5 + 95 | 0], 1);
  }
  jshSPISet16(HEAPU8[$5 + 94 | 0], 0);
 }
 __stack_pointer = $5 + 112 | 0;
}

function jswrap_graphics_setTheme($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 if (jsvIsObject(HEAP32[$2 + 8 >> 2]) & 1) {
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 130040);
  if (HEAP32[$2 + 4 >> 2]) {
   $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
   HEAP8[366785] = $0;
   HEAP8[366786] = $0 >>> 8;
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
  }
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 130044);
  if (HEAP32[$2 + 4 >> 2]) {
   $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
   HEAP8[366787] = $0;
   HEAP8[366788] = $0 >>> 8;
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
  }
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 139561);
  if (HEAP32[$2 + 4 >> 2]) {
   $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
   HEAP8[366789] = $0;
   HEAP8[366790] = $0 >>> 8;
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
  }
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 139565);
  if (HEAP32[$2 + 4 >> 2]) {
   $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
   HEAP8[366791] = $0;
   HEAP8[366792] = $0 >>> 8;
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
  }
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 137564);
  if (HEAP32[$2 + 4 >> 2]) {
   $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
   HEAP8[366793] = $0;
   HEAP8[366794] = $0 >>> 8;
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
  }
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 137568);
  if (HEAP32[$2 + 4 >> 2]) {
   $0 = jswrap_graphics_toColor(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2], 0, 0);
   HEAP8[366795] = $0;
   HEAP8[366796] = $0 >>> 8;
   jsvUnLock(HEAP32[$2 + 4 >> 2]);
  }
  HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 129083);
  if (HEAP32[$2 + 4 >> 2]) {
   HEAP8[366797] = jsvGetBoolAndUnLock(HEAP32[$2 + 4 >> 2]) & 1;
  }
 }
 $0 = jsvLockAgain(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function jsvGetPathTo_int($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 128 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 120 >> 2] = $0;
 HEAP32[$5 + 116 >> 2] = $1;
 HEAP32[$5 + 112 >> 2] = $2;
 HEAP32[$5 + 108 >> 2] = $3;
 HEAP32[$5 + 104 >> 2] = $4;
 label$1: {
  if (HEAP32[$5 + 112 >> 2] <= 0) {
   HEAP32[$5 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 112 >> 2] + 1;
  HEAP32[$5 + 96 >> 2] = 0;
  jsvIteratorNew($5 + 32 | 0, HEAP32[$5 + 120 >> 2], 0);
  while (1) {
   if (jsvIteratorHasElement($5 + 32 | 0) & 1) {
    HEAP32[$5 + 28 >> 2] = jsvIteratorGetValue($5 + 32 | 0);
    if (!(HEAP32[$5 + 120 >> 2] == HEAP32[$5 + 108 >> 2] | HEAP32[$5 + 28 >> 2] != HEAP32[$5 + 116 >> 2])) {
     HEAP32[$5 + 24 >> 2] = jsvAsStringAndUnLock(jsvIteratorGetKey($5 + 32 | 0));
     jsvIteratorFree($5 + 32 | 0);
     HEAP32[$5 + 124 >> 2] = HEAP32[$5 + 24 >> 2];
     break label$1;
    }
    label$6: {
     label$7: {
      if (jsvIsObject(HEAP32[$5 + 28 >> 2]) & 1) {
       break label$7;
      }
      if (jsvIsArray(HEAP32[$5 + 28 >> 2]) & 1) {
       break label$7;
      }
      if (!(jsvIsFunction(HEAP32[$5 + 28 >> 2]) & 1)) {
       break label$6;
      }
     }
     HEAP32[$5 + 16 >> 2] = jsvGetPathTo_int(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 116 >> 2], HEAP32[$5 + 112 >> 2] - 1 | 0, HEAP32[$5 + 108 >> 2], $5 + 20 | 0);
     if (!(!HEAP32[$5 + 16 >> 2] | HEAP32[$5 + 20 >> 2] >= HEAP32[$5 + 100 >> 2])) {
      HEAP32[$5 + 100 >> 2] = HEAP32[$5 + 20 >> 2];
      HEAP32[$5 + 12 >> 2] = jsvIteratorGetKey($5 + 32 | 0);
      jsvUnLock(HEAP32[$5 + 96 >> 2]);
      $0 = jsvIsObject(HEAP32[$5 + 28 >> 2]) & 1;
      $1 = HEAP32[$5 + 12 >> 2];
      HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 16 >> 2];
      HEAP32[$5 >> 2] = $1;
      HEAP32[$5 + 96 >> 2] = jsvVarPrintf($0 ? 116807 : 135900, $5);
      jsvUnLock(HEAP32[$5 + 12 >> 2]);
     }
     jsvUnLock(HEAP32[$5 + 16 >> 2]);
    }
    jsvIteratorNext($5 + 32 | 0);
    continue;
   }
   break;
  }
  jsvIteratorFree($5 + 32 | 0);
  HEAP32[HEAP32[$5 + 104 >> 2] >> 2] = HEAP32[$5 + 100 >> 2];
  HEAP32[$5 + 124 >> 2] = HEAP32[$5 + 96 >> 2];
 }
 __stack_pointer = $5 + 128 | 0;
 return HEAP32[$5 + 124 >> 2];
}

function jsspiPopulateSPIInfo($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 128 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 124 >> 2] = $0;
 HEAP32[$2 + 120 >> 2] = $1;
 jshSPIInitInfo(HEAP32[$2 + 124 >> 2]);
 HEAP32[$2 + 116 >> 2] = 0;
 HEAP32[$2 + 112 >> 2] = HEAPU8[HEAP32[$2 + 124 >> 2] + 8 | 0];
 HEAP32[$2 + 16 >> 2] = 129109;
 HEAP16[$2 + 20 >> 1] = 13;
 HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 124 >> 2] + 5;
 HEAP32[$2 + 28 >> 2] = 128037;
 HEAP16[$2 + 32 >> 1] = 13;
 HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 124 >> 2] + 6;
 HEAP32[$2 + 40 >> 2] = 129317;
 HEAP16[$2 + 44 >> 1] = 13;
 HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 124 >> 2] + 7;
 HEAP32[$2 + 52 >> 2] = 132898;
 HEAP16[$2 + 56 >> 1] = 10;
 HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 124 >> 2];
 HEAP32[$2 + 64 >> 2] = 132782;
 HEAP16[$2 + 68 >> 1] = 10;
 HEAP32[$2 + 72 >> 2] = $2 + 112;
 HEAP32[$2 + 76 >> 2] = 121362;
 HEAP16[$2 + 80 >> 1] = 5;
 HEAP32[$2 + 84 >> 2] = $2 + 116;
 HEAP32[$2 + 88 >> 2] = 119849;
 HEAP16[$2 + 92 >> 1] = 10;
 HEAP32[$2 + 96 >> 2] = HEAP32[$2 + 124 >> 2] + 10;
 HEAP8[$2 + 15 | 0] = 1;
 if (jsvReadConfigObject(HEAP32[$2 + 120 >> 2], $2 + 16 | 0, 7) & 1) {
  HEAP8[HEAP32[$2 + 124 >> 2] + 8 | 0] = HEAP32[$2 + 112 >> 2] & 3;
  label$2: {
   label$3: {
    if (!(jsvIsString(HEAP32[$2 + 116 >> 2]) & 1)) {
     break label$3;
    }
    if (!(jsvIsStringEqual(HEAP32[$2 + 116 >> 2], 135689) & 1)) {
     break label$3;
    }
    HEAP8[HEAP32[$2 + 124 >> 2] + 9 | 0] = 1;
    break label$2;
   }
   label$4: {
    label$5: {
     if (!(jsvIsString(HEAP32[$2 + 116 >> 2]) & 1)) {
      break label$5;
     }
     if (!(jsvIsStringEqual(HEAP32[$2 + 116 >> 2], 135693) & 1)) {
      break label$5;
     }
     HEAP8[HEAP32[$2 + 124 >> 2] + 9 | 0] = 0;
     break label$4;
    }
    if (!(jsvIsUndefined(HEAP32[$2 + 116 >> 2]) & 1)) {
     jsExceptionHere(1, 145393, 0);
     HEAP8[$2 + 15 | 0] = 0;
    }
   }
  }
  $0 = HEAP32[$2 + 124 >> 2];
  if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) < 100) {
   jsExceptionHere(1, 132044, 0);
   HEAP8[$2 + 15 | 0] = 0;
  }
 }
 jsvUnLock(HEAP32[$2 + 116 >> 2]);
 __stack_pointer = $2 + 128 | 0;
 return HEAP8[$2 + 15 | 0] & 1;
}

function jsserialGetSendFunction($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 HEAP8[$3 + 31 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 40 >> 2]);
 label$1: {
  if (!(HEAPU8[$3 + 31 | 0] < 17 | HEAPU8[$3 + 31 | 0] > 22)) {
   label$3: {
    if (HEAPU8[$3 + 31 | 0] < 22 | HEAPU8[$3 + 31 | 0] > 22) {
     break label$3;
    }
    if (jshIsDeviceInitialised(HEAPU8[$3 + 31 | 0]) & 1) {
     break label$3;
    }
    jshUSARTInitInfo($3 + 16 | 0);
    jshUSARTSetup(HEAPU8[$3 + 31 | 0], $3 + 16 | 0);
   }
   HEAP32[HEAP32[$3 + 36 >> 2] >> 2] = 569;
   HEAP8[HEAP32[$3 + 32 >> 2]] = HEAPU8[$3 + 31 | 0];
   HEAP8[$3 + 47 | 0] = 1;
   break label$1;
  }
  if (!HEAPU8[$3 + 31 | 0]) {
   HEAP32[$3 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 40 >> 2], 132026);
   HEAP32[$3 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 40 >> 2], 120075);
   jsserialPopulateUSARTInfo($3 + 16 | 0, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
   jsvUnLock(HEAP32[$3 + 8 >> 2]);
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   HEAP32[HEAP32[$3 + 36 >> 2] >> 2] = 570;
   $0 = HEAP32[$3 + 20 >> 2];
   $1 = HEAP32[$3 + 16 >> 2];
   $4 = $1;
   $2 = HEAP32[$3 + 32 >> 2];
   $1 = $2;
   HEAP8[$1 | 0] = $4;
   HEAP8[$1 + 1 | 0] = $4 >>> 8;
   HEAP8[$1 + 2 | 0] = $4 >>> 16;
   HEAP8[$1 + 3 | 0] = $4 >>> 24;
   HEAP8[$1 + 4 | 0] = $0;
   HEAP8[$1 + 5 | 0] = $0 >>> 8;
   HEAP8[$1 + 6 | 0] = $0 >>> 16;
   HEAP8[$1 + 7 | 0] = $0 >>> 24;
   $1 = HEAPU8[$3 + 25 | 0] | HEAPU8[$3 + 26 | 0] << 8 | (HEAPU8[$3 + 27 | 0] << 16 | HEAPU8[$3 + 28 | 0] << 24);
   $0 = HEAPU8[$3 + 21 | 0] | HEAPU8[$3 + 22 | 0] << 8 | (HEAPU8[$3 + 23 | 0] << 16 | HEAPU8[$3 + 24 | 0] << 24);
   $4 = $0;
   $0 = $2;
   HEAP8[$0 + 5 | 0] = $4;
   HEAP8[$0 + 6 | 0] = $4 >>> 8;
   HEAP8[$0 + 7 | 0] = $4 >>> 16;
   HEAP8[$0 + 8 | 0] = $4 >>> 24;
   HEAP8[$0 + 9 | 0] = $1;
   HEAP8[$0 + 10 | 0] = $1 >>> 8;
   HEAP8[$0 + 11 | 0] = $1 >>> 16;
   HEAP8[$0 + 12 | 0] = $1 >>> 24;
   HEAP8[$3 + 47 | 0] = 1;
   break label$1;
  }
  HEAP8[$3 + 47 | 0] = 0;
 }
 __stack_pointer = $3 + 48 | 0;
 return HEAP8[$3 + 47 | 0] & 1;
}

function jspeiFindChildFromStringInParents($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1: {
  label$2: {
   if (jsvIsObject(HEAP32[$2 + 40 >> 2]) & 1) {
    HEAP32[$2 + 32 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 40 >> 2], 135865);
    if (!HEAP32[$2 + 32 >> 2]) {
     HEAP32[$2 + 32 >> 2] = jspFindPrototypeFor(117903);
    }
    label$5: {
     if (!(!HEAP32[$2 + 32 >> 2] | HEAP32[$2 + 32 >> 2] == HEAP32[$2 + 40 >> 2])) {
      HEAP32[$2 + 28 >> 2] = jsvFindChildFromString(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 36 >> 2]);
      if (!HEAP32[$2 + 28 >> 2]) {
       HEAP32[$2 + 28 >> 2] = jspeiFindChildFromStringInParents(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 36 >> 2]);
      }
      jsvUnLock(HEAP32[$2 + 32 >> 2]);
      if (HEAP32[$2 + 28 >> 2]) {
       HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 28 >> 2];
       break label$1;
      }
      break label$5;
     }
     jsvUnLock(HEAP32[$2 + 32 >> 2]);
    }
    break label$2;
   }
   HEAP32[$2 + 24 >> 2] = jswGetBasicObjectName(HEAP32[$2 + 40 >> 2]);
   while (1) {
    if (HEAP32[$2 + 24 >> 2]) {
     HEAP32[$2 + 20 >> 2] = jsvFindChildFromString(HEAP32[91086], HEAP32[$2 + 24 >> 2]);
     if (!HEAP32[$2 + 20 >> 2]) {
      HEAP32[$2 + 20 >> 2] = jspNewPrototype(HEAP32[$2 + 24 >> 2], 1);
     }
     if (HEAP32[$2 + 20 >> 2]) {
      HEAP32[$2 + 16 >> 2] = 0;
      HEAP32[$2 + 12 >> 2] = jsvSkipNameAndUnLock(HEAP32[$2 + 20 >> 2]);
      if (jsvHasChildren(HEAP32[$2 + 12 >> 2]) & 1) {
       HEAP32[$2 + 8 >> 2] = jspGetNamedField(HEAP32[$2 + 12 >> 2], 132159, 0);
       if (HEAP32[$2 + 8 >> 2]) {
        HEAP32[$2 + 16 >> 2] = jsvFindChildFromString(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 36 >> 2]);
        jsvUnLock(HEAP32[$2 + 8 >> 2]);
       }
      }
      jsvUnLock(HEAP32[$2 + 12 >> 2]);
      if (HEAP32[$2 + 16 >> 2]) {
       HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 16 >> 2];
       break label$1;
      }
     }
     HEAP32[$2 + 24 >> 2] = jswGetBasicObjectPrototypeName(HEAP32[$2 + 24 >> 2]);
     continue;
    }
    break;
   }
  }
  HEAP32[$2 + 44 >> 2] = 0;
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function jswrap_spi_write($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 76 >> 2] = $0;
 HEAP32[$2 + 72 >> 2] = $1;
 label$1: {
  if (!(jsvIsObject(HEAP32[$2 + 76 >> 2]) & 1)) {
   break label$1;
  }
  HEAP8[$2 + 71 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 76 >> 2]);
  if (!(jsspiGetSendFunction(HEAP32[$2 + 76 >> 2], $2 - -64 | 0, $2 + 48 | 0) & 1)) {
   break label$1;
  }
  HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 64 >> 2];
  $0 = HEAP32[$2 + 52 >> 2];
  $1 = HEAP32[$2 + 48 >> 2];
  $3 = $1;
  $4 = $2 + 24 | 0;
  $1 = $4;
  HEAP8[$1 + 4 | 0] = $3;
  HEAP8[$1 + 5 | 0] = $3 >>> 8;
  HEAP8[$1 + 6 | 0] = $3 >>> 16;
  HEAP8[$1 + 7 | 0] = $3 >>> 24;
  HEAP8[$1 + 8 | 0] = $0;
  HEAP8[$1 + 9 | 0] = $0 >>> 8;
  HEAP8[$1 + 10 | 0] = $0 >>> 16;
  HEAP8[$1 + 11 | 0] = $0 >>> 24;
  $1 = HEAPU16[$2 + 58 >> 1] | HEAPU16[$2 + 60 >> 1] << 16;
  $0 = HEAPU16[$2 + 54 >> 1] | HEAPU16[$2 + 56 >> 1] << 16;
  $3 = $0;
  $0 = $4;
  HEAP8[$0 + 10 | 0] = $3;
  HEAP8[$0 + 11 | 0] = $3 >>> 8;
  HEAP8[$0 + 12 | 0] = $3 >>> 16;
  HEAP8[$0 + 13 | 0] = $3 >>> 24;
  HEAP8[$0 + 14 | 0] = $1;
  HEAP8[$0 + 15 | 0] = $1 >>> 8;
  HEAP8[$0 + 16 | 0] = $1 >>> 16;
  HEAP8[$0 + 17 | 0] = $1 >>> 24;
  HEAP8[$2 + 23 | 0] = 255;
  HEAP32[$2 + 16 >> 2] = jsvGetArrayLength(HEAP32[$2 + 72 >> 2]);
  if (HEAP32[$2 + 16 >> 2] > 0) {
   HEAP32[$2 + 12 >> 2] = jsvGetArrayItem(HEAP32[$2 + 72 >> 2], HEAP32[$2 + 16 >> 2] - 1 | 0);
   if (jsvIsPin(HEAP32[$2 + 12 >> 2]) & 1) {
    HEAP8[$2 + 23 | 0] = jshGetPinFromVar(HEAP32[$2 + 12 >> 2]);
    jsvUnLock(jsvArrayPop(HEAP32[$2 + 72 >> 2]));
   }
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
  }
  if (!(HEAPU8[$2 + 71 | 0] < 26 | HEAPU8[$2 + 71 | 0] > 26)) {
   jshSPISetReceive(HEAPU8[$2 + 71 | 0], 0);
  }
  if (HEAPU8[$2 + 23 | 0] != 255) {
   jshPinOutput(HEAPU8[$2 + 23 | 0], 0);
  }
  jsvIterateBufferCallback(HEAP32[$2 + 72 >> 2], 659, $2 + 24 | 0);
  if (!(HEAPU8[$2 + 71 | 0] < 26 | HEAPU8[$2 + 71 | 0] > 26)) {
   jshSPIWait(HEAPU8[$2 + 71 | 0]);
  }
  if (HEAPU8[$2 + 23 | 0] == 255) {
   break label$1;
  }
  jshPinOutput(HEAPU8[$2 + 23 | 0], 1);
 }
 __stack_pointer = $2 + 80 | 0;
}

function jswrap_encodeURIComponent($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 112 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 104 >> 2] = $0;
 HEAP32[$1 + 100 >> 2] = jsvAsString(HEAP32[$1 + 104 >> 2]);
 label$1: {
  if (!HEAP32[$1 + 100 >> 2]) {
   HEAP32[$1 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 96 >> 2] = jsvNewFromEmptyString_6();
  if (HEAP32[$1 + 96 >> 2]) {
   jsvStringIteratorNew($1 + 56 | 0, HEAP32[$1 + 100 >> 2], 0);
   jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 96 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar_6($1 + 56 | 0) & 1) {
     HEAP8[$1 + 15 | 0] = jsvStringIteratorGetCharAndNext($1 + 56 | 0);
     label$6: {
      label$7: {
       label$8: {
        if (isAlpha(HEAP8[$1 + 15 | 0]) & 1) {
         break label$8;
        }
        if (isNumeric(HEAP8[$1 + 15 | 0]) & 1 | HEAP8[$1 + 15 | 0] == 45 | (HEAP8[$1 + 15 | 0] == 46 | HEAP8[$1 + 15 | 0] == 33)) {
         break label$8;
        }
        if (HEAP8[$1 + 15 | 0] == 126 | HEAP8[$1 + 15 | 0] == 42 | (HEAP8[$1 + 15 | 0] == 39 | HEAP8[$1 + 15 | 0] == 40)) {
         break label$8;
        }
        if (HEAP8[$1 + 15 | 0] != 41) {
         break label$7;
        }
       }
       jsvStringIteratorAppend($1 + 16 | 0, HEAP8[$1 + 15 | 0]);
       break label$6;
      }
      jsvStringIteratorAppend($1 + 16 | 0, 37);
      HEAP32[$1 + 8 >> 2] = HEAP8[$1 + 15 | 0] >>> 4;
      $2 = $1 + 16 | 0;
      if (HEAPU32[$1 + 8 >> 2] > 9) {
       $0 = HEAP32[$1 + 8 >> 2] + 55 | 0;
      } else {
       $0 = HEAP32[$1 + 8 >> 2] + 48 | 0;
      }
      jsvStringIteratorAppend($2, $0 << 24 >> 24);
      HEAP32[$1 + 8 >> 2] = HEAP8[$1 + 15 | 0] & 15;
      $2 = $1 + 16 | 0;
      if (HEAPU32[$1 + 8 >> 2] > 9) {
       $0 = HEAP32[$1 + 8 >> 2] + 55 | 0;
      } else {
       $0 = HEAP32[$1 + 8 >> 2] + 48 | 0;
      }
      jsvStringIteratorAppend($2, $0 << 24 >> 24);
     }
     continue;
    }
    break;
   }
   jsvStringIteratorFree_7($1 + 16 | 0);
   jsvStringIteratorFree_7($1 + 56 | 0);
  }
  jsvUnLock(HEAP32[$1 + 100 >> 2]);
  HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 96 >> 2];
 }
 __stack_pointer = $1 + 112 | 0;
 return HEAP32[$1 + 108 >> 2];
}

function jswrap_interface_clearWatch($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer + -64 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 60 >> 2] = $0;
 label$1: {
  label$2: {
   if (!(jsvIsUndefined(HEAP32[$1 + 60 >> 2]) & 1)) {
    if (jsvGetArrayLength(HEAP32[$1 + 60 >> 2])) {
     break label$2;
    }
   }
   HEAP32[$1 + 56 >> 2] = jsvLock(HEAPU16[182205]);
   jsvObjectIteratorNew($1 + 48 | 0, HEAP32[$1 + 56 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_15($1 + 48 | 0) & 1) {
     HEAP32[$1 + 44 >> 2] = jsvObjectIteratorGetValue_14($1 + 48 | 0);
     HEAP32[$1 + 40 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 44 >> 2], 128488);
     HEAP8[$1 + 39 | 0] = jshGetPinFromVar(HEAP32[$1 + 40 >> 2]);
     if (!(jshGetPinShouldStayWatched(HEAPU8[$1 + 39 | 0]) & 1)) {
      jshPinWatch(HEAPU8[$1 + 39 | 0], 0, 0);
     }
     jsvUnLock2(HEAP32[$1 + 40 >> 2], HEAP32[$1 + 44 >> 2]);
     jsvObjectIteratorNext($1 + 48 | 0);
     continue;
    }
    break;
   }
   jsvObjectIteratorFree_15($1 + 48 | 0);
   jsvRemoveAllChildren(HEAP32[$1 + 56 >> 2]);
   jsvUnLock(HEAP32[$1 + 56 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 32 >> 2] = jsvGetArrayItem(HEAP32[$1 + 60 >> 2], 0);
  if (jsvIsUndefined(HEAP32[$1 + 32 >> 2]) & 1) {
   jsExceptionHere(1, 134361, 0);
   break label$1;
  }
  HEAP32[$1 + 28 >> 2] = jsvLock(HEAPU16[182205]);
  HEAP32[$1 + 24 >> 2] = jsvFindChildFromVar(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 32 >> 2], 0);
  jsvUnLock(HEAP32[$1 + 28 >> 2]);
  label$8: {
   if (HEAP32[$1 + 24 >> 2]) {
    HEAP32[$1 + 20 >> 2] = jsvSkipName(HEAP32[$1 + 24 >> 2]);
    HEAP8[$1 + 19 | 0] = jshGetPinFromVarAndUnLock(jsvObjectGetChildIfExists(HEAP32[$1 + 20 >> 2], 128488));
    jsvUnLock(HEAP32[$1 + 20 >> 2]);
    HEAP32[$1 + 12 >> 2] = jsvLock(HEAPU16[182205]);
    jsvRemoveChildAndUnLock(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 24 >> 2]);
    jsvUnLock(HEAP32[$1 + 12 >> 2]);
    if (!(jsiIsWatchingPin(HEAPU8[$1 + 19 | 0]) & 1)) {
     jshPinWatch(HEAPU8[$1 + 19 | 0], 0, 0);
    }
    break label$8;
   }
   HEAP32[$1 >> 2] = HEAP32[$1 + 32 >> 2];
   jsExceptionHere(1, 116850, $1);
  }
  jsvUnLock(HEAP32[$1 + 32 >> 2]);
 }
 __stack_pointer = $1 - -64 | 0;
}

function _jswrap_i2c_readFrom($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $6 = __stack_pointer - 112 | 0;
 $5 = $6;
 __stack_pointer = $5;
 HEAP32[$5 + 104 >> 2] = $0;
 HEAP8[$5 + 103 | 0] = $1;
 HEAP32[$5 + 96 >> 2] = $2;
 HEAP8[$5 + 95 | 0] = $3;
 HEAP32[$5 + 88 >> 2] = $4;
 label$1: {
  if (HEAP32[$5 + 88 >> 2] <= 0) {
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$5 + 88 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
   jsExceptionHere(1, 135807, 0);
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  $6 = $6 - (HEAP32[$5 + 88 >> 2] + 15 & -16) | 0;
  __stack_pointer = $6;
  HEAP32[$5 + 84 >> 2] = $6;
  label$4: {
   if (!(HEAPU8[$5 + 103 | 0] < 27 | HEAPU8[$5 + 103 | 0] > 27)) {
    jshI2CRead(HEAPU8[$5 + 103 | 0], HEAP32[$5 + 96 >> 2] & 255, HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP8[$5 + 95 | 0] & 1);
    break label$4;
   }
   label$6: {
    if (!HEAPU8[$5 + 103 | 0]) {
     HEAP32[$5 + 68 >> 2] = jsvObjectGetChildIfExists(HEAP32[$5 + 104 >> 2], 120075);
     if (jsi2cPopulateI2CInfo($5 + 72 | 0, HEAP32[$5 + 68 >> 2]) & 1) {
      HEAP8[$5 + 78 | 0] = jsvObjectGetBoolChild(HEAP32[$5 + 104 >> 2], 133568) & 1;
      jsi2cRead($5 + 72 | 0, HEAP32[$5 + 96 >> 2] & 255, HEAP32[$5 + 88 >> 2], HEAP32[$5 + 84 >> 2], HEAP8[$5 + 95 | 0] & 1);
     }
     jsvUnLock2(jsvObjectSetChild(HEAP32[$5 + 104 >> 2], 133568, jsvNewFromBool(HEAP8[$5 + 78 | 0] & 1)), HEAP32[$5 + 68 >> 2]);
     break label$6;
    }
    HEAP32[$5 + 108 >> 2] = 0;
    break label$1;
   }
  }
  HEAP32[$5 + 64 >> 2] = jsvNewTypedArray(1, HEAP32[$5 + 88 >> 2]);
  if (HEAP32[$5 + 64 >> 2]) {
   jsvArrayBufferIteratorNew($5 + 8 | 0, HEAP32[$5 + 64 >> 2], 0);
   HEAP32[$5 + 4 >> 2] = 0;
   while (1) {
    if (HEAPU32[$5 + 4 >> 2] < HEAPU32[$5 + 88 >> 2]) {
     jsvArrayBufferIteratorSetByteValue($5 + 8 | 0, HEAP8[HEAP32[$5 + 84 >> 2] + HEAP32[$5 + 4 >> 2] | 0]);
     jsvArrayBufferIteratorNext($5 + 8 | 0);
     HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] + 1;
     continue;
    }
    break;
   }
   jsvArrayBufferIteratorFree($5 + 8 | 0);
  }
  HEAP32[$5 + 108 >> 2] = HEAP32[$5 + 64 >> 2];
 }
 __stack_pointer = $5 + 112 | 0;
 return HEAP32[$5 + 108 >> 2];
}

function jslPrintTokenisedChar($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 96 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 92 >> 2] = $0;
 HEAP32[$6 + 88 >> 2] = $1;
 HEAP32[$6 + 84 >> 2] = $2;
 HEAP32[$6 + 80 >> 2] = $3;
 HEAP32[$6 + 76 >> 2] = $4;
 HEAP32[$6 + 72 >> 2] = $5;
 HEAP8[$6 + 71 | 0] = jsvStringIteratorGetCharAndNext(HEAP32[$6 + 92 >> 2]);
 label$1: {
  if (!(HEAPU8[$6 + 71 | 0] != 209 & HEAPU8[$6 + 71 | 0] != 210)) {
   HEAP32[$6 + 64 >> 2] = jsvStringIteratorGetCharAndNext(HEAP32[$6 + 92 >> 2]) & 255;
   if (HEAPU8[$6 + 71 | 0] == 210) {
    $0 = HEAP32[$6 + 80 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
    HEAP32[$6 + 64 >> 2] = (jsvStringIteratorGetCharAndNext(HEAP32[$6 + 92 >> 2]) & 255) << 8 | HEAP32[$6 + 64 >> 2];
   }
   $0 = HEAP32[$6 + 80 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 2;
   FUNCTION_TABLE[HEAP32[$6 + 76 >> 2]](145507, HEAP32[$6 + 72 >> 2]);
   while (1) {
    $0 = HEAP32[$6 + 64 >> 2];
    HEAP32[$6 + 64 >> 2] = $0 - 1;
    if ($0) {
     HEAP8[$6 + 63 | 0] = jsvStringIteratorGetCharAndNext(HEAP32[$6 + 92 >> 2]);
     HEAP32[$6 + 56 >> 2] = escapeCharacter(HEAP8[$6 + 63 | 0], 0, 0);
     $0 = HEAP32[$6 + 80 >> 2];
     HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
     FUNCTION_TABLE[HEAP32[$6 + 76 >> 2]](HEAP32[$6 + 56 >> 2], HEAP32[$6 + 72 >> 2]);
     continue;
    }
    break;
   }
   FUNCTION_TABLE[HEAP32[$6 + 76 >> 2]](145507, HEAP32[$6 + 72 >> 2]);
   break label$1;
  }
  if (jslNeedSpaceBetween(HEAPU8[HEAP32[$6 + 88 >> 2]], HEAPU8[$6 + 71 | 0]) & 1) {
   $0 = HEAP32[$6 + 84 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
   FUNCTION_TABLE[HEAP32[$6 + 76 >> 2]](146437, HEAP32[$6 + 72 >> 2]);
  }
  jslFunctionCharAsString(HEAPU8[$6 + 71 | 0], $6 + 16 | 0, 32);
  HEAP32[$6 + 12 >> 2] = strlen($6 + 16 | 0);
  if (HEAP32[$6 + 12 >> 2]) {
   $0 = HEAP32[$6 + 84 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + (HEAP32[$6 + 12 >> 2] - 1 | 0);
  }
  FUNCTION_TABLE[HEAP32[$6 + 76 >> 2]]($6 + 16 | 0, HEAP32[$6 + 72 >> 2]);
  $0 = HEAP32[$6 + 80 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
  HEAP8[HEAP32[$6 + 88 >> 2]] = HEAPU8[$6 + 71 | 0];
 }
 __stack_pointer = $6 + 96 | 0;
}

function jsvReplaceWith($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP32[$2 + 40 >> 2] = $1;
 label$1: {
  if (jsvIsArrayBufferName(HEAP32[$2 + 44 >> 2]) & 1) {
   HEAP32[$2 + 36 >> 2] = jsvGetInteger(HEAP32[$2 + 44 >> 2]);
   HEAP32[$2 + 32 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 44 >> 2]) & 65535);
   jsvArrayBufferSet(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 36 >> 2], HEAP32[$2 + 40 >> 2]);
   jsvUnLock(HEAP32[$2 + 32 >> 2]);
   break label$1;
  }
  if (!(jsvIsName(HEAP32[$2 + 44 >> 2]) & 1)) {
   HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 44 >> 2];
   jsExceptionHere(1, 119301, $2 + 16 | 0);
   break label$1;
  }
  if (jsvIsConstant(HEAP32[$2 + 44 >> 2]) & 1) {
   jsExceptionHere(3, 117614, 0);
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = jsvGetValueOfName(HEAP32[$2 + 44 >> 2]);
  if (jsvIsGetterOrSetter(HEAP32[$2 + 28 >> 2]) & 1) {
   label$6: {
    if (jsvIsNewChild(HEAP32[$2 + 44 >> 2]) & 1) {
     $0 = jsvLock(jsvGetNextSibling(HEAP32[$2 + 44 >> 2]) & 65535);
     break label$6;
    }
    $0 = 0;
   }
   HEAP32[$2 + 24 >> 2] = $0;
   jsvExecuteSetter(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 40 >> 2]);
   jsvUnLock2(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]);
   break label$1;
  }
  jsvUnLock(HEAP32[$2 + 28 >> 2]);
  jsvSetValueOfName(HEAP32[$2 + 44 >> 2], HEAP32[$2 + 40 >> 2]);
  if (!(jsvIsNewChild(HEAP32[$2 + 44 >> 2]) & 1)) {
   break label$1;
  }
  HEAP32[$2 + 20 >> 2] = jsvLock(jsvGetNextSibling(HEAP32[$2 + 44 >> 2]) & 65535);
  if (!(jsvIsString(HEAP32[$2 + 20 >> 2]) & 1)) {
   label$9: {
    if (!(jsvHasChildren(HEAP32[$2 + 20 >> 2]) & 1)) {
     $0 = HEAP32[$2 + 44 >> 2];
     HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 20 >> 2];
     HEAP32[$2 >> 2] = $0;
     jsExceptionHere(1, 119194, $2);
     break label$9;
    }
    jsvUnRef(HEAP32[$2 + 20 >> 2]);
    jsvSetNextSibling(HEAP32[$2 + 44 >> 2], 0);
    jsvUnRef(HEAP32[$2 + 20 >> 2]);
    jsvSetPrevSibling(HEAP32[$2 + 44 >> 2], 0);
    jsvAddName(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 44 >> 2]);
   }
  }
  jsvUnLock(HEAP32[$2 + 20 >> 2]);
 }
 __stack_pointer = $2 + 48 | 0;
}

function tflite___28anonymous_20namespace_29__AllocationInfoBuilder__GetOfflinePlannedOffsets_28tflite__Model_20const__2c_20int_20const___29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 56 >> 2] = $0;
 HEAP32[$3 + 52 >> 2] = $1;
 HEAP32[$3 + 48 >> 2] = $2;
 $0 = HEAP32[$3 + 56 >> 2];
 label$1: {
  if (tflite__Model__metadata_28_29_20const(HEAP32[$3 + 52 >> 2])) {
   HEAP32[$3 + 44 >> 2] = 0;
   while (1) {
    if (HEAPU32[$3 + 44 >> 2] < flatbuffers__Vector_flatbuffers__Offset_tflite__Metadata____size_28_29_20const(tflite__Model__metadata_28_29_20const(HEAP32[$3 + 52 >> 2])) >>> 0) {
     HEAP32[$3 + 40 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__Metadata____Get_28unsigned_20int_29_20const(tflite__Model__metadata_28_29_20const(HEAP32[$3 + 52 >> 2]), HEAP32[$3 + 44 >> 2]);
     if (!strncmp(flatbuffers__String__c_str_28_29_20const(tflite__Metadata__name_28_29_20const(HEAP32[$3 + 40 >> 2])), 189872, 23)) {
      HEAP32[$3 + 36 >> 2] = tflite__Model__buffers_28_29_20const(HEAP32[$3 + 52 >> 2]);
      HEAP32[$3 + 32 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer____operator_5b_5d_28unsigned_20int_29_20const(HEAP32[$3 + 36 >> 2], tflite__Metadata__buffer_28_29_20const(HEAP32[$3 + 40 >> 2]));
      HEAP32[$3 + 28 >> 2] = tflite__Buffer__data_28_29_20const(HEAP32[$3 + 32 >> 2]);
      HEAP32[$3 + 24 >> 2] = flatbuffers__Vector_unsigned_20char___data_28_29_20const(HEAP32[$3 + 28 >> 2]);
      HEAP32[$3 + 20 >> 2] = HEAP32[HEAP32[$3 + 24 >> 2] + 8 >> 2];
      HEAP32[HEAP32[$3 + 48 >> 2] >> 2] = HEAP32[$3 + 24 >> 2] + 12;
      if (HEAP32[$0 + 8 >> 2] != HEAP32[$3 + 20 >> 2]) {
       $1 = HEAP32[$0 >> 2];
       $2 = HEAP32[$3 + 20 >> 2];
       HEAP32[$3 + 4 >> 2] = HEAP32[$0 + 8 >> 2];
       HEAP32[$3 >> 2] = $2;
       tflite__ErrorReporter__Report_28char_20const__2c_20____29($1, 148069, $3);
       HEAP32[$3 + 60 >> 2] = 1;
       break label$1;
      }
     }
     HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 44 >> 2] + 1;
     continue;
    }
    break;
   }
  }
  HEAP32[$3 + 60 >> 2] = 0;
 }
 __stack_pointer = $3 - -64 | 0;
 return HEAP32[$3 + 60 >> 2];
}

function jsiSoftInit($0) {
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 47 | 0] = $0;
 HEAP8[364342] = 0;
 HEAP8[364431] = 0;
 HEAP32[91101] = jsvNewEmptyArray();
 HEAP32[91104] = jsvNewFromEmptyString_5();
 HEAP32[91106] = 0;
 HEAP16[182217] = 0;
 jsiInputLineCursorMoved();
 HEAP32[91112] = 0;
 jsfSetFlag(1, 0);
 HEAP8[195665] = 255;
 HEAP8[195666] = 255;
 HEAP16[182204] = _jsiInitNamedArray(119955);
 HEAP16[182205] = _jsiInitNamedArray(120298);
 HEAP32[91118] = jshGetSystemTime();
 HEAP32[91119] = i64toi32_i32$HIGH_BITS;
 HEAP32[$1 + 40 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 120167);
 if (HEAP32[$1 + 40 >> 2]) {
  HEAP8[196320] = jsvGetIntegerAndUnLock(HEAP32[$1 + 40 >> 2]);
  jsvObjectRemoveChild(HEAP32[91087], 120167);
 }
 jswInit();
 jsfLoadBootCodeFromFlash(HEAP8[$1 + 47 | 0] & 1);
 HEAP32[$1 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 117678);
 if (HEAP32[$1 + 36 >> 2]) {
  jsvUnLock2(jspEvaluateVar(HEAP32[$1 + 36 >> 2], 0, 0), HEAP32[$1 + 36 >> 2]);
  jsvObjectRemoveChild(HEAP32[91087], 117678);
 }
 if (HEAPU16[182205]) {
  HEAP32[$1 + 32 >> 2] = jsvLock(HEAPU16[182205]);
  jsvObjectIteratorNew($1 + 24 | 0, HEAP32[$1 + 32 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_3($1 + 24 | 0) & 1) {
    HEAP32[$1 + 20 >> 2] = jsvObjectIteratorGetValue_3($1 + 24 | 0);
    HEAP32[$1 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 20 >> 2], 128488);
    HEAP8[$1 + 15 | 0] = jsvObjectGetBoolChild(HEAP32[$1 + 20 >> 2], 134129) & 1;
    jshPinWatch(jshGetPinFromVar(HEAP32[$1 + 16 >> 2]) & 255, 1, HEAP8[$1 + 15 | 0] & 1);
    jsvUnLock2(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
    jsvObjectIteratorNext($1 + 24 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_3($1 + 24 | 0);
  jsvUnLock(HEAP32[$1 + 32 >> 2]);
 }
 jsiExecuteEventCallbackOn(137917, 117675, 0, 0);
 HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[91086], 117683);
 if (HEAP32[$1 + 8 >> 2]) {
  if (jsiEcho() & 1) {
   jsiConsolePrintString(147924);
  }
  jsiExecuteEventCallback(0, HEAP32[$1 + 8 >> 2], 0, 0);
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
 }
 __stack_pointer = $1 + 48 | 0;
}

function jswrap_banglejs_setLCDOverlay($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 44 >> 2] = $0;
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 36 >> 2] = $2;
 HEAP32[$4 + 32 >> 2] = $3;
 HEAP8[$4 + 31 | 0] = jsvIsUndefined(HEAP32[$4 + 44 >> 2]) & 1;
 HEAP32[$4 + 24 >> 2] = jsvGetInteger(HEAP32[$4 + 40 >> 2]);
 if (HEAP8[$4 + 31 | 0] & 1) {
  HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 40 >> 2];
 }
 HEAP32[$4 + 20 >> 2] = 0;
 if (jsvIsObject(HEAP32[$4 + 32 >> 2]) & 1) {
  HEAP32[$4 + 20 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 32 >> 2], 133321);
 }
 HEAP32[$4 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 134426);
 HEAP8[$4 + 15 | 0] = (jsvIsEqual(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]) ^ -1) & 1;
 jsvUnLock(HEAP32[$4 + 16 >> 2]);
 label$3: {
  if (!(!(HEAP8[$4 + 15 | 0] & 1) | (!(HEAP8[$4 + 31 | 0] & 1) | !HEAP32[$4 + 20 >> 2]))) {
   jsvUnLock(HEAP32[$4 + 20 >> 2]);
   break label$3;
  }
  if (HEAP8[$4 + 15 | 0] & 1) {
   HEAP32[$4 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 135734);
   if (HEAP32[$4 + 8 >> 2]) {
    jsiQueueEvents(0, HEAP32[$4 + 8 >> 2], 0, 0);
    jsvUnLock(HEAP32[$4 + 8 >> 2]);
   }
  }
  label$7: {
   if (HEAP32[$4 + 44 >> 2]) {
    jsvObjectSetOrRemoveChild(HEAP32[91087], 134426, HEAP32[$4 + 20 >> 2]);
    label$9: {
     if (jsvIsObject(HEAP32[$4 + 32 >> 2]) & 1) {
      $0 = jsvObjectGetChildIfExists(HEAP32[$4 + 32 >> 2], 131695);
      break label$9;
     }
     $0 = 0;
    }
    HEAP32[$4 + 4 >> 2] = $0;
    jsvObjectSetOrRemoveChild(HEAP32[91087], 135734, HEAP32[$4 + 4 >> 2]);
    jsvUnLock(HEAP32[$4 + 4 >> 2]);
    break label$7;
   }
   jsvObjectRemoveChild(HEAP32[91087], 134426);
   jsvObjectRemoveChild(HEAP32[91087], 135734);
  }
  jsvUnLock(HEAP32[$4 + 20 >> 2]);
  lcdMemLCD_setOverlay(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 36 >> 2]);
  HEAP8[366840] = 0;
  HEAP8[366841] = 0;
  HEAP8[366842] = 0;
  HEAP8[366843] = 0;
  HEAP8[366844] = 175;
  HEAP8[366845] = 0;
  HEAP8[366846] = 175;
  HEAP8[366847] = 0;
 }
 __stack_pointer = $4 + 48 | 0;
}

function jsiHandleDelete($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 31 | 0] = $0;
 HEAP32[$1 + 24 >> 2] = jsvGetStringLength(HEAP32[91104]);
 label$1: {
  if (!(HEAP32[91106] | !(HEAP8[$1 + 31 | 0] & 1)) | !(HEAP8[$1 + 31 | 0] & 1 | HEAPU32[91106] < HEAPU32[$1 + 24 >> 2])) {
   break label$1;
  }
  label$4: {
   if (HEAP8[$1 + 31 | 0] & 1) {
    $0 = 1;
    if ((jsvGetCharInString(HEAP32[91104], HEAP32[91106] - 1 | 0) | 0) == 10) {
     break label$4;
    }
   }
   if (!(HEAP8[$1 + 31 | 0] & 1)) {
    $2 = (jsvGetCharInString(HEAP32[91104], HEAP32[91106]) | 0) == 10;
   }
   $0 = $2;
  }
  HEAP8[$1 + 23 | 0] = $0 & 1;
  label$7: {
   if (!(HEAP8[$1 + 23 | 0] & 1)) {
    break label$7;
   }
   if (!(jsiShowInputLine() & 1)) {
    break label$7;
   }
   jsiConsoleEraseAfterCursor();
   if (HEAP8[$1 + 31 | 0] & 1) {
    jsiConsolePrintString(146436);
    jsiMoveCursorChar(HEAP32[91104], HEAP32[91106], HEAP32[91106] - 1 | 0);
    jsiInputLineCursorMoved();
   }
  }
  HEAP32[$1 + 16 >> 2] = jsvNewFromEmptyString_5();
  HEAP32[$1 + 12 >> 2] = HEAP32[91106];
  if (HEAP8[$1 + 31 | 0] & 1) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] - 1;
  }
  if (HEAP32[$1 + 12 >> 2]) {
   jsvAppendStringVar(HEAP32[$1 + 16 >> 2], HEAP32[91104], 0, HEAP32[$1 + 12 >> 2]);
  }
  if (HEAPU32[$1 + 24 >> 2] > HEAP32[$1 + 12 >> 2] + 1 >>> 0) {
   jsvAppendStringVar(HEAP32[$1 + 16 >> 2], HEAP32[91104], HEAP32[$1 + 12 >> 2] + 1 | 0, 2147483647);
  }
  jsiInputLineCursorMoved();
  jsvUnLock(HEAP32[91104]);
  HEAP32[91104] = HEAP32[$1 + 16 >> 2];
  if (HEAP8[$1 + 31 | 0] & 1) {
   HEAP32[91106] = HEAP32[91106] - 1;
  }
  if (!(jsiShowInputLine() & 1)) {
   break label$1;
  }
  label$13: {
   if (HEAP8[$1 + 23 | 0] & 1) {
    jsiConsolePrintStringVarWithNewLineChar(HEAP32[91104], HEAP32[91106], 58);
    jsiMoveCursorChar(HEAP32[91104], jsvGetStringLength(HEAP32[91104]), HEAP32[91106]);
    break label$13;
   }
   if (HEAP8[$1 + 31 | 0] & 1) {
    jsiConsolePrintChar(8);
   }
   jsiConsolePrintStringVarUntilEOL(HEAP32[91104], HEAP32[91106], -1, 1);
  }
 }
 __stack_pointer = $1 + 32 | 0;
}

function jswrap_crypto_SHAx($0, $1) {
 var $2 = 0, $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 $2 = $3;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = jsvGetDataPointer(HEAP32[$2 + 24 >> 2], $2 + 16 | 0);
 if (!(HEAP32[$2 + 12 >> 2] | !HEAP32[$2 + 24 >> 2])) {
  HEAP32[$2 + 16 >> 2] = jsvIterateCallbackCount(HEAP32[$2 + 24 >> 2]);
  label$2: {
   if (HEAP32[$2 + 16 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
    jsExceptionHere(1, 135807, 0);
    break label$2;
   }
   $3 = $3 - (HEAP32[$2 + 16 >> 2] + 15 & -16) | 0;
   __stack_pointer = $3;
   HEAP32[$2 + 12 >> 2] = $3;
   jsvIterateCallbackToBytes(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2]);
  }
 }
 label$4: {
  if (!HEAP32[$2 + 12 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$4;
  }
  HEAP32[$2 + 8 >> 2] = 20;
  if (HEAP32[$2 + 20 >> 2] > 1) {
   HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 20 >> 2] / 8;
  }
  HEAP32[$2 + 4 >> 2] = 0;
  HEAP32[$2 >> 2] = jsvNewArrayBufferWithPtr(HEAP32[$2 + 8 >> 2], $2 + 4 | 0);
  if (!HEAP32[$2 + 4 >> 2]) {
   jsError(117639, 0);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$4;
  }
  label$8: {
   if (HEAP32[$2 + 20 >> 2] == 1) {
    mbedtls_sha1(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 4 >> 2]);
    break label$8;
   }
   label$10: {
    if (HEAP32[$2 + 20 >> 2] == 224) {
     mbedtls_sha256(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 4 >> 2], 1);
     break label$10;
    }
    label$12: {
     if (HEAP32[$2 + 20 >> 2] == 256) {
      mbedtls_sha256(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 4 >> 2], 0);
      break label$12;
     }
     label$14: {
      if (HEAP32[$2 + 20 >> 2] == 384) {
       mbedtls_sha512(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 4 >> 2], 1);
       break label$14;
      }
      if (HEAP32[$2 + 20 >> 2] == 512) {
       mbedtls_sha512(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 4 >> 2], 0);
      }
     }
    }
   }
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jsspiGetSendFunction($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 HEAP8[$3 + 31 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 40 >> 2]);
 label$1: {
  if (!(HEAPU8[$3 + 31 | 0] < 26 | HEAPU8[$3 + 31 | 0] > 26)) {
   if (!(jshIsDeviceInitialised(HEAPU8[$3 + 31 | 0]) & 1)) {
    jshSPIInitInfo($3 + 16 | 0);
    jshSPISetup(HEAPU8[$3 + 31 | 0], $3 + 16 | 0);
   }
   HEAP32[HEAP32[$3 + 36 >> 2] >> 2] = 572;
   HEAP8[HEAP32[$3 + 32 >> 2]] = HEAPU8[$3 + 31 | 0];
   HEAP8[$3 + 47 | 0] = 1;
   break label$1;
  }
  if (!HEAPU8[$3 + 31 | 0]) {
   HEAP32[$3 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 40 >> 2], 120075);
   jsspiPopulateSPIInfo($3 + 16 | 0, HEAP32[$3 + 12 >> 2]);
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   label$5: {
    label$6: {
     if (HEAPU8[$3 + 23 | 0] == 255 | HEAPU8[$3 + 22 | 0] != 255 | (HEAPU8[$3 + 24 | 0] | HEAPU8[$3 + 21 | 0] == 255)) {
      break label$6;
     }
     if (!(HEAP8[$3 + 25 | 0] & 1)) {
      break label$6;
     }
     HEAP32[HEAP32[$3 + 36 >> 2] >> 2] = 573;
     break label$5;
    }
    HEAP32[HEAP32[$3 + 36 >> 2] >> 2] = 574;
   }
   $0 = HEAP32[$3 + 20 >> 2];
   $1 = HEAP32[$3 + 16 >> 2];
   $4 = $1;
   $2 = HEAP32[$3 + 32 >> 2];
   $1 = $2;
   HEAP8[$1 | 0] = $4;
   HEAP8[$1 + 1 | 0] = $4 >>> 8;
   HEAP8[$1 + 2 | 0] = $4 >>> 16;
   HEAP8[$1 + 3 | 0] = $4 >>> 24;
   HEAP8[$1 + 4 | 0] = $0;
   HEAP8[$1 + 5 | 0] = $0 >>> 8;
   HEAP8[$1 + 6 | 0] = $0 >>> 16;
   HEAP8[$1 + 7 | 0] = $0 >>> 24;
   $1 = HEAPU16[$3 + 26 >> 1] | HEAPU16[$3 + 28 >> 1] << 16;
   $0 = HEAPU16[$3 + 22 >> 1] | HEAPU16[$3 + 24 >> 1] << 16;
   $4 = $0;
   $0 = $2;
   HEAP8[$0 + 6 | 0] = $4;
   HEAP8[$0 + 7 | 0] = $4 >>> 8;
   HEAP8[$0 + 8 | 0] = $4 >>> 16;
   HEAP8[$0 + 9 | 0] = $4 >>> 24;
   HEAP8[$0 + 10 | 0] = $1;
   HEAP8[$0 + 11 | 0] = $1 >>> 8;
   HEAP8[$0 + 12 | 0] = $1 >>> 16;
   HEAP8[$0 + 13 | 0] = $1 >>> 24;
   HEAP8[$3 + 47 | 0] = 1;
   break label$1;
  }
  HEAP8[$3 + 47 | 0] = 0;
 }
 __stack_pointer = $3 + 48 | 0;
 return HEAP8[$3 + 47 | 0] & 1;
}

function tflite__ops__micro__fully_connected___28anonymous_20namespace_29__CalculateOpData_28TfLiteContext__2c_20TfLiteFusedActivation_2c_20TfLiteType_2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20tflite__ops__micro__fully_connected___28anonymous_20namespace_29__OpData__29($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0;
 $8 = __stack_pointer + -64 | 0;
 __stack_pointer = $8;
 HEAP32[$8 + 56 >> 2] = $0;
 HEAP32[$8 + 52 >> 2] = $1;
 HEAP32[$8 + 48 >> 2] = $2;
 HEAP32[$8 + 44 >> 2] = $3;
 HEAP32[$8 + 40 >> 2] = $4;
 HEAP32[$8 + 36 >> 2] = $5;
 HEAP32[$8 + 32 >> 2] = $6;
 HEAP32[$8 + 28 >> 2] = $7;
 HEAP32[$8 + 24 >> 2] = 0;
 label$1: {
  if (HEAP32[$8 + 48 >> 2] != 1) {
   HEAPF64[$8 + 16 >> 3] = 0;
   HEAP32[$8 + 12 >> 2] = tflite__GetQuantizedConvolutionMultipler_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20double__29(HEAP32[$8 + 56 >> 2], HEAP32[$8 + 44 >> 2], HEAP32[$8 + 40 >> 2], HEAP32[$8 + 36 >> 2], HEAP32[$8 + 32 >> 2], $8 + 16 | 0);
   if (HEAP32[$8 + 12 >> 2]) {
    HEAP32[$8 + 60 >> 2] = HEAP32[$8 + 12 >> 2];
    break label$1;
   }
   tflite__QuantizeMultiplier_28double_2c_20int__2c_20int__29(HEAPF64[$8 + 16 >> 3], HEAP32[$8 + 28 >> 2], $8 + 8 | 0);
   HEAP32[HEAP32[$8 + 28 >> 2] + 4 >> 2] = 0 - HEAP32[$8 + 8 >> 2];
   HEAP32[$8 + 4 >> 2] = tflite__CalculateActivationRangeQuantized_28TfLiteContext__2c_20TfLiteFusedActivation_2c_20TfLiteTensor__2c_20int__2c_20int__29(HEAP32[$8 + 56 >> 2], HEAP32[$8 + 52 >> 2], HEAP32[$8 + 32 >> 2], HEAP32[$8 + 28 >> 2] + 8 | 0, HEAP32[$8 + 28 >> 2] + 12 | 0);
   if (HEAP32[$8 + 4 >> 2]) {
    HEAP32[$8 + 60 >> 2] = HEAP32[$8 + 4 >> 2];
    break label$1;
   }
   HEAP32[HEAP32[$8 + 28 >> 2] + 20 >> 2] = HEAP32[HEAP32[$8 + 44 >> 2] + 12 >> 2];
   HEAP32[HEAP32[$8 + 28 >> 2] + 24 >> 2] = HEAP32[HEAP32[$8 + 40 >> 2] + 12 >> 2];
   HEAP32[HEAP32[$8 + 28 >> 2] + 28 >> 2] = HEAP32[HEAP32[$8 + 32 >> 2] + 12 >> 2];
  }
  HEAP32[$8 + 60 >> 2] = HEAP32[$8 + 24 >> 2];
 }
 __stack_pointer = $8 - -64 | 0;
 return HEAP32[$8 + 60 >> 2];
}

function lcdScroll_ArrayBuffer_flat8($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 var $7 = 0;
 $7 = __stack_pointer - 48 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 44 >> 2] = $0;
 HEAP32[$7 + 40 >> 2] = $1;
 HEAP32[$7 + 36 >> 2] = $2;
 HEAP32[$7 + 32 >> 2] = $3;
 HEAP32[$7 + 28 >> 2] = $4;
 HEAP32[$7 + 24 >> 2] = $5;
 HEAP32[$7 + 20 >> 2] = $6;
 HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 24 >> 2] - HEAP32[$7 + 32 >> 2];
 HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 20 >> 2] - HEAP32[$7 + 28 >> 2];
 HEAP32[$7 + 8 >> 2] = 0 - (HEAP32[$7 + 40 >> 2] + Math_imul(HEAP32[$7 + 36 >> 2], HEAP32[$7 + 16 >> 2]) | 0);
 $0 = HEAP32[$7 + 44 >> 2];
 HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 32 >> 2] + Math_imul(HEAP32[$7 + 28 >> 2] - HEAP32[$7 + 36 >> 2] | 0, HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
 HEAP32[$7 >> 2] = 0;
 while (1) {
  if (HEAP32[$7 >> 2] < (HEAP32[$7 + 12 >> 2] + HEAP32[$7 + 36 >> 2] | 0)) {
   label$3: {
    if (HEAP32[$7 + 8 >> 2] < 0) {
     $0 = HEAP32[$7 + 44 >> 2];
     $1 = HEAP32[$7 + 44 >> 2];
     __memcpy((HEAP32[$7 + 4 >> 2] - HEAP32[$7 + 8 >> 2] | 0) + (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) | 0, HEAP32[$7 + 4 >> 2] + (HEAPU8[$1 + 48 | 0] | HEAPU8[$1 + 49 | 0] << 8 | (HEAPU8[$1 + 50 | 0] << 16 | HEAPU8[$1 + 51 | 0] << 24)) | 0, HEAP32[$7 + 16 >> 2] + HEAP32[$7 + 40 >> 2] | 0);
     break label$3;
    }
    $0 = HEAP32[$7 + 44 >> 2];
    $1 = HEAP32[$7 + 44 >> 2];
    __memcpy(HEAP32[$7 + 4 >> 2] + (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) | 0, (HEAP32[$7 + 4 >> 2] + HEAP32[$7 + 8 >> 2] | 0) + (HEAPU8[$1 + 48 | 0] | HEAPU8[$1 + 49 | 0] << 8 | (HEAPU8[$1 + 50 | 0] << 16 | HEAPU8[$1 + 51 | 0] << 24)) | 0, HEAP32[$7 + 16 >> 2] - HEAP32[$7 + 40 >> 2] | 0);
   }
   $0 = HEAP32[$7 + 44 >> 2];
   HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] + (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
   HEAP32[$7 >> 2] = HEAP32[$7 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $7 + 48 | 0;
}

function jslPrintPosition($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 128 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 124 >> 2] = $0;
 HEAP32[$3 + 120 >> 2] = $1;
 HEAP32[$3 + 116 >> 2] = $2;
 label$1: {
  label$2: {
   if (!(jsvIsNativeString(HEAP32[HEAP32[49079] + 84 >> 2]) & 1)) {
    if (!(jsvIsFlashString(HEAP32[HEAP32[49079] + 84 >> 2]) & 1)) {
     break label$2;
    }
   }
   $0 = HEAP32[HEAP32[49079] + 84 >> 2];
   HEAP32[$3 + 104 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   HEAP32[$3 + 68 >> 2] = jsfFindFileFromAddr(HEAP32[$3 + 104 >> 2], $3 + 72 | 0);
   if (HEAP32[$3 + 68 >> 2]) {
    HEAP32[$3 + 64 >> 2] = jsvAddressToVar(HEAP32[$3 + 68 >> 2], jsfGetFileSize($3 + 72 | 0));
    jsvGetLineAndCol(HEAP32[$3 + 64 >> 2], (HEAP32[$3 + 116 >> 2] + HEAP32[$3 + 104 >> 2] | 0) - HEAP32[$3 + 68 >> 2] | 0, $3 + 112 | 0, $3 + 108 | 0);
    $1 = $3 + 72 | 0;
    HEAP32[$3 + 24 >> 2] = HEAP32[$1 + 28 >> 2];
    $0 = HEAP32[$1 + 20 >> 2];
    $2 = HEAP32[$1 + 24 >> 2];
    HEAP32[$3 + 16 >> 2] = $0;
    HEAP32[$3 + 20 >> 2] = $2;
    $0 = HEAP32[$1 + 16 >> 2];
    $2 = HEAP32[$1 + 12 >> 2];
    HEAP32[$3 + 8 >> 2] = $2;
    HEAP32[$3 + 12 >> 2] = $0;
    $2 = HEAP32[$1 + 8 >> 2];
    $0 = HEAP32[$1 + 4 >> 2];
    HEAP32[$3 >> 2] = $0;
    HEAP32[$3 + 4 >> 2] = $2;
    HEAP32[$3 + 60 >> 2] = jsfVarFromName($3);
    $0 = HEAP32[$3 + 124 >> 2];
    $1 = HEAP32[$3 + 120 >> 2];
    $2 = HEAP32[$3 + 112 >> 2];
    $4 = HEAP32[$3 + 108 >> 2];
    HEAP32[$3 + 40 >> 2] = HEAP32[$3 + 60 >> 2];
    HEAP32[$3 + 36 >> 2] = $4;
    HEAP32[$3 + 32 >> 2] = $2;
    cbprintf($0, $1, 146472, $3 + 32 | 0);
    jsvUnLock2(HEAP32[$3 + 64 >> 2], HEAP32[$3 + 60 >> 2]);
    break label$1;
   }
  }
  jsvGetLineAndCol(HEAP32[HEAP32[49079] + 84 >> 2], HEAP32[$3 + 116 >> 2], $3 + 112 | 0, $3 + 108 | 0);
  $0 = HEAP32[$3 + 124 >> 2];
  $1 = HEAP32[$3 + 120 >> 2];
  $2 = HEAP32[$3 + 112 >> 2];
  HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 108 >> 2];
  HEAP32[$3 + 48 >> 2] = $2;
  cbprintf($0, $1, 147273, $3 + 48 | 0);
 }
 __stack_pointer = $3 + 128 | 0;
}

function jswGetBasicObjectName($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1) {
   if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 129) {
    HEAP32[$1 + 12 >> 2] = 121317;
    break label$1;
   }
   if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 1) {
    HEAP32[$1 + 12 >> 2] = 116290;
    break label$1;
   }
   if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 65) {
    HEAP32[$1 + 12 >> 2] = 116272;
    break label$1;
   }
   if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 17) {
    HEAP32[$1 + 12 >> 2] = 116301;
    break label$1;
   }
   if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 2) {
    HEAP32[$1 + 12 >> 2] = 116311;
    break label$1;
   }
   if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 18) {
    HEAP32[$1 + 12 >> 2] = 116323;
    break label$1;
   }
   if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 3) {
    HEAP32[$1 + 12 >> 2] = 116347;
    break label$1;
   }
   if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 4) {
    HEAP32[$1 + 12 >> 2] = 116359;
    break label$1;
   }
   if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 20) {
    HEAP32[$1 + 12 >> 2] = 116371;
    break label$1;
   }
   if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 36) {
    HEAP32[$1 + 12 >> 2] = 116382;
    break label$1;
   }
   if (HEAPU8[HEAP32[$1 + 8 >> 2] + 5 | 0] == 40) {
    HEAP32[$1 + 12 >> 2] = 116334;
    break label$1;
   }
  }
  if (jsvIsPin(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 128511;
   break label$1;
  }
  if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 116389;
   break label$1;
  }
  if (jsvIsNumeric(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 121446;
   break label$1;
  }
  if (jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 117903;
   break label$1;
  }
  if (jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 128354;
   break label$1;
  }
  if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 129941;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jspeStatementIf() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 48 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 32 >> 2] = 0;
 jslGetNextToken();
 label$1: {
  if (!(jslMatch(40) & 1)) {
   HEAP32[$0 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 36 >> 2] = jspeExpression();
  if (HEAP32[91094] & 80) {
   HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 36 >> 2];
   break label$1;
  }
  if (!(jslMatch(41) & 1)) {
   HEAP32[$0 + 44 >> 2] = 0;
   break label$1;
  }
  if ((HEAP32[91094] & 63) == 1) {
   $1 = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$0 + 36 >> 2]));
  }
  HEAP8[$0 + 43 | 0] = $1 & 1;
  jsvUnLock(HEAP32[$0 + 36 >> 2]);
  HEAP32[$0 + 28 >> 2] = HEAP32[91094];
  if (!(HEAP8[$0 + 43 | 0] & 1)) {
   jspSetNoExecute();
  }
  HEAP32[$0 + 24 >> 2] = 0;
  HEAP32[$0 + 20 >> 2] = 0;
  if (HEAP16[HEAP32[49079] + 2 >> 1] != 59) {
   HEAP32[$0 + 20 >> 2] = jspeBlockOrStatement();
  }
  HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] | HEAP32[91094] & 112;
  label$8: {
   if (!(HEAP8[$0 + 43 | 0] & 1)) {
    jsvUnLock(HEAP32[$0 + 20 >> 2]);
    HEAP32[91094] = HEAP32[91094] & -1664 | HEAP32[$0 + 28 >> 2] & 1663;
    HEAP32[91094] = HEAP32[$0 + 24 >> 2] | HEAP32[91094];
    break label$8;
   }
   HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 20 >> 2];
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 59) {
   jslGetNextToken();
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 164) {
   jslGetNextToken();
   HEAP32[$0 + 16 >> 2] = HEAP32[91094];
   if (HEAP8[$0 + 43 | 0] & 1) {
    jspSetNoExecute();
   }
   HEAP32[$0 + 12 >> 2] = 0;
   if (HEAP16[HEAP32[49079] + 2 >> 1] != 59) {
    HEAP32[$0 + 12 >> 2] = jspeBlockOrStatement();
   }
   HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] | HEAP32[91094] & 112;
   label$14: {
    if (HEAP8[$0 + 43 | 0] & 1) {
     jsvUnLock(HEAP32[$0 + 12 >> 2]);
     HEAP32[91094] = HEAP32[91094] & -1664 | HEAP32[$0 + 16 >> 2] & 1663;
     HEAP32[91094] = HEAP32[$0 + 24 >> 2] | HEAP32[91094];
     break label$14;
    }
    HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 12 >> 2];
   }
  }
  HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 32 >> 2];
 }
 __stack_pointer = $0 + 48 | 0;
 return HEAP32[$0 + 44 >> 2];
}

function jswrap_number_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1: {
  if (!jsvGetArrayLength(HEAP32[$1 + 24 >> 2])) {
   HEAP32[$1 + 28 >> 2] = jsvNewFromInteger(0);
   break label$1;
  }
  HEAP32[$1 + 20 >> 2] = jsvGetArrayItem(HEAP32[$1 + 24 >> 2], 0);
  HEAP32[$1 + 16 >> 2] = 0;
  label$3: {
   if (jsvIsArray(HEAP32[$1 + 20 >> 2]) & 1) {
    HEAP32[$1 + 12 >> 2] = jsvGetArrayLength(HEAP32[$1 + 20 >> 2]);
    label$5: {
     if (!HEAP32[$1 + 12 >> 2]) {
      HEAP32[$1 + 16 >> 2] = jsvNewFromInteger(0);
      break label$5;
     }
     if (HEAP32[$1 + 12 >> 2] == 1) {
      HEAP32[$1 + 8 >> 2] = jsvGetArrayItem(HEAP32[$1 + 20 >> 2], 0);
      label$8: {
       label$9: {
        if (!(jsvIsString(HEAP32[$1 + 8 >> 2]) & 1)) {
         break label$9;
        }
        if (!(jsvIsEmptyString(HEAP32[$1 + 8 >> 2]) & 1)) {
         break label$9;
        }
        HEAP32[$1 + 16 >> 2] = jsvNewFromInteger(0);
        break label$8;
       }
       if (!(jsvIsBoolean(HEAP32[$1 + 8 >> 2]) & 1)) {
        HEAP32[$1 + 16 >> 2] = jsvAsNumber(HEAP32[$1 + 8 >> 2]);
       }
      }
      jsvUnLock(HEAP32[$1 + 8 >> 2]);
     }
    }
    break label$3;
   }
   label$11: {
    label$12: {
     if (!(jsvIsUndefined(HEAP32[$1 + 20 >> 2]) & 1)) {
      if (!(jsvIsObject(HEAP32[$1 + 20 >> 2]) & 1)) {
       break label$12;
      }
     }
     HEAP32[$1 + 16 >> 2] = 0;
     break label$11;
    }
    label$14: {
     label$15: {
      if (!(jsvIsString(HEAP32[$1 + 20 >> 2]) & 1)) {
       break label$15;
      }
      if (!(jsvIsEmptyString(HEAP32[$1 + 20 >> 2]) & 1)) {
       break label$15;
      }
      HEAP32[$1 + 16 >> 2] = jsvNewFromInteger(0);
      break label$14;
     }
     HEAP32[$1 + 16 >> 2] = jsvAsNumber(HEAP32[$1 + 20 >> 2]);
    }
   }
  }
  jsvUnLock(HEAP32[$1 + 20 >> 2]);
  if (HEAP32[$1 + 16 >> 2]) {
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 16 >> 2];
   break label$1;
  }
  HEAP32[$1 + 28 >> 2] = jsvNewFromFloat(nan);
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function heatshrink_decoder_poll($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 label$1: {
  if (HEAP32[$4 + 28 >> 2] ? !HEAP32[$4 + 40 >> 2] | !HEAP32[$4 + 36 >> 2] : 1) {
   HEAP32[$4 + 44 >> 2] = -1;
   break label$1;
  }
  HEAP32[HEAP32[$4 + 28 >> 2] >> 2] = 0;
  HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 36 >> 2];
  HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 32 >> 2];
  HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 28 >> 2];
  while (1) {
   HEAP8[$4 + 15 | 0] = HEAPU8[HEAP32[$4 + 40 >> 2] + 10 | 0];
   label$5: {
    label$6: {
     switch (HEAPU8[$4 + 15 | 0]) {
     case 0:
      $0 = st_tag_bit(HEAP32[$4 + 40 >> 2]);
      HEAP8[HEAP32[$4 + 40 >> 2] + 10 | 0] = $0;
      break label$5;

     case 1:
      $0 = st_d_yield_literal(HEAP32[$4 + 40 >> 2], $4 + 16 | 0);
      HEAP8[HEAP32[$4 + 40 >> 2] + 10 | 0] = $0;
      break label$5;

     case 2:
      $0 = st_backref_index_msb(HEAP32[$4 + 40 >> 2]);
      HEAP8[HEAP32[$4 + 40 >> 2] + 10 | 0] = $0;
      break label$5;

     case 3:
      $0 = st_backref_index_lsb(HEAP32[$4 + 40 >> 2]);
      HEAP8[HEAP32[$4 + 40 >> 2] + 10 | 0] = $0;
      break label$5;

     case 4:
      $0 = st_backref_count_msb(HEAP32[$4 + 40 >> 2]);
      HEAP8[HEAP32[$4 + 40 >> 2] + 10 | 0] = $0;
      break label$5;

     case 5:
      $0 = st_backref_count_lsb(HEAP32[$4 + 40 >> 2]);
      HEAP8[HEAP32[$4 + 40 >> 2] + 10 | 0] = $0;
      break label$5;

     case 6:
      $0 = st_yield_backref(HEAP32[$4 + 40 >> 2], $4 + 16 | 0);
      HEAP8[HEAP32[$4 + 40 >> 2] + 10 | 0] = $0;
      break label$5;

     default:
      break label$6;
     }
    }
    HEAP32[$4 + 44 >> 2] = -2;
    break label$1;
   }
   if (HEAPU8[HEAP32[$4 + 40 >> 2] + 10 | 0] != HEAPU8[$4 + 15 | 0]) {
    continue;
   }
   break;
  }
  if (HEAP32[HEAP32[$4 + 28 >> 2] >> 2] == HEAP32[$4 + 32 >> 2]) {
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 44 >> 2] = 0;
 }
 __stack_pointer = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}

function tflite__ops__micro__pooling__Prepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (!HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 16 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2];
 label$2: {
  if (!HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2]) {
   break label$2;
  }
 }
 HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2];
 HEAP32[$2 + 8 >> 2] = tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0);
 HEAP32[$2 + 4 >> 2] = tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0);
 HEAP32[$2 >> 2] = tflite__ops__micro__pooling___28anonymous_20namespace_29__CalculateOpData_28TfLiteContext_20const__2c_20TfLitePoolParams_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData__29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2], HEAP32[$2 + 12 >> 2]);
 label$3: {
  if (HEAP32[$2 >> 2]) {
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 >> 2];
   break label$3;
  }
  label$5: {
   if (HEAP32[HEAP32[$2 + 8 >> 2] + 28 >> 2] == 1) {
    void_20tflite__CalculateActivationRange_float__28TfLiteFusedActivation_2c_20float__2c_20float__29(HEAP32[HEAP32[$2 + 16 >> 2] + 20 >> 2], HEAP32[$2 + 12 >> 2] + 24 | 0, HEAP32[$2 + 12 >> 2] + 28 | 0);
    break label$5;
   }
   if (!(HEAP32[HEAP32[$2 + 8 >> 2] + 28 >> 2] != 9 & HEAP32[HEAP32[$2 + 8 >> 2] + 28 >> 2] != 3)) {
    tflite__CalculateActivationRangeQuantized_28TfLiteContext__2c_20TfLiteFusedActivation_2c_20TfLiteTensor__2c_20int__2c_20int__29(HEAP32[$2 + 24 >> 2], HEAP32[HEAP32[$2 + 16 >> 2] + 20 >> 2], HEAP32[$2 + 4 >> 2], HEAP32[$2 + 12 >> 2] + 16 | 0, HEAP32[$2 + 12 >> 2] + 20 | 0);
   }
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function mbedtls_sha512_starts($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 label$1: {
  if (!HEAP32[$2 + 8 >> 2]) {
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 16 >> 2] = -205731576;
   HEAP32[$0 + 20 >> 2] = 1779033703;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 24 >> 2] = -2067093701;
   HEAP32[$0 + 28 >> 2] = -1150833019;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 32 >> 2] = -23791573;
   HEAP32[$0 + 36 >> 2] = 1013904242;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 40 >> 2] = 1595750129;
   HEAP32[$0 + 44 >> 2] = -1521486534;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 48 >> 2] = -1377402159;
   HEAP32[$0 + 52 >> 2] = 1359893119;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 56 >> 2] = 725511199;
   HEAP32[$0 + 60 >> 2] = -1694144372;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 64 >> 2] = -79577749;
   HEAP32[$0 + 68 >> 2] = 528734635;
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 72 >> 2] = 327033209;
   HEAP32[$0 + 76 >> 2] = 1541459225;
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 16 >> 2] = -1056596264;
  HEAP32[$0 + 20 >> 2] = -876896931;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 24 >> 2] = 914150663;
  HEAP32[$0 + 28 >> 2] = 1654270250;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 32 >> 2] = 812702999;
  HEAP32[$0 + 36 >> 2] = -1856437926;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 40 >> 2] = -150054599;
  HEAP32[$0 + 44 >> 2] = 355462360;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 48 >> 2] = -4191439;
  HEAP32[$0 + 52 >> 2] = 1731405415;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 56 >> 2] = 1750603025;
  HEAP32[$0 + 60 >> 2] = -1900787065;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 64 >> 2] = 1694076839;
  HEAP32[$0 + 68 >> 2] = -619958771;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 72 >> 2] = -1090891868;
  HEAP32[$0 + 76 >> 2] = 1203062813;
 }
 HEAP32[HEAP32[$2 + 12 >> 2] + 208 >> 2] = HEAP32[$2 + 8 >> 2];
}

function jswrap_object_on_X($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 44 >> 2] = $0;
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 36 >> 2] = $2;
 HEAP8[$4 + 35 | 0] = $3;
 label$1: {
  if (!(jsvHasChildren(HEAP32[$4 + 44 >> 2]) & 1)) {
   jsExceptionHere(3, 135617, 0);
   break label$1;
  }
  if (!(jsvIsString(HEAP32[$4 + 40 >> 2]) & 1)) {
   jsExceptionHere(3, 129842, 0);
   break label$1;
  }
  label$4: {
   if (jsvIsFunction(HEAP32[$4 + 36 >> 2]) & 1) {
    break label$4;
   }
   if (jsvIsString(HEAP32[$4 + 36 >> 2]) & 1) {
    break label$4;
   }
   jsExceptionHere(3, 129872, 0);
   break label$1;
  }
  HEAP32[$4 >> 2] = HEAP32[$4 + 40 >> 2];
  HEAP32[$4 + 28 >> 2] = jsvVarPrintf(116801, $4);
  if (!HEAP32[$4 + 28 >> 2]) {
   break label$1;
  }
  HEAP32[$4 + 24 >> 2] = jsvFindChildFromVar(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 28 >> 2], 1);
  jsvUnLock(HEAP32[$4 + 28 >> 2]);
  HEAP32[$4 + 20 >> 2] = jsvSkipName(HEAP32[$4 + 24 >> 2]);
  HEAP32[$4 + 16 >> 2] = 0;
  label$5: {
   if (HEAP8[$4 + 35 | 0] & 1) {
    HEAP32[$4 + 16 >> 2] = jsvNewArray($4 + 36 | 0, 1);
    if (HEAP32[$4 + 20 >> 2]) {
     jsvArrayPushAll(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 20 >> 2], 0);
    }
    break label$5;
   }
   HEAP32[$4 + 16 >> 2] = jsvNewEmptyArray();
   if (HEAP32[$4 + 20 >> 2]) {
    jsvArrayPushAll(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 20 >> 2], 0);
   }
   jsvArrayPush(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 36 >> 2]);
  }
  jsvUnLock(HEAP32[$4 + 20 >> 2]);
  HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 16 >> 2];
  jsvSetValueOfName(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2]);
  jsvUnLock2(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2]);
  if (!(jsvIsStringEqual(HEAP32[$4 + 40 >> 2], 135835) & 1)) {
   break label$1;
  }
  HEAP32[$4 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 44 >> 2], 130086);
  if (jsvIsString(HEAP32[$4 + 12 >> 2]) & 1) {
   jsiQueueObjectCallbacks(HEAP32[$4 + 44 >> 2], 135743, $4 + 12 | 0, 1);
   jsvObjectRemoveChild(HEAP32[$4 + 44 >> 2], 130086);
  }
  jsvUnLock(HEAP32[$4 + 12 >> 2]);
 }
 __stack_pointer = $4 + 48 | 0;
}

function jsfCompactWriteBuffer($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 48 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 44 >> 2] = $0;
 HEAP32[$6 + 40 >> 2] = $1;
 HEAP32[$6 + 36 >> 2] = $2;
 HEAP32[$6 + 32 >> 2] = $3;
 HEAP32[$6 + 28 >> 2] = $4;
 HEAP32[$6 + 24 >> 2] = $5;
 HEAP32[$6 + 20 >> 2] = jsfGetBankEndAddress(HEAP32[HEAP32[$6 + 44 >> 2] >> 2]);
 HEAP32[$6 + 16 >> 2] = jsfGetAddressOfNextPage(HEAP32[HEAP32[$6 + 44 >> 2] >> 2]);
 if (!HEAP32[$6 + 16 >> 2]) {
  HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 20 >> 2];
 }
 while (1) {
  label$3: {
   if (!HEAP32[HEAP32[$6 + 28 >> 2] >> 2]) {
    break label$3;
   }
   HEAP32[$6 + 12 >> 2] = HEAP32[HEAP32[$6 + 28 >> 2] >> 2];
   if (HEAPU32[$6 + 32 >> 2] < HEAP32[$6 + 12 >> 2] + HEAP32[HEAP32[$6 + 24 >> 2] >> 2] >>> 0) {
    HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 32 >> 2] - HEAP32[HEAP32[$6 + 24 >> 2] >> 2];
   }
   if (HEAPU32[$6 + 16 >> 2] < HEAP32[$6 + 12 >> 2] + HEAP32[HEAP32[$6 + 44 >> 2] >> 2] >>> 0) {
    HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 16 >> 2] - HEAP32[HEAP32[$6 + 44 >> 2] >> 2];
   }
   if (HEAPU32[$6 + 40 >> 2] < HEAPU32[$6 + 16 >> 2]) {
    break label$3;
   }
   if (!(!(jshFlashGetPage(HEAP32[HEAP32[$6 + 44 >> 2] >> 2], $6 + 8 | 0, $6 + 4 | 0) & 1) | HEAP32[$6 + 8 >> 2] != HEAP32[HEAP32[$6 + 44 >> 2] >> 2])) {
    jshFlashErasePage(HEAP32[HEAP32[$6 + 44 >> 2] >> 2]);
   }
   jshFlashWrite(HEAP32[$6 + 36 >> 2] + HEAP32[HEAP32[$6 + 24 >> 2] >> 2] | 0, HEAP32[HEAP32[$6 + 44 >> 2] >> 2], HEAP32[$6 + 12 >> 2]);
   $0 = HEAP32[$6 + 44 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$6 + 12 >> 2] + HEAP32[$0 >> 2];
   HEAP32[$6 + 16 >> 2] = jsfGetAddressOfNextPage(HEAP32[HEAP32[$6 + 44 >> 2] >> 2]);
   if (!HEAP32[$6 + 16 >> 2]) {
    HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 20 >> 2];
   }
   HEAP32[HEAP32[$6 + 24 >> 2] >> 2] = (HEAP32[HEAP32[$6 + 24 >> 2] >> 2] + HEAP32[$6 + 12 >> 2] >>> 0) % HEAPU32[$6 + 32 >> 2];
   $0 = HEAP32[$6 + 28 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - HEAP32[$6 + 12 >> 2];
   jshKickWatchDog();
   jshKickSoftWatchDog();
   continue;
  }
  break;
 }
 __stack_pointer = $6 + 48 | 0;
}

function _jsvTraceGetLowestLevel($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1: {
  if (HEAP32[$2 + 40 >> 2] == HEAP32[$2 + 36 >> 2]) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 32 >> 2] = -1;
  $0 = HEAP32[$2 + 40 >> 2];
  if ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 512) {
   HEAP32[$2 + 44 >> 2] = -1;
   break label$1;
  }
  $0 = HEAP32[$2 + 40 >> 2];
  $1 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8 | 512;
  HEAP8[$0 + 12 | 0] = $1;
  HEAP8[$0 + 13 | 0] = $1 >>> 8;
  label$4: {
   if (!(jsvHasSingleChild(HEAP32[$2 + 40 >> 2]) & 1)) {
    break label$4;
   }
   if (!(jsvGetFirstChild(HEAP32[$2 + 40 >> 2]) & 65535)) {
    break label$4;
   }
   HEAP32[$2 + 28 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 40 >> 2]) & 65535);
   HEAP32[$2 + 24 >> 2] = _jsvTraceGetLowestLevel(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 36 >> 2]);
   jsvUnLock(HEAP32[$2 + 28 >> 2]);
   if (!(HEAP32[$2 + 32 >> 2] >= 0 & HEAP32[$2 + 24 >> 2] >= HEAP32[$2 + 32 >> 2] | HEAP32[$2 + 24 >> 2] < 0)) {
    HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 24 >> 2] + 1;
   }
  }
  if (jsvHasChildren(HEAP32[$2 + 40 >> 2]) & 1) {
   HEAP16[$2 + 22 >> 1] = jsvGetFirstChild(HEAP32[$2 + 40 >> 2]);
   while (1) {
    if (HEAPU16[$2 + 22 >> 1]) {
     HEAP32[$2 + 16 >> 2] = jsvLock(HEAPU16[$2 + 22 >> 1]);
     HEAP32[$2 + 12 >> 2] = _jsvTraceGetLowestLevel(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 36 >> 2]);
     if (!(HEAP32[$2 + 32 >> 2] >= 0 & HEAP32[$2 + 12 >> 2] >= HEAP32[$2 + 32 >> 2] | HEAP32[$2 + 12 >> 2] < 0)) {
      HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
     }
     HEAP16[$2 + 22 >> 1] = jsvGetNextSibling(HEAP32[$2 + 16 >> 2]);
     jsvUnLock(HEAP32[$2 + 16 >> 2]);
     continue;
    }
    break;
   }
  }
  $0 = HEAP32[$2 + 40 >> 2];
  $1 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & -513;
  HEAP8[$0 + 12 | 0] = $1;
  HEAP8[$0 + 13 | 0] = $1 >>> 8;
  HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function mbedtls_sha512_update($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1: {
  if (!HEAP32[$3 + 20 >> 2]) {
   break label$1;
  }
  $4 = HEAP32[$3 + 28 >> 2];
  $0 = HEAP32[$4 >> 2];
  HEAP32[$3 + 12 >> 2] = $0 & 127;
  HEAP32[$3 + 16 >> 2] = 128 - HEAP32[$3 + 12 >> 2];
  $7 = HEAP32[$3 + 28 >> 2];
  $0 = HEAP32[$3 + 20 >> 2];
  $5 = $0;
  $0 = $7;
  $4 = HEAP32[$0 >> 2];
  $1 = $4;
  $0 = HEAP32[$0 + 4 >> 2];
  $2 = $0;
  $0 = $5;
  $6 = $0 + $1 | 0;
  $0 = $7;
  HEAP32[$0 >> 2] = $6;
  $2 = $1 >>> 0 > $6 >>> 0 ? $2 + 1 | 0 : $2;
  HEAP32[$0 + 4 >> 2] = $2;
  $0 = HEAP32[$3 + 28 >> 2];
  $2 = HEAP32[$0 >> 2];
  $4 = $2;
  $0 = HEAP32[$0 + 4 >> 2];
  $2 = $0;
  $0 = HEAP32[$3 + 20 >> 2];
  $1 = $0;
  $0 = $4;
  if (!$2 & $0 >>> 0 < $1 >>> 0) {
   $5 = HEAP32[$3 + 28 >> 2];
   $1 = $5;
   $0 = HEAP32[$1 + 8 >> 2];
   $2 = HEAP32[$1 + 12 >> 2];
   $1 = $0;
   $4 = $1 + 1 | 0;
   $6 = $4 ? $2 : $2 + 1 | 0;
   $1 = $5;
   HEAP32[$1 + 8 >> 2] = $4;
   HEAP32[$1 + 12 >> 2] = $6;
  }
  if (!(!HEAP32[$3 + 12 >> 2] | HEAPU32[$3 + 20 >> 2] < HEAPU32[$3 + 16 >> 2])) {
   __memcpy(HEAP32[$3 + 12 >> 2] + (HEAP32[$3 + 28 >> 2] + 80 | 0) | 0, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 16 >> 2]);
   mbedtls_sha512_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 28 >> 2] + 80 | 0);
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 16 >> 2];
   HEAP32[$3 + 12 >> 2] = 0;
  }
  while (1) {
   if (HEAPU32[$3 + 20 >> 2] >= 128) {
    mbedtls_sha512_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] + 128;
    HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - 128;
    continue;
   }
   break;
  }
  if (!HEAP32[$3 + 20 >> 2]) {
   break label$1;
  }
  __memcpy(HEAP32[$3 + 12 >> 2] + (HEAP32[$3 + 28 >> 2] + 80 | 0) | 0, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
 }
 __stack_pointer = $3 + 32 | 0;
}

function jsfGetStorageStats($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 80 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 76 >> 2] = $1;
 HEAP8[$3 + 75 | 0] = $2;
 if (!HEAP32[$3 + 76 >> 2]) {
  HEAP32[$3 + 76 >> 2] = 134217728;
 }
 HEAP32[$3 + 68 >> 2] = HEAP32[$3 + 76 >> 2];
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$3 + 56 >> 2] = 0;
 HEAP32[$3 + 60 >> 2] = 0;
 HEAP32[$3 + 48 >> 2] = 0;
 HEAP32[$3 + 52 >> 2] = 0;
 HEAP32[$3 + 40 >> 2] = 0;
 HEAP32[$3 + 44 >> 2] = 0;
 HEAP32[$3 + 32 >> 2] = 0;
 HEAP32[$3 + 36 >> 2] = 0;
 HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 76 >> 2];
 HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 76 >> 2];
 if (jsfGetFileHeader(HEAP32[$3 + 76 >> 2], $3 + 32 | 0, 0) & 1) {
  while (1) {
   if (!(!(jshFlashGetPage(HEAP32[$3 + 76 >> 2], $3 + 20 | 0, $3 + 16 | 0) & 1) | HEAP32[$3 + 20 >> 2] != HEAP32[$3 + 76 >> 2])) {
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 20 >> 2];
   }
   HEAP32[$3 + 12 >> 2] = jsfAlignAddress(jsfGetFileSize($3 + 32 | 0)) + 32;
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 76 >> 2] + HEAP32[$3 + 12 >> 2];
   label$5: {
    if (HEAP32[$3 + 36 >> 2]) {
     HEAP32[$0 >> 2] = HEAP32[$3 + 12 >> 2] + HEAP32[$0 >> 2];
     HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
     break label$5;
    }
    HEAP32[$0 + 8 >> 2] = HEAP32[$3 + 12 >> 2] + HEAP32[$0 + 8 >> 2];
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    if (!HEAP32[$0 + 24 >> 2]) {
     HEAP32[$0 + 24 >> 2] = HEAP32[$3 + 24 >> 2];
    }
   }
   if (jsfGetNextFileHeader($3 + 76 | 0, $3 + 32 | 0, HEAP8[$3 + 75 | 0] & 1 | 2) & 1) {
    continue;
   }
   break;
  }
 }
 label$8: {
  if (HEAP8[$3 + 75 | 0] & 1) {
   $1 = jsfGetBankEndAddress(HEAP32[$3 + 68 >> 2]);
   break label$8;
  }
  $1 = jsfGetAddressOfNextPage(HEAP32[$3 + 68 >> 2]);
 }
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$0 + 16 >> 2] = HEAP32[$3 + 8 >> 2] - HEAP32[$3 + 68 >> 2];
 HEAP32[$0 + 20 >> 2] = HEAP32[$3 + 8 >> 2] - HEAP32[$3 + 28 >> 2];
 __stack_pointer = $3 + 80 | 0;
}

function jswrap_array_reduce($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 112 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 104 >> 2] = $0;
 HEAP32[$3 + 100 >> 2] = $1;
 HEAP32[$3 + 96 >> 2] = $2;
 label$1: {
  if (!(jsvIsIterable(HEAP32[$3 + 104 >> 2]) & 1)) {
   jsExceptionHere(1, 132530, 0);
   HEAP32[$3 + 108 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsFunction(HEAP32[$3 + 100 >> 2]) & 1)) {
   jsExceptionHere(1, 128290, 0);
   HEAP32[$3 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 92 >> 2] = jsvLockAgainSafe(HEAP32[$3 + 96 >> 2]);
  jsvIteratorNew($3 + 32 | 0, HEAP32[$3 + 104 >> 2], 0);
  if (!HEAP32[$3 + 92 >> 2]) {
   HEAP8[$3 + 31 | 0] = 0;
   while (1) {
    $0 = 0;
    if (!(HEAP8[$3 + 31 | 0] & 1)) {
     $0 = jsvIteratorHasElement($3 + 32 | 0);
    }
    if ($0 & 1) {
     HEAP32[$3 + 24 >> 2] = jsvIteratorGetKey($3 + 32 | 0);
     if (jsvIsInt(HEAP32[$3 + 24 >> 2]) & 1) {
      HEAP32[$3 + 92 >> 2] = jsvIteratorGetValue($3 + 32 | 0);
      HEAP8[$3 + 31 | 0] = 1;
     }
     jsvUnLock(HEAP32[$3 + 24 >> 2]);
     jsvIteratorNext($3 + 32 | 0);
     continue;
    }
    break;
   }
   if (!HEAP32[$3 + 92 >> 2]) {
    jsExceptionHere(1, 131794, 0);
   }
  }
  while (1) {
   if (jsvIteratorHasElement($3 + 32 | 0) & 1) {
    HEAP32[$3 + 20 >> 2] = jsvIteratorGetKey($3 + 32 | 0);
    if (jsvIsInt(HEAP32[$3 + 20 >> 2]) & 1) {
     HEAP32[$3 + 16 >> 2] = jsvGetInteger(HEAP32[$3 + 20 >> 2]);
     HEAP32[$3 >> 2] = HEAP32[$3 + 92 >> 2];
     HEAP32[$3 + 4 >> 2] = jsvIteratorGetValue($3 + 32 | 0);
     HEAP32[$3 + 8 >> 2] = jsvNewFromInteger(HEAP32[$3 + 16 >> 2]);
     HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 104 >> 2];
     HEAP32[$3 + 92 >> 2] = jspeFunctionCall(HEAP32[$3 + 100 >> 2], 0, 0, 0, 4, $3);
     jsvUnLockMany(3, $3);
    }
    jsvUnLock(HEAP32[$3 + 20 >> 2]);
    jsvIteratorNext($3 + 32 | 0);
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 32 | 0);
  HEAP32[$3 + 108 >> 2] = HEAP32[$3 + 92 >> 2];
 }
 __stack_pointer = $3 + 112 | 0;
 return HEAP32[$3 + 108 >> 2];
}

function jswrap_object_getOwnPropertyDescriptor($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1: {
  if (!(jswrap_object_hasOwnProperty(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]) & 1)) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 32 >> 2] = jsvAsArrayIndex(HEAP32[$2 + 36 >> 2]);
  HEAP32[$2 + 28 >> 2] = jspGetVarNamedField(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 32 >> 2], 1);
  jsvUnLock(HEAP32[$2 + 32 >> 2]);
  if (!HEAP32[$2 + 28 >> 2]) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 24 >> 2] = jsvNewObject();
  if (!HEAP32[$2 + 24 >> 2]) {
   jsvUnLock(HEAP32[$2 + 28 >> 2]);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP8[$2 + 23 | 0] = jsvIsNewChild(HEAP32[$2 + 28 >> 2]) & 1;
  HEAP32[$2 + 16 >> 2] = jsvGetInternalFunctionCheckerFor(HEAP32[$2 + 40 >> 2]);
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 132508, jsvNewFromBool((jsvIsConstant(HEAP32[$2 + 28 >> 2]) ^ -1) & 1));
  $0 = 1;
  $1 = HEAP32[$2 + 24 >> 2];
  if (HEAP32[$2 + 16 >> 2]) {
   $0 = FUNCTION_TABLE[HEAP32[$2 + 16 >> 2]](HEAP32[$2 + 28 >> 2]) ^ -1;
  }
  jsvObjectSetChildAndUnLock($1, 132567, jsvNewFromBool($0 & 1));
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 132517, jsvNewFromBool((HEAPU8[$2 + 23 | 0] ^ -1) & 1));
  HEAP32[$2 + 12 >> 2] = jsvGetValueOfName(HEAP32[$2 + 28 >> 2]);
  label$7: {
   if (jsvIsGetterOrSetter(HEAP32[$2 + 12 >> 2]) & 1) {
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 117892, jsvObjectGetChildIfExists(HEAP32[$2 + 12 >> 2], 117892));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 117878, jsvObjectGetChildIfExists(HEAP32[$2 + 12 >> 2], 117878));
    break label$7;
   }
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 131830, jsvSkipName(HEAP32[$2 + 28 >> 2]));
  }
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  jsvUnLock(HEAP32[$2 + 28 >> 2]);
  HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 24 >> 2];
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function jsiCheckErrors() {
 var $0 = 0;
 $0 = __stack_pointer - 48 | 0;
 __stack_pointer = $0;
 if (HEAPU16[182206] & 32768) {
  jspSetInterrupted(0);
  HEAP16[182206] = HEAPU16[182206] & -32769;
  jsiConsoleRemoveInputLine();
  jsiConsolePrintString(147672);
 }
 HEAP8[$0 + 47 | 0] = 0;
 HEAP8[$0 + 46 | 0] = (HEAP32[91094] & 32) != 0;
 HEAP32[$0 + 40 >> 2] = jspGetException();
 if (HEAP8[$0 + 46 | 0] & 1) {
  if (jsiExecuteEventCallbackOn(119866, 128115, 1, $0 + 40 | 0) & 1) {
   jsvUnLock(HEAP32[$0 + 40 >> 2]);
   HEAP32[$0 + 40 >> 2] = jspGetException();
   if (!HEAP32[$0 + 40 >> 2]) {
    HEAP8[$0 + 46 | 0] = 0;
   }
  }
 }
 if (HEAP8[$0 + 46 | 0] & 1) {
  jsiConsoleRemoveInputLine();
  HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 40 >> 2];
  jsiConsolePrintf(146459, $0 + 16 | 0);
  HEAP8[$0 + 47 | 0] = 1;
  if (jsvIsObject(HEAP32[$0 + 40 >> 2]) & 1) {
   HEAP32[$0 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 40 >> 2], 129121);
   if (HEAP32[$0 + 36 >> 2]) {
    jsiConsolePrintStringVar(HEAP32[$0 + 36 >> 2]);
    jsvUnLock(HEAP32[$0 + 36 >> 2]);
   }
  }
 }
 jsvUnLock(HEAP32[$0 + 40 >> 2]);
 if (jspIsInterrupted() & 1) {
  jsiConsoleRemoveInputLine();
  jsiConsolePrintString(147085);
  jspSetInterrupted(0);
  HEAP8[$0 + 47 | 0] = 1;
 }
 HEAP32[$0 + 32 >> 2] = jspGetStackTrace();
 if (HEAP32[$0 + 32 >> 2]) {
  if (HEAP8[$0 + 47 | 0] & 1) {
   jsiConsolePrintStringVar(HEAP32[$0 + 32 >> 2]);
  }
  jsvUnLock(HEAP32[$0 + 32 >> 2]);
 }
 if (jspHasError() & 1) {
  HEAP32[91094] = HEAP32[91094] & -113;
 }
 if (HEAPU8[364431] != HEAPU8[364342]) {
  HEAP8[$0 + 31 | 0] = HEAPU8[364342] & (HEAPU8[364431] ^ -1);
  if (HEAPU8[$0 + 31 | 0] & -9) {
   HEAP32[$0 + 24 >> 2] = jswrap_espruino_getErrorFlagArray(HEAPU8[$0 + 31 | 0]);
   jsiExecuteEventCallbackOn(137917, 130073, 1, $0 + 24 | 0);
   if (HEAP32[$0 + 24 >> 2]) {
    jsiConsoleRemoveInputLine();
    HEAP32[$0 >> 2] = HEAP32[$0 + 24 >> 2];
    jsiConsolePrintf(146494, $0);
    jsvUnLock(HEAP32[$0 + 24 >> 2]);
   }
  }
  HEAP8[364431] = HEAPU8[364342];
 }
 __stack_pointer = $0 + 48 | 0;
}

function graphicsSetPixelDevice($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = HEAP32[$4 + 12 >> 2];
 label$1: {
  if (HEAP32[$4 + 8 >> 2] < (HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8)) {
   break label$1;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  if (HEAP32[$4 + 4 >> 2] < (HEAPU8[$0 + 34 | 0] | HEAPU8[$0 + 35 | 0] << 8)) {
   break label$1;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  if (HEAP32[$4 + 8 >> 2] > (HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8)) {
   break label$1;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  if (HEAP32[$4 + 4 >> 2] > (HEAPU8[$0 + 38 | 0] | HEAPU8[$0 + 39 | 0] << 8)) {
   break label$1;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  if (HEAP32[$4 + 8 >> 2] < (HEAPU8[$0 + 40 | 0] | HEAPU8[$0 + 41 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$4 + 12 >> 2];
   $1 = HEAP32[$4 + 8 >> 2];
   HEAP8[$0 + 40 | 0] = $1;
   HEAP8[$0 + 41 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  if (HEAP32[$4 + 8 >> 2] > (HEAPU8[$0 + 44 | 0] | HEAPU8[$0 + 45 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$4 + 12 >> 2];
   $1 = HEAP32[$4 + 8 >> 2];
   HEAP8[$0 + 44 | 0] = $1;
   HEAP8[$0 + 45 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  if (HEAP32[$4 + 4 >> 2] < (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$4 + 12 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   HEAP8[$0 + 42 | 0] = $1;
   HEAP8[$0 + 43 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  if (HEAP32[$4 + 4 >> 2] > (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16) {
   $0 = HEAP32[$4 + 12 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   HEAP8[$0 + 46 | 0] = $1;
   HEAP8[$0 + 47 | 0] = $1 >>> 8;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  FUNCTION_TABLE[HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24)](HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2] & (1 << HEAPU8[HEAP32[$4 + 12 >> 2] + 16 | 0]) - 1);
 }
 __stack_pointer = $4 + 16 | 0;
}

function tflite__MicroInterpreter__Invoke_28_29($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 40 >> 2] = $0;
 $0 = HEAP32[$1 + 40 >> 2];
 label$1: {
  if (HEAP32[$0 + 112 >> 2]) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 12 >> 2], 147108, 0);
   HEAP32[$1 + 44 >> 2] = 1;
   break label$1;
  }
  if (!(HEAP8[$0 + 108 | 0] & 1)) {
   HEAP32[$1 + 36 >> 2] = tflite__MicroInterpreter__AllocateTensors_28_29($0);
   if (HEAP32[$1 + 36 >> 2]) {
    HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 36 >> 2];
    break label$1;
   }
  }
  HEAP32[$1 + 32 >> 2] = 0;
  while (1) {
   if (HEAPU32[$1 + 32 >> 2] < flatbuffers__Vector_flatbuffers__Offset_tflite__Operator____size_28_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$0 + 116 >> 2])) >>> 0) {
    HEAP32[$1 + 28 >> 2] = HEAP32[$0 >> 2] + Math_imul(HEAP32[$1 + 32 >> 2], 28);
    HEAP32[$1 + 24 >> 2] = HEAP32[(HEAP32[$0 >> 2] + Math_imul(HEAP32[$1 + 32 >> 2], 28) | 0) + 24 >> 2];
    if (HEAP32[HEAP32[$1 + 24 >> 2] + 12 >> 2]) {
     HEAP32[$1 + 20 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$1 + 24 >> 2] + 12 >> 2]]($0 + 16 | 0, HEAP32[$1 + 28 >> 2]);
     $2 = HEAP32[$0 + 104 >> 2];
     FUNCTION_TABLE[HEAP32[HEAP32[$2 >> 2] + 8 >> 2]]($2);
     if (HEAP32[$1 + 20 >> 2] == 1) {
      $0 = HEAP32[$0 + 12 >> 2];
      $2 = tflite___28anonymous_20namespace_29__OpNameFromRegistration_28TfLiteRegistration_20const__29(HEAP32[$1 + 24 >> 2]);
      $3 = HEAP32[$1 + 32 >> 2];
      HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 20 >> 2];
      HEAP32[$1 + 4 >> 2] = $3;
      HEAP32[$1 >> 2] = $2;
      tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 134727, $1);
      HEAP32[$1 + 44 >> 2] = 1;
      break label$1;
     }
     if (HEAP32[$1 + 20 >> 2]) {
      HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 20 >> 2];
      break label$1;
     }
    }
    HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 32 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$1 + 44 >> 2] = 0;
 }
 __stack_pointer = $1 + 48 | 0;
 return HEAP32[$1 + 44 >> 2];
}

function jsfBankListFiles($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 80 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 76 >> 2] = $0;
 HEAP32[$6 + 72 >> 2] = $1;
 HEAP32[$6 + 68 >> 2] = $2;
 HEAP32[$6 + 64 >> 2] = $3;
 HEAP32[$6 + 60 >> 2] = $4;
 HEAP32[$6 + 56 >> 2] = $5;
 HEAP32[$6 + 48 >> 2] = 0;
 HEAP32[$6 + 52 >> 2] = 0;
 HEAP32[$6 + 40 >> 2] = 0;
 HEAP32[$6 + 44 >> 2] = 0;
 HEAP32[$6 + 32 >> 2] = 0;
 HEAP32[$6 + 36 >> 2] = 0;
 HEAP32[$6 + 24 >> 2] = 0;
 HEAP32[$6 + 28 >> 2] = 0;
 label$1: {
  label$2: {
   if (!(!HEAP32[91095] | HEAP32[$6 + 72 >> 2] != 134217728)) {
    HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 72 >> 2];
    HEAP32[$6 + 16 >> 2] = HEAP32[91095];
    HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 16 >> 2] + HEAP32[91096];
    while (1) {
     if (HEAPU32[$6 + 16 >> 2] < HEAPU32[$6 + 12 >> 2]) {
      jshFlashRead($6 + 24 | 0, HEAP32[$6 + 16 >> 2], 4);
      HEAP32[$6 + 16 >> 2] = HEAP32[$6 + 16 >> 2] + 32;
      HEAP32[$6 + 8 >> 2] = HEAP32[$6 + 20 >> 2] + HEAP32[$6 + 24 >> 2];
      label$6: {
       if (!(jsfGetFileHeader(HEAP32[$6 + 8 >> 2], $6 + 24 | 0, 1) & 1)) {
        break label$6;
       }
       if (!(jsfIsRealFile($6 + 24 | 0) & 1)) {
        break label$6;
       }
       jsfBankListFilesHandleFile(HEAP32[$6 + 76 >> 2], HEAP32[$6 + 8 >> 2], $6 + 24 | 0, HEAP32[$6 + 68 >> 2], HEAP32[$6 + 64 >> 2], HEAP32[$6 + 60 >> 2], HEAP32[$6 + 56 >> 2]);
      }
      continue;
     }
     break;
    }
    HEAP32[$6 + 72 >> 2] = HEAP32[91095] - 32;
    HEAP32[$6 + 28 >> 2] = 0;
    HEAP32[$6 + 24 >> 2] = HEAP32[91096];
    break label$2;
   }
   if (!(jsfGetFileHeader(HEAP32[$6 + 72 >> 2], $6 + 24 | 0, 1) & 1)) {
    break label$1;
   }
  }
  while (1) {
   if (jsfIsRealFile($6 + 24 | 0) & 1) {
    jsfBankListFilesHandleFile(HEAP32[$6 + 76 >> 2], HEAP32[$6 + 72 >> 2], $6 + 24 | 0, HEAP32[$6 + 68 >> 2], HEAP32[$6 + 64 >> 2], HEAP32[$6 + 60 >> 2], HEAP32[$6 + 56 >> 2]);
   }
   if (jsfGetNextFileHeader($6 + 72 | 0, $6 + 24 | 0, 1) & 1) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $6 + 80 | 0;
}

function jswrap_math_mod($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 HEAPF64[$2 + 64 >> 3] = $0;
 HEAPF64[$2 + 56 >> 3] = $1;
 HEAPF64[$2 + 32 >> 3] = HEAPF64[$2 + 64 >> 3];
 $3 = __DOUBLE_BITS_6(HEAPF64[$2 + 64 >> 3]);
 $5 = $3;
 $4 = i64toi32_i32$HIGH_BITS;
 $3 = $4 & 2147483647;
 label$1: {
  label$2: {
   label$3: {
    if (($3 | 0) == 2146435072 | $3 >>> 0 > 2146435072) {
     break label$3;
    }
    $4 = __DOUBLE_BITS_6(HEAPF64[$2 + 56 >> 3]);
    $5 = $4;
    $3 = i64toi32_i32$HIGH_BITS;
    $4 = $3 & 2147483647;
    $3 = $5;
    if (($4 | 0) == 2146435072 & ($3 | 0) != 0 | $4 >>> 0 > 2146435072) {
     break label$3;
    }
    if (HEAPF64[$2 + 56 >> 3] != 0) {
     break label$2;
    }
   }
   HEAPF64[$2 + 72 >> 3] = nan;
   break label$1;
  }
  if (HEAPF64[$2 + 56 >> 3] == infinity) {
   HEAPF64[$2 + 72 >> 3] = HEAPF64[$2 + 64 >> 3];
   break label$1;
  }
  if (HEAPF64[$2 + 32 >> 3] < 0) {
   HEAPF64[$2 + 64 >> 3] = -HEAPF64[$2 + 64 >> 3];
  }
  if (HEAPF64[$2 + 56 >> 3] < 0) {
   HEAPF64[$2 + 56 >> 3] = -HEAPF64[$2 + 56 >> 3];
  }
  label$8: {
   if (!(!(HEAPF64[$2 + 64 >> 3] <= 17976931348623157e292) | (!(HEAPF64[$2 + 56 >> 3] <= 17976931348623157e292) | HEAPF64[$2 + 56 >> 3] == 0))) {
    while (1) {
     if (HEAPF64[$2 + 64 >> 3] >= HEAPF64[$2 + 56 >> 3]) {
      HEAPF64[$2 + 48 >> 3] = HEAPF64[$2 + 64 >> 3] * .5;
      HEAPF64[$2 + 40 >> 3] = HEAPF64[$2 + 56 >> 3];
      while (1) {
       if (HEAPF64[$2 + 48 >> 3] >= HEAPF64[$2 + 40 >> 3]) {
        $0 = HEAPF64[$2 + 40 >> 3];
        HEAPF64[$2 + 40 >> 3] = $0 + $0;
        continue;
       }
       break;
      }
      HEAPF64[$2 + 64 >> 3] = HEAPF64[$2 + 64 >> 3] - HEAPF64[$2 + 40 >> 3];
      continue;
     }
     break;
    }
    break label$8;
   }
   HEAPF64[$2 + 64 >> 3] = 0;
  }
  if (HEAPF64[$2 + 32 >> 3] < 0) {
   $0 = -HEAPF64[$2 + 64 >> 3];
  } else {
   $0 = HEAPF64[$2 + 64 >> 3];
  }
  HEAPF64[$2 + 72 >> 3] = $0;
 }
 __stack_pointer = $2 + 80 | 0;
 return HEAPF64[$2 + 72 >> 3];
}

function tflite__internal__InitializeTfLiteEvalTensorFromFlatbuffer_28tflite__SimpleMemoryAllocator__2c_20tflite__Tensor_20const__2c_20flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer___20const__2c_20tflite__ErrorReporter__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP32[$5 + 36 >> 2] = $1;
 HEAP32[$5 + 32 >> 2] = $2;
 HEAP32[$5 + 28 >> 2] = $3;
 HEAP32[$5 + 24 >> 2] = $4;
 HEAP32[$5 + 8 >> 2] = 0;
 HEAP32[$5 + 12 >> 2] = 0;
 HEAP32[$5 + 16 >> 2] = 0;
 $2 = HEAP32[$5 + 12 >> 2];
 $0 = HEAP32[$5 + 8 >> 2];
 $1 = $0;
 $0 = HEAP32[$5 + 24 >> 2];
 HEAP32[$0 >> 2] = $1;
 HEAP32[$0 + 4 >> 2] = $2;
 HEAP32[$0 + 8 >> 2] = HEAP32[$5 + 16 >> 2];
 HEAP32[$5 + 4 >> 2] = tflite__ConvertTensorType_28tflite__TensorType_2c_20TfLiteType__2c_20tflite__ErrorReporter__29(tflite__Tensor__type_28_29_20const(HEAP32[$5 + 36 >> 2]), HEAP32[$5 + 24 >> 2] + 8 | 0, HEAP32[$5 + 28 >> 2]);
 label$1: {
  if (HEAP32[$5 + 4 >> 2]) {
   HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 4 >> 2];
   break label$1;
  }
  $0 = tflite__internal__GetFlatbufferTensorBuffer_28tflite__Tensor_20const__2c_20flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer___20const__29(HEAP32[$5 + 36 >> 2], HEAP32[$5 + 32 >> 2]);
  HEAP32[HEAP32[$5 + 24 >> 2] >> 2] = $0;
  label$3: {
   if (!tflite__Tensor__shape_28_29_20const(HEAP32[$5 + 36 >> 2])) {
    HEAP32[HEAP32[$5 + 24 >> 2] + 4 >> 2] = 189760;
    break label$3;
   }
   HEAP32[$5 >> 2] = TfLiteStatus_20tflite__internal__FlatBufferVectorToTfLiteTypeArray_int_2c_20TfLiteIntArray__28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__2c_20flatbuffers__Vector_int__20const__2c_20TfLiteIntArray___29(HEAP32[$5 + 40 >> 2], HEAP32[$5 + 28 >> 2], tflite__Tensor__shape_28_29_20const(HEAP32[$5 + 36 >> 2]), HEAP32[$5 + 24 >> 2] + 4 | 0);
   if (HEAP32[$5 >> 2]) {
    HEAP32[$5 + 44 >> 2] = HEAP32[$5 >> 2];
    break label$1;
   }
  }
  HEAP32[$5 + 44 >> 2] = 0;
 }
 __stack_pointer = $5 + 48 | 0;
 return HEAP32[$5 + 44 >> 2];
}

function lcdMemLCD_scrollX($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 60 >> 2] = $0;
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP32[$4 + 48 >> 2] = $3;
 HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 56 >> 2] + 2;
 HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 52 >> 2] + 2;
 label$1: {
  if (!HEAP32[$4 + 48 >> 2]) {
   __memcpy(HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2], 68);
   break label$1;
  }
  label$3: {
   if (HEAP32[$4 + 48 >> 2] < 0) {
    HEAP32[$4 + 36 >> 2] = Math_imul(HEAP32[$4 + 48 >> 2], -3);
    HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 36 >> 2] >> 5;
    HEAP32[$4 + 36 >> 2] = HEAP32[$4 + 36 >> 2] & 31;
    HEAP32[$4 + 28 >> 2] = 528 - HEAP32[$4 + 36 >> 2] >> 5;
    HEAP32[$4 + 24 >> 2] = 0;
    while (1) {
     if (HEAP32[$4 + 24 >> 2] <= HEAP32[$4 + 28 >> 2]) {
      HEAP32[HEAP32[$4 + 44 >> 2] + (HEAP32[$4 + 24 >> 2] << 2) >> 2] = HEAP32[HEAP32[$4 + 40 >> 2] + ((HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 32 >> 2] | 0) + 1 << 2) >> 2] << 32 - HEAP32[$4 + 36 >> 2] | HEAP32[HEAP32[$4 + 40 >> 2] + (HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 32 >> 2] << 2) >> 2] >>> HEAP32[$4 + 36 >> 2];
      HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] + 1;
      continue;
     }
     break;
    }
    break label$3;
   }
   HEAP32[$4 + 20 >> 2] = Math_imul(HEAP32[$4 + 48 >> 2], 3);
   HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 20 >> 2] >> 5;
   HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] & 31;
   HEAP32[$4 + 12 >> 2] = 543 - HEAP32[$4 + 20 >> 2] >> 5;
   HEAP32[$4 + 8 >> 2] = 0;
   while (1) {
    if (HEAP32[$4 + 8 >> 2] <= HEAP32[$4 + 12 >> 2]) {
     HEAP32[HEAP32[$4 + 44 >> 2] + (HEAP32[$4 + 8 >> 2] << 2) >> 2] = HEAP32[HEAP32[$4 + 40 >> 2] + (HEAP32[$4 + 8 >> 2] - HEAP32[$4 + 16 >> 2] << 2) >> 2] << HEAP32[$4 + 20 >> 2] | HEAP32[HEAP32[$4 + 40 >> 2] + (HEAP32[$4 + 8 >> 2] - (HEAP32[$4 + 16 >> 2] + 1 | 0) << 2) >> 2] >>> 32 - HEAP32[$4 + 20 >> 2];
     HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] + 1;
     continue;
    }
    break;
   }
  }
 }
 __stack_pointer = $4 - -64 | 0;
}

function jswrap_interface_edit($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = 0;
 label$1: {
  if (jsvIsString(HEAP32[$1 + 28 >> 2]) & 1) {
   HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 28 >> 2]);
   HEAP32[$1 + 24 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromVar(HEAP32[91086], HEAP32[$1 + 28 >> 2], 0));
   break label$1;
  }
  HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 28 >> 2];
  HEAP32[$1 + 28 >> 2] = jsvGetPathTo(HEAP32[91086], HEAP32[$1 + 24 >> 2], 4, 0);
 }
 label$3: {
  if (jsvIsString(HEAP32[$1 + 28 >> 2]) & 1) {
   if (jsvIsFunction(HEAP32[$1 + 24 >> 2]) & 1) {
    HEAP32[$1 + 20 >> 2] = jsvFindChildFromString(HEAP32[$1 + 24 >> 2], 128047);
    HEAP32[$1 + 16 >> 2] = jsvGetIndexOf(HEAP32[91086], HEAP32[$1 + 24 >> 2], 1);
    $2 = HEAP32[$1 + 20 >> 2] ? $2 : HEAP32[$1 + 16 >> 2] != 0;
    HEAP8[$1 + 15 | 0] = $2;
    jsvUnLock2(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
    HEAP32[$1 + 8 >> 2] = jsvNewFromEmptyString_10();
    if (HEAP32[$1 + 8 >> 2]) {
     HEAP32[$1 + 4 >> 2] = jsvAsString(HEAP32[$1 + 24 >> 2]);
     label$8: {
      if (HEAP8[$1 + 15 | 0] & 1) {
       jsvAppendString(HEAP32[$1 + 8 >> 2], 146102);
       jsvAppendStringVarComplete(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 28 >> 2]);
       jsvAppendStringVar(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2], 9, 2147483647);
       break label$8;
      }
      jsvAppendStringVarComplete(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 28 >> 2]);
      jsvAppendString(HEAP32[$1 + 8 >> 2], 145218);
      jsvAppendStringVarComplete(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2]);
      jsvAppendString(HEAP32[$1 + 8 >> 2], 139014);
     }
     jsvUnLock(HEAP32[$1 + 4 >> 2]);
     jsiReplaceInputLine(HEAP32[$1 + 8 >> 2]);
     jsvUnLock(HEAP32[$1 + 8 >> 2]);
    }
    break label$3;
   }
   jsExceptionHere(1, 128188, 0);
   break label$3;
  }
  jsExceptionHere(1, 145121, 0);
 }
 jsvUnLock2(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 28 >> 2]);
 __stack_pointer = $1 + 32 | 0;
}

function atan($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 wasm2js_scratch_store_f64(+$0);
 $4 = wasm2js_scratch_load_i32(1) | 0;
 wasm2js_scratch_load_i32(0) | 0;
 $1 = $4 & 2147483647;
 if ($1 >>> 0 >= 1141899264) {
  wasm2js_scratch_store_f64(1.5707963267948966);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  $4 = wasm2js_scratch_load_i32(0) | 0;
  $7 = $4;
  $2 = $1 & 2147483647;
  $8 = $2;
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  $4 = $2 & -2147483648;
  $1 = $4;
  $2 = $7;
  wasm2js_scratch_store_i32(0, $9 | $2);
  $4 = $8;
  $1 = $4 | $1;
  wasm2js_scratch_store_i32(1, $1 | 0);
  $5 = +wasm2js_scratch_load_f64();
  $1 = __DOUBLE_BITS_12($0);
  $4 = $1;
  $2 = i64toi32_i32$HIGH_BITS;
  $1 = $2 & 2147483647;
  $2 = $4;
  return ($1 | 0) == 2146435072 & ($2 | 0) != 0 | $1 >>> 0 > 2146435072 ? $0 : $5;
 }
 label$2: {
  label$3: {
   if ($1 >>> 0 <= 1071382527) {
    $2 = -1;
    if ($1 >>> 0 >= 1044381696) {
     break label$3;
    }
    break label$2;
   }
   $0 = fabs($0);
   if ($1 >>> 0 <= 1072889855) {
    if ($1 >>> 0 <= 1072037887) {
     $0 = ($0 + $0 + -1) / ($0 + 2);
     $2 = 0;
     break label$3;
    }
    $0 = ($0 + -1) / ($0 + 1);
    $2 = 1;
    break label$3;
   }
   if ($1 >>> 0 <= 1073971199) {
    $0 = ($0 + -1.5) / ($0 * 1.5 + 1);
    $2 = 2;
    break label$3;
   }
   $0 = -1 / $0;
   $2 = 3;
  }
  $6 = $0 * $0;
  $3 = $6 * $6;
  $5 = $3 * ($3 * ($3 * ($3 * ($3 * -.036531572744216916 + -.058335701337905735) + -.0769187620504483) + -.11111110405462356) + -.19999999999876483);
  $3 = $6 * ($3 * ($3 * ($3 * ($3 * ($3 * .016285820115365782 + .049768779946159324) + .06661073137387531) + .09090887133436507) + .14285714272503466) + .3333333333333293);
  if ($1 >>> 0 <= 1071382527) {
   return $0 - $0 * ($5 + $3);
  }
  $1 = $2 << 3;
  $0 = HEAPF64[$1 + 190176 >> 3] - ($0 * ($5 + $3) - HEAPF64[$1 + 190208 >> 3] - $0);
  $2 = $4;
  $0 = ($2 | 0) < 0 ? -$0 : $0;
 }
 return $0;
}

function jsvCreateConfigObject($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = jsvNewObject();
 label$1: {
  if (!HEAP32[$2 + 16 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 12 >> 2] < HEAP32[$2 + 20 >> 2]) {
    if (HEAP32[(HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) | 0) + 8 >> 2]) {
     HEAP32[$2 + 8 >> 2] = 0;
     label$6: {
      label$7: {
       switch (HEAPU16[(HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) | 0) + 4 >> 1] - 3 | 0) {
       case 0:
       case 2:
       case 4:
       case 25:
        HEAP32[$2 + 8 >> 2] = jsvLockAgain(HEAP32[HEAP32[(HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) | 0) + 8 >> 2] >> 2]);
        break label$6;

       case 10:
        HEAP32[$2 + 8 >> 2] = jsvNewFromPin(HEAPU8[HEAP32[(HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) | 0) + 8 >> 2]]);
        break label$6;

       case 9:
        HEAP32[$2 + 8 >> 2] = jsvNewFromBool(HEAP8[HEAP32[(HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) | 0) + 8 >> 2]] & 1);
        break label$6;

       case 7:
        HEAP32[$2 + 8 >> 2] = jsvNewFromInteger(HEAP32[HEAP32[(HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) | 0) + 8 >> 2] >> 2]);
        break label$6;

       case 8:
        break label$7;

       default:
        break label$6;
       }
      }
      HEAP32[$2 + 8 >> 2] = jsvNewFromFloat(HEAPF64[HEAP32[(HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) | 0) + 8 >> 2] >> 3]);
     }
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 16 >> 2], HEAP32[HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 12) >> 2], HEAP32[$2 + 8 >> 2]);
    }
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jsserialEventCallback($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 47 | 0] = $0;
 HEAP8[$2 + 46 | 0] = $1;
 HEAP32[$2 + 40 >> 2] = jsserialGetSerialList(0);
 label$1: {
  if (!HEAP32[$2 + 40 >> 2]) {
   break label$1;
  }
  HEAP32[$2 + 36 >> 2] = jsvGetArrayItem(HEAP32[$2 + 40 >> 2], HEAPU8[$2 + 46 | 0]);
  if (!HEAP32[$2 + 36 >> 2]) {
   break label$1;
  }
  HEAP32[$2 + 32 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 36 >> 2], 135840);
  HEAP32[$2 + 28 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 32 >> 2]);
  if (!HEAP32[$2 + 28 >> 2]) {
   break label$1;
  }
  HEAP32[$2 + 16 >> 2] = jshGetSystemTime();
  HEAP32[$2 + 20 >> 2] = i64toi32_i32$HIGH_BITS;
  $5 = HEAP32[$2 + 20 >> 2];
  $3 = HEAP32[$2 + 28 >> 2];
  $1 = HEAP32[$3 + 72 >> 2];
  $0 = HEAP32[$3 + 76 >> 2];
  $3 = HEAP32[$2 + 16 >> 2];
  $0 = $0 + ($1 >>> 0 > $3 >>> 0) | 0;
  HEAP32[$2 + 8 >> 2] = $3 - $1;
  $0 = $5 - $0 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  $3 = HEAP32[$2 + 20 >> 2];
  $0 = HEAP32[$2 + 16 >> 2];
  $1 = $0;
  $0 = HEAP32[$2 + 28 >> 2];
  HEAP32[$0 + 72 >> 2] = $1;
  HEAP32[$0 + 76 >> 2] = $3;
  HEAP8[$2 + 7 | 0] = (HEAPU8[$2 + 47 | 0] ^ -1) & 1;
  $3 = HEAP32[$2 + 8 >> 2];
  $0 = HEAP32[$2 + 12 >> 2];
  $4 = jshGetMillisecondsFromTime($3, $0) * +HEAP32[HEAP32[$2 + 28 >> 2] + 80 >> 2] / 1e3 + .5;
  label$2: {
   if (Math_abs($4) < 2147483648) {
    $0 = ~~$4;
    break label$2;
   }
   $0 = -2147483648;
  }
  HEAP32[$2 >> 2] = $0;
  if (!(HEAPU8[HEAP32[$2 + 28 >> 2] + 88 | 0] | !(HEAP8[$2 + 7 | 0] & 1)) | HEAP32[$2 >> 2] > 12) {
   break label$1;
  }
  if (HEAP8[$2 + 7 | 0] & 1) {
   $0 = HEAP32[$2 + 28 >> 2];
   HEAP32[$0 + 84 >> 2] = HEAP32[$0 + 84 >> 2] | (1 << HEAP32[$2 >> 2]) - 1 << HEAPU8[HEAP32[$2 + 28 >> 2] + 88 | 0];
  }
  $0 = HEAP32[$2 + 28 >> 2];
  HEAP8[$0 + 88 | 0] = HEAP32[$2 >> 2] + HEAPU8[$0 + 88 | 0];
  jsserialCheckForCharacter(HEAP32[$2 + 28 >> 2]);
 }
 __stack_pointer = $2 + 48 | 0;
}

function jswrap_espruino_FFT($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 $3 = $4;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP8[$3 + 39 | 0] = $2;
 label$1: {
  label$2: {
   if (jsvIsIterable(HEAP32[$3 + 44 >> 2]) & 1) {
    if (jsvIsUndefined(HEAP32[$3 + 40 >> 2]) & 1) {
     break label$2;
    }
    if (jsvIsIterable(HEAP32[$3 + 40 >> 2]) & 1) {
     break label$2;
    }
   }
   $0 = HEAP32[$3 + 44 >> 2];
   HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 40 >> 2];
   HEAP32[$3 >> 2] = $0;
   jsExceptionHere(1, 119418, $3);
   break label$1;
  }
  HEAP32[$3 + 32 >> 2] = jsvGetLength(HEAP32[$3 + 44 >> 2]);
  HEAP32[$3 + 28 >> 2] = 1;
  HEAP32[$3 + 24 >> 2] = 0;
  while (1) {
   if (HEAPU32[$3 + 28 >> 2] < HEAPU32[$3 + 32 >> 2]) {
    HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] << 1;
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] + 1;
    continue;
   }
   break;
  }
  if (jsuGetFreeStack() >>> 0 < (HEAP32[$3 + 28 >> 2] << 4) + 256 >>> 0) {
   jsExceptionHere(1, 136718, 0);
   break label$1;
  }
  $4 = $4 - (HEAP32[$3 + 28 >> 2] << 4) | 0;
  __stack_pointer = $4;
  HEAP32[$3 + 20 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 28 >> 2] << 3);
  _jswrap_espruino_FFT_getData(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 44 >> 2], HEAP32[$3 + 28 >> 2]);
  _jswrap_espruino_FFT_getData(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 40 >> 2], HEAP32[$3 + 28 >> 2]);
  FFT((HEAP8[$3 + 39 | 0] & 1 ? -1 : 1) << 16 >> 16, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
  HEAP8[$3 + 15 | 0] = jsvIsIterable(HEAP32[$3 + 40 >> 2]) & 1;
  _jswrap_espruino_FFT_setData(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 20 >> 2], HEAP8[$3 + 15 | 0] & 1 ? 0 : HEAP32[$3 + 16 >> 2], HEAP32[$3 + 28 >> 2]);
  if (!(HEAP8[$3 + 15 | 0] & 1)) {
   break label$1;
  }
  _jswrap_espruino_FFT_setData(HEAP32[$3 + 40 >> 2], HEAP32[$3 + 16 >> 2], 0, HEAP32[$3 + 28 >> 2]);
 }
 __stack_pointer = $3 + 48 | 0;
}

function jsvGarbageCollectMarkUsed($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 $2 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 65279;
 HEAP8[$0 + 12 | 0] = $2;
 HEAP8[$0 + 13 | 0] = $2 >>> 8;
 if (jsvHasStringExt(HEAP32[$1 + 8 >> 2]) & 1) {
  HEAP16[$1 + 6 >> 1] = jsvGetLastChild(HEAP32[$1 + 8 >> 2]);
  while (1) {
   if (HEAPU16[$1 + 6 >> 1]) {
    HEAP32[$1 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 6 >> 1]);
    $0 = HEAP32[$1 >> 2];
    $2 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 65279;
    HEAP8[$0 + 12 | 0] = $2;
    HEAP8[$0 + 13 | 0] = $2 >>> 8;
    HEAP16[$1 + 6 >> 1] = jsvGetLastChild(HEAP32[$1 >> 2]);
    continue;
   }
   break;
  }
 }
 label$4: {
  label$5: {
   if (jsvHasSingleChild(HEAP32[$1 + 8 >> 2]) & 1) {
    if (jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535) {
     HEAP32[$1 >> 2] = jsvGetAddressOf(jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535);
     $0 = HEAP32[$1 >> 2];
     if ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 256) {
      if (!(jsvGarbageCollectMarkUsed(HEAP32[$1 >> 2]) & 1)) {
       HEAP8[$1 + 15 | 0] = 0;
       break label$4;
      }
     }
    }
    break label$5;
   }
   if (jsvHasChildren(HEAP32[$1 + 8 >> 2]) & 1) {
    if (jsuGetFreeStack() >>> 0 < 256) {
     HEAP8[$1 + 15 | 0] = 0;
     break label$4;
    }
    HEAP16[$1 + 6 >> 1] = jsvGetFirstChild(HEAP32[$1 + 8 >> 2]);
    while (1) {
     if (HEAPU16[$1 + 6 >> 1]) {
      HEAP32[$1 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 6 >> 1]);
      $0 = HEAP32[$1 >> 2];
      if ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 256) {
       if (!(jsvGarbageCollectMarkUsed(HEAP32[$1 >> 2]) & 1)) {
        HEAP8[$1 + 15 | 0] = 0;
        break label$4;
       }
      }
      HEAP16[$1 + 6 >> 1] = jsvGetNextSibling(HEAP32[$1 >> 2]);
      continue;
     }
     break;
    }
   }
  }
  HEAP8[$1 + 15 | 0] = 1;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}

function tflite__QuantizeMultiplier_28double_2c_20int__2c_20int__29($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAPF64[$3 + 24 >> 3] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1: {
  if (HEAPF64[$3 + 24 >> 3] == 0) {
   HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 0;
   HEAP32[HEAP32[$3 + 16 >> 2] >> 2] = 0;
   break label$1;
  }
  HEAPF64[$3 + 8 >> 3] = frexp(HEAPF64[$3 + 24 >> 3], HEAP32[$3 + 16 >> 2]);
  $0 = double_20tflite__TfLiteRound_double__28double_29(HEAPF64[$3 + 8 >> 3] * 2147483648);
  label$3: {
   if (Math_abs($0) < 0x8000000000000000) {
    $2 = Math_abs($0) >= 1 ? ~~($0 > 0 ? Math_min(Math_floor($0 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($0 - +(~~$0 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
    $5 = ~~$0 >>> 0;
    break label$3;
   }
   $2 = -2147483648;
  }
  $4 = $3;
  HEAP32[$4 >> 2] = $5;
  HEAP32[$4 + 4 >> 2] = $2;
  $2 = HEAP32[$3 >> 2];
  $5 = $2;
  $4 = HEAP32[$3 + 4 >> 2];
  if ($5 >>> 0 > 2147483648 & ($4 | 0) >= 0 | ($4 | 0) > 0) {
   abort();
   abort();
  }
  $5 = HEAP32[$3 >> 2];
  $1 = $5;
  $4 = HEAP32[$3 + 4 >> 2];
  if (!$4 & ($1 | 0) == -2147483648) {
   $1 = HEAP32[$3 >> 2];
   $4 = HEAP32[$3 + 4 >> 2];
   $1 = __wasm_i64_sdiv($1, $4, 2, 0);
   HEAP32[$3 >> 2] = $1;
   $4 = i64toi32_i32$HIGH_BITS;
   HEAP32[$3 + 4 >> 2] = $4;
   $1 = HEAP32[$3 + 16 >> 2];
   HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + 1;
  }
  $4 = HEAP32[$3 >> 2];
  $6 = $4;
  $1 = HEAP32[$3 + 4 >> 2];
  $2 = $1;
  $4 = std____2__numeric_limits_int___max_28_29();
  $1 = $4 >> 31;
  $5 = $4;
  $4 = $1;
  $1 = $2;
  $2 = $6;
  if (($4 | 0) <= ($1 | 0) & $2 >>> 0 > $5 >>> 0 | ($1 | 0) > ($4 | 0)) {
   abort();
   abort();
  }
  if (HEAP32[HEAP32[$3 + 16 >> 2] >> 2] < -31) {
   HEAP32[HEAP32[$3 + 16 >> 2] >> 2] = 0;
   HEAP32[$3 >> 2] = 0;
   HEAP32[$3 + 4 >> 2] = 0;
  }
  $2 = HEAP32[$3 >> 2];
  HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = $2;
 }
 __stack_pointer = $3 + 32 | 0;
}

function jswrap_process_memory($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = -1;
 label$1: {
  if (!(jsvIsUndefined(HEAP32[$1 + 44 >> 2]) & 1)) {
   if (!(jsvGetBool(HEAP32[$1 + 44 >> 2]) & 1)) {
    break label$1;
   }
  }
  HEAP32[$1 + 32 >> 2] = jshGetSystemTime();
  HEAP32[$1 + 36 >> 2] = i64toi32_i32$HIGH_BITS;
  HEAP32[$1 + 20 >> 2] = jsvGarbageCollect();
  HEAP32[$1 + 24 >> 2] = jshGetSystemTime();
  HEAP32[$1 + 28 >> 2] = i64toi32_i32$HIGH_BITS;
 }
 HEAP32[$1 + 16 >> 2] = jsvNewObject();
 if (HEAP32[$1 + 16 >> 2]) {
  HEAP32[$1 + 12 >> 2] = 0;
  HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 116128);
  if (HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 12 >> 2] = jsvCountJsVarsUsed(HEAP32[$1 + 8 >> 2]);
   jsvUnLock(HEAP32[$1 + 8 >> 2]);
  }
  HEAP32[$1 + 4 >> 2] = jsvGetMemoryUsage() - HEAP32[$1 + 12 >> 2];
  HEAP32[$1 >> 2] = jsvGetMemoryTotal();
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 132716, jsvNewFromInteger(HEAP32[$1 >> 2] - HEAP32[$1 + 4 >> 2] | 0));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 132666, jsvNewFromInteger(HEAP32[$1 + 4 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 129052, jsvNewFromInteger(HEAP32[$1 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 116128, jsvNewFromInteger(HEAP32[$1 + 12 >> 2]));
  if (HEAP32[$1 + 20 >> 2] >= 0) {
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 135682, jsvNewFromInteger(HEAP32[$1 + 20 >> 2]));
   $2 = HEAP32[$1 + 24 >> 2];
   $3 = HEAP32[$1 + 32 >> 2];
   $0 = HEAP32[$1 + 36 >> 2] + ($2 >>> 0 < $3 >>> 0) | 0;
   $0 = HEAP32[$1 + 28 >> 2] - $0 | 0;
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 132370, jsvNewFromFloat(jshGetMillisecondsFromTime($2 - $3 | 0, $0)));
  }
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 16 >> 2], 131515, jsvNewFromInteger(14));
 }
 __stack_pointer = $1 + 48 | 0;
 return HEAP32[$1 + 16 >> 2];
}

function _jswrap_array_sort($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 160 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 156 >> 2] = $0;
 HEAP32[$3 + 152 >> 2] = $1;
 HEAP32[$3 + 148 >> 2] = $2;
 label$1: {
  if (HEAP32[$3 + 152 >> 2] < 2) {
   break label$1;
  }
  jsvIteratorClone($3 + 88 | 0, HEAP32[$3 + 156 >> 2]);
  HEAP8[$3 + 87 | 0] = 1;
  HEAP32[$3 + 80 >> 2] = jsvIteratorGetValue($3 + 88 | 0);
  HEAP32[$3 + 76 >> 2] = 0;
  HEAP32[$3 + 72 >> 2] = 0;
  jsvIteratorClone($3 + 8 | 0, HEAP32[$3 + 156 >> 2]);
  jsvIteratorNext($3 + 8 | 0);
  while (1) {
   $0 = HEAP32[$3 + 152 >> 2] - 1 | 0;
   HEAP32[$3 + 152 >> 2] = $0;
   $1 = 0;
   if ($0) {
    $1 = jspIsInterrupted() ^ -1;
   }
   if ($1 & 1) {
    HEAP32[$3 + 4 >> 2] = jsvIteratorGetValue($3 + 8 | 0);
    HEAP32[$3 >> 2] = _jswrap_array_sort_compare(HEAP32[$3 + 4 >> 2], HEAP32[$3 + 80 >> 2], HEAP32[$3 + 148 >> 2]);
    label$5: {
     if (HEAP32[$3 >> 2] <= 0) {
      if (HEAP32[$3 >> 2] < 0) {
       HEAP8[$3 + 87 | 0] = 0;
      }
      HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 76 >> 2] + 1;
      jsvIteratorSetValue($3 + 88 | 0, HEAP32[$3 + 4 >> 2]);
      jsvIteratorNext($3 + 88 | 0);
      jsvUnLock(jsvIteratorSetValue($3 + 8 | 0, jsvIteratorGetValue($3 + 88 | 0)));
      jsvIteratorSetValue($3 + 88 | 0, HEAP32[$3 + 80 >> 2]);
      break label$5;
     }
     HEAP32[$3 + 72 >> 2] = HEAP32[$3 + 72 >> 2] + 1;
    }
    jsvUnLock(HEAP32[$3 + 4 >> 2]);
    jsvIteratorNext($3 + 8 | 0);
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 8 | 0);
  jsvUnLock(HEAP32[$3 + 80 >> 2]);
  if (jspIsInterrupted() & 1) {
   jsvIteratorFree($3 + 88 | 0);
   break label$1;
  }
  jsvIteratorNext($3 + 88 | 0);
  _jswrap_array_sort($3 + 88 | 0, HEAP32[$3 + 72 >> 2], HEAP32[$3 + 148 >> 2]);
  jsvIteratorFree($3 + 88 | 0);
  if (HEAP8[$3 + 87 | 0] & 1) {
   break label$1;
  }
  _jswrap_array_sort(HEAP32[$3 + 156 >> 2], HEAP32[$3 + 76 >> 2], HEAP32[$3 + 148 >> 2]);
 }
 __stack_pointer = $3 + 160 | 0;
}

function tflite__MicroInterpreter__output_28unsigned_20long_29($0, $1) {
 var $2 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0, wasm2js_i32$3 = 0, wasm2js_i32$4 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 $0 = HEAP32[$2 + 24 >> 2];
 HEAP32[$2 + 16 >> 2] = tflite__MicroInterpreter__outputs_size_28_29_20const($0);
 label$1: {
  if (HEAPU32[$2 + 20 >> 2] >= HEAPU32[$2 + 16 >> 2]) {
   $0 = HEAP32[$0 + 12 >> 2];
   $1 = HEAP32[$2 + 20 >> 2];
   HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 16 >> 2];
   HEAP32[$2 >> 2] = $1;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 143197, $2);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$2 + 20 >> 2]) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 12 >> 2], 145509, 0);
   $1 = HEAP32[$0 + 104 >> 2];
   HEAP32[$2 + 28 >> 2] = (wasm2js_i32$1 = $1, wasm2js_i32$2 = HEAP32[$0 + 4 >> 2], 
   wasm2js_i32$3 = HEAP32[$0 + 120 >> 2], wasm2js_i32$4 = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__MicroInterpreter__outputs_28_29_20const($0), HEAP32[$2 + 20 >> 2]), 
   wasm2js_i32$0 = HEAP32[HEAP32[$1 >> 2] >> 2], FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$1 | 0, wasm2js_i32$2 | 0, wasm2js_i32$3 | 0, wasm2js_i32$4 | 0) | 0);
   break label$1;
  }
  if (!HEAP32[$0 + 148 >> 2]) {
   $1 = HEAP32[$0 + 104 >> 2];
   HEAP32[$0 + 148 >> 2] = (wasm2js_i32$4 = $1, wasm2js_i32$3 = HEAP32[$0 + 4 >> 2], 
   wasm2js_i32$2 = HEAP32[$0 + 120 >> 2], wasm2js_i32$1 = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__MicroInterpreter__outputs_28_29_20const($0), HEAP32[$2 + 20 >> 2]), 
   wasm2js_i32$0 = HEAP32[HEAP32[$1 >> 2] >> 2], FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$4 | 0, wasm2js_i32$3 | 0, wasm2js_i32$2 | 0, wasm2js_i32$1 | 0) | 0);
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$0 + 148 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function tflite__MicroInterpreter__input_28unsigned_20long_29($0, $1) {
 var $2 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0, wasm2js_i32$3 = 0, wasm2js_i32$4 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 $0 = HEAP32[$2 + 24 >> 2];
 HEAP32[$2 + 16 >> 2] = tflite__MicroInterpreter__inputs_size_28_29_20const($0);
 label$1: {
  if (HEAPU32[$2 + 20 >> 2] >= HEAPU32[$2 + 16 >> 2]) {
   $0 = HEAP32[$0 + 12 >> 2];
   $1 = HEAP32[$2 + 20 >> 2];
   HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 16 >> 2];
   HEAP32[$2 >> 2] = $1;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 143241, $2);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$2 + 20 >> 2]) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 12 >> 2], 145630, 0);
   $1 = HEAP32[$0 + 104 >> 2];
   HEAP32[$2 + 28 >> 2] = (wasm2js_i32$1 = $1, wasm2js_i32$2 = HEAP32[$0 + 4 >> 2], 
   wasm2js_i32$3 = HEAP32[$0 + 120 >> 2], wasm2js_i32$4 = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__MicroInterpreter__inputs_28_29_20const($0), HEAP32[$2 + 20 >> 2]), 
   wasm2js_i32$0 = HEAP32[HEAP32[$1 >> 2] >> 2], FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$1 | 0, wasm2js_i32$2 | 0, wasm2js_i32$3 | 0, wasm2js_i32$4 | 0) | 0);
   break label$1;
  }
  if (!HEAP32[$0 + 144 >> 2]) {
   $1 = HEAP32[$0 + 104 >> 2];
   HEAP32[$0 + 144 >> 2] = (wasm2js_i32$4 = $1, wasm2js_i32$3 = HEAP32[$0 + 4 >> 2], 
   wasm2js_i32$2 = HEAP32[$0 + 120 >> 2], wasm2js_i32$1 = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__MicroInterpreter__inputs_28_29_20const($0), HEAP32[$2 + 20 >> 2]), 
   wasm2js_i32$0 = HEAP32[HEAP32[$1 >> 2] >> 2], FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$4 | 0, wasm2js_i32$3 | 0, wasm2js_i32$2 | 0, wasm2js_i32$1 | 0) | 0);
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$0 + 144 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jsvIsStringNumericInt($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 72 >> 2] = $0;
 HEAP8[$2 + 71 | 0] = $1;
 jsvStringIteratorNew($2 + 32 | 0, HEAP32[$2 + 72 >> 2], 0);
 while (1) {
  $0 = 0;
  if (jsvStringIteratorHasChar_1($2 + 32 | 0) & 1) {
   $0 = isWhitespace(jsvStringIteratorGetChar_1($2 + 32 | 0) << 24 >> 24);
  }
  if ($0 & 1) {
   jsvStringIteratorNext($2 + 32 | 0);
   continue;
  }
  break;
 }
 label$4: {
  if ((jsvStringIteratorGetChar_1($2 + 32 | 0) & 255) != 45) {
   if ((jsvStringIteratorGetChar_1($2 + 32 | 0) & 255) != 43) {
    break label$4;
   }
  }
  jsvStringIteratorNext($2 + 32 | 0);
 }
 HEAP32[$2 + 28 >> 2] = 0;
 if ((jsvStringIteratorGetChar_1($2 + 32 | 0) & 255) == 48) {
  jsvStringIteratorNext($2 + 32 | 0);
  HEAP8[$2 + 25 | 0] = 48;
  HEAP8[$2 + 26 | 0] = jsvStringIteratorGetChar_1($2 + 32 | 0);
  HEAP8[$2 + 27 | 0] = 0;
  HEAP32[$2 + 20 >> 2] = $2 + 25;
  HEAP32[$2 + 28 >> 2] = getRadix($2 + 20 | 0);
  if (HEAPU32[$2 + 20 >> 2] > $2 + 26 >>> 0) {
   jsvStringIteratorNext($2 + 32 | 0);
  }
 }
 if (!HEAP32[$2 + 28 >> 2]) {
  HEAP32[$2 + 28 >> 2] = 10;
 }
 HEAP32[$2 + 16 >> 2] = 0;
 label$9: {
  while (1) {
   if (jsvStringIteratorHasChar_1($2 + 32 | 0) & 1) {
    HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] + 1;
    HEAP8[$2 + 15 | 0] = jsvStringIteratorGetCharAndNext($2 + 32 | 0);
    label$12: {
     if (!(!(HEAP8[$2 + 71 | 0] & 1) | HEAP8[$2 + 15 | 0] != 46)) {
      HEAP8[$2 + 71 | 0] = 0;
      break label$12;
     }
     HEAP32[$2 + 8 >> 2] = chtod(HEAP8[$2 + 15 | 0]);
     if (!(HEAP32[$2 + 8 >> 2] < HEAP32[$2 + 28 >> 2] & HEAP32[$2 + 8 >> 2] >= 0)) {
      jsvStringIteratorFree_1($2 + 32 | 0);
      HEAP8[$2 + 79 | 0] = 0;
      break label$9;
     }
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree_1($2 + 32 | 0);
  HEAP8[$2 + 79 | 0] = HEAP32[$2 + 16 >> 2] > 0;
 }
 __stack_pointer = $2 + 80 | 0;
 return HEAP8[$2 + 79 | 0] & 1;
}

function jstStartSignal($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0;
 $9 = __stack_pointer + -64 | 0;
 __stack_pointer = $9;
 HEAP32[$9 + 48 >> 2] = $0;
 HEAP32[$9 + 52 >> 2] = $1;
 HEAP32[$9 + 40 >> 2] = $2;
 HEAP32[$9 + 44 >> 2] = $3;
 HEAP8[$9 + 39 | 0] = $4;
 HEAP8[$9 + 38 | 0] = $5;
 HEAP32[$9 + 32 >> 2] = $6;
 HEAP32[$9 + 28 >> 2] = $7;
 HEAP8[$9 + 27 | 0] = $8;
 label$1: {
  if (!(jshIsPinValid(HEAPU8[$9 + 39 | 0]) & 1)) {
   HEAP8[$9 + 63 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$9 + 40 >> 2];
  HEAP8[$9 + 4 | 0] = $0;
  HEAP8[$9 + 5 | 0] = $0 >>> 8;
  HEAP8[$9 + 6 | 0] = $0 >>> 16;
  HEAP8[$9 + 7 | 0] = $0 >>> 24;
  $2 = HEAP32[$9 + 40 >> 2];
  $0 = $2 + HEAP32[$9 + 48 >> 2] | 0;
  $1 = HEAP32[$9 + 44 >> 2] + HEAP32[$9 + 52 >> 2] | 0;
  HEAP8[$9 | 0] = $0;
  HEAP8[$9 + 1 | 0] = $0 >>> 8;
  HEAP8[$9 + 2 | 0] = $0 >>> 16;
  HEAP8[$9 + 3 | 0] = $0 >>> 24;
  HEAP8[$9 + 24 | 0] = HEAPU8[$9 + 27 | 0];
  label$3: {
   if (!(HEAPU8[$9 + 27 | 0] != 4 & HEAPU8[$9 + 27 | 0] != 6)) {
    HEAP8[$9 + 22 | 0] = HEAPU8[$9 + 39 | 0];
    HEAP8[$9 + 23 | 0] = HEAPU8[$9 + 38 | 0];
    break label$3;
   }
   label$6: {
    if (!(HEAPU8[$9 + 27 | 0] != 5 & HEAPU8[$9 + 27 | 0] != 7)) {
     if (!HEAPU8[(Math_imul(HEAPU8[$9 + 39 | 0], 3) + 180752 | 0) + 2 | 0]) {
      HEAP8[$9 + 63 | 0] = 0;
      break label$1;
     }
     HEAP8[$9 + 22 | 0] = HEAPU8[$9 + 39 | 0];
     break label$6;
    }
    HEAP8[$9 + 63 | 0] = 0;
    break label$1;
   }
  }
  $0 = jsvGetRef(HEAP32[$9 + 32 >> 2]);
  HEAP8[$9 + 12 | 0] = $0;
  HEAP8[$9 + 13 | 0] = $0 >>> 8;
  label$10: {
   if (HEAP32[$9 + 28 >> 2]) {
    $0 = jsvGetRef(HEAP32[$9 + 28 >> 2]);
    HEAP8[$9 + 14 | 0] = $0;
    HEAP8[$9 + 15 | 0] = $0 >>> 8;
    break label$10;
   }
   HEAP8[$9 + 14 | 0] = 0;
   HEAP8[$9 + 15 | 0] = 0;
  }
  jstUtilTimerSetupBuffer($9);
  HEAP8[$9 + 63 | 0] = utilTimerInsertTask($9, 0) & 1;
 }
 __stack_pointer = $9 - -64 | 0;
 return HEAP8[$9 + 63 | 0] & 1;
}

function jspExecuteJSFunctionCode($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer + -64 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 56 >> 2] = $0;
 HEAP32[$6 + 52 >> 2] = $1;
 HEAP32[$6 + 48 >> 2] = $2;
 HEAP32[$6 + 44 >> 2] = $3;
 HEAP32[$6 + 40 >> 2] = $4;
 HEAP32[$6 + 36 >> 2] = $5;
 if (!HEAP32[$6 + 48 >> 2]) {
  HEAP32[$6 + 48 >> 2] = strlen(HEAP32[$6 + 52 >> 2]);
 }
 HEAP32[$6 + 32 >> 2] = jsvNewWithFlags(7);
 label$2: {
  if (!HEAP32[$6 + 32 >> 2]) {
   HEAP32[$6 + 60 >> 2] = 0;
   break label$2;
  }
  if (!(!HEAP32[$6 + 56 >> 2] | !HEAP8[HEAP32[$6 + 56 >> 2]])) {
   HEAP8[$6 + 22 | 0] = 255;
   while (1) {
    if (HEAPU8[HEAP32[$6 + 56 >> 2]]) {
     HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 56 >> 2];
     HEAP32[$6 + 16 >> 2] = 1;
     while (1) {
      $0 = 0;
      $0 = HEAP8[HEAP32[$6 + 12 >> 2]] ? HEAP8[HEAP32[$6 + 12 >> 2]] != 44 : $0;
      if ($0) {
       $1 = HEAPU8[HEAP32[$6 + 12 >> 2]];
       $0 = HEAP32[$6 + 16 >> 2];
       HEAP32[$6 + 16 >> 2] = $0 + 1;
       HEAP8[($6 + 22 | 0) + $0 | 0] = $1;
       HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 12 >> 2] + 1;
       continue;
      }
      break;
     }
     HEAP8[HEAP32[$6 + 16 >> 2] + ($6 + 22 | 0) | 0] = 0;
     HEAP32[$6 + 8 >> 2] = jsvNewNameFromString($6 + 22 | 0);
     jsvAddFunctionParameter(HEAP32[$6 + 32 >> 2], HEAP32[$6 + 8 >> 2], 0);
     if (HEAP8[HEAP32[$6 + 12 >> 2]]) {
      $0 = HEAP32[$6 + 12 >> 2] + 1 | 0;
     } else {
      $0 = HEAP32[$6 + 12 >> 2];
     }
     HEAP32[$6 + 56 >> 2] = $0;
     continue;
    }
    break;
   }
  }
  jsvObjectSetChildAndUnLock(HEAP32[$6 + 32 >> 2], 133204, jsvNewNativeString(HEAP32[$6 + 52 >> 2], HEAP32[$6 + 48 >> 2]));
  HEAP32[$6 + 4 >> 2] = jspExecuteFunction(HEAP32[$6 + 32 >> 2], HEAP32[$6 + 44 >> 2], HEAP32[$6 + 40 >> 2], HEAP32[$6 + 36 >> 2]);
  jsvUnLock(HEAP32[$6 + 32 >> 2]);
  HEAP32[$6 + 60 >> 2] = HEAP32[$6 + 4 >> 2];
 }
 __stack_pointer = $6 - -64 | 0;
 return HEAP32[$6 + 60 >> 2];
}

function _jswrap_graphics_getRect($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 144 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 140 >> 2] = $0;
 HEAP32[$6 + 136 >> 2] = $1;
 HEAP32[$6 + 132 >> 2] = $2;
 HEAP32[$6 + 128 >> 2] = $3;
 HEAP32[$6 + 124 >> 2] = $4;
 HEAP32[$6 + 120 >> 2] = $5;
 HEAP32[HEAP32[$6 + 120 >> 2] >> 2] = 0;
 label$1: {
  if (jsvIsObject(HEAP32[$6 + 140 >> 2]) & 1) {
   HEAP32[$6 + 116 >> 2] = -1;
   HEAP32[$6 + 112 >> 2] = -1;
   HEAP32[$6 >> 2] = 116522;
   HEAP16[$6 + 4 >> 1] = 10;
   HEAP32[$6 + 8 >> 2] = HEAP32[$6 + 136 >> 2];
   HEAP32[$6 + 12 >> 2] = 116397;
   HEAP16[$6 + 16 >> 1] = 10;
   HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 132 >> 2];
   HEAP32[$6 + 24 >> 2] = 139857;
   HEAP16[$6 + 28 >> 1] = 10;
   HEAP32[$6 + 32 >> 2] = HEAP32[$6 + 136 >> 2];
   HEAP32[$6 + 36 >> 2] = 139854;
   HEAP16[$6 + 40 >> 1] = 10;
   HEAP32[$6 + 44 >> 2] = HEAP32[$6 + 132 >> 2];
   HEAP32[$6 + 48 >> 2] = 139550;
   HEAP16[$6 + 52 >> 1] = 10;
   HEAP32[$6 + 56 >> 2] = HEAP32[$6 + 128 >> 2];
   HEAP32[$6 + 60 >> 2] = 139547;
   HEAP16[$6 + 64 >> 1] = 10;
   HEAP32[$6 + 68 >> 2] = HEAP32[$6 + 124 >> 2];
   HEAP32[$6 + 72 >> 2] = 116775;
   HEAP16[$6 + 76 >> 1] = 10;
   HEAP32[$6 + 80 >> 2] = $6 + 116;
   HEAP32[$6 + 84 >> 2] = 129676;
   HEAP16[$6 + 88 >> 1] = 10;
   HEAP32[$6 + 92 >> 2] = $6 + 112;
   HEAP32[$6 + 96 >> 2] = 121469;
   HEAP16[$6 + 100 >> 1] = 10;
   HEAP32[$6 + 104 >> 2] = HEAP32[$6 + 120 >> 2];
   jsvReadConfigObject(HEAP32[$6 + 140 >> 2], $6, 9);
   if (HEAP32[$6 + 116 >> 2] >= 0) {
    HEAP32[HEAP32[$6 + 128 >> 2] >> 2] = HEAP32[HEAP32[$6 + 136 >> 2] >> 2] + HEAP32[$6 + 116 >> 2];
   }
   if (HEAP32[$6 + 112 >> 2] >= 0) {
    HEAP32[HEAP32[$6 + 124 >> 2] >> 2] = HEAP32[HEAP32[$6 + 132 >> 2] >> 2] + HEAP32[$6 + 112 >> 2];
   }
   break label$1;
  }
  $0 = jsvGetInteger(HEAP32[$6 + 140 >> 2]);
  HEAP32[HEAP32[$6 + 136 >> 2] >> 2] = $0;
 }
 __stack_pointer = $6 + 144 | 0;
}

function jswBinarySearch($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 HEAP8[$3 + 31 | 0] = HEAPU8[HEAP32[$3 + 40 >> 2] + 8 | 0];
 HEAP32[$3 + 24 >> 2] = 0;
 HEAP32[$3 + 20 >> 2] = HEAPU8[$3 + 31 | 0] - 1;
 label$1: {
  while (1) {
   if (HEAP32[$3 + 24 >> 2] <= HEAP32[$3 + 20 >> 2]) {
    HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 24 >> 2] + HEAP32[$3 + 20 >> 2] >> 1;
    $0 = HEAP32[$3 + 40 >> 2];
    HEAP32[$3 + 12 >> 2] = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) + (HEAP32[$3 + 16 >> 2] << 3);
    $0 = HEAP32[$3 + 40 >> 2];
    $1 = HEAP32[$3 + 12 >> 2];
    HEAP32[$3 + 8 >> 2] = strcmp(HEAP32[$3 + 32 >> 2], (HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) + (HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8) | 0);
    if (HEAP32[$3 + 8 >> 2]) {
     if (HEAP32[$3 + 8 >> 2] < 0) {
      HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 16 >> 2] - 1;
      continue;
     }
     HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
     continue;
    } else {
     $0 = HEAP32[$3 + 12 >> 2];
     HEAP16[$3 + 6 >> 1] = HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8;
     if ((HEAPU16[$3 + 6 >> 1] & 32256) == 28672) {
      $0 = HEAP32[$3 + 12 >> 2];
      HEAP32[$3 + 44 >> 2] = jsnCallFunction(HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24), HEAPU16[$3 + 6 >> 1], HEAP32[$3 + 36 >> 2], 0, 0);
      break label$1;
     }
     $0 = HEAP32[$3 + 12 >> 2];
     HEAP32[$3 + 44 >> 2] = jsvNewNativeFunction(HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24), HEAPU16[$3 + 6 >> 1]);
     break label$1;
    }
   }
   break;
  }
  HEAP32[$3 + 44 >> 2] = 0;
 }
 __stack_pointer = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}

function jsvIsStringEqualOrStartsWithOffset($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 80 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 72 >> 2] = $0;
 HEAP32[$5 + 68 >> 2] = $1;
 HEAP8[$5 + 67 | 0] = $2;
 HEAP32[$5 + 60 >> 2] = $3;
 HEAP8[$5 + 59 | 0] = $4;
 label$1: {
  if (!(jsvHasCharacterData(HEAP32[$5 + 72 >> 2]) & 1)) {
   HEAP8[$5 + 79 | 0] = 0;
   break label$1;
  }
  jsvStringIteratorNew($5 + 16 | 0, HEAP32[$5 + 72 >> 2], HEAP32[$5 + 60 >> 2]);
  label$3: {
   if (HEAP8[$5 + 59 | 0] & 1) {
    while (1) {
     $0 = 0;
     label$6: {
      if (!(jsvStringIteratorHasChar_1($5 + 16 | 0) & 1)) {
       break label$6;
      }
      $0 = 0;
      if (!HEAP8[HEAP32[$5 + 68 >> 2]]) {
       break label$6;
      }
      $0 = (charToLowerCase(jsvStringIteratorGetChar_1($5 + 16 | 0) << 24 >> 24) & 255) == (charToLowerCase(HEAP8[HEAP32[$5 + 68 >> 2]]) & 255);
     }
     if ($0) {
      HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 68 >> 2] + 1;
      jsvStringIteratorNext($5 + 16 | 0);
      continue;
     }
     break;
    }
    break label$3;
   }
   while (1) {
    $0 = 0;
    label$9: {
     if (!(jsvStringIteratorHasChar_1($5 + 16 | 0) & 1)) {
      break label$9;
     }
     $0 = 0;
     if (!HEAP8[HEAP32[$5 + 68 >> 2]]) {
      break label$9;
     }
     $0 = (jsvStringIteratorGetChar_1($5 + 16 | 0) & 255) == HEAPU8[HEAP32[$5 + 68 >> 2]];
    }
    if ($0) {
     HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 68 >> 2] + 1;
     jsvStringIteratorNext($5 + 16 | 0);
     continue;
    }
    break;
   }
  }
  label$11: {
   if (HEAP8[$5 + 67 | 0] & 1) {
    $0 = 1;
    if (!HEAPU8[HEAP32[$5 + 68 >> 2]]) {
     break label$11;
    }
   }
   $0 = (jsvStringIteratorGetChar_1($5 + 16 | 0) & 255) == HEAPU8[HEAP32[$5 + 68 >> 2]];
  }
  HEAP8[$5 + 15 | 0] = $0;
  jsvStringIteratorFree_1($5 + 16 | 0);
  HEAP8[$5 + 79 | 0] = HEAP8[$5 + 15 | 0] & 1;
 }
 __stack_pointer = $5 + 80 | 0;
 return HEAP8[$5 + 79 | 0] & 1;
}

function jswrap_banglejs_buzz($0, $1) {
 $0 = $0 | 0;
 $1 = +$1;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAPF64[$2 + 32 >> 3] = $1;
 __DOUBLE_BITS_2(HEAPF64[$2 + 32 >> 3]);
 $0 = i64toi32_i32$HIGH_BITS & 2147483647;
 if (HEAPF64[$2 + 32 >> 3] > 1 ? 1 : ($0 | 0) == 2146435072 | $0 >>> 0 > 2146435072) {
  HEAPF64[$2 + 32 >> 3] = 1;
 }
 if (HEAPF64[$2 + 32 >> 3] < 0) {
  HEAPF64[$2 + 32 >> 3] = 0;
 }
 if (HEAP32[$2 + 40 >> 2] <= 0) {
  HEAP32[$2 + 40 >> 2] = 200;
 }
 if (HEAP32[$2 + 40 >> 2] > 5e3) {
  HEAP32[$2 + 40 >> 2] = 5e3;
 }
 label$7: {
  if (HEAP32[97790]) {
   HEAP32[$2 + 28 >> 2] = jsvNewNativeFunction(139, 481);
   HEAP32[$2 + 24 >> 2] = jsvNewFromInteger(HEAP32[$2 + 40 >> 2]);
   jsvAddFunctionParameter(HEAP32[$2 + 28 >> 2], 0, HEAP32[$2 + 24 >> 2]);
   jsvUnLock(HEAP32[$2 + 24 >> 2]);
   HEAP32[$2 + 24 >> 2] = jsvNewFromFloat(HEAPF64[$2 + 32 >> 3]);
   jsvAddFunctionParameter(HEAP32[$2 + 28 >> 2], 0, HEAP32[$2 + 24 >> 2]);
   jsvUnLock(HEAP32[$2 + 24 >> 2]);
   HEAP32[$2 + 20 >> 2] = jswrap_promise_then(HEAP32[97790], HEAP32[$2 + 28 >> 2], 0);
   jsvUnLock(HEAP32[$2 + 28 >> 2]);
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 20 >> 2];
   break label$7;
  }
  HEAP32[97790] = jspromise_create();
  if (!HEAP32[97790]) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$7;
  }
  $1 = HEAPF64[$2 + 32 >> 3] * 255;
  label$10: {
   if ($1 < 4294967296 & $1 >= 0) {
    $0 = ~~$1 >>> 0;
    break label$10;
   }
   $0 = 0;
  }
  HEAP8[391136] = $0;
  $3 = jshGetTimeFromMilliseconds(+HEAP32[$2 + 40 >> 2]);
  $0 = i64toi32_i32$HIGH_BITS;
  label$12: {
   if (jstExecuteFn(620, 0, $3, $0, 0, 0) & 1) {
    if (HEAP32[97749] & 512) {
     _jswrap_banglejs_setVibration();
    }
    break label$12;
   }
   HEAP8[391136] = 0;
  }
  HEAP32[$2 + 44 >> 2] = jsvLockAgain(HEAP32[97790]);
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function lcdMemLCD_scroll($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 var $7 = 0;
 $7 = __stack_pointer - 128 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 124 >> 2] = $0;
 HEAP32[$7 + 120 >> 2] = $1;
 HEAP32[$7 + 116 >> 2] = $2;
 HEAP32[$7 + 112 >> 2] = $3;
 HEAP32[$7 + 108 >> 2] = $4;
 HEAP32[$7 + 104 >> 2] = $5;
 HEAP32[$7 + 100 >> 2] = $6;
 lcdMemLCD_waitForSendComplete();
 label$1: {
  if (!(!HEAP32[$7 + 112 >> 2] & HEAP32[$7 + 104 >> 2] == 175)) {
   graphicsFallbackScroll(HEAP32[$7 + 124 >> 2], HEAP32[$7 + 120 >> 2], HEAP32[$7 + 116 >> 2], HEAP32[$7 + 112 >> 2], HEAP32[$7 + 108 >> 2], HEAP32[$7 + 104 >> 2], HEAP32[$7 + 100 >> 2]);
   break label$1;
  }
  if (HEAP32[$7 + 116 >> 2] <= 0) {
   HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 108 >> 2];
   while (1) {
    if (HEAP32[$7 + 12 >> 2] <= (HEAP32[$7 + 100 >> 2] + HEAP32[$7 + 116 >> 2] | 0)) {
     HEAP32[$7 + 8 >> 2] = HEAP32[$7 + 12 >> 2] - HEAP32[$7 + 116 >> 2];
     lcdMemLCD_scrollX(HEAP32[$7 + 124 >> 2], $7 + 16 | 0, Math_imul(HEAP32[$7 + 8 >> 2], 68) + 378848 | 0, HEAP32[$7 + 120 >> 2]);
     __memcpy(Math_imul(HEAP32[$7 + 12 >> 2], 68) + 378850 | 0, $7 + 18 | 0, 66);
     HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 12 >> 2] + 1;
     continue;
    }
    break;
   }
   break label$1;
  }
  if (HEAP32[$7 + 116 >> 2] > 0) {
   HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 100 >> 2] - HEAP32[$7 + 116 >> 2];
   while (1) {
    if (HEAP32[$7 + 4 >> 2] >= HEAP32[$7 + 108 >> 2]) {
     HEAP32[$7 >> 2] = HEAP32[$7 + 4 >> 2] + HEAP32[$7 + 116 >> 2];
     lcdMemLCD_scrollX(HEAP32[$7 + 124 >> 2], $7 + 16 | 0, Math_imul(HEAP32[$7 + 4 >> 2], 68) + 378848 | 0, HEAP32[$7 + 120 >> 2]);
     __memcpy(Math_imul(HEAP32[$7 >> 2], 68) + 378850 | 0, $7 + 18 | 0, 66);
     HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] - 1;
     continue;
    }
    break;
   }
  }
 }
 __stack_pointer = $7 + 128 | 0;
}

function jsserialEventCallbackInit($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = jsvNewFlatStringOfLength(96);
 label$1: {
  if (!HEAP32[$2 + 16 >> 2]) {
   jsExceptionHere(1, 136365, 0);
   HEAP8[$2 + 31 | 0] = 0;
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 135840, HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 12 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 16 >> 2]);
  HEAP8[HEAP32[$2 + 12 >> 2] + 64 | 0] = 0;
  $0 = jshGetSystemTime();
  $1 = $0;
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP32[$0 + 72 >> 2] = $1;
  HEAP32[$0 + 76 >> 2] = i64toi32_i32$HIGH_BITS;
  $0 = HEAP32[$2 + 20 >> 2];
  HEAP32[HEAP32[$2 + 12 >> 2] + 80 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
  HEAP32[HEAP32[$2 + 12 >> 2] + 84 >> 2] = 0;
  HEAP8[HEAP32[$2 + 12 >> 2] + 88 | 0] = 0;
  HEAP8[HEAP32[$2 + 12 >> 2] + 89 | 0] = !!HEAPU8[HEAP32[$2 + 20 >> 2] + 9 | 0] + (HEAPU8[HEAP32[$2 + 20 >> 2] + 8 | 0] + HEAPU8[HEAP32[$2 + 20 >> 2] + 10 | 0] | 0);
  HEAP8[$2 + 11 | 0] = jshPinWatch(HEAPU8[HEAP32[$2 + 20 >> 2] + 4 | 0], 1, 1);
  label$3: {
   if (HEAPU8[$2 + 11 | 0]) {
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 129312, jsvNewFromInteger(HEAPU8[$2 + 11 | 0]));
    HEAP32[$2 + 4 >> 2] = jsserialGetSerialList(1);
    if (!HEAP32[$2 + 4 >> 2]) {
     HEAP8[$2 + 31 | 0] = 0;
     break label$1;
    }
    jsvSetArrayItem(HEAP32[$2 + 4 >> 2], HEAPU8[$2 + 11 | 0], HEAP32[$2 + 24 >> 2]);
    jsvUnLock(HEAP32[$2 + 4 >> 2]);
    jshSetEventCallback(HEAPU8[$2 + 11 | 0], 571);
    break label$3;
   }
   HEAP32[$2 >> 2] = HEAPU8[HEAP32[$2 + 20 >> 2] + 4 | 0];
   jsExceptionHere(1, 136403, $2);
   HEAP8[$2 + 31 | 0] = 0;
   break label$1;
  }
  HEAP8[$2 + 31 | 0] = 1;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP8[$2 + 31 | 0] & 1;
}

function lcdGetPixelIndex_ArrayBuffer($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 $0 = HEAP32[$4 + 24 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 1 & (HEAP32[$4 + 16 >> 2] & 1)) {
  $0 = HEAP32[$4 + 24 >> 2];
  HEAP32[$4 + 20 >> 2] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - (HEAP32[$4 + 20 >> 2] + HEAP32[$4 + 12 >> 2] | 0);
 }
 $0 = HEAP32[$4 + 24 >> 2];
 label$3: {
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 8) {
   $0 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 8 >> 2] = (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) >>> 1;
   HEAP32[$4 + 4 >> 2] = 0;
   if (HEAP32[$4 + 16 >> 2] >= HEAP32[$4 + 8 >> 2]) {
    HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 16 >> 2] - HEAP32[$4 + 8 >> 2];
    HEAP32[$4 + 4 >> 2] = HEAPU8[HEAP32[$4 + 24 >> 2] + 16 | 0];
   }
   $0 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 4 >> 2] + Math_imul(HEAP32[$4 + 20 >> 2] + Math_imul(HEAP32[$4 + 16 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) | 0, HEAPU8[HEAP32[$4 + 24 >> 2] + 16 | 0] << 1);
   break label$3;
  }
  $0 = HEAP32[$4 + 24 >> 2];
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 2) {
   $0 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 16 >> 2] & 7 | HEAP32[$4 + 20 >> 2] + Math_imul(HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8, HEAP32[$4 + 16 >> 2] >> 3) << 3;
   break label$3;
  }
  $0 = HEAP32[$4 + 24 >> 2];
  HEAP32[$4 + 28 >> 2] = Math_imul(HEAPU8[HEAP32[$4 + 24 >> 2] + 16 | 0], HEAP32[$4 + 20 >> 2] + Math_imul(HEAP32[$4 + 16 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) | 0);
 }
 return HEAP32[$4 + 28 >> 2];
}

function tflite__ConvertTensorType_28tflite__TensorType_2c_20TfLiteType__2c_20tflite__ErrorReporter__29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1: {
  label$2: {
   switch (HEAP32[$3 + 24 >> 2]) {
   case 1:
    HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 10;
    HEAP32[$3 + 28 >> 2] = 0;
    break label$1;

   case 0:
    HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 1;
    HEAP32[$3 + 28 >> 2] = 0;
    break label$1;

   case 10:
    HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 11;
    HEAP32[$3 + 28 >> 2] = 0;
    break label$1;

   case 7:
    HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 7;
    HEAP32[$3 + 28 >> 2] = 0;
    break label$1;

   case 2:
    HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 2;
    HEAP32[$3 + 28 >> 2] = 0;
    break label$1;

   case 3:
    HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 3;
    HEAP32[$3 + 28 >> 2] = 0;
    break label$1;

   case 9:
    HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 9;
    HEAP32[$3 + 28 >> 2] = 0;
    break label$1;

   case 4:
    HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 4;
    HEAP32[$3 + 28 >> 2] = 0;
    break label$1;

   case 5:
    HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 5;
    HEAP32[$3 + 28 >> 2] = 0;
    break label$1;

   case 6:
    HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 6;
    HEAP32[$3 + 28 >> 2] = 0;
    break label$1;

   case 8:
    HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 8;
    HEAP32[$3 + 28 >> 2] = 0;
    break label$1;

   case 11:
    HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 12;
    HEAP32[$3 + 28 >> 2] = 0;
    break label$1;

   default:
    break label$2;
   }
  }
  HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = 0;
  $0 = HEAP32[$3 + 16 >> 2];
  HEAP32[$3 >> 2] = HEAP32[$3 + 24 >> 2];
  tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 146649, $3);
  HEAP32[$3 + 28 >> 2] = 1;
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jswrap_onewire_select($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 76 >> 2] = $0;
 HEAP32[$2 + 72 >> 2] = $1;
 HEAP8[$2 + 71 | 0] = onewire_getpin(HEAP32[$2 + 76 >> 2]);
 label$1: {
  if (!(jshIsPinValid(HEAPU8[$2 + 71 | 0]) & 1)) {
   break label$1;
  }
  label$2: {
   if (jsvIsString(HEAP32[$2 + 72 >> 2]) & 1) {
    if ((jsvGetStringLength(HEAP32[$2 + 72 >> 2]) | 0) == 16) {
     break label$2;
    }
   }
   HEAP32[$2 >> 2] = HEAP32[$2 + 72 >> 2];
   jsExceptionHere(3, 121487, $2);
   break label$1;
  }
  OneWireReset(HEAPU8[$2 + 71 | 0]);
  HEAP32[$2 + 56 >> 2] = 0;
  HEAP32[$2 + 60 >> 2] = 0;
  jsvStringIteratorNew($2 + 16 | 0, HEAP32[$2 + 72 >> 2], 0);
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 12 >> 2] < 8) {
    HEAP8[$2 + 9 | 0] = jsvStringIteratorGetCharAndNext($2 + 16 | 0);
    HEAP8[$2 + 10 | 0] = jsvStringIteratorGetCharAndNext($2 + 16 | 0);
    HEAP8[$2 + 11 | 0] = 0;
    $1 = HEAP32[$2 + 56 >> 2];
    $5 = $1;
    $0 = HEAP32[$2 + 60 >> 2];
    $6 = $0;
    $0 = stringToIntWithRadix($2 + 9 | 0, 16, 0, 0);
    $1 = i64toi32_i32$HIGH_BITS;
    $3 = $0;
    $0 = HEAP32[$2 + 12 >> 2] << 3;
    $4 = $0 & 31;
    if (($0 & 63) >>> 0 >= 32) {
     $0 = $3 << $4;
     $4 = 0;
    } else {
     $0 = (1 << $4) - 1 & $3 >>> 32 - $4 | $1 << $4;
     $4 = $3 << $4;
    }
    $3 = $0;
    $1 = $5;
    $0 = $4;
    $0 = $1 | $0;
    $1 = $2;
    HEAP32[$1 + 56 >> 2] = $0;
    $0 = $6;
    $3 = $0 | $3;
    HEAP32[$1 + 60 >> 2] = $3;
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
  jsvStringIteratorFree_13($2 + 16 | 0);
  OneWireWrite(HEAPU8[$2 + 71 | 0], 8, 85, 0);
  $3 = HEAP32[$2 + 56 >> 2];
  $1 = HEAP32[$2 + 60 >> 2];
  OneWireWrite(HEAPU8[$2 + 71 | 0], 64, $3, $1);
 }
 __stack_pointer = $2 + 80 | 0;
}

function _jswrap_array_reverse_block($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 176 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 172 >> 2] = $0;
 HEAP32[$3 + 168 >> 2] = $1;
 HEAP32[$3 + 164 >> 2] = $2;
 jsvIteratorClone($3 + 104 | 0, HEAP32[$3 + 168 >> 2]);
 jsvIteratorClone($3 + 40 | 0, HEAP32[$3 + 168 >> 2]);
 HEAP32[$3 + 36 >> 2] = (HEAP32[$3 + 164 >> 2] + 1 | 0) / 2;
 while (1) {
  if (HEAP32[$3 + 36 >> 2] > 0) {
   jsvIteratorNext($3 + 40 | 0);
   HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 36 >> 2] - 1;
   continue;
  }
  break;
 }
 if (HEAP32[$3 + 164 >> 2] > 3) {
  _jswrap_array_reverse_block(HEAP32[$3 + 172 >> 2], $3 + 104 | 0, HEAP32[$3 + 164 >> 2] / 2 | 0);
  _jswrap_array_reverse_block(HEAP32[$3 + 172 >> 2], $3 + 40 | 0, HEAP32[$3 + 164 >> 2] / 2 | 0);
 }
 HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 164 >> 2] / 2;
 while (1) {
  if (HEAP32[$3 + 36 >> 2] > 0) {
   HEAP32[$3 + 32 >> 2] = jsvIteratorGetValue($3 + 104 | 0);
   HEAP32[$3 + 28 >> 2] = jsvIteratorGetValue($3 + 40 | 0);
   jsvIteratorSetValue($3 + 104 | 0, HEAP32[$3 + 28 >> 2]);
   jsvIteratorSetValue($3 + 40 | 0, HEAP32[$3 + 32 >> 2]);
   jsvUnLock2(HEAP32[$3 + 32 >> 2], HEAP32[$3 + 28 >> 2]);
   if (jsvIsArray(HEAP32[$3 + 172 >> 2]) & 1) {
    HEAP32[$3 + 24 >> 2] = jsvIteratorGetKey($3 + 104 | 0);
    HEAP32[$3 + 20 >> 2] = jsvIteratorGetKey($3 + 40 | 0);
    HEAP32[$3 + 16 >> 2] = jsvGetInteger(HEAP32[$3 + 24 >> 2]);
    HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 20 >> 2]);
    jsvSetInteger(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 12 >> 2]);
    jsvSetInteger(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
    jsvUnLock2(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
   }
   jsvIteratorNext($3 + 104 | 0);
   jsvIteratorNext($3 + 40 | 0);
   HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 36 >> 2] - 1;
   continue;
  }
  break;
 }
 jsvIteratorFree($3 + 104 | 0);
 jsvIteratorFree($3 + 40 | 0);
 __stack_pointer = $3 + 176 | 0;
}

function jswGetSymbolListForConstructorProto($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 HEAP32[$1 + 4 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
 label$1: {
  if (HEAP32[$1 + 4 >> 2] == 10) {
   HEAP32[$1 + 12 >> 2] = 159085;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 11) {
   HEAP32[$1 + 12 >> 2] = 159148;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 12) {
   HEAP32[$1 + 12 >> 2] = 159166;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 13) {
   HEAP32[$1 + 12 >> 2] = 159175;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 14) {
   HEAP32[$1 + 12 >> 2] = 159184;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 15) {
   HEAP32[$1 + 12 >> 2] = 159193;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 16) {
   HEAP32[$1 + 12 >> 2] = 159202;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 17) {
   HEAP32[$1 + 12 >> 2] = 159211;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 18) {
   HEAP32[$1 + 12 >> 2] = 159283;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 19) {
   HEAP32[$1 + 12 >> 2] = 159355;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 20) {
   HEAP32[$1 + 12 >> 2] = 159373;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 21) {
   HEAP32[$1 + 12 >> 2] = 159391;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 22) {
   HEAP32[$1 + 12 >> 2] = 159409;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 23) {
   HEAP32[$1 + 12 >> 2] = 159427;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 24) {
   HEAP32[$1 + 12 >> 2] = 159445;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 25) {
   HEAP32[$1 + 12 >> 2] = 159463;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2] == 26) {
   HEAP32[$1 + 12 >> 2] = 159517;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 return HEAP32[$1 + 12 >> 2];
}

function jsvGetDataPointer($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (jsvIsArrayBuffer(HEAP32[$2 + 24 >> 2]) & 1) {
   HEAP32[$2 + 16 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$2 + 24 >> 2], 0);
   HEAP32[$2 + 12 >> 2] = jsvGetDataPointer(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2]);
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   if (HEAP32[$2 + 12 >> 2]) {
    $0 = HEAP32[$2 + 24 >> 2];
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8);
    $0 = HEAP32[$2 + 24 >> 2];
    HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = HEAPU8[$0 + 4 | 0] << 16 | (HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8);
   }
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
   break label$1;
  }
  if (jsvIsNativeString(HEAP32[$2 + 24 >> 2]) & 1) {
   $0 = HEAP32[$2 + 24 >> 2];
   HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
   $0 = HEAP32[$2 + 24 >> 2];
   HEAP32[$2 + 28 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   break label$1;
  }
  if (jsvIsFlatString(HEAP32[$2 + 24 >> 2]) & 1) {
   $0 = jsvGetStringLength(HEAP32[$2 + 24 >> 2]);
   HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = $0;
   HEAP32[$2 + 28 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 24 >> 2]);
   break label$1;
  }
  label$6: {
   if (!(jsvIsBasicString(HEAP32[$2 + 24 >> 2]) & 1)) {
    break label$6;
   }
   if (jsvGetLastChild(HEAP32[$2 + 24 >> 2]) & 65535) {
    break label$6;
   }
   $0 = jsvGetCharactersInVar(HEAP32[$2 + 24 >> 2]);
   HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = $0;
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 24 >> 2];
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function tflite___28anonymous_20namespace_29__CreatePlan_28tflite__ErrorReporter__2c_20tflite__GreedyMemoryPlanner__2c_20tflite___28anonymous_20namespace_29__AllocationInfo_20const__2c_20unsigned_20long_29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 HEAP32[$4 + 24 >> 2] = 0;
 label$1: {
  while (1) {
   if (HEAPU32[$4 + 24 >> 2] < HEAPU32[$4 + 28 >> 2]) {
    HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 32 >> 2] + Math_imul(HEAP32[$4 + 24 >> 2], 24);
    if (HEAP8[HEAP32[$4 + 20 >> 2] + 20 | 0] & 1) {
     HEAP32[$4 + 16 >> 2] = tflite__AlignSizeUp_28unsigned_20long_2c_20unsigned_20long_29(HEAP32[HEAP32[$4 + 20 >> 2] >> 2], 16);
     label$5: {
      if (HEAP32[HEAP32[$4 + 20 >> 2] + 16 >> 2] == -1) {
       $0 = HEAP32[$4 + 36 >> 2];
       HEAP32[$4 + 12 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 8 >> 2]]($0, HEAP32[$4 + 40 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[HEAP32[$4 + 20 >> 2] + 8 >> 2], HEAP32[HEAP32[$4 + 20 >> 2] + 12 >> 2]);
       if (HEAP32[$4 + 12 >> 2]) {
        HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 12 >> 2];
        break label$1;
       }
       break label$5;
      }
      HEAP32[$4 + 8 >> 2] = tflite__GreedyMemoryPlanner__AddBuffer_28tflite__ErrorReporter__2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$4 + 36 >> 2], HEAP32[$4 + 40 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[HEAP32[$4 + 20 >> 2] + 8 >> 2], HEAP32[HEAP32[$4 + 20 >> 2] + 12 >> 2], HEAP32[HEAP32[$4 + 20 >> 2] + 16 >> 2]);
      if (HEAP32[$4 + 8 >> 2]) {
       HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 8 >> 2];
       break label$1;
      }
     }
    }
    HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$4 + 44 >> 2] = 0;
 }
 __stack_pointer = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}

function _jswrap_interface_clearTimeoutOrInterval($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP8[$2 + 43 | 0] = $1;
 HEAP32[$2 + 36 >> 2] = jsvLock(HEAPU16[182204]);
 label$1: {
  label$2: {
   if (!(jsvIsUndefined(HEAP32[$2 + 44 >> 2]) & 1)) {
    if (jsvGetArrayLength(HEAP32[$2 + 44 >> 2])) {
     break label$2;
    }
   }
   jsvObjectIteratorNew($2 + 32 | 0, HEAP32[$2 + 36 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_14($2 + 32 | 0) & 1) {
     HEAP32[$2 + 28 >> 2] = jsvObjectIteratorGetValue_13($2 + 32 | 0);
     HEAP32[$2 + 24 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 28 >> 2], 129672);
     label$6: {
      if (!HEAP32[$2 + 24 >> 2]) {
       jsvObjectIteratorRemoveAndGotoNext($2 + 32 | 0, HEAP32[$2 + 36 >> 2]);
       break label$6;
      }
      jsvObjectIteratorNext($2 + 32 | 0);
     }
     jsvUnLock2(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 28 >> 2]);
     continue;
    }
    break;
   }
   jsvObjectIteratorFree_14($2 + 32 | 0);
   break label$1;
  }
  HEAP32[$2 + 20 >> 2] = jsvGetArrayItem(HEAP32[$2 + 44 >> 2], 0);
  label$8: {
   if (jsvIsUndefined(HEAP32[$2 + 20 >> 2]) & 1) {
    HEAP32[$2 + 16 >> 2] = HEAP8[$2 + 43 | 0] & 1 ? 117296 : 129043;
    $0 = HEAP32[$2 + 16 >> 2];
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 16 >> 2];
    HEAP32[$2 >> 2] = $0;
    jsExceptionHere(1, 134307, $2);
    break label$8;
   }
   label$10: {
    if (jsvIsBasic(HEAP32[$2 + 20 >> 2]) & 1) {
     $0 = jsvFindChildFromVar(HEAP32[$2 + 36 >> 2], HEAP32[$2 + 20 >> 2], 0);
     break label$10;
    }
    $0 = 0;
   }
   HEAP32[$2 + 12 >> 2] = $0;
   if (HEAP32[$2 + 12 >> 2]) {
    jsvRemoveChildAndUnLock(HEAP32[$2 + 36 >> 2], HEAP32[$2 + 12 >> 2]);
   }
   jsvUnLock(HEAP32[$2 + 20 >> 2]);
  }
 }
 jsvUnLock(HEAP32[$2 + 36 >> 2]);
 jsiTimersChanged();
 __stack_pointer = $2 + 48 | 0;
}

function tflite__CalculateActivationRangeQuantized_28TfLiteContext__2c_20TfLiteFusedActivation_2c_20TfLiteTensor__2c_20int__2c_20int__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP32[$5 + 36 >> 2] = $1;
 HEAP32[$5 + 32 >> 2] = $2;
 HEAP32[$5 + 28 >> 2] = $3;
 HEAP32[$5 + 24 >> 2] = $4;
 HEAP32[$5 + 20 >> 2] = 0;
 HEAP32[$5 + 16 >> 2] = 0;
 label$1: {
  label$2: {
   if (HEAP32[HEAP32[$5 + 32 >> 2] + 28 >> 2] == 3) {
    HEAP32[$5 + 20 >> 2] = std____2__numeric_limits_unsigned_20char___min_28_29() & 255;
    HEAP32[$5 + 16 >> 2] = std____2__numeric_limits_unsigned_20char___max_28_29() & 255;
    break label$2;
   }
   label$4: {
    if (HEAP32[HEAP32[$5 + 32 >> 2] + 28 >> 2] == 9) {
     HEAP32[$5 + 20 >> 2] = std____2__numeric_limits_signed_20char___min_28_29() << 24 >> 24;
     HEAP32[$5 + 16 >> 2] = std____2__numeric_limits_signed_20char___max_28_29() << 24 >> 24;
     break label$4;
    }
    label$6: {
     if (HEAP32[HEAP32[$5 + 32 >> 2] + 28 >> 2] == 7) {
      HEAP32[$5 + 20 >> 2] = std____2__numeric_limits_short___min_28_29() << 16 >> 16;
      HEAP32[$5 + 16 >> 2] = std____2__numeric_limits_short___max_28_29() << 16 >> 16;
      break label$6;
     }
     $0 = HEAP32[HEAP32[$5 + 40 >> 2] + 20 >> 2];
     $1 = HEAP32[$5 + 40 >> 2];
     HEAP32[$5 >> 2] = 132085;
     FUNCTION_TABLE[$0 | 0]($1, 140586, $5);
     HEAP32[$5 + 44 >> 2] = 1;
     break label$1;
    }
   }
  }
  tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29(HEAP32[$5 + 36 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 32 >> 2], HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2]);
  HEAP32[$5 + 44 >> 2] = 0;
 }
 __stack_pointer = $5 + 48 | 0;
 return HEAP32[$5 + 44 >> 2];
}

function jslLexRegex() {
 var $0 = 0, $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 20 >> 2] = 0;
 label$1: {
  if ((HEAP32[91094] & 63) == 1) {
   $0 = jsvNewFromEmptyString();
   HEAP32[HEAP32[49079] + 76 >> 2] = $0;
   if (!HEAP32[HEAP32[49079] + 76 >> 2]) {
    HEAP16[HEAP32[49079] + 2 >> 1] = 0;
    break label$1;
   }
   jsvStringIteratorNew($1 + 8 | 0, HEAP32[HEAP32[49079] + 76 >> 2], 0);
   jsvStringIteratorAppend($1 + 8 | 0, 47);
  }
  jslGetNextCh();
  while (1) {
   $0 = 0;
   label$6: {
    $0 = HEAP8[HEAP32[49079]] ? HEAP8[HEAP32[49079]] != 47 : $0;
    if (!$0) {
     break label$6;
    }
    label$7: {
     if (HEAP8[HEAP32[49079]] == 92) {
      jsvStringIteratorAppend($1 + 8 | 0, HEAP8[HEAP32[49079]]);
      jslGetNextCh();
      break label$7;
     }
     if (HEAP8[HEAP32[49079]] == 10) {
      break label$6;
     }
    }
    jsvStringIteratorAppend($1 + 8 | 0, HEAP8[HEAP32[49079]]);
    jslGetNextCh();
    continue;
   }
   break;
  }
  HEAP16[HEAP32[49079] + 2 >> 1] = 135;
  label$9: {
   if (HEAP8[HEAP32[49079]] != 47) {
    $0 = HEAP32[49079];
    HEAP16[$0 + 2 >> 1] = HEAPU16[$0 + 2 >> 1] + 1;
    break label$9;
   }
   jsvStringIteratorAppend($1 + 8 | 0, 47);
   jslGetNextCh();
   while (1) {
    $0 = 1;
    label$12: {
     if (HEAP8[HEAP32[49079]] == 103) {
      break label$12;
     }
     $0 = 1;
     if (HEAP8[HEAP32[49079]] == 105) {
      break label$12;
     }
     $0 = 1;
     if (HEAP8[HEAP32[49079]] == 109) {
      break label$12;
     }
     $0 = 1;
     if (HEAP8[HEAP32[49079]] == 121) {
      break label$12;
     }
     $0 = HEAP8[HEAP32[49079]] == 117;
    }
    if ($0) {
     jsvStringIteratorAppend($1 + 8 | 0, HEAP8[HEAP32[49079]]);
     jslGetNextCh();
     continue;
    }
    break;
   }
  }
  jsvStringIteratorFree($1 + 8 | 0);
 }
 __stack_pointer = $1 + 48 | 0;
}

function graphicsFallbackScrollX($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 32 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $5;
 label$1: {
  if (HEAP32[$6 + 24 >> 2] <= 0) {
   HEAP32[$6 >> 2] = HEAP32[$6 + 8 >> 2] + HEAP32[$6 + 24 >> 2];
   HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 12 >> 2];
   while (1) {
    if (HEAP32[$6 + 4 >> 2] <= HEAP32[$6 >> 2]) {
     $0 = HEAP32[$6 + 28 >> 2];
     $1 = HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24);
     $0 = HEAP32[$6 + 28 >> 2];
     FUNCTION_TABLE[$1 | 0](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 4 >> 2], HEAP32[$6 + 16 >> 2], FUNCTION_TABLE[HEAPU8[$0 + 60 | 0] | HEAPU8[$0 + 61 | 0] << 8 | (HEAPU8[$0 + 62 | 0] << 16 | HEAPU8[$0 + 63 | 0] << 24)](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 4 >> 2] - HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 20 >> 2]) | 0);
     HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] + 1;
     continue;
    }
    break;
   }
   break label$1;
  }
  HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 8 >> 2] - HEAP32[$6 + 24 >> 2];
  while (1) {
   if (HEAP32[$6 + 4 >> 2] >= HEAP32[$6 + 12 >> 2]) {
    $0 = HEAP32[$6 + 28 >> 2];
    $1 = HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24);
    $0 = HEAP32[$6 + 28 >> 2];
    FUNCTION_TABLE[$1 | 0](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 4 >> 2] + HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 16 >> 2], FUNCTION_TABLE[HEAPU8[$0 + 60 | 0] | HEAPU8[$0 + 61 | 0] << 8 | (HEAPU8[$0 + 62 | 0] << 16 | HEAPU8[$0 + 63 | 0] << 24)](HEAP32[$6 + 28 >> 2], HEAP32[$6 + 4 >> 2], HEAP32[$6 + 20 >> 2]) | 0);
    HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] - 1;
    continue;
   }
   break;
  }
 }
 __stack_pointer = $6 + 32 | 0;
}

function tflite__MicroAllocator__AllocateVariables_28tflite__SubGraph_20const__2c_20TfLiteEvalTensor__29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 $0 = HEAP32[$3 + 40 >> 2];
 HEAP32[$3 + 28 >> 2] = 0;
 label$1: {
  while (1) {
   if (HEAPU32[$3 + 28 >> 2] < flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor____size_28_29_20const(tflite__SubGraph__tensors_28_29_20const(HEAP32[$3 + 36 >> 2])) >>> 0) {
    HEAP32[$3 + 24 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor____Get_28unsigned_20int_29_20const(tflite__SubGraph__tensors_28_29_20const(HEAP32[$3 + 36 >> 2]), HEAP32[$3 + 28 >> 2]);
    if (tflite__Tensor__is_variable_28_29_20const(HEAP32[$3 + 24 >> 2]) & 1) {
     HEAP32[$3 + 16 >> 2] = tflite__TfLiteEvalTensorByteLength_28TfLiteEvalTensor_20const__2c_20unsigned_20long__29(HEAP32[$3 + 32 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) | 0, $3 + 20 | 0);
     if (HEAP32[$3 + 16 >> 2]) {
      HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 16 >> 2];
      break label$1;
     }
     $1 = HEAP32[$0 + 4 >> 2];
     $1 = FUNCTION_TABLE[HEAP32[HEAP32[$1 >> 2] + 12 >> 2]]($1, HEAP32[$3 + 20 >> 2], 16) | 0;
     HEAP32[HEAP32[$3 + 32 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) >> 2] = $1;
     if (!HEAP32[HEAP32[$3 + 32 >> 2] + Math_imul(HEAP32[$3 + 28 >> 2], 12) >> 2]) {
      $0 = HEAP32[$0 + 8 >> 2];
      HEAP32[$3 >> 2] = HEAP32[$3 + 20 >> 2];
      tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 134926, $3);
      HEAP32[$3 + 44 >> 2] = 1;
      break label$1;
     }
    }
    HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$3 + 44 >> 2] = 0;
 }
 __stack_pointer = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}

function jswrap_espruino_getSizeOf($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1: {
  label$2: {
   if (HEAP32[$2 + 36 >> 2] <= 0) {
    break label$2;
   }
   if (!(jsvHasChildren(HEAP32[$2 + 40 >> 2]) & 1)) {
    break label$2;
   }
   HEAP32[$2 + 32 >> 2] = jsvNewEmptyArray();
   if (!HEAP32[$2 + 32 >> 2]) {
    HEAP32[$2 + 44 >> 2] = 0;
    break label$1;
   }
   jsvObjectIteratorNew($2 + 24 | 0, HEAP32[$2 + 40 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_13($2 + 24 | 0) & 1) {
     HEAP32[$2 + 20 >> 2] = jsvObjectIteratorGetKey_8($2 + 24 | 0);
     HEAP32[$2 + 16 >> 2] = jsvSkipName(HEAP32[$2 + 20 >> 2]);
     HEAP32[$2 + 12 >> 2] = jsvNewObject();
     if (HEAP32[$2 + 12 >> 2]) {
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 132398, jsvAsString(HEAP32[$2 + 20 >> 2]));
      jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 131648, jswrap_espruino_getSizeOf(HEAP32[$2 + 20 >> 2], 0));
      label$7: {
       if (HEAP32[$2 + 36 >> 2] <= 1) {
        break label$7;
       }
       if (!(jsvHasChildren(HEAP32[$2 + 16 >> 2]) & 1)) {
        break label$7;
       }
       jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 132145, jswrap_espruino_getSizeOf(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 36 >> 2] - 1 | 0));
      }
      jsvArrayPushAndUnLock(HEAP32[$2 + 32 >> 2], HEAP32[$2 + 12 >> 2]);
     }
     jsvUnLock2(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2]);
     jsvObjectIteratorNext($2 + 24 | 0);
     continue;
    }
    break;
   }
   jsvObjectIteratorFree_13($2 + 24 | 0);
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 32 >> 2];
   break label$1;
  }
  HEAP32[$2 + 44 >> 2] = jsvNewFromInteger(jsvCountJsVarsUsed(HEAP32[$2 + 40 >> 2]));
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function jsfBankFindFileFromAddr($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 56 >> 2] = $0;
 HEAP32[$4 + 52 >> 2] = $1;
 HEAP32[$4 + 48 >> 2] = $2;
 HEAP32[$4 + 44 >> 2] = $3;
 HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 56 >> 2];
 HEAP32[$4 + 32 >> 2] = 0;
 HEAP32[$4 + 36 >> 2] = 0;
 HEAP32[$4 + 24 >> 2] = 0;
 HEAP32[$4 + 28 >> 2] = 0;
 HEAP32[$4 + 16 >> 2] = 0;
 HEAP32[$4 + 20 >> 2] = 0;
 HEAP32[$4 + 8 >> 2] = 0;
 HEAP32[$4 + 12 >> 2] = 0;
 label$1: {
  if (jsfGetFileHeader(HEAP32[$4 + 40 >> 2], $4 + 8 | 0, 0) & 1) {
   while (1) {
    HEAP32[$4 + 4 >> 2] = (HEAP32[$4 + 40 >> 2] + 32 | 0) + jsfGetFileSize($4 + 8 | 0);
    if (!(!HEAP32[$4 + 12 >> 2] | HEAPU32[$4 + 40 >> 2] > HEAPU32[$4 + 48 >> 2] | HEAPU32[$4 + 48 >> 2] > HEAPU32[$4 + 4 >> 2])) {
     jsfGetFileHeader(HEAP32[$4 + 40 >> 2], $4 + 8 | 0, 1);
     if (HEAP32[$4 + 44 >> 2]) {
      $0 = HEAP32[$4 + 12 >> 2];
      $1 = HEAP32[$4 + 8 >> 2];
      $3 = $1;
      $2 = HEAP32[$4 + 44 >> 2];
      $1 = $2;
      HEAP32[$1 >> 2] = $3;
      HEAP32[$1 + 4 >> 2] = $0;
      $1 = HEAP32[$4 + 36 >> 2];
      $0 = HEAP32[$4 + 32 >> 2];
      $3 = $0;
      $0 = $2;
      HEAP32[$0 + 24 >> 2] = $3;
      HEAP32[$0 + 28 >> 2] = $1;
      $0 = HEAP32[$4 + 28 >> 2];
      $1 = HEAP32[$4 + 24 >> 2];
      $3 = $1;
      $1 = $2;
      HEAP32[$1 + 16 >> 2] = $3;
      HEAP32[$1 + 20 >> 2] = $0;
      $1 = HEAP32[$4 + 20 >> 2];
      $0 = HEAP32[$4 + 16 >> 2];
      $3 = $0;
      $0 = $2;
      HEAP32[$0 + 8 >> 2] = $3;
      HEAP32[$0 + 12 >> 2] = $1;
     }
     HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 40 >> 2] + 32;
     break label$1;
    }
    if (jsfGetNextFileHeader($4 + 40 | 0, $4 + 8 | 0, 3) & 1) {
     continue;
    }
    break;
   }
  }
  HEAP32[$4 + 60 >> 2] = 0;
 }
 __stack_pointer = $4 - -64 | 0;
 return HEAP32[$4 + 60 >> 2];
}

function vfGetCharFromPtr($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0;
 $8 = __stack_pointer - 256 | 0;
 __stack_pointer = $8;
 HEAP32[$8 + 252 >> 2] = $0;
 HEAP32[$8 + 248 >> 2] = $1;
 HEAP32[$8 + 244 >> 2] = $2;
 HEAP32[$8 + 240 >> 2] = $3;
 HEAP32[$8 + 236 >> 2] = $4;
 HEAP32[$8 + 232 >> 2] = $5;
 HEAP32[$8 + 228 >> 2] = $6;
 HEAP32[$8 + 224 >> 2] = $7;
 HEAP32[$8 + 244 >> 2] = (HEAP32[$8 + 244 >> 2] << 4) - 8;
 HEAP32[$8 + 240 >> 2] = (HEAP32[$8 + 240 >> 2] << 4) - 8;
 HEAP32[$8 + 220 >> 2] = 0;
 HEAP32[$8 + 216 >> 2] = 0;
 while (1) {
  if (HEAP32[$8 + 216 >> 2] < HEAP32[$8 + 224 >> 2]) {
   HEAP32[$8 + 24 >> 2] = vfGetPolyPtr(HEAPU8[HEAP32[$8 + 228 >> 2] + HEAP32[$8 + 216 >> 2] | 0], $8 + 28 | 0);
   HEAP32[$8 + 20 >> 2] = 0;
   while (1) {
    if (HEAP32[$8 + 20 >> 2] < HEAP32[$8 + 28 >> 2]) {
     HEAP8[$8 + 19 | 0] = HEAPU8[HEAP32[$8 + 24 >> 2] + HEAP32[$8 + 20 >> 2] | 0];
     HEAP32[$8 + 12 >> 2] = HEAPU8[$8 + 19 | 0] % 13;
     HEAP32[$8 + 8 >> 2] = HEAPU8[$8 + 19 | 0] / 13;
     if (HEAP32[$8 + 12 >> 2] > HEAP32[$8 + 220 >> 2]) {
      HEAP32[$8 + 220 >> 2] = HEAP32[$8 + 12 >> 2];
     }
     HEAP16[($8 + 32 | 0) + (HEAP32[$8 + 20 >> 2] << 2) >> 1] = HEAP32[$8 + 244 >> 2] + ((Math_imul(HEAP32[$8 + 12 >> 2], HEAP32[$8 + 236 >> 2]) << 4) / 16 | 0);
     HEAP16[((HEAP32[$8 + 20 >> 2] << 2) + $8 | 0) + 34 >> 1] = HEAP32[$8 + 240 >> 2] + ((Math_imul(HEAP32[$8 + 232 >> 2], HEAP32[$8 + 8 >> 2] - 2 | 0) << 4) / 16 | 0);
     HEAP32[$8 + 20 >> 2] = HEAP32[$8 + 20 >> 2] + 1;
     continue;
    }
    break;
   }
   FUNCTION_TABLE[HEAP32[$8 + 252 >> 2]](HEAP32[$8 + 248 >> 2], HEAP32[$8 + 28 >> 2], $8 + 32 | 0);
   HEAP32[$8 + 216 >> 2] = HEAP32[$8 + 216 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $8 + 256 | 0;
 return ((Math_imul(HEAP32[$8 + 236 >> 2], HEAP32[$8 + 220 >> 2] + 2 | 0) << 4) / 16 | 0) + 7 >> 4;
}

function jshFlashWriteAligned($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1: {
  if (!(HEAPU32[$3 + 24 >> 2] < 134217728 | HEAPU32[$3 + 24 >> 2] >= 142606336)) {
   jshFlashWrite(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
   break label$1;
  }
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 24 >> 2] & 3;
  if (HEAP32[$3 + 12 >> 2]) {
   jshFlashRead($3 + 8 | 0, HEAP32[$3 + 24 >> 2] - HEAP32[$3 + 12 >> 2] | 0, 4);
   HEAP32[$3 + 4 >> 2] = 4 - HEAP32[$3 + 12 >> 2];
   if (HEAPU32[$3 + 4 >> 2] > HEAPU32[$3 + 20 >> 2]) {
    HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 20 >> 2];
   }
   __memcpy(HEAP32[$3 + 12 >> 2] + ($3 + 8 | 0) | 0, HEAP32[$3 + 16 >> 2], HEAP32[$3 + 4 >> 2]);
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 4 >> 2] + HEAP32[$3 + 16 >> 2];
   jshFlashWrite($3 + 8 | 0, HEAP32[$3 + 24 >> 2] - HEAP32[$3 + 12 >> 2] | 0, 4);
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 4 >> 2] + HEAP32[$3 + 24 >> 2];
   if (HEAPU32[$3 + 4 >> 2] >= HEAPU32[$3 + 20 >> 2]) {
    break label$1;
   }
   HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 4 >> 2];
  }
  HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 20 >> 2] & 3;
  HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 12 >> 2];
  if (HEAP32[$3 + 20 >> 2]) {
   jshFlashWrite(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
  }
  HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 20 >> 2] + HEAP32[$3 + 24 >> 2];
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 20 >> 2] + HEAP32[$3 + 16 >> 2];
  if (!HEAP32[$3 + 12 >> 2]) {
   break label$1;
  }
  jshFlashRead($3, HEAP32[$3 + 24 >> 2], 4);
  __memcpy($3, HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2]);
  jshFlashWrite($3, HEAP32[$3 + 24 >> 2], 4);
 }
 __stack_pointer = $3 + 32 | 0;
}

function tflite__ops__micro__pooling___28anonymous_20namespace_29__AverageEvalFloat_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20TfLitePoolParams_20const__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 128 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 124 >> 2] = $0;
 HEAP32[$6 + 120 >> 2] = $1;
 HEAP32[$6 + 116 >> 2] = $2;
 HEAP32[$6 + 112 >> 2] = $3;
 HEAP32[$6 + 108 >> 2] = $4;
 HEAP32[$6 + 104 >> 2] = $5;
 HEAP32[$6 + 68 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 8 >> 2];
 HEAP32[$6 + 72 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 4 >> 2];
 HEAP32[$6 + 76 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 16 >> 2];
 HEAP32[$6 + 80 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 12 >> 2];
 HEAP16[$6 + 60 >> 1] = HEAP32[HEAP32[$6 + 112 >> 2] + 4 >> 2];
 HEAP16[$6 + 58 >> 1] = HEAP32[HEAP32[$6 + 112 >> 2] >> 2];
 HEAPF32[$6 + 92 >> 2] = HEAPF32[HEAP32[$6 + 112 >> 2] + 24 >> 2];
 HEAPF32[$6 + 96 >> 2] = HEAPF32[HEAP32[$6 + 112 >> 2] + 28 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 32 | 0, HEAP32[$6 + 108 >> 2]);
 $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$6 + 108 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 8 | 0, HEAP32[$6 + 104 >> 2]);
 tflite__reference_ops__AveragePool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($6 + 56 | 0, $6 + 32 | 0, $0, $6 + 8 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$6 + 104 >> 2]));
 tflite__RuntimeShape___RuntimeShape_28_29($6 + 8 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($6 + 32 | 0);
 __stack_pointer = $6 + 128 | 0;
}

function tflite__MicroInterpreter__MicroInterpreter_28tflite__Model_20const__2c_20tflite__MicroOpResolver_20const__2c_20unsigned_20char__2c_20unsigned_20long_2c_20tflite__ErrorReporter__2c_20tflite__Profiler__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = __stack_pointer - 32 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 28 >> 2] = $0;
 HEAP32[$7 + 24 >> 2] = $1;
 HEAP32[$7 + 20 >> 2] = $2;
 HEAP32[$7 + 16 >> 2] = $3;
 HEAP32[$7 + 12 >> 2] = $4;
 HEAP32[$7 + 8 >> 2] = $5;
 HEAP32[$7 + 4 >> 2] = $6;
 $0 = HEAP32[$7 + 28 >> 2];
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = HEAP32[$7 + 24 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[$7 + 20 >> 2];
 HEAP32[$0 + 12 >> 2] = HEAP32[$7 + 8 >> 2];
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 32 >> 2] = 0;
 HEAP32[$0 + 36 >> 2] = 0;
 HEAP32[$0 + 40 >> 2] = 0;
 HEAP32[$0 + 44 >> 2] = 0;
 HEAP32[$0 + 48 >> 2] = 0;
 HEAP32[$0 + 52 >> 2] = 0;
 HEAP32[$0 + 56 >> 2] = 0;
 HEAP32[$0 + 60 >> 2] = 0;
 HEAP8[$0 + 64 | 0] = 0;
 HEAP32[$0 + 68 >> 2] = 0;
 HEAP32[$0 + 72 >> 2] = 0;
 HEAP32[$0 + 76 >> 2] = 0;
 HEAP32[$0 + 80 >> 2] = 0;
 HEAP32[$0 + 84 >> 2] = 0;
 HEAP32[$0 + 88 >> 2] = 0;
 HEAP32[$0 + 92 >> 2] = 0;
 HEAP32[$0 + 96 >> 2] = 0;
 HEAP32[$0 + 100 >> 2] = 0;
 HEAP32[$0 + 104 >> 2] = tflite__MicroAllocator__Create_28unsigned_20char__2c_20unsigned_20long_2c_20tflite__ErrorReporter__29(HEAP32[$7 + 16 >> 2], HEAP32[$7 + 12 >> 2], HEAP32[$7 + 8 >> 2]);
 HEAP8[$0 + 108 | 0] = 0;
 HEAP32[$0 + 112 >> 2] = 1;
 HEAP32[$0 + 120 >> 2] = 0;
 FUNCTION_TABLE[674]($0 + 124 | 0, HEAP32[$0 + 12 >> 2], HEAP32[$0 + 104 >> 2], HEAP32[$7 + 24 >> 2]) | 0;
 HEAP32[$0 + 144 >> 2] = 0;
 HEAP32[$0 + 148 >> 2] = 0;
 tflite__MicroInterpreter__Init_28tflite__Profiler__29($0, HEAP32[$7 + 4 >> 2]);
 __stack_pointer = $7 + 32 | 0;
 return $0;
}

function jsvNewStringOfLength($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (HEAPU32[$2 + 24 >> 2] > 19) {
   HEAP32[$2 + 16 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 24 >> 2]);
   if (HEAP32[$2 + 16 >> 2]) {
    if (HEAP32[$2 + 20 >> 2]) {
     jsvSetString(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 24 >> 2]);
    }
    HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
    break label$1;
   }
  }
  HEAP32[$2 + 12 >> 2] = jsvNewWithFlags(28);
  if (!HEAP32[$2 + 12 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 8 >> 2] = jsvLockAgain(HEAP32[$2 + 12 >> 2]);
  while (1) {
   label$7: {
    HEAP32[$2 + 4 >> 2] = jsvGetMaxCharactersInVar(HEAP32[$2 + 8 >> 2]);
    if (HEAPU32[$2 + 4 >> 2] >= HEAPU32[$2 + 24 >> 2]) {
     if (HEAP32[$2 + 20 >> 2]) {
      __memcpy(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 24 >> 2]);
     }
     jsvSetCharactersInVar(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 24 >> 2]);
     break label$7;
    }
    if (HEAP32[$2 + 20 >> 2]) {
     __memcpy(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 4 >> 2]);
     HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 4 >> 2] + HEAP32[$2 + 20 >> 2];
    }
    jsvSetCharactersInVar(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
    HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 24 >> 2] - HEAP32[$2 + 4 >> 2];
    HEAP32[$2 >> 2] = jsvNewWithFlags(41);
    if (!HEAP32[$2 >> 2]) {
     break label$7;
    }
    jsvSetLastChild(HEAP32[$2 + 8 >> 2], jsvGetRef(HEAP32[$2 >> 2]) & 65535);
    jsvUnLock(HEAP32[$2 + 8 >> 2]);
    HEAP32[$2 + 8 >> 2] = HEAP32[$2 >> 2];
    continue;
   }
   break;
  }
  jsvUnLock(HEAP32[$2 + 8 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jswrap_date_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 80 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 76 >> 2] = $0;
 HEAPF64[$1 + 64 >> 3] = 0;
 label$1: {
  if (!jsvGetArrayLength(HEAP32[$1 + 76 >> 2])) {
   HEAPF64[$1 + 64 >> 3] = jswrap_date_now();
   break label$1;
  }
  label$3: {
   if ((jsvGetArrayLength(HEAP32[$1 + 76 >> 2]) | 0) == 1) {
    HEAP32[$1 + 60 >> 2] = jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 0);
    label$5: {
     if (jsvIsNumeric(HEAP32[$1 + 60 >> 2]) & 1) {
      HEAPF64[$1 + 64 >> 3] = jsvGetFloat(HEAP32[$1 + 60 >> 2]);
      break label$5;
     }
     label$7: {
      if (jsvIsString(HEAP32[$1 + 60 >> 2]) & 1) {
       HEAPF64[$1 + 64 >> 3] = jswrap_date_parse(HEAP32[$1 + 60 >> 2]);
       break label$7;
      }
      HEAP32[$1 >> 2] = HEAP32[$1 + 60 >> 2];
      jsExceptionHere(3, 120767, $1);
     }
    }
    jsvUnLock(HEAP32[$1 + 60 >> 2]);
    break label$3;
   }
   HEAP32[$1 + 52 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 0));
   HEAP32[$1 + 48 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 1));
   HEAP32[$1 + 44 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 2));
   HEAP32[$1 + 8 >> 2] = fromCalendarDate($1 + 40 | 0);
   HEAP32[$1 + 24 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 3));
   HEAP32[$1 + 20 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 4));
   HEAP32[$1 + 16 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 5));
   HEAP32[$1 + 12 >> 2] = jsvGetIntegerAndUnLock(jsvGetArrayItem(HEAP32[$1 + 76 >> 2], 6));
   setCorrectTimeZone($1 + 8 | 0);
   HEAPF64[$1 + 64 >> 3] = fromTimeInDay($1 + 8 | 0);
  }
 }
 $0 = jswrap_date_from_milliseconds(HEAPF64[$1 + 64 >> 3]);
 __stack_pointer = $1 + 80 | 0;
 return $0 | 0;
}

function jswrap_serial_setup($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 label$1: {
  if (!(jsvIsObject(HEAP32[$3 + 44 >> 2]) & 1)) {
   break label$1;
  }
  HEAP8[$3 + 35 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 44 >> 2]);
  label$2: {
   if (jsvIsUndefined(HEAP32[$3 + 36 >> 2]) & 1) {
    HEAP32[$3 + 36 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 44 >> 2], 120075);
    break label$2;
   }
   jsvLockAgain(HEAP32[$3 + 36 >> 2]);
  }
  HEAP8[$3 + 15 | 0] = jsserialPopulateUSARTInfo($3 + 16 | 0, HEAP32[$3 + 40 >> 2], HEAP32[$3 + 36 >> 2]) & 1;
  if (!(HEAP8[$3 + 15 | 0] & 1)) {
   jsvUnLock(HEAP32[$3 + 36 >> 2]);
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$3 + 44 >> 2], 132026, jsvNewFromInteger(HEAPU8[$3 + 16 | 0] | HEAPU8[$3 + 17 | 0] << 8 | (HEAPU8[$3 + 18 | 0] << 16 | HEAPU8[$3 + 19 | 0] << 24)));
  label$5: {
   if (HEAP32[$3 + 36 >> 2]) {
    jsvObjectSetChildAndUnLock(HEAP32[$3 + 44 >> 2], 120075, HEAP32[$3 + 36 >> 2]);
    break label$5;
   }
   jsvObjectRemoveChild(HEAP32[$3 + 44 >> 2], 120075);
  }
  if (!(HEAPU8[$3 + 35 | 0] < 17 | HEAPU8[$3 + 35 | 0] > 22)) {
   if (!(HEAPU8[$3 + 35 | 0] < 22 | HEAPU8[$3 + 35 | 0] > 22)) {
    jshUSARTSetup(HEAPU8[$3 + 35 | 0], $3 + 16 | 0);
   }
   break label$1;
  }
  if (!HEAPU8[$3 + 35 | 0]) {
   if (HEAPU8[$3 + 21 | 0] != 255) {
    jshPinSetState(HEAPU8[$3 + 21 | 0], 1);
    jshPinOutput(HEAPU8[$3 + 21 | 0], 1);
   }
   if (HEAPU8[$3 + 20 | 0] != 255) {
    jshPinSetState(HEAPU8[$3 + 20 | 0], 5);
    jsserialEventCallbackInit(HEAP32[$3 + 44 >> 2], $3 + 16 | 0);
   }
   if (HEAPU8[$3 + 22 | 0] != 255) {
    jsExceptionHere(1, 117825, 0);
   }
  }
 }
 __stack_pointer = $3 + 48 | 0;
}

function tflite__ops__micro__reshape__Prepare_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1: {
  label$2: {
   if ((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 36 >> 2]) | 0) == 1) {
    break label$2;
   }
   if ((tflite__NumInputs_28TfLiteNode_20const__29(HEAP32[$2 + 36 >> 2]) | 0) == 2) {
    break label$2;
   }
   $0 = HEAP32[HEAP32[$2 + 40 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 40 >> 2];
   HEAP32[$2 + 32 >> 2] = 139809;
   FUNCTION_TABLE[$0 | 0]($1, 140586, $2 + 32 | 0);
   HEAP32[$2 + 44 >> 2] = 1;
   break label$1;
  }
  if ((tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 36 >> 2]) | 0) != 1) {
   $0 = HEAP32[HEAP32[$2 + 40 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 40 >> 2];
   $3 = tflite__NumOutputs_28TfLiteNode_20const__29(HEAP32[$2 + 36 >> 2]);
   HEAP32[$2 + 12 >> 2] = 1;
   HEAP32[$2 + 8 >> 2] = $3;
   HEAP32[$2 + 4 >> 2] = 139997;
   HEAP32[$2 >> 2] = 143033;
   FUNCTION_TABLE[$0 | 0]($1, 143305, $2);
   HEAP32[$2 + 44 >> 2] = 1;
   break label$1;
  }
  if (tflite__ops__micro__reshape__ReshapeOutput_28TfLiteContext__2c_20TfLiteNode__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2])) {
   $0 = HEAP32[HEAP32[$2 + 40 >> 2] + 20 >> 2];
   $1 = HEAP32[$2 + 40 >> 2];
   $3 = tflite__ops__micro__reshape__ReshapeOutput_28TfLiteContext__2c_20TfLiteNode__29(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 36 >> 2]);
   HEAP32[$2 + 28 >> 2] = 0;
   HEAP32[$2 + 24 >> 2] = $3;
   HEAP32[$2 + 20 >> 2] = 129141;
   HEAP32[$2 + 16 >> 2] = 143066;
   FUNCTION_TABLE[$0 | 0]($1, 143305, $2 + 16 | 0);
   HEAP32[$2 + 44 >> 2] = 1;
   break label$1;
  }
  HEAP32[$2 + 44 >> 2] = 0;
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function jsfSaveBootCodeToFlash($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 208 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 204 >> 2] = $0;
 HEAP8[$2 + 203 | 0] = $1;
 jsfNameFromString($2 + 168 | 0, 132787);
 HEAP32[$2 + 64 >> 2] = HEAP32[$2 + 192 >> 2];
 $0 = HEAP32[$2 + 188 >> 2];
 $1 = HEAP32[$2 + 184 >> 2];
 HEAP32[$2 + 56 >> 2] = $1;
 HEAP32[$2 + 60 >> 2] = $0;
 $1 = HEAP32[$2 + 180 >> 2];
 $0 = HEAP32[$2 + 176 >> 2];
 HEAP32[$2 + 48 >> 2] = $0;
 HEAP32[$2 + 52 >> 2] = $1;
 $0 = HEAP32[$2 + 172 >> 2];
 $1 = HEAP32[$2 + 168 >> 2];
 HEAP32[$2 + 40 >> 2] = $1;
 HEAP32[$2 + 44 >> 2] = $0;
 jsfEraseFile($2 + 40 | 0);
 jsfNameFromString($2 + 136 | 0, 117304);
 HEAP32[$2 + 96 >> 2] = HEAP32[$2 + 160 >> 2];
 $1 = HEAP32[$2 + 156 >> 2];
 $0 = HEAP32[$2 + 152 >> 2];
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP32[$2 + 92 >> 2] = $1;
 $0 = HEAP32[$2 + 148 >> 2];
 $1 = HEAP32[$2 + 144 >> 2];
 HEAP32[$2 + 80 >> 2] = $1;
 HEAP32[$2 + 84 >> 2] = $0;
 $1 = HEAP32[$2 + 140 >> 2];
 $0 = HEAP32[$2 + 136 >> 2];
 HEAP32[$2 + 72 >> 2] = $0;
 HEAP32[$2 + 76 >> 2] = $1;
 jsfEraseFile($2 + 72 | 0);
 label$1: {
  if (jsvIsUndefined(HEAP32[$2 + 204 >> 2]) & 1) {
   break label$1;
  }
  if (!jsvGetLength(HEAP32[$2 + 204 >> 2])) {
   break label$1;
  }
  jsfNameFromString($2 + 104 | 0, HEAP8[$2 + 203 | 0] & 1 ? 117304 : 132787);
  $3 = HEAP32[$2 + 204 >> 2];
  HEAP32[$2 + 32 >> 2] = HEAP32[$2 + 128 >> 2];
  $0 = HEAP32[$2 + 124 >> 2];
  $1 = HEAP32[$2 + 120 >> 2];
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 28 >> 2] = $0;
  $1 = HEAP32[$2 + 116 >> 2];
  $0 = HEAP32[$2 + 112 >> 2];
  HEAP32[$2 + 16 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  $0 = HEAP32[$2 + 108 >> 2];
  $1 = HEAP32[$2 + 104 >> 2];
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 12 >> 2] = $0;
  jsfWriteFile($2 + 8 | 0, $3, 0, 0, 0);
 }
 __stack_pointer = $2 + 208 | 0;
}

function jswrap_array_reverse($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 144 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 136 >> 2] = $0;
 label$1: {
  label$2: {
   if (jsvIsIterable(HEAP32[$1 + 136 >> 2]) & 1) {
    if (!(jsvIsObject(HEAP32[$1 + 136 >> 2]) & 1)) {
     break label$2;
    }
   }
   HEAP32[$1 + 140 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 132 >> 2] = 0;
  label$4: {
   if (jsvIsArray(HEAP32[$1 + 136 >> 2]) & 1) {
    jsvIteratorNew($1 + 72 | 0, HEAP32[$1 + 136 >> 2], 0);
    while (1) {
     if (jsvIteratorHasElement($1 + 72 | 0) & 1) {
      HEAP32[$1 + 68 >> 2] = jsvIteratorGetKey($1 + 72 | 0);
      if (jsvIsInt(HEAP32[$1 + 68 >> 2]) & 1) {
       HEAP32[$1 + 132 >> 2] = HEAP32[$1 + 132 >> 2] + 1;
      }
      jsvUnLock(HEAP32[$1 + 68 >> 2]);
      jsvIteratorNext($1 + 72 | 0);
      continue;
     }
     break;
    }
    jsvIteratorFree($1 + 72 | 0);
    break label$4;
   }
   HEAP32[$1 + 132 >> 2] = jsvGetLength(HEAP32[$1 + 136 >> 2]);
  }
  jsvIteratorNew($1 + 8 | 0, HEAP32[$1 + 136 >> 2], 0);
  if (HEAP32[$1 + 132 >> 2] > 1) {
   _jswrap_array_reverse_block(HEAP32[$1 + 136 >> 2], $1 + 8 | 0, HEAP32[$1 + 132 >> 2]);
  }
  if (jsvIsArray(HEAP32[$1 + 136 >> 2]) & 1) {
   HEAP32[$1 + 4 >> 2] = jsvGetArrayLength(HEAP32[$1 + 136 >> 2]) - 1;
   while (1) {
    if (jsvIteratorHasElement($1 + 8 | 0) & 1) {
     HEAP32[$1 >> 2] = jsvIteratorGetKey($1 + 8 | 0);
     if (jsvIsInt(HEAP32[$1 >> 2]) & 1) {
      jsvSetInteger(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2] - jsvGetInteger(HEAP32[$1 >> 2]) | 0);
     }
     jsvUnLock(HEAP32[$1 >> 2]);
     jsvIteratorNext($1 + 8 | 0);
     continue;
    }
    break;
   }
  }
  jsvIteratorFree($1 + 8 | 0);
  HEAP32[$1 + 140 >> 2] = jsvLockAgain(HEAP32[$1 + 136 >> 2]);
 }
 __stack_pointer = $1 + 144 | 0;
 return HEAP32[$1 + 140 >> 2];
}

function find_longest_match($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 48 | 0;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP16[$5 + 38 >> 1] = $1;
 HEAP16[$5 + 36 >> 1] = $2;
 HEAP16[$5 + 34 >> 1] = $3;
 HEAP32[$5 + 28 >> 2] = $4;
 HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 40 >> 2] + 15;
 HEAP16[$5 + 22 >> 1] = 0;
 HEAP16[$5 + 20 >> 1] = 65535;
 HEAP16[$5 + 18 >> 1] = 0;
 HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 24 >> 2] + HEAPU16[$5 + 36 >> 1];
 HEAP16[$5 + 10 >> 1] = HEAPU16[$5 + 36 >> 1] - 1;
 while (1) {
  label$2: {
   if ((HEAP16[$5 + 10 >> 1] - HEAP16[$5 + 38 >> 1] | 0) < 0) {
    break label$2;
   }
   HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 24 >> 2] + HEAP16[$5 + 10 >> 1];
   if (!(HEAPU8[HEAP32[$5 + 4 >> 2] + HEAPU16[$5 + 22 >> 1] | 0] != HEAPU8[HEAP32[$5 + 12 >> 2] + HEAPU16[$5 + 22 >> 1] | 0] | HEAPU8[HEAP32[$5 + 4 >> 2]] != HEAPU8[HEAP32[$5 + 12 >> 2]])) {
    HEAP16[$5 + 18 >> 1] = 1;
    while (1) {
     if (!(HEAPU8[HEAP32[$5 + 4 >> 2] + HEAPU16[$5 + 18 >> 1] | 0] != HEAPU8[HEAP32[$5 + 12 >> 2] + HEAPU16[$5 + 18 >> 1] | 0] | HEAPU16[$5 + 18 >> 1] >= HEAPU16[$5 + 34 >> 1])) {
      HEAP16[$5 + 18 >> 1] = HEAPU16[$5 + 18 >> 1] + 1;
      continue;
     }
     break;
    }
    if (HEAPU16[$5 + 18 >> 1] > HEAPU16[$5 + 22 >> 1]) {
     HEAP16[$5 + 22 >> 1] = HEAPU16[$5 + 18 >> 1];
     HEAP16[$5 + 20 >> 1] = HEAPU16[$5 + 10 >> 1];
     if (HEAPU16[$5 + 18 >> 1] == HEAPU16[$5 + 34 >> 1]) {
      break label$2;
     }
    }
   }
   HEAP16[$5 + 10 >> 1] = HEAPU16[$5 + 10 >> 1] - 1;
   continue;
  }
  break;
 }
 HEAP32[$5 >> 2] = 15;
 label$7: {
  if (HEAPU16[$5 + 22 >> 1] > 1) {
   HEAP16[HEAP32[$5 + 28 >> 2] >> 1] = HEAPU16[$5 + 22 >> 1];
   HEAP16[$5 + 46 >> 1] = HEAPU16[$5 + 36 >> 1] - HEAPU16[$5 + 20 >> 1];
   break label$7;
  }
  HEAP16[$5 + 46 >> 1] = 65535;
 }
 return HEAPU16[$5 + 46 >> 1];
}

function tflite__ops__micro__pooling___28anonymous_20namespace_29__MaxEvalFloat_28TfLiteContext__2c_20TfLiteNode__2c_20TfLitePoolParams__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData_20const__2c_20TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 128 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 124 >> 2] = $0;
 HEAP32[$6 + 120 >> 2] = $1;
 HEAP32[$6 + 116 >> 2] = $2;
 HEAP32[$6 + 112 >> 2] = $3;
 HEAP32[$6 + 108 >> 2] = $4;
 HEAP32[$6 + 104 >> 2] = $5;
 HEAP32[$6 + 68 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 8 >> 2];
 HEAP32[$6 + 72 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 4 >> 2];
 HEAP32[$6 + 76 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 16 >> 2];
 HEAP32[$6 + 80 >> 2] = HEAP32[HEAP32[$6 + 116 >> 2] + 12 >> 2];
 HEAP16[$6 + 60 >> 1] = HEAP32[HEAP32[$6 + 112 >> 2] + 4 >> 2];
 HEAP16[$6 + 58 >> 1] = HEAP32[HEAP32[$6 + 112 >> 2] >> 2];
 HEAPF32[$6 + 92 >> 2] = HEAPF32[HEAP32[$6 + 112 >> 2] + 24 >> 2];
 HEAPF32[$6 + 96 >> 2] = HEAPF32[HEAP32[$6 + 112 >> 2] + 28 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 32 | 0, HEAP32[$6 + 108 >> 2]);
 $0 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$6 + 108 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($6 + 8 | 0, HEAP32[$6 + 104 >> 2]);
 tflite__reference_ops__MaxPool_28tflite__PoolParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($6 + 56 | 0, $6 + 32 | 0, $0, $6 + 8 | 0, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$6 + 104 >> 2]));
 tflite__RuntimeShape___RuntimeShape_28_29($6 + 8 | 0);
 tflite__RuntimeShape___RuntimeShape_28_29($6 + 32 | 0);
 __stack_pointer = $6 + 128 | 0;
}

function jswrap_espruino_convolve($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 176 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 164 >> 2] = $0;
 HEAP32[$3 + 160 >> 2] = $1;
 HEAP32[$3 + 156 >> 2] = $2;
 label$1: {
  label$2: {
   if (jsvIsIterable(HEAP32[$3 + 164 >> 2]) & 1) {
    if (jsvIsIterable(HEAP32[$3 + 160 >> 2]) & 1) {
     break label$2;
    }
   }
   $0 = HEAP32[$3 + 164 >> 2];
   HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 160 >> 2];
   HEAP32[$3 >> 2] = $0;
   jsExceptionHere(1, 119360, $3);
   HEAPF64[$3 + 168 >> 3] = nan;
   break label$1;
  }
  HEAPF64[$3 + 144 >> 3] = 0;
  jsvIteratorNew($3 + 80 | 0, HEAP32[$3 + 164 >> 2], 1);
  jsvIteratorNew($3 + 16 | 0, HEAP32[$3 + 160 >> 2], 1);
  HEAP32[$3 + 12 >> 2] = jsvGetLength(HEAP32[$3 + 160 >> 2]);
  HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 156 >> 2] % HEAP32[$3 + 12 >> 2];
  if (HEAP32[$3 + 156 >> 2] < 0) {
   HEAP32[$3 + 156 >> 2] = HEAP32[$3 + 12 >> 2] + HEAP32[$3 + 156 >> 2];
  }
  while (1) {
   $0 = HEAP32[$3 + 156 >> 2];
   HEAP32[$3 + 156 >> 2] = $0 - 1;
   if (($0 | 0) > 0) {
    jsvIteratorNext($3 + 16 | 0);
    continue;
   }
   break;
  }
  while (1) {
   if (jsvIteratorHasElement($3 + 80 | 0) & 1) {
    HEAPF64[$3 + 144 >> 3] = jsvIteratorGetFloatValue($3 + 80 | 0) * jsvIteratorGetFloatValue($3 + 16 | 0) + HEAPF64[$3 + 144 >> 3];
    jsvIteratorNext($3 + 80 | 0);
    jsvIteratorNext($3 + 16 | 0);
    if (!(jsvIteratorHasElement($3 + 16 | 0) & 1)) {
     jsvIteratorFree($3 + 16 | 0);
     jsvIteratorNew($3 + 16 | 0, HEAP32[$3 + 160 >> 2], 1);
    }
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 80 | 0);
  jsvIteratorFree($3 + 16 | 0);
  HEAPF64[$3 + 168 >> 3] = HEAPF64[$3 + 144 >> 3];
 }
 __stack_pointer = $3 + 176 | 0;
 return +HEAPF64[$3 + 168 >> 3];
}

function __stdio_write($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 $3 = HEAP32[$0 + 28 >> 2];
 HEAP32[$4 + 16 >> 2] = $3;
 $5 = HEAP32[$0 + 20 >> 2];
 HEAP32[$4 + 28 >> 2] = $2;
 HEAP32[$4 + 24 >> 2] = $1;
 $1 = $5 - $3 | 0;
 HEAP32[$4 + 20 >> 2] = $1;
 $7 = $1 + $2 | 0;
 $3 = $4 + 16 | 0;
 $8 = 2;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     if (__wasi_syscall_ret(__wasi_fd_write(HEAP32[$0 + 60 >> 2], $4 + 16 | 0, 2, $4 + 12 | 0) | 0)) {
      $5 = $3;
      break label$4;
     }
     while (1) {
      $1 = HEAP32[$4 + 12 >> 2];
      if (($7 | 0) == ($1 | 0)) {
       break label$3;
      }
      if (($1 | 0) < 0) {
       $5 = $3;
       break label$2;
      }
      $6 = HEAP32[$3 + 4 >> 2];
      $9 = $6 >>> 0 < $1 >>> 0;
      $5 = ($9 << 3) + $3 | 0;
      $6 = $1 - ($9 ? $6 : 0) | 0;
      HEAP32[$5 >> 2] = $6 + HEAP32[$5 >> 2];
      $3 = ($9 ? 12 : 4) + $3 | 0;
      HEAP32[$3 >> 2] = HEAP32[$3 >> 2] - $6;
      $7 = $7 - $1 | 0;
      $3 = $5;
      $8 = $8 - $9 | 0;
      if (!__wasi_syscall_ret(__wasi_fd_write(HEAP32[$0 + 60 >> 2], $3 | 0, $8 | 0, $4 + 12 | 0) | 0)) {
       continue;
      }
      break;
     }
    }
    if (($7 | 0) != -1) {
     break label$2;
    }
   }
   $1 = HEAP32[$0 + 44 >> 2];
   HEAP32[$0 + 28 >> 2] = $1;
   HEAP32[$0 + 20 >> 2] = $1;
   HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 48 >> 2] + $1;
   $1 = $2;
   break label$1;
  }
  HEAP32[$0 + 28 >> 2] = 0;
  HEAP32[$0 + 16 >> 2] = 0;
  HEAP32[$0 + 20 >> 2] = 0;
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] | 32;
  $1 = 0;
  if (($8 | 0) == 2) {
   break label$1;
  }
  $1 = $2 - HEAP32[$5 + 4 >> 2] | 0;
 }
 __stack_pointer = $4 + 32 | 0;
 return $1 | 0;
}

function tflite__ops__micro__activations__SoftmaxEval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0);
 HEAP32[$2 + 12 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0);
 label$1: {
  if (!HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 8 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2];
 label$2: {
  label$3: {
   switch (HEAP32[HEAP32[$2 + 16 >> 2] + 8 >> 2] - 1 | 0) {
   case 0:
    tflite__ops__micro__activations__SoftmaxFloat_28TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20tflite__SoftmaxParams_20const__29(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
    HEAP32[$2 + 28 >> 2] = 0;
    break label$2;

   case 2:
   case 8:
    tflite__ops__micro__activations__SoftmaxQuantized_28TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20tflite__SoftmaxParams_20const__29(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
    HEAP32[$2 + 28 >> 2] = 0;
    break label$2;

   default:
    break label$3;
   }
  }
  $0 = HEAP32[HEAP32[$2 + 24 >> 2] + 20 >> 2];
  $1 = HEAP32[$2 + 24 >> 2];
  $3 = TfLiteTypeGetName(HEAP32[HEAP32[$2 + 16 >> 2] + 8 >> 2]);
  HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 16 >> 2] + 8 >> 2];
  HEAP32[$2 >> 2] = $3;
  FUNCTION_TABLE[$0 | 0]($1, 140819, $2);
  HEAP32[$2 + 28 >> 2] = 1;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jsvIteratorGetIntegerValue($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  label$2: {
   switch (HEAP32[HEAP32[$1 + 8 >> 2] >> 2] - 1 | 0) {
   case 3:
    label$7: {
     if (!(jsvIsNameInt(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) & 1)) {
      break label$7;
     }
     if ((jsvGetInteger(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) | 0) != HEAP32[HEAP32[$1 + 8 >> 2] + 12 >> 2]) {
      break label$7;
     }
     HEAP32[$1 + 12 >> 2] = jsvGetFirstChildSigned(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) << 16 >> 16;
     break label$1;
    }
    label$8: {
     if (!(jsvIsIntegerish(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) & 1)) {
      break label$8;
     }
     if ((jsvGetInteger(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) | 0) != HEAP32[HEAP32[$1 + 8 >> 2] + 12 >> 2]) {
      break label$8;
     }
     HEAP32[$1 + 12 >> 2] = jsvGetIntegerAndUnLock(jsvObjectIteratorGetValue_1(HEAP32[$1 + 8 >> 2] + 4 | 0));
     break label$1;
    }
    HEAP32[$1 + 12 >> 2] = 0;
    break label$1;

   case 1:
    if (jsvIsNameInt(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) & 1) {
     HEAP32[$1 + 12 >> 2] = jsvGetFirstChildSigned(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) << 16 >> 16;
     break label$1;
    }
    HEAP32[$1 + 12 >> 2] = jsvGetIntegerAndUnLock(jsvObjectIteratorGetValue_1(HEAP32[$1 + 8 >> 2] + 4 | 0));
    break label$1;

   case 0:
    HEAP32[$1 + 12 >> 2] = jsvStringIteratorGetChar_2(HEAP32[$1 + 8 >> 2] + 4 | 0) << 24 >> 24;
    break label$1;

   case 2:
    HEAP32[$1 + 12 >> 2] = jsvArrayBufferIteratorGetIntegerValue(HEAP32[$1 + 8 >> 2] + 4 | 0);
    break label$1;

   default:
    break label$2;
   }
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jspeFactorArray() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 32 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 label$1: {
  if ((HEAP32[91094] & 63) == 1) {
   HEAP32[$0 + 20 >> 2] = jsvNewEmptyArray();
   if (!HEAP32[$0 + 20 >> 2]) {
    jspSetError(0);
    HEAP32[$0 + 28 >> 2] = 0;
    break label$1;
   }
  }
  if (!(jslMatch(91) & 1)) {
   HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 20 >> 2];
   break label$1;
  }
  while (1) {
   $1 = 0;
   $1 = HEAP32[91094] & 80 ? $1 : HEAP16[HEAP32[49079] + 2 >> 1] != 93;
   if ($1) {
    label$8: {
     if ((HEAP32[91094] & 63) == 1) {
      if (HEAP16[HEAP32[49079] + 2 >> 1] != 44) {
       $1 = jsvSkipNameAndUnLock(jspeAssignmentExpression());
       HEAP32[$0 + 16 >> 2] = $1;
       HEAP32[$0 + 16 >> 2] = $1;
       HEAP32[$0 + 12 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(HEAP32[$0 + 24 >> 2]), HEAP32[$0 + 16 >> 2]);
       if (HEAP32[$0 + 12 >> 2]) {
        jsvAddName(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 12 >> 2]);
        jsvUnLock(HEAP32[$0 + 12 >> 2]);
       }
       jsvUnLock(HEAP32[$0 + 16 >> 2]);
      }
      break label$8;
     }
     jsvUnLock(jspeAssignmentExpression());
    }
    if (HEAP16[HEAP32[49079] + 2 >> 1] != 93) {
     if (!(jslMatch(44) & 1)) {
      HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 20 >> 2];
      break label$1;
     }
    }
    HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[$0 + 20 >> 2]) {
   jsvSetArrayLength(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 24 >> 2], 0);
  }
  if (!(jslMatch(93) & 1)) {
   HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 20 >> 2];
   break label$1;
  }
  HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 20 >> 2];
 }
 __stack_pointer = $0 + 32 | 0;
 return HEAP32[$0 + 28 >> 2];
}

function jswrap_io_digitalWrite($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP32[$2 + 40 >> 2] = $1;
 label$1: {
  if (jsvIsBoolean(HEAP32[$2 + 40 >> 2]) & 1) {
   HEAP32[$2 + 36 >> 2] = jsvGetBool(HEAP32[$2 + 40 >> 2]) & 1 ? -1 : 0;
   break label$1;
  }
  HEAP32[$2 + 36 >> 2] = jsvGetInteger(HEAP32[$2 + 40 >> 2]);
 }
 label$3: {
  if (jsvIsArray(HEAP32[$2 + 44 >> 2]) & 1) {
   HEAP16[$2 + 34 >> 1] = jsvGetLastChild(HEAP32[$2 + 44 >> 2]);
   while (1) {
    if (HEAPU16[$2 + 34 >> 1]) {
     HEAP32[$2 + 28 >> 2] = jsvLock(HEAPU16[$2 + 34 >> 1]);
     HEAP32[$2 + 24 >> 2] = jsvSkipName(HEAP32[$2 + 28 >> 2]);
     jshPinOutput(jshGetPinFromVar(HEAP32[$2 + 24 >> 2]) & 255, HEAP32[$2 + 36 >> 2] & 1);
     jsvUnLock(HEAP32[$2 + 24 >> 2]);
     HEAP16[$2 + 34 >> 1] = jsvGetPrevSibling(HEAP32[$2 + 28 >> 2]);
     jsvUnLock(HEAP32[$2 + 28 >> 2]);
     HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 36 >> 2] >> 1;
     continue;
    }
    break;
   }
   break label$3;
  }
  label$7: {
   if (jsvIsObject(HEAP32[$2 + 44 >> 2]) & 1) {
    HEAP32[$2 + 20 >> 2] = jspGetNamedField(HEAP32[$2 + 44 >> 2], 131969, 0);
    label$9: {
     if (jsvIsFunction(HEAP32[$2 + 20 >> 2]) & 1) {
      HEAP32[$2 + 16 >> 2] = jsvNewFromInteger(HEAP32[$2 + 36 >> 2]);
      jsvUnLock2(jspeFunctionCall(HEAP32[$2 + 20 >> 2], 0, HEAP32[$2 + 44 >> 2], 0, 1, $2 + 16 | 0), HEAP32[$2 + 16 >> 2]);
      break label$9;
     }
     jsExceptionHere(1, 128480, 0);
    }
    jsvUnLock(HEAP32[$2 + 20 >> 2]);
    break label$7;
   }
   HEAP8[$2 + 15 | 0] = jshGetPinFromVar(HEAP32[$2 + 44 >> 2]);
   jshPinOutput(HEAPU8[$2 + 15 | 0], HEAP32[$2 + 36 >> 2] != 0);
  }
 }
 __stack_pointer = $2 + 48 | 0;
}

function escapeCharacter($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP8[$3 + 19 | 0] = $2;
 label$1: {
  if (HEAP32[$3 + 24 >> 2] == 10) {
   HEAP32[$3 + 28 >> 2] = 128554;
   break label$1;
  }
  if (HEAP32[$3 + 24 >> 2] == 9) {
   HEAP32[$3 + 28 >> 2] = 117952;
   break label$1;
  }
  if (HEAP32[$3 + 24 >> 2] == 8) {
   HEAP32[$3 + 28 >> 2] = 135731;
   break label$1;
  }
  if (!(HEAP8[$3 + 19 | 0] & 1 | HEAP32[$3 + 24 >> 2] != 11)) {
   HEAP32[$3 + 28 >> 2] = 116788;
   break label$1;
  }
  if (HEAP32[$3 + 24 >> 2] == 12) {
   HEAP32[$3 + 28 >> 2] = 130148;
   break label$1;
  }
  if (HEAP32[$3 + 24 >> 2] == 13) {
   HEAP32[$3 + 28 >> 2] = 121468;
   break label$1;
  }
  if (HEAP32[$3 + 24 >> 2] == 92) {
   HEAP32[$3 + 28 >> 2] = 136254;
   break label$1;
  }
  if (HEAP32[$3 + 24 >> 2] == 34) {
   HEAP32[$3 + 28 >> 2] = 145506;
   break label$1;
  }
  if (!(HEAP32[$3 + 20 >> 2] <= 55 & HEAP32[$3 + 20 >> 2] >= 48 | (HEAP8[$3 + 19 | 0] & 1 | HEAP32[$3 + 24 >> 2] >= 8))) {
   HEAP8[364328] = 92;
   HEAP8[364329] = HEAP32[$3 + 24 >> 2] + 48;
   HEAP8[364330] = 0;
   HEAP32[$3 + 28 >> 2] = 364328;
   break label$1;
  }
  if (!(HEAP32[$3 + 24 >> 2] < 127 & HEAP32[$3 + 24 >> 2] >= 32)) {
   HEAP32[$3 + 12 >> 2] = 364328;
   $0 = 1;
   $0 = HEAP8[$3 + 19 | 0] & 1 ? $0 : HEAP32[$3 + 24 >> 2] > 255;
   HEAP32[$3 + 12 >> 2] = numericEscapeChar(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 24 >> 2], $0);
   HEAP8[HEAP32[$3 + 12 >> 2]] = 0;
   HEAP32[$3 + 28 >> 2] = 364328;
   break label$1;
  }
  HEAP8[364329] = 0;
  HEAP8[364328] = HEAP32[$3 + 24 >> 2];
  HEAP32[$3 + 28 >> 2] = 364328;
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jswrap_math_pow($0, $1) {
 $0 = +$0;
 $1 = +$1;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAPF64[$2 + 32 >> 3] = $0;
 HEAPF64[$2 + 24 >> 3] = $1;
 $0 = HEAPF64[$2 + 24 >> 3];
 label$1: {
  if (Math_abs($0) < 2147483648) {
   $3 = ~~$0;
   break label$1;
  }
  $3 = -2147483648;
 }
 HEAP32[$2 + 12 >> 2] = $3;
 label$3: {
  if (!(HEAP32[$2 + 12 >> 2] < 0 | HEAP32[$2 + 12 >> 2] >= 10 | HEAPF64[$2 + 24 >> 3] != +HEAP32[$2 + 12 >> 2])) {
   if (!HEAP32[$2 + 12 >> 2]) {
    HEAPF64[$2 + 40 >> 3] = 1;
    break label$3;
   }
   HEAPF64[$2 + 16 >> 3] = HEAPF64[$2 + 32 >> 3];
   while (1) {
    if (HEAP32[$2 + 12 >> 2] > 1) {
     HEAPF64[$2 + 16 >> 3] = HEAPF64[$2 + 16 >> 3] * HEAPF64[$2 + 32 >> 3];
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] - 1;
     continue;
    }
    break;
   }
   HEAPF64[$2 + 40 >> 3] = HEAPF64[$2 + 16 >> 3];
   break label$3;
  }
  label$8: {
   label$9: {
    if (!(HEAPF64[$2 + 32 >> 3] < 0)) {
     break label$9;
    }
    if (jswrap_math_mod(HEAPF64[$2 + 24 >> 3], 1) != 0) {
     break label$9;
    }
    label$10: {
     if (jswrap_math_mod(HEAPF64[$2 + 24 >> 3], 2) == 0) {
      HEAPF64[$2 + 16 >> 3] = exp(log(-HEAPF64[$2 + 32 >> 3]) * HEAPF64[$2 + 24 >> 3]);
      break label$10;
     }
     HEAPF64[$2 + 16 >> 3] = -exp(log(-HEAPF64[$2 + 32 >> 3]) * HEAPF64[$2 + 24 >> 3]);
    }
    break label$8;
   }
   label$12: {
    if (!(HEAPF64[$2 + 24 >> 3] <= 0 ? 0 : HEAPF64[$2 + 32 >> 3] == 0)) {
     HEAPF64[$2 + 16 >> 3] = exp(log(HEAPF64[$2 + 32 >> 3]) * HEAPF64[$2 + 24 >> 3]);
     break label$12;
    }
    HEAPF64[$2 + 16 >> 3] = 0;
   }
  }
  HEAPF64[$2 + 40 >> 3] = HEAPF64[$2 + 16 >> 3];
 }
 __stack_pointer = $2 + 48 | 0;
 return +HEAPF64[$2 + 40 >> 3];
}

function jsvArrayJoin($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 144 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 136 >> 2] = $0;
 HEAP32[$3 + 132 >> 2] = $1;
 HEAP8[$3 + 131 | 0] = $2;
 HEAP32[$3 + 124 >> 2] = jsvNewFromEmptyString_1();
 label$1: {
  if (!HEAP32[$3 + 124 >> 2]) {
   HEAP32[$3 + 140 >> 2] = 0;
   break label$1;
  }
  jsvIteratorNew($3 - -64 | 0, HEAP32[$3 + 136 >> 2], 1);
  jsvStringIteratorNew($3 + 24 | 0, HEAP32[$3 + 124 >> 2], 0);
  HEAP8[$3 + 23 | 0] = 1;
  while (1) {
   $0 = 0;
   if (!(jspIsInterrupted() & 1)) {
    $0 = jsvIteratorHasElement($3 - -64 | 0);
   }
   if ($0 & 1) {
    HEAP32[$3 + 16 >> 2] = jsvIteratorGetKey($3 - -64 | 0);
    if (jsvIsInt(HEAP32[$3 + 16 >> 2]) & 1) {
     if (!(!HEAP32[$3 + 132 >> 2] | HEAP8[$3 + 23 | 0] & 1)) {
      jsvStringIteratorAppendString($3 + 24 | 0, HEAP32[$3 + 132 >> 2], 0, 2147483647);
     }
     HEAP8[$3 + 23 | 0] = 0;
     HEAP32[$3 + 12 >> 2] = jsvIteratorGetValue($3 - -64 | 0);
     label$8: {
      if (!HEAP32[$3 + 12 >> 2]) {
       break label$8;
      }
      if (HEAP8[$3 + 131 | 0] & 1) {
       if (jsvIsNull(HEAP32[$3 + 12 >> 2]) & 1) {
        break label$8;
       }
      }
      HEAP32[$3 + 8 >> 2] = jsvAsString(HEAP32[$3 + 12 >> 2]);
      if (HEAP32[$3 + 8 >> 2]) {
       jsvStringIteratorAppendString($3 + 24 | 0, HEAP32[$3 + 8 >> 2], 0, 2147483647);
       jsvUnLock(HEAP32[$3 + 8 >> 2]);
      }
     }
     jsvUnLock(HEAP32[$3 + 12 >> 2]);
    }
    jsvUnLock(HEAP32[$3 + 16 >> 2]);
    jsvIteratorNext($3 - -64 | 0);
    continue;
   }
   break;
  }
  jsvIteratorFree($3 - -64 | 0);
  jsvStringIteratorFree_1($3 + 24 | 0);
  HEAP32[$3 + 140 >> 2] = HEAP32[$3 + 124 >> 2];
 }
 __stack_pointer = $3 + 144 | 0;
 return HEAP32[$3 + 140 >> 2];
}

function jswrap_arraybufferview_subarray($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1: {
  if (!(jsvIsArrayBuffer(HEAP32[$3 + 24 >> 2]) & 1)) {
   jsExceptionHere(1, 116661, 0);
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 16 >> 2]);
  if (!(jsvIsNumeric(HEAP32[$3 + 16 >> 2]) & 1)) {
   HEAP32[$3 + 12 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 24 >> 2]);
  }
  if (HEAP32[$3 + 20 >> 2] < 0) {
   HEAP32[$3 + 20 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 24 >> 2]) + HEAP32[$3 + 20 >> 2];
  }
  if (HEAP32[$3 + 12 >> 2] < 0) {
   HEAP32[$3 + 12 >> 2] = jsvGetArrayBufferLength(HEAP32[$3 + 24 >> 2]) + HEAP32[$3 + 12 >> 2];
  }
  if (HEAP32[$3 + 12 >> 2] < 0) {
   HEAP32[$3 + 12 >> 2] = 0;
  }
  if (HEAP32[$3 + 20 >> 2] > HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 20 >> 2] = 0;
   HEAP32[$3 + 12 >> 2] = 0;
  }
  HEAP8[$3 + 11 | 0] = HEAPU8[HEAP32[$3 + 24 >> 2] + 5 | 0];
  if (HEAP32[$3 + 20 >> 2] == HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = jsvNewTypedArray(HEAPU8[$3 + 11 | 0], 0);
   break label$1;
  }
  HEAP32[$3 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$3 + 24 >> 2]) & 65535);
  $0 = HEAP32[$3 + 24 >> 2];
  HEAP32[$3 >> 2] = jswrap_typedarray_constructor(HEAPU8[$3 + 11 | 0], HEAP32[$3 + 4 >> 2], Math_imul(HEAP32[$3 + 20 >> 2], HEAPU8[$3 + 11 | 0] & 15) + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8) | 0, HEAP32[$3 + 12 >> 2] - HEAP32[$3 + 20 >> 2] | 0);
  jsvUnLock(HEAP32[$3 + 4 >> 2]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 >> 2];
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jsExceptionHere($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 label$1: {
  if (jspHasError() & 1) {
   break label$1;
  }
  jsiConsoleRemoveInputLine();
  HEAP32[$3 + 52 >> 2] = jsvNewFromEmptyString_2();
  if (!HEAP32[$3 + 52 >> 2]) {
   jspSetError(0);
   break label$1;
  }
  jsvStringIteratorNew($3 + 16 | 0, HEAP32[$3 + 52 >> 2], 0);
  jsvStringIteratorGotoEnd($3 + 16 | 0);
  HEAP32[$3 + 12 >> 2] = 2;
  HEAP32[$3 + 8 >> 2] = $2;
  vcbprintf(HEAP32[$3 + 12 >> 2], $3 + 16 | 0, HEAP32[$3 + 56 >> 2], HEAP32[$3 + 8 >> 2]);
  jsvStringIteratorFree_3($3 + 16 | 0);
  if (HEAP32[$3 + 60 >> 2]) {
   HEAP32[$3 + 4 >> 2] = 0;
   label$4: {
    if (HEAP32[$3 + 60 >> 2] == 1) {
     HEAP32[$3 + 4 >> 2] = jswrap_error_constructor(HEAP32[$3 + 52 >> 2]);
     break label$4;
    }
    label$6: {
     if (HEAP32[$3 + 60 >> 2] == 2) {
      HEAP32[$3 + 4 >> 2] = jswrap_syntaxerror_constructor(HEAP32[$3 + 52 >> 2]);
      break label$6;
     }
     label$8: {
      if (HEAP32[$3 + 60 >> 2] == 3) {
       HEAP32[$3 + 4 >> 2] = jswrap_typeerror_constructor(HEAP32[$3 + 52 >> 2]);
       break label$8;
      }
      label$10: {
       if (HEAP32[$3 + 60 >> 2] == 4) {
        HEAP32[$3 + 4 >> 2] = jswrap_internalerror_constructor(HEAP32[$3 + 52 >> 2]);
        break label$10;
       }
       if (HEAP32[$3 + 60 >> 2] == 5) {
        HEAP32[$3 + 4 >> 2] = jswrap_referenceerror_constructor(HEAP32[$3 + 52 >> 2]);
       }
      }
     }
    }
   }
   jsvUnLock(HEAP32[$3 + 52 >> 2]);
   HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 4 >> 2];
  }
  jspSetException(HEAP32[$3 + 52 >> 2]);
  jsvUnLock(HEAP32[$3 + 52 >> 2]);
 }
 __stack_pointer = $3 - -64 | 0;
}

function jsvRemoveChild($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP16[$2 + 22 >> 1] = jsvGetRef(HEAP32[$2 + 24 >> 2]);
 HEAP8[$2 + 21 | 0] = 0;
 if ((jsvGetFirstChild(HEAP32[$2 + 28 >> 2]) & 65535) == HEAPU16[$2 + 22 >> 1]) {
  jsvSetFirstChild(HEAP32[$2 + 28 >> 2], jsvGetNextSibling(HEAP32[$2 + 24 >> 2]) & 65535);
  HEAP8[$2 + 21 | 0] = 1;
 }
 if ((jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535) == HEAPU16[$2 + 22 >> 1]) {
  jsvSetLastChild(HEAP32[$2 + 28 >> 2], jsvGetPrevSibling(HEAP32[$2 + 24 >> 2]) & 65535);
  HEAP8[$2 + 21 | 0] = 1;
  if (jsvIsArray(HEAP32[$2 + 28 >> 2]) & 1) {
   HEAP32[$2 + 16 >> 2] = 0;
   if (jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535) {
    HEAP32[$2 + 16 >> 2] = jsvGetIntegerAndUnLock(jsvLock(jsvGetLastChild(HEAP32[$2 + 28 >> 2]) & 65535)) + 1;
   }
   jsvSetArrayLength(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2], 0);
  }
 }
 if (jsvGetPrevSibling(HEAP32[$2 + 24 >> 2]) & 65535) {
  HEAP32[$2 + 12 >> 2] = jsvLock(jsvGetPrevSibling(HEAP32[$2 + 24 >> 2]) & 65535);
  jsvSetNextSibling(HEAP32[$2 + 12 >> 2], jsvGetNextSibling(HEAP32[$2 + 24 >> 2]) & 65535);
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  HEAP8[$2 + 21 | 0] = 1;
 }
 if (jsvGetNextSibling(HEAP32[$2 + 24 >> 2]) & 65535) {
  HEAP32[$2 + 8 >> 2] = jsvLock(jsvGetNextSibling(HEAP32[$2 + 24 >> 2]) & 65535);
  jsvSetPrevSibling(HEAP32[$2 + 8 >> 2], jsvGetPrevSibling(HEAP32[$2 + 24 >> 2]) & 65535);
  jsvUnLock(HEAP32[$2 + 8 >> 2]);
  HEAP8[$2 + 21 | 0] = 1;
 }
 jsvSetPrevSibling(HEAP32[$2 + 24 >> 2], 0);
 jsvSetNextSibling(HEAP32[$2 + 24 >> 2], 0);
 if (HEAP8[$2 + 21 | 0] & 1) {
  jsvUnRef(HEAP32[$2 + 24 >> 2]);
 }
 __stack_pointer = $2 + 32 | 0;
}

function jsiSoftKill() {
 var $0 = 0;
 $0 = __stack_pointer + -64 | 0;
 __stack_pointer = $0;
 jsiPacketFileEnd();
 jsiPacketExit();
 jsiExecuteEventCallbackOn(137917, 128734, 0, 0);
 jsiCheckErrors();
 HEAP32[91106] = 0;
 jsiInputLineCursorMoved();
 jsvUnLock(HEAP32[91104]);
 HEAP32[91104] = 0;
 jswKill();
 jstReset();
 if (HEAP32[91101]) {
  jsvUnLock(HEAP32[91101]);
  HEAP32[91101] = 0;
 }
 if (HEAPU16[182204]) {
  jsvUnRefRef(HEAPU16[182204]);
  HEAP16[182204] = 0;
 }
 if (HEAPU16[182205]) {
  HEAP32[$0 + 60 >> 2] = jsvLock(HEAPU16[182205]);
  jsvObjectIteratorNew($0 + 56 | 0, HEAP32[$0 + 60 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_3($0 + 56 | 0) & 1) {
    HEAP32[$0 + 52 >> 2] = jsvObjectIteratorGetValue_3($0 + 56 | 0);
    HEAP32[$0 + 48 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 52 >> 2], 128488);
    jshPinWatch(jshGetPinFromVar(HEAP32[$0 + 48 >> 2]) & 255, 0, 0);
    jsvUnLock2(HEAP32[$0 + 48 >> 2], HEAP32[$0 + 52 >> 2]);
    jsvObjectIteratorNext($0 + 56 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_3($0 + 56 | 0);
  jsvUnRef(HEAP32[$0 + 60 >> 2]);
  jsvUnLock(HEAP32[$0 + 60 >> 2]);
  HEAP16[182205] = 0;
 }
 if (HEAPU8[196320]) {
  jsvObjectSetChildAndUnLock(HEAP32[91087], 120167, jsvNewFromInteger(HEAPU8[196320]));
 }
 HEAP32[$0 + 44 >> 2] = jsvNewFromEmptyString_5();
 if (HEAP32[$0 + 44 >> 2]) {
  jsvStringIteratorNew($0 + 8 | 0, HEAP32[$0 + 44 >> 2], 0);
  jsiDumpHardwareInitialisation(2, $0 + 8 | 0, 0);
  jsvStringIteratorFree_5($0 + 8 | 0);
  jsvObjectSetChild(HEAP32[91087], 117678, HEAP32[$0 + 44 >> 2]);
  jsvUnLock(HEAP32[$0 + 44 >> 2]);
 }
 HEAP16[182206] = HEAPU16[182206] & -2049;
 HEAP16[182206] = HEAPU16[182206] & -4097;
 __stack_pointer = $0 - -64 | 0;
}

function jswrap_string_padX($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP8[$4 + 15 | 0] = $3;
 label$1: {
  label$2: {
   if (jsvIsString(HEAP32[$4 + 24 >> 2]) & 1) {
    if ((jsvGetStringLength(HEAP32[$4 + 24 >> 2]) | 0) < HEAP32[$4 + 20 >> 2]) {
     break label$2;
    }
   }
   HEAP32[$4 + 28 >> 2] = jsvLockAgain(HEAP32[$4 + 24 >> 2]);
   break label$1;
  }
  HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 20 >> 2] - jsvGetStringLength(HEAP32[$4 + 24 >> 2]);
  label$4: {
   if (HEAP8[$4 + 15 | 0] & 1) {
    $0 = jsvNewFromEmptyString_8();
    break label$4;
   }
   $0 = jsvNewFromStringVarComplete(HEAP32[$4 + 24 >> 2]);
  }
  HEAP32[$4 + 4 >> 2] = $0;
  if (!HEAP32[$4 + 4 >> 2]) {
   HEAP32[$4 + 28 >> 2] = 0;
   break label$1;
  }
  label$7: {
   if (HEAP32[$4 + 16 >> 2]) {
    $0 = jsvAsString(HEAP32[$4 + 16 >> 2]);
    break label$7;
   }
   $0 = jsvNewFromString(146437);
  }
  HEAP32[$4 + 16 >> 2] = $0;
  HEAP32[$4 >> 2] = jsvGetStringLength(HEAP32[$4 + 16 >> 2]);
  while (1) {
   if (HEAP32[$4 + 8 >> 2] > 0) {
    $1 = HEAP32[$4 + 4 >> 2];
    $2 = HEAP32[$4 + 16 >> 2];
    if (HEAP32[$4 >> 2] > HEAP32[$4 + 8 >> 2]) {
     $0 = HEAP32[$4 + 8 >> 2];
    } else {
     $0 = HEAP32[$4 >> 2];
    }
    jsvAppendStringVar($1, $2, 0, $0);
    HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] - HEAP32[$4 >> 2];
    continue;
   }
   break;
  }
  if (HEAP8[$4 + 15 | 0] & 1) {
   jsvAppendStringVarComplete(HEAP32[$4 + 4 >> 2], HEAP32[$4 + 24 >> 2]);
  }
  jsvUnLock(HEAP32[$4 + 16 >> 2]);
  HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 4 >> 2];
 }
 __stack_pointer = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}

function jsiExecuteEventCallbackInner($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 label$1: {
  if (!HEAP32[$4 + 36 >> 2]) {
   HEAP8[$4 + 47 | 0] = 0;
   break label$1;
  }
  HEAP8[$4 + 27 | 0] = 1;
  label$3: {
   if (jsvIsArray(HEAP32[$4 + 36 >> 2]) & 1) {
    jsvObjectIteratorNew($4 + 16 | 0, HEAP32[$4 + 36 >> 2]);
    while (1) {
     $0 = 0;
     label$6: {
      if (!(HEAP8[$4 + 27 | 0] & 1)) {
       break label$6;
      }
      $0 = 0;
      if (!(jsvObjectIteratorHasValue_3($4 + 16 | 0) & 1)) {
       break label$6;
      }
      $0 = (HEAPU16[182206] & 16384) != 0 ^ -1;
     }
     if ($0 & 1) {
      HEAP32[$4 + 12 >> 2] = jsvObjectIteratorGetValue_3($4 + 16 | 0);
      jsvObjectIteratorNext($4 + 16 | 0);
      HEAP8[$4 + 27 | 0] = jsiExecuteEventCallbackInner(HEAP32[$4 + 40 >> 2], HEAP32[$4 + 12 >> 2], HEAP32[$4 + 32 >> 2], HEAP32[$4 + 28 >> 2]) & 1 & (HEAP8[$4 + 27 | 0] & 1);
      jsvUnLock(HEAP32[$4 + 12 >> 2]);
      continue;
     }
     break;
    }
    jsvObjectIteratorFree_3($4 + 16 | 0);
    break label$3;
   }
   label$8: {
    if (jsvIsFunction(HEAP32[$4 + 36 >> 2]) & 1) {
     jsvUnLock(jspExecuteFunction(HEAP32[$4 + 36 >> 2], HEAP32[$4 + 40 >> 2], HEAP32[$4 + 32 >> 2], HEAP32[$4 + 28 >> 2]));
     break label$8;
    }
    label$10: {
     if (jsvIsString(HEAP32[$4 + 36 >> 2]) & 1) {
      jsvUnLock(jspEvaluateVar(HEAP32[$4 + 36 >> 2], 0, 0));
      break label$10;
     }
     jsError(131836, 0);
    }
   }
  }
  HEAP8[$4 + 47 | 0] = HEAP8[$4 + 27 | 0] & 1;
 }
 __stack_pointer = $4 + 48 | 0;
 return HEAP8[$4 + 47 | 0] & 1;
}

function jshTransmit($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 label$1: {
  if (!(HEAPU8[$2 + 15 | 0] != 17 & HEAPU8[$2 + 15 | 0] != 18)) {
   jshPushIOCharEvent((HEAPU8[$2 + 15 | 0] == 18 ? 17 : 18) & 255, HEAP8[$2 + 14 | 0]);
   break label$1;
  }
  if (HEAPU8[$2 + 15 | 0] == 20) {
   terminalSendChar(HEAP8[$2 + 14 | 0]);
   break label$1;
  }
  label$5: {
   if (HEAPU8[$2 + 15 | 0] != 21) {
    break label$5;
   }
   if (jshIsUSBSERIALConnected() & 1) {
    break label$5;
   }
   jshTransmitClearDevice(21);
   break label$1;
  }
  if (!HEAPU8[$2 + 15 | 0]) {
   break label$1;
  }
  HEAP8[$2 + 13 | 0] = HEAPU8[364484] + 1;
  if (HEAPU8[$2 + 13 | 0] == HEAPU8[364485]) {
   jsiSetBusy(2, 1);
   if (HEAPU8[$2 + 15 | 0] == 19) {
    $3 = (jsiGetConsoleDevice() & 255) == 19;
   }
   HEAP8[$2 + 12 | 0] = $3;
   while (1) {
    if (HEAPU8[$2 + 13 | 0] == HEAPU8[364485]) {
     if (jshIsInInterrupt() & 1) {
      HEAP8[364342] = HEAPU8[364342] | 2;
      break label$1;
     }
     jshBusyIdle();
     if (!(jshIsUSBSERIALConnected() & 1)) {
      jshTransmitClearDevice(21);
     }
     continue;
    }
    break;
   }
   label$12: {
    if (!(HEAP8[$2 + 12 | 0] & 1)) {
     break label$12;
    }
    if ((jsiGetConsoleDevice() & 255) == 19) {
     break label$12;
    }
    HEAP8[$2 + 15 | 0] = jsiGetConsoleDevice();
   }
   jsiSetBusy(2, 0);
  }
  HEAP8[(HEAPU8[364484] << 1) + 364560 | 0] = HEAPU8[$2 + 15 | 0];
  HEAP8[((HEAPU8[364484] << 1) + 364560 | 0) + 1 | 0] = HEAPU8[$2 + 14 | 0];
  HEAP8[364484] = HEAPU8[$2 + 13 | 0];
  jshUSARTKick(HEAPU8[$2 + 15 | 0]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function getRadix($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 10;
 if (HEAP8[HEAP32[HEAP32[$1 + 12 >> 2] >> 2]] == 48) {
  HEAP32[$1 + 8 >> 2] = 8;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
  label$2: {
   if (!(HEAP8[HEAP32[HEAP32[$1 + 12 >> 2] >> 2]] != 111 & HEAP8[HEAP32[HEAP32[$1 + 12 >> 2] >> 2]] != 79)) {
    HEAP32[$1 + 8 >> 2] = 8;
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
    break label$2;
   }
   label$5: {
    if (!(HEAP8[HEAP32[HEAP32[$1 + 12 >> 2] >> 2]] != 120 & HEAP8[HEAP32[HEAP32[$1 + 12 >> 2] >> 2]] != 88)) {
     HEAP32[$1 + 8 >> 2] = 16;
     $0 = HEAP32[$1 + 12 >> 2];
     HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
     break label$5;
    }
    label$8: {
     if (!(HEAP8[HEAP32[HEAP32[$1 + 12 >> 2] >> 2]] != 98 & HEAP8[HEAP32[HEAP32[$1 + 12 >> 2] >> 2]] != 66)) {
      HEAP32[$1 + 8 >> 2] = 2;
      $0 = HEAP32[$1 + 12 >> 2];
      HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
      break label$8;
     }
     HEAP32[$1 + 4 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
     while (1) {
      label$12: {
       if (!HEAPU8[HEAP32[$1 + 4 >> 2]]) {
        break label$12;
       }
       label$13: {
        if (!(!(HEAP8[HEAP32[$1 + 4 >> 2]] == 46 | HEAP8[HEAP32[$1 + 4 >> 2]] == 56) & HEAP8[HEAP32[$1 + 4 >> 2]] != 57)) {
         HEAP32[$1 + 8 >> 2] = 10;
         break label$13;
        }
        if (HEAP8[HEAP32[$1 + 4 >> 2]] < 48 | HEAP8[HEAP32[$1 + 4 >> 2]] > 57) {
         break label$12;
        }
       }
       HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
       continue;
      }
      break;
     }
    }
   }
  }
 }
 return HEAP32[$1 + 8 >> 2];
}

function tflite__ComputePaddingHeightWidth_28int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLitePadding_2c_20int__2c_20int__29($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) {
 var $12 = 0;
 $12 = __stack_pointer - 48 | 0;
 __stack_pointer = $12;
 HEAP32[$12 + 44 >> 2] = $1;
 HEAP32[$12 + 40 >> 2] = $2;
 HEAP32[$12 + 36 >> 2] = $3;
 HEAP32[$12 + 32 >> 2] = $4;
 HEAP32[$12 + 28 >> 2] = $5;
 HEAP32[$12 + 24 >> 2] = $6;
 HEAP32[$12 + 20 >> 2] = $7;
 HEAP32[$12 + 16 >> 2] = $8;
 HEAP32[$12 + 12 >> 2] = $9;
 HEAP32[$12 + 8 >> 2] = $10;
 HEAP32[$12 + 4 >> 2] = $11;
 $1 = tflite__ComputeOutSize_28TfLitePadding_2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$12 + 12 >> 2], HEAP32[$12 + 24 >> 2], HEAP32[$12 + 16 >> 2], HEAP32[$12 + 40 >> 2], HEAP32[$12 + 32 >> 2]);
 HEAP32[HEAP32[$12 + 4 >> 2] >> 2] = $1;
 $1 = tflite__ComputeOutSize_28TfLitePadding_2c_20int_2c_20int_2c_20int_2c_20int_29(HEAP32[$12 + 12 >> 2], HEAP32[$12 + 28 >> 2], HEAP32[$12 + 20 >> 2], HEAP32[$12 + 44 >> 2], HEAP32[$12 + 36 >> 2]);
 HEAP32[HEAP32[$12 + 8 >> 2] >> 2] = $1;
 HEAP32[$12 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = tflite__ComputePaddingWithOffset_28int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int__29(HEAP32[$12 + 44 >> 2], HEAP32[$12 + 36 >> 2], HEAP32[$12 + 28 >> 2], HEAP32[$12 + 20 >> 2], HEAP32[HEAP32[$12 + 8 >> 2] >> 2], $12);
 HEAP32[$0 + 12 >> 2] = HEAP32[$12 >> 2];
 HEAP32[$0 >> 2] = tflite__ComputePaddingWithOffset_28int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int__29(HEAP32[$12 + 40 >> 2], HEAP32[$12 + 32 >> 2], HEAP32[$12 + 24 >> 2], HEAP32[$12 + 16 >> 2], HEAP32[HEAP32[$12 + 4 >> 2] >> 2], $12);
 HEAP32[$0 + 8 >> 2] = HEAP32[$12 >> 2];
 __stack_pointer = $12 + 48 | 0;
}

function jswrap_tfmicrointerpreter_tensorToArrayBuffer($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP8[$2 + 55 | 0] = $1;
 HEAP32[$2 + 48 >> 2] = jswrap_tfmicrointerpreter_getTFMI(HEAP32[$2 + 56 >> 2]);
 HEAP32[$2 + 44 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 56 >> 2], 129322);
 tf_get($2 + 32 | 0, HEAP32[$2 + 48 >> 2], HEAP8[$2 + 55 | 0] & 1);
 label$1: {
  if (!(HEAP32[$2 + 44 >> 2] ? HEAP32[$2 + 32 >> 2] : 0)) {
   jsExceptionHere(1, 120907, 0);
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP8[$2 + 31 | 0] = 0;
  label$4: {
   label$5: {
    switch (HEAP32[$2 + 36 >> 2] - 1 | 0) {
    case 0:
     HEAP8[$2 + 31 | 0] = 36;
     break label$4;

    case 1:
     HEAP8[$2 + 31 | 0] = 20;
     break label$4;

    case 2:
     HEAP8[$2 + 31 | 0] = 1;
     break label$4;

    case 6:
     HEAP8[$2 + 31 | 0] = 18;
     break label$4;

    case 8:
     HEAP8[$2 + 31 | 0] = 17;
     break label$4;

    default:
     break label$5;
    }
   }
   HEAP32[$2 >> 2] = HEAP32[$2 + 36 >> 2];
   jsExceptionHere(3, 134530, $2);
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 20 >> 2] = jsvGetDataPointer(HEAP32[$2 + 44 >> 2], $2 + 24 | 0);
  HEAP32[$2 + 16 >> 2] = jsvNewArrayBufferFromString(HEAP32[$2 + 44 >> 2], 0);
  HEAP32[$2 + 12 >> 2] = jswrap_typedarray_constructor(HEAPU8[$2 + 31 | 0], HEAP32[$2 + 16 >> 2], HEAP32[$2 + 32 >> 2] - HEAP32[$2 + 20 >> 2] | 0, HEAPU32[$2 + 40 >> 2] / ((HEAPU8[$2 + 31 | 0] & 15) >>> 0) | 0);
  jsvUnLock2(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 44 >> 2]);
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}

function tflite__MicroAllocator__RequestScratchBufferInArena_28int_2c_20unsigned_20long_2c_20int__29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 label$1: {
  label$2: {
   $2 = HEAP32[$4 + 40 >> 2];
   if (!HEAP32[$2 + 16 >> 2]) {
    break label$2;
   }
   if (HEAP32[$2 + 16 >> 2] == (tflite__SimpleMemoryAllocator__GetTail_28_29_20const(HEAP32[$2 + 4 >> 2]) | 0)) {
    break label$2;
   }
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$2 + 8 >> 2], 140329, 0);
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
  HEAP32[$4 + 24 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 12 >> 2]]($0, 12, 4);
  if (!HEAP32[$4 + 24 >> 2]) {
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP32[$4 >> 2] = HEAP32[$4 + 36 >> 2];
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 120610, $4);
   HEAP32[$4 + 44 >> 2] = 1;
   break label$1;
  }
  HEAP32[$4 + 8 >> 2] = 0;
  HEAP32[$4 + 12 >> 2] = 0;
  HEAP32[$4 + 16 >> 2] = 0;
  $3 = HEAP32[$4 + 12 >> 2];
  $0 = HEAP32[$4 + 8 >> 2];
  $1 = $0;
  $0 = HEAP32[$4 + 24 >> 2];
  HEAP32[$0 >> 2] = $1;
  HEAP32[$0 + 4 >> 2] = $3;
  HEAP32[$0 + 8 >> 2] = HEAP32[$4 + 16 >> 2];
  HEAP32[HEAP32[$4 + 24 >> 2] + 4 >> 2] = HEAP32[$4 + 32 >> 2];
  HEAP32[HEAP32[$4 + 24 >> 2] + 8 >> 2] = HEAP32[$4 + 36 >> 2];
  HEAP32[HEAP32[$4 + 28 >> 2] >> 2] = HEAP32[$2 + 20 >> 2];
  HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] + 1;
  HEAP32[$2 + 16 >> 2] = HEAP32[$4 + 24 >> 2];
  HEAP32[$4 + 44 >> 2] = 0;
 }
 __stack_pointer = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}

function jswrap_array_fill($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 96 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 88 >> 2] = $0;
 HEAP32[$4 + 84 >> 2] = $1;
 HEAP32[$4 + 80 >> 2] = $2;
 HEAP32[$4 + 76 >> 2] = $3;
 label$1: {
  if (!(jsvIsIterable(HEAP32[$4 + 88 >> 2]) & 1)) {
   HEAP32[$4 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 72 >> 2] = jsvGetLength(HEAP32[$4 + 88 >> 2]);
  if (HEAP32[$4 + 80 >> 2] < 0) {
   HEAP32[$4 + 80 >> 2] = HEAP32[$4 + 80 >> 2] + HEAP32[$4 + 72 >> 2];
  }
  if (HEAP32[$4 + 80 >> 2] < 0) {
   HEAP32[$4 + 92 >> 2] = 0;
   break label$1;
  }
  label$5: {
   if (jsvIsNumeric(HEAP32[$4 + 76 >> 2]) & 1) {
    $0 = jsvGetInteger(HEAP32[$4 + 76 >> 2]);
    break label$5;
   }
   $0 = HEAP32[$4 + 72 >> 2];
  }
  HEAP32[$4 + 68 >> 2] = $0;
  if (HEAP32[$4 + 68 >> 2] < 0) {
   HEAP32[$4 + 68 >> 2] = HEAP32[$4 + 68 >> 2] + HEAP32[$4 + 72 >> 2];
  }
  if (HEAP32[$4 + 68 >> 2] < 0) {
   HEAP32[$4 + 92 >> 2] = 0;
   break label$1;
  }
  jsvIteratorNew($4 + 8 | 0, HEAP32[$4 + 88 >> 2], 1);
  while (1) {
   $0 = 0;
   if (jsvIteratorHasElement($4 + 8 | 0) & 1) {
    $0 = jspIsInterrupted() ^ -1;
   }
   if ($0 & 1) {
    HEAP32[$4 + 4 >> 2] = jsvGetIntegerAndUnLock(jsvIteratorGetKey($4 + 8 | 0));
    if (!(HEAP32[$4 + 4 >> 2] < HEAP32[$4 + 80 >> 2] | HEAP32[$4 + 4 >> 2] >= HEAP32[$4 + 68 >> 2])) {
     jsvIteratorSetValue($4 + 8 | 0, HEAP32[$4 + 84 >> 2]);
    }
    jsvIteratorNext($4 + 8 | 0);
    continue;
   }
   break;
  }
  jsvIteratorFree($4 + 8 | 0);
  HEAP32[$4 + 92 >> 2] = jsvLockAgain(HEAP32[$4 + 88 >> 2]);
 }
 __stack_pointer = $4 + 96 | 0;
 return HEAP32[$4 + 92 >> 2];
}

function void_20tflite__reference_ops__AffineQuantize_float_2c_20unsigned_20char__28tflite__QuantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = Math_fround(0);
 $5 = __stack_pointer + -64 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 60 >> 2] = $0;
 HEAP32[$5 + 56 >> 2] = $1;
 HEAP32[$5 + 52 >> 2] = $2;
 HEAP32[$5 + 48 >> 2] = $3;
 HEAP32[$5 + 44 >> 2] = $4;
 HEAP32[$5 + 40 >> 2] = HEAP32[HEAP32[$5 + 60 >> 2] >> 2];
 HEAPF64[$5 + 32 >> 3] = HEAPF64[HEAP32[$5 + 60 >> 2] + 8 >> 3];
 HEAP32[$5 + 28 >> 2] = tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 56 >> 2], HEAP32[$5 + 48 >> 2]);
 HEAP32[$5 + 24 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 24 >> 2] < HEAP32[$5 + 28 >> 2]) {
   HEAPF32[$5 + 20 >> 2] = HEAPF32[HEAP32[$5 + 52 >> 2] + (HEAP32[$5 + 24 >> 2] << 2) >> 2];
   $6 = float_20tflite__TfLiteRound_float__28float_29(Math_fround(HEAPF32[$5 + 20 >> 2] / Math_fround(HEAPF64[$5 + 32 >> 3])));
   label$3: {
    if (Math_fround(Math_abs($6)) < Math_fround(2147483648)) {
     $0 = ~~$6;
     break label$3;
    }
    $0 = -2147483648;
   }
   HEAP32[$5 + 16 >> 2] = $0 + HEAP32[$5 + 40 >> 2];
   HEAP32[$5 + 12 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 16 | 0, 189904), 189908) >> 2];
   HEAP8[HEAP32[$5 + 44 >> 2] + HEAP32[$5 + 24 >> 2] | 0] = HEAP32[$5 + 12 >> 2];
   HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 24 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 - -64 | 0;
}

function jswrap_e_dumpFragmentation() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 while (1) {
  if (HEAPU32[$0 + 8 >> 2] < jsvGetMemoryTotal() >>> 0) {
   HEAP32[$0 + 4 >> 2] = _jsvGetAddressOf(HEAP32[$0 + 8 >> 2] + 1 & 65535);
   $1 = HEAP32[$0 + 4 >> 2];
   label$3: {
    if (!((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63)) {
     jsiConsolePrintString(146437);
     $1 = HEAP32[$0 + 12 >> 2];
     HEAP32[$0 + 12 >> 2] = $1 + 1;
     if (($1 | 0) > 80) {
      jsiConsolePrintString(148266);
      HEAP32[$0 + 12 >> 2] = 0;
     }
     break label$3;
    }
    label$6: {
     if (jsvGetLocks(HEAP32[$0 + 4 >> 2]) & 255) {
      jsiConsolePrintString(137431);
      break label$6;
     }
     jsiConsolePrintString(145504);
    }
    $1 = HEAP32[$0 + 12 >> 2];
    HEAP32[$0 + 12 >> 2] = $1 + 1;
    if (($1 | 0) > 80) {
     jsiConsolePrintString(148266);
     HEAP32[$0 + 12 >> 2] = 0;
    }
    if (jsvIsFlatString(HEAP32[$0 + 4 >> 2]) & 1) {
     HEAP32[$0 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 4 >> 2]);
     HEAP32[$0 + 8 >> 2] = HEAP32[$0 >> 2] + HEAP32[$0 + 8 >> 2];
     while (1) {
      $1 = HEAP32[$0 >> 2];
      HEAP32[$0 >> 2] = $1 - 1;
      if ($1) {
       jsiConsolePrintString(138383);
       $1 = HEAP32[$0 + 12 >> 2];
       HEAP32[$0 + 12 >> 2] = $1 + 1;
       if (($1 | 0) > 80) {
        jsiConsolePrintString(148266);
        HEAP32[$0 + 12 >> 2] = 0;
       }
       continue;
      }
      break;
     }
    }
   }
   HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 jsiConsolePrintString(148266);
 __stack_pointer = $0 + 16 | 0;
}

function void_20tflite__reference_ops__AffineQuantize_float_2c_20signed_20char__28tflite__QuantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char__29($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = Math_fround(0);
 $5 = __stack_pointer + -64 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 60 >> 2] = $0;
 HEAP32[$5 + 56 >> 2] = $1;
 HEAP32[$5 + 52 >> 2] = $2;
 HEAP32[$5 + 48 >> 2] = $3;
 HEAP32[$5 + 44 >> 2] = $4;
 HEAP32[$5 + 40 >> 2] = HEAP32[HEAP32[$5 + 60 >> 2] >> 2];
 HEAPF64[$5 + 32 >> 3] = HEAPF64[HEAP32[$5 + 60 >> 2] + 8 >> 3];
 HEAP32[$5 + 28 >> 2] = tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 56 >> 2], HEAP32[$5 + 48 >> 2]);
 HEAP32[$5 + 24 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 24 >> 2] < HEAP32[$5 + 28 >> 2]) {
   HEAPF32[$5 + 20 >> 2] = HEAPF32[HEAP32[$5 + 52 >> 2] + (HEAP32[$5 + 24 >> 2] << 2) >> 2];
   $6 = float_20tflite__TfLiteRound_float__28float_29(Math_fround(HEAPF32[$5 + 20 >> 2] / Math_fround(HEAPF64[$5 + 32 >> 3])));
   label$3: {
    if (Math_fround(Math_abs($6)) < Math_fround(2147483648)) {
     $0 = ~~$6;
     break label$3;
    }
    $0 = -2147483648;
   }
   HEAP32[$5 + 16 >> 2] = $0 + HEAP32[$5 + 40 >> 2];
   HEAP32[$5 + 12 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 16 | 0, 189896), 189900) >> 2];
   HEAP8[HEAP32[$5 + 44 >> 2] + HEAP32[$5 + 24 >> 2] | 0] = HEAP32[$5 + 12 >> 2];
   HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 24 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 - -64 | 0;
}

function void_20tflite__reference_ops__AffineQuantize_float_2c_20short__28tflite__QuantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20short__29($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = Math_fround(0);
 $5 = __stack_pointer + -64 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 60 >> 2] = $0;
 HEAP32[$5 + 56 >> 2] = $1;
 HEAP32[$5 + 52 >> 2] = $2;
 HEAP32[$5 + 48 >> 2] = $3;
 HEAP32[$5 + 44 >> 2] = $4;
 HEAP32[$5 + 40 >> 2] = HEAP32[HEAP32[$5 + 60 >> 2] >> 2];
 HEAPF64[$5 + 32 >> 3] = HEAPF64[HEAP32[$5 + 60 >> 2] + 8 >> 3];
 HEAP32[$5 + 28 >> 2] = tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 56 >> 2], HEAP32[$5 + 48 >> 2]);
 HEAP32[$5 + 24 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 24 >> 2] < HEAP32[$5 + 28 >> 2]) {
   HEAPF32[$5 + 20 >> 2] = HEAPF32[HEAP32[$5 + 52 >> 2] + (HEAP32[$5 + 24 >> 2] << 2) >> 2];
   $6 = float_20tflite__TfLiteRound_float__28float_29(Math_fround(HEAPF32[$5 + 20 >> 2] / Math_fround(HEAPF64[$5 + 32 >> 3])));
   label$3: {
    if (Math_fround(Math_abs($6)) < Math_fround(2147483648)) {
     $0 = ~~$6;
     break label$3;
    }
    $0 = -2147483648;
   }
   HEAP32[$5 + 16 >> 2] = $0 + HEAP32[$5 + 40 >> 2];
   HEAP32[$5 + 12 >> 2] = HEAP32[int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($5 + 16 | 0, 189912), 189916) >> 2];
   HEAP16[HEAP32[$5 + 44 >> 2] + (HEAP32[$5 + 24 >> 2] << 1) >> 1] = HEAP32[$5 + 12 >> 2];
   HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 24 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 - -64 | 0;
}

function jswrap_object_emit($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $4 = __stack_pointer + -64 | 0;
 $3 = $4;
 __stack_pointer = $3;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 HEAP32[$3 + 52 >> 2] = $2;
 label$1: {
  if (!(jsvHasChildren(HEAP32[$3 + 60 >> 2]) & 1)) {
   jsExceptionHere(3, 135617, 0);
   break label$1;
  }
  if (!(jsvIsString(HEAP32[$3 + 56 >> 2]) & 1)) {
   jsExceptionHere(3, 129842, 0);
   break label$1;
  }
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 56 >> 2];
  HEAP32[$3 + 48 >> 2] = jsvVarPrintf(116801, $3 + 16 | 0);
  if (!HEAP32[$3 + 48 >> 2]) {
   break label$1;
  }
  HEAP32[$3 + 44 >> 2] = 4;
  HEAP32[$3 + 40 >> 2] = $4;
  $4 = $4 - 16 | 0;
  __stack_pointer = $4;
  HEAP32[$3 + 36 >> 2] = 0;
  jsvObjectIteratorNew($3 + 32 | 0, HEAP32[$3 + 52 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_9($3 + 32 | 0) & 1) {
    if (HEAPU32[$3 + 36 >> 2] >= 4) {
     HEAP32[$3 >> 2] = 4;
     jsExceptionHere(3, 143132, $3);
    } else {
     $0 = jsvObjectIteratorGetValue_9($3 + 32 | 0);
     $1 = HEAP32[$3 + 36 >> 2];
     HEAP32[$3 + 36 >> 2] = $1 + 1;
     HEAP32[($1 << 2) + $4 >> 2] = $0;
     jsvObjectIteratorNext($3 + 32 | 0);
     continue;
    }
   }
   break;
  }
  jsvObjectIteratorFree_9($3 + 32 | 0);
  HEAP32[$3 + 28 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromVar(HEAP32[$3 + 60 >> 2], HEAP32[$3 + 48 >> 2], 0));
  jsvUnLock(HEAP32[$3 + 48 >> 2]);
  if (HEAP32[$3 + 28 >> 2]) {
   jsiQueueEvents(HEAP32[$3 + 60 >> 2], HEAP32[$3 + 28 >> 2], $4, HEAP32[$3 + 36 >> 2]);
  }
  jsvUnLock(HEAP32[$3 + 28 >> 2]);
  jsvUnLockMany(HEAP32[$3 + 36 >> 2], $4);
 }
 __stack_pointer = $3 - -64 | 0;
}

function jswrap_tensorflow_create($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1: {
  if (HEAP32[$2 + 40 >> 2] < 512) {
   jsExceptionHere(1, 131676, 0);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 32 >> 2] = 0;
  HEAP32[$2 + 28 >> 2] = jsvGetDataPointer(HEAP32[$2 + 36 >> 2], $2 + 32 | 0);
  if (!HEAP32[$2 + 28 >> 2]) {
   jsExceptionHere(3, 121194, 0);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 24 >> 2] = jspNewObject(0, 121013);
  if (!HEAP32[$2 + 24 >> 2]) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 20 >> 2] = tf_get_size(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 28 >> 2]);
  HEAP32[$2 + 16 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 20 >> 2] + 15 | 0);
  if (!HEAP32[$2 + 16 >> 2]) {
   jsExceptionHere(1, 116592, 0);
   jsvUnLock(HEAP32[$2 + 24 >> 2]);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  if (!jsvGetDataPointer(HEAP32[$2 + 16 >> 2], $2 + 20 | 0)) {
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  jsvObjectSetChild(HEAP32[$2 + 24 >> 2], 128981, HEAP32[$2 + 36 >> 2]);
  jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 129322, HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 12 >> 2] = jswrap_tfmicrointerpreter_getTFMI(HEAP32[$2 + 24 >> 2]);
  if (!(tf_create(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 40 >> 2], HEAP32[$2 + 28 >> 2]) & 1)) {
   jsExceptionHere(1, 134037, 0);
   jsvUnLock(HEAP32[$2 + 24 >> 2]);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 24 >> 2];
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function void_20tflite__reference_ops__Requantize_signed_20char_2c_20signed_20char__28signed_20char_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20signed_20char__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0;
 $7 = __stack_pointer + -64 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 60 >> 2] = $0;
 HEAP32[$7 + 56 >> 2] = $1;
 HEAP32[$7 + 52 >> 2] = $2;
 HEAP32[$7 + 48 >> 2] = $3;
 HEAP32[$7 + 44 >> 2] = $4;
 HEAP32[$7 + 40 >> 2] = $5;
 HEAP32[$7 + 36 >> 2] = $6;
 ruy__profiler__ScopeLabel__ScopeLabel_char_20const___28char_20const__29($7 + 32 | 0, 131504);
 $8 = HEAP32[$7 + 52 >> 2] == 1073741824 ? HEAP32[$7 + 48 >> 2] == 1 : $8;
 HEAP8[$7 + 31 | 0] = $8;
 if (HEAP8[$7 + 31 | 0] & 1) {
  HEAP8[$7 + 30 | 0] = 0;
  HEAP8[$7 + 29 | 0] = 0;
  HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 44 >> 2] - HEAP32[$7 + 40 >> 2];
 }
 HEAP32[$7 + 20 >> 2] = 0;
 while (1) {
  if (HEAP32[$7 + 20 >> 2] < HEAP32[$7 + 56 >> 2]) {
   HEAP32[$7 + 16 >> 2] = HEAP8[HEAP32[$7 + 60 >> 2] + HEAP32[$7 + 20 >> 2] | 0] - HEAP32[$7 + 44 >> 2];
   HEAP32[$7 + 12 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$7 + 16 >> 2], HEAP32[$7 + 52 >> 2], HEAP32[$7 + 48 >> 2]) + HEAP32[$7 + 40 >> 2];
   HEAP32[$7 + 8 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($7 + 12 | 0, 189940), 189936) >> 2];
   HEAP8[HEAP32[$7 + 36 >> 2] + HEAP32[$7 + 20 >> 2] | 0] = HEAP32[$7 + 8 >> 2];
   HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
 ruy__profiler__ScopeLabel___ScopeLabel_28_29($7 + 32 | 0);
 __stack_pointer = $7 - -64 | 0;
}

function jswrap_promise_then($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 HEAP32[$3 + 24 >> 2] = jspromise_create_prombox($3 + 28 | 0);
 label$1: {
  if (!HEAP32[$3 + 24 >> 2]) {
   HEAP32[$3 + 44 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$3 + 28 >> 2]) {
   if (!(jsvIsFunction(HEAP32[$3 + 36 >> 2]) & 1)) {
    HEAP32[$3 + 36 >> 2] = 0;
   }
   if (!(jsvIsFunction(HEAP32[$3 + 32 >> 2]) & 1)) {
    HEAP32[$3 + 32 >> 2] = 0;
   }
   HEAP32[$3 + 20 >> 2] = jsvObjectGetIntegerChild(HEAP32[$3 + 40 >> 2], 131993);
   label$6: {
    if (!HEAP32[$3 + 20 >> 2]) {
     _jswrap_promise_add_reaction(HEAP32[$3 + 40 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 36 >> 2], 1);
     _jswrap_promise_add_reaction(HEAP32[$3 + 40 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 32 >> 2], 0);
     break label$6;
    }
    if (HEAP32[$3 + 20 >> 2] == 2) {
     $0 = HEAP32[$3 + 36 >> 2];
    } else {
     $0 = HEAP32[$3 + 32 >> 2];
    }
    HEAP32[$3 + 16 >> 2] = $0;
    HEAP32[$3 + 12 >> 2] = _jswrap_promise_new_reaction(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 16 >> 2]);
    if (HEAP32[$3 + 12 >> 2]) {
     HEAP32[$3 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 40 >> 2], 129e3);
     _jswrap_promise_queue_reaction(HEAP32[$3 + 40 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 0);
     jsvUnLock2(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 12 >> 2]);
    }
   }
  }
  jsvUnLock(HEAP32[$3 + 24 >> 2]);
  HEAP32[$3 + 44 >> 2] = jsvLockAgainSafe(HEAP32[$3 + 28 >> 2]);
 }
 __stack_pointer = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}

function st_step_search($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP16[$1 + 22 >> 1] = get_input_buffer_size(HEAP32[$1 + 24 >> 2]);
 HEAP16[$1 + 20 >> 1] = get_lookahead_size(HEAP32[$1 + 24 >> 2]);
 HEAP16[$1 + 18 >> 1] = HEAPU16[HEAP32[$1 + 24 >> 2] + 2 >> 1];
 HEAP8[$1 + 17 | 0] = (is_finishing(HEAP32[$1 + 24 >> 2]) | 0) != 0;
 label$1: {
  if (HEAPU16[$1 + 18 >> 1] > (HEAPU16[HEAP32[$1 + 24 >> 2] >> 1] - (HEAP8[$1 + 17 | 0] & 1 ? 1 : HEAPU16[$1 + 20 >> 1]) | 0)) {
   HEAP32[$1 + 28 >> 2] = HEAP8[$1 + 17 | 0] & 1 ? 8 : 7;
   break label$1;
  }
  HEAP16[$1 + 14 >> 1] = get_input_offset(HEAP32[$1 + 24 >> 2]);
  HEAP16[$1 + 12 >> 1] = HEAPU16[$1 + 14 >> 1] + HEAPU16[$1 + 18 >> 1];
  HEAP16[$1 + 10 >> 1] = HEAPU16[$1 + 12 >> 1] - HEAPU16[$1 + 22 >> 1];
  HEAP16[$1 + 8 >> 1] = HEAPU16[$1 + 20 >> 1];
  if (HEAPU16[$1 + 20 >> 1] > (HEAPU16[HEAP32[$1 + 24 >> 2] >> 1] - HEAPU16[$1 + 18 >> 1] | 0)) {
   HEAP16[$1 + 8 >> 1] = HEAPU16[HEAP32[$1 + 24 >> 2] >> 1] - HEAPU16[$1 + 18 >> 1];
  }
  HEAP16[$1 + 6 >> 1] = 0;
  HEAP16[$1 + 4 >> 1] = find_longest_match(HEAP32[$1 + 24 >> 2], HEAPU16[$1 + 10 >> 1], HEAPU16[$1 + 12 >> 1], HEAPU16[$1 + 8 >> 1], $1 + 6 | 0);
  if (HEAPU16[$1 + 4 >> 1] == 65535) {
   $0 = HEAP32[$1 + 24 >> 2];
   HEAP16[$0 + 2 >> 1] = HEAPU16[$0 + 2 >> 1] + 1;
   HEAP16[HEAP32[$1 + 24 >> 2] + 4 >> 1] = 0;
   HEAP32[$1 + 28 >> 2] = 3;
   break label$1;
  }
  HEAP16[HEAP32[$1 + 24 >> 2] + 6 >> 1] = HEAPU16[$1 + 4 >> 1];
  HEAP16[HEAP32[$1 + 24 >> 2] + 4 >> 1] = HEAPU16[$1 + 6 >> 1];
  HEAP32[$1 + 28 >> 2] = 3;
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function void_20tflite__reference_ops__Requantize_short_2c_20signed_20char__28short_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20signed_20char__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0;
 $7 = __stack_pointer + -64 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 60 >> 2] = $0;
 HEAP32[$7 + 56 >> 2] = $1;
 HEAP32[$7 + 52 >> 2] = $2;
 HEAP32[$7 + 48 >> 2] = $3;
 HEAP32[$7 + 44 >> 2] = $4;
 HEAP32[$7 + 40 >> 2] = $5;
 HEAP32[$7 + 36 >> 2] = $6;
 ruy__profiler__ScopeLabel__ScopeLabel_char_20const___28char_20const__29($7 + 32 | 0, 131504);
 $8 = HEAP32[$7 + 52 >> 2] == 1073741824 ? HEAP32[$7 + 48 >> 2] == 1 : $8;
 HEAP8[$7 + 31 | 0] = $8;
 if (HEAP8[$7 + 31 | 0] & 1) {
  HEAP8[$7 + 30 | 0] = 0;
  HEAP8[$7 + 29 | 0] = 0;
  HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 44 >> 2] - HEAP32[$7 + 40 >> 2];
 }
 HEAP32[$7 + 20 >> 2] = 0;
 while (1) {
  if (HEAP32[$7 + 20 >> 2] < HEAP32[$7 + 56 >> 2]) {
   HEAP32[$7 + 16 >> 2] = HEAP16[HEAP32[$7 + 60 >> 2] + (HEAP32[$7 + 20 >> 2] << 1) >> 1] - HEAP32[$7 + 44 >> 2];
   HEAP32[$7 + 12 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$7 + 16 >> 2], HEAP32[$7 + 52 >> 2], HEAP32[$7 + 48 >> 2]) + HEAP32[$7 + 40 >> 2];
   HEAP32[$7 + 8 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($7 + 12 | 0, 189924), 189920) >> 2];
   HEAP8[HEAP32[$7 + 36 >> 2] + HEAP32[$7 + 20 >> 2] | 0] = HEAP32[$7 + 8 >> 2];
   HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
 ruy__profiler__ScopeLabel___ScopeLabel_28_29($7 + 32 | 0);
 __stack_pointer = $7 - -64 | 0;
}

function tflite__MicroInterpreter__ResetVariableTensors_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 $0 = HEAP32[$1 + 24 >> 2];
 HEAP32[$1 + 20 >> 2] = 0;
 label$1: {
  while (1) {
   if (HEAPU32[$1 + 20 >> 2] < flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor____size_28_29_20const(tflite__SubGraph__tensors_28_29_20const(HEAP32[$0 + 116 >> 2])) >>> 0) {
    HEAP32[$1 + 16 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor____Get_28unsigned_20int_29_20const(tflite__SubGraph__tensors_28_29_20const(HEAP32[$0 + 116 >> 2]), HEAP32[$1 + 20 >> 2]);
    if (tflite__Tensor__is_variable_28_29_20const(HEAP32[$1 + 16 >> 2]) & 1) {
     HEAP32[$1 + 8 >> 2] = tflite__TfLiteEvalTensorByteLength_28TfLiteEvalTensor_20const__2c_20unsigned_20long__29(HEAP32[$0 + 120 >> 2] + Math_imul(HEAP32[$1 + 20 >> 2], 12) | 0, $1 + 12 | 0);
     if (HEAP32[$1 + 8 >> 2]) {
      HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 8 >> 2];
      break label$1;
     }
     HEAP32[$1 + 4 >> 2] = 0;
     if ((tflite__Tensor__type_28_29_20const(HEAP32[$1 + 16 >> 2]) | 0) == 9) {
      HEAP32[$1 + 4 >> 2] = flatbuffers__Vector_long_20long___Get_28unsigned_20int_29_20const(tflite__QuantizationParameters__zero_point_28_29_20const(tflite__Tensor__quantization_28_29_20const(HEAP32[$1 + 16 >> 2])), 0);
     }
     memset(HEAP32[HEAP32[$0 + 120 >> 2] + Math_imul(HEAP32[$1 + 20 >> 2], 12) >> 2], HEAP32[$1 + 4 >> 2], HEAP32[$1 + 12 >> 2]);
    }
    HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 20 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$1 + 28 >> 2] = 0;
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function void_20tflite__reference_ops__Requantize_signed_20char_2c_20int__28signed_20char_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0;
 $7 = __stack_pointer + -64 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 60 >> 2] = $0;
 HEAP32[$7 + 56 >> 2] = $1;
 HEAP32[$7 + 52 >> 2] = $2;
 HEAP32[$7 + 48 >> 2] = $3;
 HEAP32[$7 + 44 >> 2] = $4;
 HEAP32[$7 + 40 >> 2] = $5;
 HEAP32[$7 + 36 >> 2] = $6;
 ruy__profiler__ScopeLabel__ScopeLabel_char_20const___28char_20const__29($7 + 32 | 0, 131504);
 $8 = HEAP32[$7 + 52 >> 2] == 1073741824 ? HEAP32[$7 + 48 >> 2] == 1 : $8;
 HEAP8[$7 + 31 | 0] = $8;
 if (HEAP8[$7 + 31 | 0] & 1) {
  HEAP8[$7 + 30 | 0] = 0;
  HEAP8[$7 + 29 | 0] = 0;
  HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 44 >> 2] - HEAP32[$7 + 40 >> 2];
 }
 HEAP32[$7 + 20 >> 2] = 0;
 while (1) {
  if (HEAP32[$7 + 20 >> 2] < HEAP32[$7 + 56 >> 2]) {
   HEAP32[$7 + 16 >> 2] = HEAP8[HEAP32[$7 + 60 >> 2] + HEAP32[$7 + 20 >> 2] | 0] - HEAP32[$7 + 44 >> 2];
   HEAP32[$7 + 12 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$7 + 16 >> 2], HEAP32[$7 + 52 >> 2], HEAP32[$7 + 48 >> 2]) + HEAP32[$7 + 40 >> 2];
   HEAP32[$7 + 8 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($7 + 12 | 0, 189956), 189952) >> 2];
   HEAP32[HEAP32[$7 + 36 >> 2] + (HEAP32[$7 + 20 >> 2] << 2) >> 2] = HEAP32[$7 + 8 >> 2];
   HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
 ruy__profiler__ScopeLabel___ScopeLabel_28_29($7 + 32 | 0);
 __stack_pointer = $7 - -64 | 0;
}

function tflite__BytesRequiredForTensor_28tflite__Tensor_20const__2c_20unsigned_20long__2c_20unsigned_20long__2c_20tflite__ErrorReporter__29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 40 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = $1;
 HEAP32[$4 + 32 >> 2] = $2;
 HEAP32[$4 + 28 >> 2] = $3;
 HEAP32[$4 + 24 >> 2] = 1;
 if (tflite__Tensor__shape_28_29_20const(HEAP32[$4 + 40 >> 2])) {
  HEAP32[$4 + 20 >> 2] = 0;
  while (1) {
   if (HEAPU32[$4 + 20 >> 2] < flatbuffers__Vector_int___Length_28_29_20const(tflite__Tensor__shape_28_29_20const(HEAP32[$4 + 40 >> 2])) >>> 0) {
    HEAP32[$4 + 24 >> 2] = Math_imul(flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(tflite__Tensor__shape_28_29_20const(HEAP32[$4 + 40 >> 2]), HEAP32[$4 + 20 >> 2]), HEAP32[$4 + 24 >> 2]);
    HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + 1;
    continue;
   }
   break;
  }
 }
 HEAP32[$4 + 12 >> 2] = tflite__ConvertTensorType_28tflite__TensorType_2c_20TfLiteType__2c_20tflite__ErrorReporter__29(tflite__Tensor__type_28_29_20const(HEAP32[$4 + 40 >> 2]), $4 + 16 | 0, HEAP32[$4 + 28 >> 2]);
 label$4: {
  if (HEAP32[$4 + 12 >> 2]) {
   HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 12 >> 2];
   break label$4;
  }
  HEAP32[$4 + 8 >> 2] = tflite__TfLiteTypeSizeOf_28TfLiteType_2c_20unsigned_20long__29(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 32 >> 2]);
  if (HEAP32[$4 + 8 >> 2]) {
   HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 8 >> 2];
   break label$4;
  }
  HEAP32[HEAP32[$4 + 36 >> 2] >> 2] = Math_imul(HEAP32[$4 + 24 >> 2], HEAP32[HEAP32[$4 + 32 >> 2] >> 2]);
  HEAP32[$4 + 44 >> 2] = 0;
 }
 __stack_pointer = $4 + 48 | 0;
 return HEAP32[$4 + 44 >> 2];
}

function void_20tflite__reference_ops__Requantize_short_2c_20short__28short_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20short__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0;
 $7 = __stack_pointer + -64 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 60 >> 2] = $0;
 HEAP32[$7 + 56 >> 2] = $1;
 HEAP32[$7 + 52 >> 2] = $2;
 HEAP32[$7 + 48 >> 2] = $3;
 HEAP32[$7 + 44 >> 2] = $4;
 HEAP32[$7 + 40 >> 2] = $5;
 HEAP32[$7 + 36 >> 2] = $6;
 ruy__profiler__ScopeLabel__ScopeLabel_char_20const___28char_20const__29($7 + 32 | 0, 131504);
 $8 = HEAP32[$7 + 52 >> 2] == 1073741824 ? HEAP32[$7 + 48 >> 2] == 1 : $8;
 HEAP8[$7 + 31 | 0] = $8;
 if (HEAP8[$7 + 31 | 0] & 1) {
  HEAP8[$7 + 30 | 0] = 0;
  HEAP8[$7 + 29 | 0] = 0;
  HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 44 >> 2] - HEAP32[$7 + 40 >> 2];
 }
 HEAP32[$7 + 20 >> 2] = 0;
 while (1) {
  if (HEAP32[$7 + 20 >> 2] < HEAP32[$7 + 56 >> 2]) {
   HEAP32[$7 + 16 >> 2] = HEAP16[HEAP32[$7 + 60 >> 2] + (HEAP32[$7 + 20 >> 2] << 1) >> 1] - HEAP32[$7 + 44 >> 2];
   HEAP32[$7 + 12 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$7 + 16 >> 2], HEAP32[$7 + 52 >> 2], HEAP32[$7 + 48 >> 2]) + HEAP32[$7 + 40 >> 2];
   HEAP32[$7 + 8 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($7 + 12 | 0, 189932), 189928) >> 2];
   HEAP16[HEAP32[$7 + 36 >> 2] + (HEAP32[$7 + 20 >> 2] << 1) >> 1] = HEAP32[$7 + 8 >> 2];
   HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
 ruy__profiler__ScopeLabel___ScopeLabel_28_29($7 + 32 | 0);
 __stack_pointer = $7 - -64 | 0;
}

function jswrap_io_digitalRead($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 40 >> 2] = $0;
 label$1: {
  if (jsvIsArray(HEAP32[$1 + 40 >> 2]) & 1) {
   HEAP32[$1 + 36 >> 2] = 0;
   HEAP32[$1 + 32 >> 2] = 0;
   jsvObjectIteratorNew($1 + 24 | 0, HEAP32[$1 + 40 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_15($1 + 24 | 0) & 1) {
     HEAP32[$1 + 20 >> 2] = jsvObjectIteratorGetValue_14($1 + 24 | 0);
     HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 32 >> 2] << 1 | jshPinInput(jshGetPinFromVar(HEAP32[$1 + 20 >> 2]) & 255) & 1;
     jsvUnLock(HEAP32[$1 + 20 >> 2]);
     jsvObjectIteratorNext($1 + 24 | 0);
     HEAP32[$1 + 36 >> 2] = HEAP32[$1 + 36 >> 2] + 1;
     continue;
    }
    break;
   }
   jsvObjectIteratorFree_15($1 + 24 | 0);
   if (!HEAP32[$1 + 36 >> 2]) {
    HEAP32[$1 + 44 >> 2] = 0;
    break label$1;
   }
   HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 32 >> 2];
   break label$1;
  }
  if (jsvIsObject(HEAP32[$1 + 40 >> 2]) & 1) {
   HEAP32[$1 + 16 >> 2] = 0;
   HEAP32[$1 + 12 >> 2] = jspGetNamedField(HEAP32[$1 + 40 >> 2], 134421, 0);
   label$7: {
    if (jsvIsFunction(HEAP32[$1 + 12 >> 2]) & 1) {
     HEAP32[$1 + 16 >> 2] = jsvGetIntegerAndUnLock(jspeFunctionCall(HEAP32[$1 + 12 >> 2], 0, HEAP32[$1 + 40 >> 2], 0, 0, 0));
     break label$7;
    }
    jsExceptionHere(1, 128480, 0);
   }
   jsvUnLock(HEAP32[$1 + 12 >> 2]);
   HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 16 >> 2];
   break label$1;
  }
  HEAP8[$1 + 11 | 0] = jshGetPinFromVar(HEAP32[$1 + 40 >> 2]);
  HEAP32[$1 + 44 >> 2] = jshPinInput(HEAPU8[$1 + 11 | 0]) & 1;
 }
 __stack_pointer = $1 + 48 | 0;
 return HEAP32[$1 + 44 >> 2];
}

function jswrap_parseInt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 144 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 136 >> 2] = $0;
 HEAP32[$2 + 132 >> 2] = $1;
 HEAP32[$2 + 128 >> 2] = 0;
 if (jsvIsNumeric(HEAP32[$2 + 132 >> 2]) & 1) {
  HEAP32[$2 + 128 >> 2] = jsvGetInteger(HEAP32[$2 + 132 >> 2]);
 }
 label$2: {
  label$3: {
   if (!(jsvIsFloat(HEAP32[$2 + 136 >> 2]) & 1)) {
    break label$3;
   }
   __DOUBLE_BITS_4(jsvGetFloat(HEAP32[$2 + 136 >> 2]));
   if ((i64toi32_i32$HIGH_BITS & 2147483647) >>> 0 < 2146435072) {
    break label$3;
   }
   HEAP32[$2 + 140 >> 2] = jsvNewFromFloat(nan);
   break label$2;
  }
  HEAP32[$2 + 44 >> 2] = $2 + 48;
  jsvGetString(HEAP32[$2 + 136 >> 2], $2 + 48 | 0, 70);
  HEAP8[$2 + 43 | 0] = 0;
  if (!(HEAP8[$2 + 49 | 0] != 120 & HEAP8[$2 + 49 | 0] != 88 | (HEAP8[$2 + 48 | 0] != 48 | (HEAP32[$2 + 128 >> 2] != 16 ? HEAP32[$2 + 128 >> 2] : 0)))) {
   HEAP32[$2 + 128 >> 2] = 16;
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 44 >> 2] + 2;
  }
  if (!HEAP32[$2 + 128 >> 2]) {
   HEAP32[$2 + 128 >> 2] = 10;
  }
  HEAP32[$2 + 24 >> 2] = stringToIntWithRadix(HEAP32[$2 + 44 >> 2], HEAP32[$2 + 128 >> 2], $2 + 43 | 0, $2 + 36 | 0);
  HEAP32[$2 + 28 >> 2] = i64toi32_i32$HIGH_BITS;
  if (HEAP8[$2 + 43 | 0] & 1) {
   HEAP32[$2 + 140 >> 2] = jsvNewFromFloat(nan);
   break label$2;
  }
  if (HEAP32[$2 + 36 >> 2] == ($2 + 117 | 0)) {
   jsExceptionHere(1, 121368, 0);
   HEAP32[$2 + 140 >> 2] = jsvNewFromFloat(nan);
   break label$2;
  }
  HEAP32[$2 + 140 >> 2] = jsvNewFromLongInteger(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 28 >> 2]);
 }
 __stack_pointer = $2 + 144 | 0;
 return HEAP32[$2 + 140 >> 2];
}

function void_20tflite__reference_ops__Requantize_short_2c_20int__28short_20const__2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int__29($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0;
 $7 = __stack_pointer + -64 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 60 >> 2] = $0;
 HEAP32[$7 + 56 >> 2] = $1;
 HEAP32[$7 + 52 >> 2] = $2;
 HEAP32[$7 + 48 >> 2] = $3;
 HEAP32[$7 + 44 >> 2] = $4;
 HEAP32[$7 + 40 >> 2] = $5;
 HEAP32[$7 + 36 >> 2] = $6;
 ruy__profiler__ScopeLabel__ScopeLabel_char_20const___28char_20const__29($7 + 32 | 0, 131504);
 $8 = HEAP32[$7 + 52 >> 2] == 1073741824 ? HEAP32[$7 + 48 >> 2] == 1 : $8;
 HEAP8[$7 + 31 | 0] = $8;
 if (HEAP8[$7 + 31 | 0] & 1) {
  HEAP8[$7 + 30 | 0] = 0;
  HEAP8[$7 + 29 | 0] = 0;
  HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 44 >> 2] - HEAP32[$7 + 40 >> 2];
 }
 HEAP32[$7 + 20 >> 2] = 0;
 while (1) {
  if (HEAP32[$7 + 20 >> 2] < HEAP32[$7 + 56 >> 2]) {
   HEAP32[$7 + 16 >> 2] = HEAP16[HEAP32[$7 + 60 >> 2] + (HEAP32[$7 + 20 >> 2] << 1) >> 1] - HEAP32[$7 + 44 >> 2];
   HEAP32[$7 + 12 >> 2] = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$7 + 16 >> 2], HEAP32[$7 + 52 >> 2], HEAP32[$7 + 48 >> 2]) + HEAP32[$7 + 40 >> 2];
   HEAP32[$7 + 8 >> 2] = HEAP32[int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29(int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($7 + 12 | 0, 189948), 189944) >> 2];
   HEAP32[HEAP32[$7 + 36 >> 2] + (HEAP32[$7 + 20 >> 2] << 2) >> 2] = HEAP32[$7 + 8 >> 2];
   HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
 ruy__profiler__ScopeLabel___ScopeLabel_28_29($7 + 32 | 0);
 __stack_pointer = $7 - -64 | 0;
}

function jsvStringIteratorAppend($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 label$1: {
  if (!HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]) {
   break label$1;
  }
  if (HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2]) {
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
  }
  if (HEAPU32[HEAP32[$2 + 12 >> 2] >> 2] >= jsvGetMaxCharactersInVar(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]) >>> 0) {
   if (!(jsvHasStringExt(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]) & 1)) {
    break label$1;
   }
   HEAP32[$2 + 4 >> 2] = jsvNewWithFlags(41);
   if (!HEAP32[$2 + 4 >> 2]) {
    jsvUnLock(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]);
    HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = 0;
    HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = 0;
    HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = 0;
    break label$1;
   }
   jsvSetLastChild(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2], jsvGetRef(HEAP32[$2 + 4 >> 2]) & 65535);
   jsvUnLock(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]);
   HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = HEAP32[$2 + 4 >> 2];
   HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = HEAP32[$2 + 4 >> 2];
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] >> 2] + HEAP32[$0 + 8 >> 2];
   HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = 0;
  }
  HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] + HEAP32[HEAP32[$2 + 12 >> 2] >> 2] | 0] = HEAPU8[$2 + 11 | 0];
  HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] >> 2] + 1;
  jsvSetCharactersInVar(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2], HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function graphicsSetCallbacks($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 HEAP8[$0 + 52 | 0] = 64;
 HEAP8[$0 + 53 | 0] = 2;
 HEAP8[$0 + 54 | 0] = 0;
 HEAP8[$0 + 55 | 0] = 0;
 $0 = HEAP32[$1 + 8 >> 2];
 HEAP8[$0 + 60 | 0] = 65;
 HEAP8[$0 + 61 | 0] = 2;
 HEAP8[$0 + 62 | 0] = 0;
 HEAP8[$0 + 63 | 0] = 0;
 $0 = HEAP32[$1 + 8 >> 2];
 HEAP8[$0 + 56 | 0] = 66;
 HEAP8[$0 + 57 | 0] = 2;
 HEAP8[$0 + 58 | 0] = 0;
 HEAP8[$0 + 59 | 0] = 0;
 $0 = HEAP32[$1 + 8 >> 2];
 HEAP8[$0 + 64 | 0] = 67;
 HEAP8[$0 + 65 | 0] = 2;
 HEAP8[$0 + 66 | 0] = 0;
 HEAP8[$0 + 67 | 0] = 0;
 $0 = HEAP32[$1 + 8 >> 2];
 HEAP8[$0 + 68 | 0] = 68;
 HEAP8[$0 + 69 | 0] = 2;
 HEAP8[$0 + 70 | 0] = 0;
 HEAP8[$0 + 71 | 0] = 0;
 $0 = HEAP32[$1 + 8 >> 2];
 label$1: {
  label$2: {
   if (!(HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24))) {
    lcdSetCallbacks_ArrayBuffer(HEAP32[$1 + 8 >> 2]);
    break label$2;
   }
   $0 = HEAP32[$1 + 8 >> 2];
   label$4: {
    if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) == 1) {
     lcdSetCallbacks_JS(HEAP32[$1 + 8 >> 2]);
     break label$4;
    }
    label$6: {
     $0 = HEAP32[$1 + 8 >> 2];
     if ((HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) == 6) {
      lcdMemLCD_setCallbacks(HEAP32[$1 + 8 >> 2]);
      break label$6;
     }
     HEAP8[$1 + 15 | 0] = 0;
     break label$1;
    }
   }
  }
  HEAP8[$1 + 15 | 0] = 1;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}

function _jswrap_graphics_getFontInfo($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[HEAP32[$2 + 8 >> 2] >> 2] = (HEAPU8[$0 + 25 | 0] | HEAPU8[$0 + 26 | 0] << 8) & 57344;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[HEAP32[$2 + 8 >> 2] + 4 >> 1] = (HEAPU8[$0 + 25 | 0] | HEAPU8[$0 + 26 | 0] << 8) & 8191;
 HEAP16[HEAP32[$2 + 8 >> 2] + 6 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1];
 HEAP16[HEAP32[$2 + 8 >> 2] + 8 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1];
 if (HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1] & 4096) {
  HEAP16[HEAP32[$2 + 8 >> 2] + 6 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1] & 63;
  HEAP16[HEAP32[$2 + 8 >> 2] + 8 >> 1] = (HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1] & 4032) >>> 6;
 }
 label$2: {
  if (HEAP32[HEAP32[$2 + 8 >> 2] >> 2] & 32768) {
   $0 = HEAP32[$2 + 12 >> 2];
   $0 = jsvGetIntegerAndUnLock(jsvObjectGetChildIfExists(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 139860));
   HEAP8[HEAP32[$2 + 8 >> 2] + 10 | 0] = $0;
   $0 = HEAP32[$2 + 12 >> 2];
   $0 = jsvObjectGetChildIfExists(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 136497);
   HEAP32[HEAP32[$2 + 8 >> 2] + 12 >> 2] = $0;
   $0 = HEAP32[$2 + 12 >> 2];
   $0 = jsvObjectGetChildIfExists(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 138138);
   HEAP32[HEAP32[$2 + 8 >> 2] + 16 >> 2] = $0;
   break label$2;
  }
  HEAP8[HEAP32[$2 + 8 >> 2] + 10 | 0] = 0;
 }
 __stack_pointer = $2 + 16 | 0;
}

function jspEvaluateVar($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 192 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 188 >> 2] = $0;
 HEAP32[$3 + 184 >> 2] = $1;
 HEAP16[$3 + 182 >> 1] = $2;
 HEAP32[$3 + 52 >> 2] = jslSetLex($3 + 56 | 0);
 jslInit(HEAP32[$3 + 188 >> 2]);
 HEAP32[$3 + 48 >> 2] = HEAP32[91094];
 $0 = HEAP32[91093];
 $1 = HEAP32[91092];
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 44 >> 2] = $0;
 $1 = HEAP32[91091];
 $0 = HEAP32[91090];
 HEAP32[$3 + 32 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 $0 = HEAP32[91089];
 $1 = HEAP32[91088];
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 28 >> 2] = $0;
 $1 = HEAP32[91087];
 $0 = HEAP32[91086];
 HEAP32[$3 + 16 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[91094] = 1;
 if (HEAP32[$3 + 184 >> 2]) {
  HEAP32[91088] = 0;
  if (HEAP32[$3 + 184 >> 2] != HEAP32[91086]) {
   jspeiAddScope(HEAP32[$3 + 184 >> 2]);
   HEAP32[91089] = HEAP32[$3 + 184 >> 2];
  }
 }
 HEAP32[$3 + 12 >> 2] = jspParse();
 if (HEAP32[$3 + 184 >> 2]) {
  jspeiClearScopes();
 }
 jslKill();
 jslSetLex(HEAP32[$3 + 52 >> 2]);
 HEAP32[$3 + 48 >> 2] = HEAP32[$3 + 48 >> 2] | HEAP32[91094] & 6256;
 $0 = HEAP32[$3 + 20 >> 2];
 $1 = HEAP32[$3 + 16 >> 2];
 HEAP32[91086] = $1;
 HEAP32[91087] = $0;
 HEAP32[91094] = HEAP32[$3 + 48 >> 2];
 $1 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$3 + 40 >> 2];
 HEAP32[91092] = $0;
 HEAP32[91093] = $1;
 $0 = HEAP32[$3 + 36 >> 2];
 $1 = HEAP32[$3 + 32 >> 2];
 HEAP32[91090] = $1;
 HEAP32[91091] = $0;
 $1 = HEAP32[$3 + 28 >> 2];
 $0 = HEAP32[$3 + 24 >> 2];
 HEAP32[91088] = $0;
 HEAP32[91089] = $1;
 $0 = jsvSkipNameAndUnLock(HEAP32[$3 + 12 >> 2]);
 __stack_pointer = $3 + 192 | 0;
 return $0;
}

function jswrap_isNaN($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer + -64 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 label$1: {
  label$2: {
   label$3: {
    if (jsvIsUndefined(HEAP32[$1 + 56 >> 2]) & 1) {
     break label$3;
    }
    if (jsvIsObject(HEAP32[$1 + 56 >> 2]) & 1) {
     break label$3;
    }
    if (!(jsvIsFloat(HEAP32[$1 + 56 >> 2]) & 1)) {
     if (!(jsvIsArray(HEAP32[$1 + 56 >> 2]) & 1)) {
      break label$2;
     }
    }
    $0 = __DOUBLE_BITS_4(jsvGetFloat(HEAP32[$1 + 56 >> 2]));
    $3 = $0;
    $2 = i64toi32_i32$HIGH_BITS;
    $0 = $2 & 2147483647;
    $2 = $3;
    if (($0 | 0) == 2146435072 & ($2 | 0) != 0 | $0 >>> 0 > 2146435072) {
     break label$3;
    }
    break label$2;
   }
   HEAP8[$1 + 63 | 0] = 1;
   break label$1;
  }
  if (jsvIsString(HEAP32[$1 + 56 >> 2]) & 1) {
   HEAP8[$1 + 55 | 0] = 1;
   jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 56 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar_6($1 + 16 | 0) & 1) {
     if (isWhitespace(jsvStringIteratorGetCharAndNext($1 + 16 | 0) << 24 >> 24) & 1) {
      continue;
     }
     HEAP8[$1 + 55 | 0] = 0;
    }
    break;
   }
   jsvStringIteratorFree_7($1 + 16 | 0);
   if (HEAP8[$1 + 55 | 0] & 1) {
    HEAP8[$1 + 63 | 0] = 0;
    break label$1;
   }
   $2 = __DOUBLE_BITS_4(jsvGetFloat(HEAP32[$1 + 56 >> 2]));
   $3 = $2;
   $0 = i64toi32_i32$HIGH_BITS;
   $2 = $0 & 2147483647;
   $0 = $3;
   HEAP8[$1 + 63 | 0] = ($2 | 0) == 2146435072 & ($0 | 0) != 0 | $2 >>> 0 > 2146435072;
   break label$1;
  }
  HEAP8[$1 + 63 | 0] = 0;
 }
 __stack_pointer = $1 - -64 | 0;
 return HEAP8[$1 + 63 | 0] & 1;
}

function jspeExpressionOrArrowFunction() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP8[$0 + 3 | 0] = 1;
 label$1: {
  while (1) {
   $1 = 0;
   $1 = HEAP16[HEAP32[49079] + 2 >> 1] != 41 ? (HEAP32[91094] & 80) != 0 ^ -1 : $1;
   if ($1 & 1) {
    if (!(!(HEAP8[$0 + 3 | 0] & 1) | !HEAP32[$0 + 8 >> 2])) {
     HEAP32[$0 + 4 >> 2] = jspeAddNamedFunctionParameter(HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2]);
    }
    jsvUnLock(HEAP32[$0 + 8 >> 2]);
    HEAP32[$0 + 8 >> 2] = jspeAssignmentExpression();
    label$6: {
     if ((HEAP32[91094] & 63) != 1) {
      break label$6;
     }
     if (jsvIsName(HEAP32[$0 + 8 >> 2]) & 1) {
      if (jsvIsString(HEAP32[$0 + 8 >> 2]) & 1) {
       break label$6;
      }
     }
     HEAP8[$0 + 3 | 0] = 0;
    }
    if (HEAP16[HEAP32[49079] + 2 >> 1] != 41) {
     if (!(jslMatch(44) & 1)) {
      jsvUnLock2(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2]);
      HEAP32[$0 + 12 >> 2] = 0;
      break label$1;
     }
    }
    continue;
   }
   break;
  }
  if (!(jslMatch(41) & 1)) {
   jsvUnLock2(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2]);
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  if (!(!(HEAP8[$0 + 3 | 0] & 1) | HEAP16[HEAP32[49079] + 2 >> 1] != 162)) {
   HEAP32[$0 + 4 >> 2] = jspeArrowFunction(HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2]);
   jsvUnLock(HEAP32[$0 + 8 >> 2]);
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2];
   break label$1;
  }
  jsvUnLock(HEAP32[$0 + 4 >> 2]);
  HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function exp($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 wasm2js_scratch_store_f64(+$0);
 $3 = wasm2js_scratch_load_i32(1) | 0;
 $4 = wasm2js_scratch_load_i32(0) | 0;
 label$1: {
  label$2: {
   $6 = $3;
   $1 = $3 >>> 20 & 2047;
   if ($1 - 969 >>> 0 < 63) {
    $8 = $1;
    break label$2;
   }
   if ($1 >>> 0 <= 968) {
    return +($0 + 1);
   }
   if ($1 >>> 0 < 1033) {
    break label$2;
   }
   $3 = $4;
   $2 = 0;
   if (!$3 & ($6 | 0) == -1048576) {
    break label$1;
   }
   if (($1 | 0) == 2047) {
    return +($0 + 1);
   }
   $3 = $6;
   if (($3 | 0) < 0) {
    return +__math_uflow(0);
   }
   return +__math_oflow(0);
  }
  $2 = HEAPF64[23789];
  $7 = HEAPF64[23788] * $0 + $2;
  $2 = $7 - $2;
  $0 = $2 * HEAPF64[23791] + ($2 * HEAPF64[23790] + $0);
  $2 = $0 * $0;
  $9 = $2 * $2 * ($0 * HEAPF64[23795] + HEAPF64[23794]);
  $2 = $2 * ($0 * HEAPF64[23793] + HEAPF64[23792]);
  wasm2js_scratch_store_f64(+$7);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  $4 = wasm2js_scratch_load_i32(0) | 0;
  $6 = $1;
  $1 = $4 << 4 & 2032;
  $0 = $9 + ($2 + (HEAPF64[$1 + 190416 >> 3] + $0));
  $5 = $1 + 190424 | 0;
  $1 = HEAP32[$5 >> 2];
  $10 = $1;
  $3 = HEAP32[$5 + 4 >> 2];
  $1 = $4 << 13;
  $5 = $1;
  $1 = $5 + $3 | 0;
  $3 = $10;
  $5 = $3 + 0 | 0;
  $1 = $11 >>> 0 > $5 >>> 0 ? $1 + 1 | 0 : $1;
  $3 = $1;
  if (!$8) {
   $1 = $3;
   $3 = $6;
   return +specialcase($0, $5, $1, $4, $3);
  }
  wasm2js_scratch_store_i32(0, $5 | 0);
  wasm2js_scratch_store_i32(1, $3 | 0);
  $2 = +wasm2js_scratch_load_f64();
  $2 = $2 * $0 + $2;
 }
 return +$2;
}

function jsiSemiInit($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 47 | 0] = $0;
 HEAP32[$2 + 40 >> 2] = $1;
 jspInit();
 HEAP16[182206] = HEAPU16[182206] & 7904;
 HEAP8[195665] = 255;
 HEAP8[$2 + 39 | 0] = 0;
 if (HEAP32[$2 + 40 >> 2]) {
  $4 = HEAP32[91086];
  $0 = HEAP32[$2 + 40 >> 2];
  HEAP32[$2 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
  $1 = HEAP32[$0 + 16 >> 2];
  $3 = HEAP32[$0 + 20 >> 2];
  HEAP32[$2 + 16 >> 2] = $1;
  HEAP32[$2 + 20 >> 2] = $3;
  $1 = HEAP32[$0 + 12 >> 2];
  $3 = HEAP32[$0 + 8 >> 2];
  HEAP32[$2 + 8 >> 2] = $3;
  HEAP32[$2 + 12 >> 2] = $1;
  $3 = HEAP32[$0 + 4 >> 2];
  $1 = HEAP32[$0 >> 2];
  HEAP32[$2 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = $3;
  jsvObjectSetChildAndUnLock($4, 135875, jsfVarFromName($2));
 }
 if (HEAP8[$2 + 47 | 0] & 1) {
  $5 = jsfFlashContainsCode();
 }
 HEAP8[$2 + 38 | 0] = $5 & 1;
 if (HEAP8[$2 + 38 | 0] & 1) {
  HEAP16[182206] = HEAPU16[182206] & -2049;
  jspSoftKill();
  jsvSoftKill();
  jsfLoadStateFromFlash();
  jsvSoftInit();
  jspSoftInit();
 }
 HEAP32[$2 + 32 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 132894);
 if (HEAP32[$2 + 32 >> 2]) {
  HEAP16[182206] = HEAPU16[182206] | 1024;
 }
 jsvUnLock(HEAP32[$2 + 32 >> 2]);
 jsiSoftInit((HEAPU8[$2 + 47 | 0] ^ -1) & 1);
 if (jsiEcho() & 1) {
  if (!(HEAP8[$2 + 38 | 0] & 1) & HEAPU8[195664] != 20) {
   jsiConsolePrintString(146714);
  }
  if (HEAPU8[195664] != 20) {
   jsiConsolePrintString(148266);
  }
  HEAP8[364420] = 1;
 }
 if (HEAP8[$2 + 39 | 0] & 1) {
  jsvUnLock(jspEvaluate(145081, 1));
 }
 __stack_pointer = $2 + 48 | 0;
}

function get_bits($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP8[$2 + 7 | 0] = $1;
 HEAP16[$2 + 4 >> 1] = 0;
 HEAP32[$2 >> 2] = 0;
 label$1: {
  if (HEAPU8[$2 + 7 | 0] > 15) {
   HEAP16[$2 + 14 >> 1] = 65535;
   break label$1;
  }
  if (!HEAPU16[HEAP32[$2 + 8 >> 2] >> 1] & HEAPU8[HEAP32[$2 + 8 >> 2] + 12 | 0] < 1 << HEAPU8[$2 + 7 | 0] - 1) {
   HEAP16[$2 + 14 >> 1] = 65535;
   break label$1;
  }
  HEAP32[$2 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 >> 2] < HEAPU8[$2 + 7 | 0]) {
    if (!HEAPU8[HEAP32[$2 + 8 >> 2] + 12 | 0]) {
     if (!HEAPU16[HEAP32[$2 + 8 >> 2] >> 1]) {
      HEAP16[$2 + 14 >> 1] = 65535;
      break label$1;
     }
     $0 = HEAP32[$2 + 8 >> 2];
     $1 = HEAPU16[$0 + 2 >> 1];
     HEAP16[$0 + 2 >> 1] = $1 + 1;
     HEAP8[HEAP32[$2 + 8 >> 2] + 11 | 0] = HEAPU8[($0 + 13 | 0) + $1 | 0];
     if (HEAPU16[HEAP32[$2 + 8 >> 2] + 2 >> 1] == HEAPU16[HEAP32[$2 + 8 >> 2] >> 1]) {
      HEAP16[HEAP32[$2 + 8 >> 2] + 2 >> 1] = 0;
      HEAP16[HEAP32[$2 + 8 >> 2] >> 1] = 0;
     }
     HEAP8[HEAP32[$2 + 8 >> 2] + 12 | 0] = 128;
    }
    HEAP16[$2 + 4 >> 1] = HEAPU16[$2 + 4 >> 1] << 1;
    if (HEAPU8[HEAP32[$2 + 8 >> 2] + 11 | 0] & HEAPU8[HEAP32[$2 + 8 >> 2] + 12 | 0]) {
     HEAP16[$2 + 4 >> 1] = HEAPU16[$2 + 4 >> 1] | 1;
    }
    $0 = HEAP32[$2 + 8 >> 2];
    HEAP8[$0 + 12 | 0] = HEAPU8[$0 + 12 | 0] >>> 1;
    HEAP32[$2 >> 2] = HEAP32[$2 >> 2] + 1;
    continue;
   }
   break;
  }
  label$11: {
   if (HEAPU8[$2 + 7 | 0] <= 1) {
    break label$11;
   }
  }
  HEAP16[$2 + 14 >> 1] = HEAPU16[$2 + 4 >> 1];
 }
 return HEAPU16[$2 + 14 >> 1];
}

function _jswrap_promise_seal($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP8[$3 + 39 | 0] = $2;
 jsvObjectSetChildAndUnLock(HEAP32[$3 + 44 >> 2], 131993, jsvNewFromInteger(HEAP8[$3 + 39 | 0] & 1 ? 2 : 1));
 HEAP32[$3 + 32 >> 2] = HEAP8[$3 + 39 | 0] & 1 ? 128515 : 117947;
 HEAP32[$3 + 28 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 32 >> 2]);
 label$1: {
  if (!HEAP32[$3 + 28 >> 2]) {
   if (!(HEAP8[$3 + 39 | 0] & 1)) {
    HEAP32[$3 >> 2] = HEAP32[$3 + 40 >> 2];
    jsExceptionHere(1, 116874, $3);
    HEAP32[$3 + 24 >> 2] = 0;
    label$4: {
     if (!(jsvIsObject(HEAP32[$3 + 40 >> 2]) & 1)) {
      break label$4;
     }
     $0 = jsvObjectGetChildIfExists(HEAP32[$3 + 40 >> 2], 129121);
     HEAP32[$3 + 24 >> 2] = $0;
     if (!$0) {
      break label$4;
     }
     jsvObjectSetChildAndUnLock(HEAP32[91087], 132883, HEAP32[$3 + 24 >> 2]);
    }
   }
   break label$1;
  }
  if (jsvIsArray(HEAP32[$3 + 28 >> 2]) & 1) {
   jsvObjectIteratorNew($3 + 16 | 0, HEAP32[$3 + 28 >> 2]);
   while (1) {
    if (jsvObjectIteratorHasValue_17($3 + 16 | 0) & 1) {
     HEAP32[$3 + 12 >> 2] = jsvObjectIteratorGetValue_16($3 + 16 | 0);
     _jswrap_promise_queue_reaction(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 40 >> 2], HEAP8[$3 + 39 | 0] & 1);
     jsvUnLock(HEAP32[$3 + 12 >> 2]);
     jsvObjectIteratorNext($3 + 16 | 0);
     continue;
    }
    break;
   }
   jsvObjectIteratorFree_17($3 + 16 | 0);
  }
  jsvUnLock(HEAP32[$3 + 28 >> 2]);
 }
 __stack_pointer = $3 + 48 | 0;
}

function mbedtls_sha256_update($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1: {
  if (!HEAP32[$3 + 20 >> 2]) {
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = HEAP32[HEAP32[$3 + 28 >> 2] >> 2] & 63;
  HEAP32[$3 + 16 >> 2] = 64 - HEAP32[$3 + 12 >> 2];
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$3 + 20 >> 2] + HEAP32[$0 >> 2];
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2];
  if (HEAPU32[HEAP32[$3 + 28 >> 2] >> 2] < HEAPU32[$3 + 20 >> 2]) {
   $0 = HEAP32[$3 + 28 >> 2];
   HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
  }
  if (!(!HEAP32[$3 + 12 >> 2] | HEAPU32[$3 + 20 >> 2] < HEAPU32[$3 + 16 >> 2])) {
   __memcpy(HEAP32[$3 + 12 >> 2] + (HEAP32[$3 + 28 >> 2] + 40 | 0) | 0, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 16 >> 2]);
   mbedtls_sha256_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 28 >> 2] + 40 | 0);
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 16 >> 2];
   HEAP32[$3 + 12 >> 2] = 0;
  }
  while (1) {
   if (HEAPU32[$3 + 20 >> 2] >= 64) {
    mbedtls_sha256_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] - -64;
    HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] + -64;
    continue;
   }
   break;
  }
  if (!HEAP32[$3 + 20 >> 2]) {
   break label$1;
  }
  __memcpy(HEAP32[$3 + 12 >> 2] + (HEAP32[$3 + 28 >> 2] + 40 | 0) | 0, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
 }
 __stack_pointer = $3 + 32 | 0;
}

function mbedtls_sha1_update($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1: {
  if (!HEAP32[$3 + 20 >> 2]) {
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = HEAP32[HEAP32[$3 + 28 >> 2] >> 2] & 63;
  HEAP32[$3 + 16 >> 2] = 64 - HEAP32[$3 + 12 >> 2];
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$3 + 20 >> 2] + HEAP32[$0 >> 2];
  $0 = HEAP32[$3 + 28 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2];
  if (HEAPU32[HEAP32[$3 + 28 >> 2] >> 2] < HEAPU32[$3 + 20 >> 2]) {
   $0 = HEAP32[$3 + 28 >> 2];
   HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
  }
  if (!(!HEAP32[$3 + 12 >> 2] | HEAPU32[$3 + 20 >> 2] < HEAPU32[$3 + 16 >> 2])) {
   __memcpy(HEAP32[$3 + 12 >> 2] + (HEAP32[$3 + 28 >> 2] + 28 | 0) | 0, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 16 >> 2]);
   mbedtls_sha1_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 28 >> 2] + 28 | 0);
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 16 >> 2];
   HEAP32[$3 + 12 >> 2] = 0;
  }
  while (1) {
   if (HEAPU32[$3 + 20 >> 2] >= 64) {
    mbedtls_sha1_process(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] - -64;
    HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] + -64;
    continue;
   }
   break;
  }
  if (!HEAP32[$3 + 20 >> 2]) {
   break label$1;
  }
  __memcpy(HEAP32[$3 + 12 >> 2] + (HEAP32[$3 + 28 >> 2] + 28 | 0) | 0, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
 }
 __stack_pointer = $3 + 32 | 0;
}

function jswrap_graphics_getFont($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 128 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 120 >> 2] = $0;
 label$1: {
  if (!(graphicsGetFromVar($1 + 48 | 0, HEAP32[$1 + 120 >> 2]) & 1)) {
   HEAP32[$1 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 44 >> 2] = (HEAPU8[$1 + 73 | 0] | HEAPU8[$1 + 74 | 0] << 8) & 57344;
  HEAP32[$1 + 40 >> 2] = 0;
  if (!HEAP32[$1 + 44 >> 2]) {
   HEAP32[$1 + 40 >> 2] = 120867;
  }
  if (HEAP32[$1 + 44 >> 2] == 8192) {
   HEAP32[$1 + 40 >> 2] = 139174;
  }
  if (HEAP32[$1 + 44 >> 2] == 16384) {
   HEAP32[$1 + 40 >> 2] = 139037;
  }
  if (HEAP32[$1 + 44 >> 2] & 32768) {
   HEAP32[$1 + 40 >> 2] = 128679;
  }
  if (HEAP32[$1 + 40 >> 2]) {
   HEAP32[$1 + 36 >> 2] = (HEAPU8[$1 + 73 | 0] | HEAPU8[$1 + 74 | 0] << 8) & 8191;
   if (HEAP32[$1 + 36 >> 2] & 4096) {
    $0 = HEAP32[$1 + 40 >> 2];
    $2 = HEAP32[$1 + 36 >> 2];
    HEAP32[$1 + 8 >> 2] = (HEAP32[$1 + 36 >> 2] & 4032) >>> 6;
    HEAP32[$1 + 4 >> 2] = $2 & 63;
    HEAP32[$1 >> 2] = $0;
    HEAP32[$1 + 124 >> 2] = jsvVarPrintf(134515, $1);
    break label$1;
   }
   if (HEAP32[$1 + 36 >> 2] > 1) {
    $0 = HEAP32[$1 + 40 >> 2];
    HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 36 >> 2];
    HEAP32[$1 + 16 >> 2] = $0;
    HEAP32[$1 + 124 >> 2] = jsvVarPrintf(134524, $1 + 16 | 0);
    break label$1;
   }
   HEAP32[$1 + 124 >> 2] = jsvNewFromString(HEAP32[$1 + 40 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 124 >> 2] = jsvNewFromInteger(HEAPU8[$1 + 73 | 0] | HEAPU8[$1 + 74 | 0] << 8);
 }
 __stack_pointer = $1 + 128 | 0;
 return HEAP32[$1 + 124 >> 2];
}

function jshGetCharToTransmit($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 11 | 0] = $0;
 label$1: {
  if (!(HEAPU8[$1 + 11 | 0] < 21 | HEAPU8[$1 + 11 | 0] > 22)) {
   HEAP32[$1 + 4 >> 2] = HEAPU8[$1 + 11 | 0] + 364467;
   if (HEAP8[HEAP32[$1 + 4 >> 2]] & 1) {
    HEAP8[HEAP32[$1 + 4 >> 2]] = HEAPU8[HEAP32[$1 + 4 >> 2]] & -2 | 4;
    HEAP32[$1 + 12 >> 2] = 19;
    break label$1;
   }
   if (HEAPU8[HEAP32[$1 + 4 >> 2]] & 2) {
    HEAP8[HEAP32[$1 + 4 >> 2]] = HEAPU8[HEAP32[$1 + 4 >> 2]] & -7;
    HEAP32[$1 + 12 >> 2] = 17;
    break label$1;
   }
  }
  HEAP8[$1 + 3 | 0] = HEAPU8[364485];
  while (1) {
   if (HEAPU8[364484] != HEAPU8[$1 + 3 | 0]) {
    if (HEAPU8[$1 + 11 | 0] == (HEAPU8[(HEAPU8[$1 + 3 | 0] << 1) + 364560 | 0] & 31)) {
     HEAP8[$1 + 2 | 0] = HEAPU8[((HEAPU8[$1 + 3 | 0] << 1) + 364560 | 0) + 1 | 0];
     if (HEAPU8[$1 + 3 | 0] != HEAPU8[364485]) {
      HEAP8[$1 + 1 | 0] = HEAPU8[$1 + 3 | 0];
      HEAP8[$1 | 0] = HEAPU8[$1 + 1 | 0] + 255;
      while (1) {
       if (HEAPU8[$1 + 1 | 0] != HEAPU8[364485]) {
        HEAP16[(HEAPU8[$1 + 1 | 0] << 1) + 364560 >> 1] = HEAPU16[(HEAPU8[$1 | 0] << 1) + 364560 >> 1];
        HEAP8[$1 + 1 | 0] = HEAPU8[$1 | 0];
        HEAP8[$1 | 0] = HEAPU8[$1 + 1 | 0] + 255;
        continue;
       }
       break;
      }
     }
     HEAP8[364485] = HEAPU8[364485] + 1;
     HEAP32[$1 + 12 >> 2] = HEAPU8[$1 + 2 | 0];
     break label$1;
    } else {
     HEAP8[$1 + 3 | 0] = HEAPU8[$1 + 3 | 0] + 1;
     continue;
    }
   }
   break;
  }
  HEAP32[$1 + 12 >> 2] = -1;
 }
 return HEAP32[$1 + 12 >> 2];
}

function log($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $3 = wasm2js_scratch_load_i32(0) | 0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     if (($1 | 0) > 0 | ($1 | 0) >= 0) {
      if ($1 >>> 0 > 1048575) {
       break label$4;
      }
     }
     if (!($1 & 2147483647 | $3)) {
      return +(-1 / ($0 * $0));
     }
     if (($1 | 0) > 0 | ($1 | 0) >= 0) {
      break label$3;
     }
     return +(($0 - $0) / 0);
    }
    if ($1 >>> 0 > 2146435071) {
     break label$1;
    }
    $4 = 1072693248;
    $5 = -1023;
    if (($1 | 0) != 1072693248) {
     $4 = $1;
     break label$2;
    }
    if ($3) {
     break label$2;
    }
    return 0;
   }
   wasm2js_scratch_store_f64(+($0 * 0x40000000000000));
   $1 = wasm2js_scratch_load_i32(1) | 0;
   $3 = wasm2js_scratch_load_i32(0) | 0;
   $4 = $1;
   $5 = -1077;
  }
  $1 = $4 + 614242 | 0;
  $6 = +(($1 >>> 20 | 0) + $5 | 0);
  $1 = ($1 & 1048575) + 1072079006 | 0;
  wasm2js_scratch_store_i32(0, $3 | 0);
  $4 = $1;
  $1 = 0;
  wasm2js_scratch_store_i32(1, $4 | $1);
  $0 = +wasm2js_scratch_load_f64() + -1;
  $8 = $0;
  $2 = $0 / ($0 + 2);
  $9 = $2;
  $7 = $0 * ($0 * .5);
  $2 = $2 * $2;
  $0 = $2 * $2;
  $0 = $6 * .6931471803691238 + ($8 + ($9 * ($7 + ($0 * ($0 * ($0 * .15313837699209373 + .22222198432149784) + .3999999999940942) + $2 * ($0 * ($0 * ($0 * .14798198605116586 + .1818357216161805) + .2857142874366239) + .6666666666666735))) + $6 * 1.9082149292705877e-10 - $7));
 }
 return +$0;
}

function jstPinOutputAtTime($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer + -64 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 56 >> 2] = $0;
 HEAP32[$6 + 60 >> 2] = $1;
 HEAP32[$6 + 52 >> 2] = $2;
 HEAP32[$6 + 48 >> 2] = $3;
 HEAP32[$6 + 44 >> 2] = $4;
 HEAP8[$6 + 43 | 0] = $5;
 $0 = HEAP32[$6 + 56 >> 2];
 HEAP8[$6 + 16 | 0] = $0;
 HEAP8[$6 + 17 | 0] = $0 >>> 8;
 HEAP8[$6 + 18 | 0] = $0 >>> 16;
 HEAP8[$6 + 19 | 0] = $0 >>> 24;
 HEAP8[$6 + 20 | 0] = 0;
 HEAP8[$6 + 21 | 0] = 0;
 HEAP8[$6 + 22 | 0] = 0;
 HEAP8[$6 + 23 | 0] = 0;
 HEAP8[$6 + 40 | 0] = 2;
 HEAP32[$6 + 12 >> 2] = 0;
 while (1) {
  if (HEAP32[$6 + 12 >> 2] < 8) {
   $1 = HEAP32[$6 + 12 >> 2] + ($6 + 24 | 0) | 0;
   if (HEAP32[$6 + 12 >> 2] < HEAP32[$6 + 44 >> 2]) {
    $0 = HEAPU8[HEAP32[$6 + 48 >> 2] + HEAP32[$6 + 12 >> 2] | 0];
   } else {
    $0 = 255;
   }
   HEAP8[$1 | 0] = $0;
   HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP8[$6 + 32 | 0] = HEAPU8[$6 + 43 | 0];
 HEAP32[$6 + 8 >> 2] = 2e6;
 while (1) {
  $0 = 0;
  label$6: {
   if (!(utilTimerIsFull() & 1)) {
    break label$6;
   }
   $0 = 0;
   if (jspIsInterrupted() & 1) {
    break label$6;
   }
   $0 = HEAP32[$6 + 8 >> 2];
   HEAP32[$6 + 8 >> 2] = $0 - 1;
   $0 = ($0 | 0) > 0;
  }
  if ($0) {
   continue;
  }
  break;
 }
 label$7: {
  if (jspIsInterrupted() & 1) {
   jsExceptionHere(4, 121089, 0);
   break label$7;
  }
  if (HEAP32[$6 + 8 >> 2] <= 0) {
   jsExceptionHere(4, 121064, 0);
  }
 }
 $0 = utilTimerInsertTask($6 + 16 | 0, HEAP32[$6 + 52 >> 2]);
 __stack_pointer = $6 - -64 | 0;
 return $0 & 1;
}

function jsvNewNameOrString($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP8[$2 + 23 | 0] = $1;
 HEAP32[$2 + 16 >> 2] = jsvNewWithFlags((HEAP8[$2 + 23 | 0] & 1 ? 23 : 28) & 65535);
 label$1: {
  if (!HEAP32[$2 + 16 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvLockAgain(HEAP32[$2 + 16 >> 2]);
  while (1) {
   if (HEAPU8[HEAP32[$2 + 24 >> 2]]) {
    HEAP32[$2 + 4 >> 2] = jsvGetMaxCharactersInVar(HEAP32[$2 + 12 >> 2]);
    HEAP32[$2 + 8 >> 2] = 0;
    while (1) {
     $0 = 0;
     $0 = HEAPU32[$2 + 8 >> 2] < HEAPU32[$2 + 4 >> 2] ? HEAP8[HEAP32[$2 + 24 >> 2]] != 0 : $0;
     if ($0) {
      $0 = HEAP32[$2 + 24 >> 2];
      HEAP32[$2 + 24 >> 2] = $0 + 1;
      HEAP8[HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 8 >> 2] | 0] = HEAPU8[$0 | 0];
      HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] + 1;
      continue;
     }
     break;
    }
    jsvSetCharactersInVar(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
    if (HEAPU8[HEAP32[$2 + 24 >> 2]]) {
     HEAP32[$2 >> 2] = jsvNewWithFlags(41);
     if (!HEAP32[$2 >> 2]) {
      jsvUnLock(HEAP32[$2 + 12 >> 2]);
      HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
      break label$1;
     }
     jsvSetLastChild(HEAP32[$2 + 12 >> 2], jsvGetRef(HEAP32[$2 >> 2]) & 65535);
     jsvUnLock(HEAP32[$2 + 12 >> 2]);
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
    }
    continue;
   }
   break;
  }
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jswrap_banglejs_beep($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 if (HEAP32[$2 + 20 >> 2] <= 0) {
  HEAP32[$2 + 20 >> 2] = 4e3;
 }
 if (HEAP32[$2 + 20 >> 2] > 6e4) {
  HEAP32[$2 + 20 >> 2] = 6e4;
 }
 if (HEAP32[$2 + 24 >> 2] <= 0) {
  HEAP32[$2 + 24 >> 2] = 200;
 }
 if (HEAP32[$2 + 24 >> 2] > 5e3) {
  HEAP32[$2 + 24 >> 2] = 5e3;
 }
 label$5: {
  if (HEAP32[97789]) {
   HEAP32[$2 + 16 >> 2] = jsvNewNativeFunction(138, 289);
   HEAP32[$2 + 12 >> 2] = jsvNewFromInteger(HEAP32[$2 + 24 >> 2]);
   jsvAddFunctionParameter(HEAP32[$2 + 16 >> 2], 0, HEAP32[$2 + 12 >> 2]);
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   HEAP32[$2 + 12 >> 2] = jsvNewFromInteger(HEAP32[$2 + 20 >> 2]);
   jsvAddFunctionParameter(HEAP32[$2 + 16 >> 2], 0, HEAP32[$2 + 12 >> 2]);
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   HEAP32[$2 + 8 >> 2] = jswrap_promise_then(HEAP32[97789], HEAP32[$2 + 16 >> 2], 0);
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 8 >> 2];
   break label$5;
  }
  HEAP32[97789] = jspromise_create();
  if (!HEAP32[97789]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$5;
  }
  if (HEAP32[97749] & 256) {
   HEAP16[195569] = HEAP32[$2 + 20 >> 2];
   if (HEAP32[97749] & 128) {
    _jswrap_banglejs_setVibration();
   }
  }
  jstExecuteFn(619, 0, jshGetTimeFromMilliseconds(+HEAP32[$2 + 24 >> 2]), i64toi32_i32$HIGH_BITS, 0, 0);
  HEAP32[$2 + 28 >> 2] = jsvLockAgain(HEAP32[97789]);
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jswrap_interface_changeInterval($0, $1) {
 $0 = $0 | 0;
 $1 = +$1;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAPF64[$2 + 32 >> 3] = $1;
 HEAP32[$2 + 28 >> 2] = jsvLock(HEAPU16[182204]);
 if (HEAPF64[$2 + 32 >> 3] < .1) {
  HEAPF64[$2 + 32 >> 3] = .1;
 }
 label$2: {
  if (jsvIsBasic(HEAP32[$2 + 44 >> 2]) & 1) {
   $0 = jsvFindChildFromVar(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 44 >> 2], 0);
   break label$2;
  }
  $0 = 0;
 }
 HEAP32[$2 + 24 >> 2] = $0;
 label$4: {
  if (HEAP32[$2 + 24 >> 2]) {
   HEAP32[$2 + 20 >> 2] = jsvSkipNameAndUnLock(HEAP32[$2 + 24 >> 2]);
   HEAP32[$2 + 8 >> 2] = jshGetTimeFromMilliseconds(HEAPF64[$2 + 32 >> 3]);
   $0 = i64toi32_i32$HIGH_BITS;
   HEAP32[$2 + 12 >> 2] = $0;
   $0 = HEAP32[$2 + 8 >> 2];
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 20 >> 2], 120745, jsvNewFromLongInteger($0, HEAP32[$2 + 12 >> 2]));
   $6 = HEAP32[$2 + 20 >> 2];
   $5 = jshGetSystemTime();
   $0 = i64toi32_i32$HIGH_BITS;
   $7 = $0;
   $0 = HEAP32[91118];
   $4 = $0;
   $3 = $5 - $0 | 0;
   $8 = $3;
   $0 = HEAP32[91119];
   $3 = HEAP32[$2 + 12 >> 2] + ($7 - ($0 + ($4 >>> 0 > $5 >>> 0) | 0) | 0) | 0;
   $4 = HEAP32[$2 + 8 >> 2];
   $0 = $4 + $8 | 0;
   $3 = $0 >>> 0 < $4 >>> 0 ? $3 + 1 | 0 : $3;
   jsvObjectSetChildAndUnLock($6, 132372, jsvNewFromLongInteger($0, $3));
   jsvUnLock(HEAP32[$2 + 20 >> 2]);
   jsiTimersChanged();
   break label$4;
  }
  jsExceptionHere(1, 129035, 0);
 }
 jsvUnLock(HEAP32[$2 + 28 >> 2]);
 __stack_pointer = $2 + 48 | 0;
}

function jswrap_decodeURIComponent($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 112 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 104 >> 2] = $0;
 HEAP32[$1 + 100 >> 2] = jsvAsString(HEAP32[$1 + 104 >> 2]);
 label$1: {
  if (!HEAP32[$1 + 100 >> 2]) {
   HEAP32[$1 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 96 >> 2] = jsvNewFromEmptyString_6();
  if (HEAP32[$1 + 96 >> 2]) {
   jsvStringIteratorNew($1 + 56 | 0, HEAP32[$1 + 100 >> 2], 0);
   jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 96 >> 2], 0);
   while (1) {
    label$5: {
     if (!(jsvStringIteratorHasChar_6($1 + 56 | 0) & 1)) {
      break label$5;
     }
     HEAP8[$1 + 15 | 0] = jsvStringIteratorGetCharAndNext($1 + 56 | 0);
     if (HEAP8[$1 + 15 | 0] >> 7) {
      jsExceptionHere(1, 116206, 0);
      break label$5;
     }
     if (HEAP8[$1 + 15 | 0] == 37) {
      HEAP8[$1 + 14 | 0] = jsvStringIteratorGetCharAndNext($1 + 56 | 0);
      HEAP8[$1 + 13 | 0] = jsvStringIteratorGetCharAndNext($1 + 56 | 0);
      HEAP32[$1 + 8 >> 2] = hexToByte(HEAP8[$1 + 14 | 0], HEAP8[$1 + 13 | 0]) << 24 >> 24;
      if (HEAP32[$1 + 8 >> 2] < 0) {
       jsExceptionHere(1, 137467, 0);
       break label$5;
      }
      HEAP8[$1 + 15 | 0] = HEAP32[$1 + 8 >> 2];
     }
     jsvStringIteratorAppend($1 + 16 | 0, HEAP8[$1 + 15 | 0]);
     continue;
    }
    break;
   }
   jsvStringIteratorFree_7($1 + 16 | 0);
   jsvStringIteratorFree_7($1 + 56 | 0);
  }
  jsvUnLock(HEAP32[$1 + 100 >> 2]);
  HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 96 >> 2];
 }
 __stack_pointer = $1 + 112 | 0;
 return HEAP32[$1 + 108 >> 2];
}

function jsfBankCompact($0, $1) {
 var $2 = 0, $3 = 0;
 $3 = __stack_pointer - 80 | 0;
 $2 = $3;
 __stack_pointer = $2;
 HEAP32[$2 + 72 >> 2] = $0;
 HEAP8[$2 + 71 | 0] = $1;
 label$1: {
  if (!(jshFlashGetPage(HEAP32[$2 + 72 >> 2], $2 - -64 | 0, $2 + 60 | 0) & 1)) {
   HEAP8[$2 + 79 | 0] = 0;
   break label$1;
  }
  HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 60 >> 2] + 32;
  jsfGetStorageStats($2 + 24 | 0, HEAP32[$2 + 72 >> 2], 1);
  if (!HEAP32[$2 + 32 >> 2]) {
   HEAP8[$2 + 79 | 0] = 0;
   break label$1;
  }
  if (HEAP8[$2 + 71 | 0] & 1) {
   jsvUnLock(jspEvaluate(138703, 1));
  }
  HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 24 >> 2];
  if (HEAPU32[$2 + 20 >> 2] > HEAPU32[$2 + 56 >> 2]) {
   HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 56 >> 2];
  }
  HEAP8[$2 + 19 | 0] = 0;
  label$6: {
   if (HEAP32[$2 + 20 >> 2] + 256 >>> 0 < jsuGetFreeStack() >>> 0) {
    $3 = $3 - (HEAP32[$2 + 20 >> 2] + 15 & -16) | 0;
    __stack_pointer = $3;
    HEAP32[$2 + 12 >> 2] = $3;
    HEAP8[$2 + 19 | 0] = jsfCompactInternal(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 20 >> 2]) & 1;
    break label$6;
   }
   HEAP32[$2 + 8 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 20 >> 2]);
   if (HEAP32[$2 + 8 >> 2]) {
    HEAP32[$2 + 4 >> 2] = jsvGetFlatStringPointer(HEAP32[$2 + 8 >> 2]);
    HEAP8[$2 + 19 | 0] = jsfCompactInternal(HEAP32[$2 + 48 >> 2], HEAP32[$2 + 4 >> 2], HEAP32[$2 + 20 >> 2]) & 1;
    jsvUnLock(HEAP32[$2 + 8 >> 2]);
   }
  }
  jsvUnLock(jspEvaluate(138984, 1));
  HEAP8[$2 + 79 | 0] = HEAP8[$2 + 19 | 0] & 1;
 }
 __stack_pointer = $2 + 80 | 0;
 return HEAP8[$2 + 79 | 0] & 1;
}

function getDstChangeTime($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
 var $10 = 0;
 $10 = __stack_pointer - 48 | 0;
 __stack_pointer = $10;
 HEAP32[$10 + 44 >> 2] = $0;
 HEAP32[$10 + 40 >> 2] = $1;
 HEAP32[$10 + 36 >> 2] = $2;
 HEAP32[$10 + 32 >> 2] = $3;
 HEAP32[$10 + 28 >> 2] = $4;
 HEAP32[$10 + 24 >> 2] = $5;
 HEAP8[$10 + 23 | 0] = $6;
 HEAP32[$10 + 16 >> 2] = $7;
 HEAP32[$10 + 12 >> 2] = $8;
 HEAP8[$10 + 11 | 0] = $9;
 if (HEAP32[$10 + 40 >> 2] == 4) {
  $0 = HEAP32[$10 + 32 >> 2] + 1 | 0;
  HEAP32[$10 + 32 >> 2] = $0;
  if (($0 | 0) > 11) {
   HEAP32[$10 + 44 >> 2] = HEAP32[$10 + 44 >> 2] + 1;
   HEAP32[$10 + 32 >> 2] = HEAP32[$10 + 32 >> 2] - 12;
  }
 }
 HEAP32[$10 + 4 >> 2] = getDayNumberFromDate(HEAP32[$10 + 44 >> 2], HEAP32[$10 + 32 >> 2], 1);
 label$3: {
  if (HEAP32[$10 + 40 >> 2] == 4) {
   HEAP32[$10 + 4 >> 2] = HEAP32[$10 + 4 >> 2] + (((HEAP32[$10 + 36 >> 2] + (14 - ((HEAP32[$10 + 4 >> 2] + 4 | 0) % 7 | 0) | 0) | 0) % 7 | 0) - 7 | 0);
   break label$3;
  }
  HEAP32[$10 + 4 >> 2] = HEAP32[$10 + 4 >> 2] + (Math_imul(HEAP32[$10 + 40 >> 2], 7) + ((HEAP32[$10 + 36 >> 2] + (14 - ((HEAP32[$10 + 4 >> 2] + 4 | 0) % 7 | 0) | 0) | 0) % 7 | 0) | 0);
 }
 HEAP32[$10 + 4 >> 2] = HEAP32[$10 + 24 >> 2] + Math_imul(HEAP32[$10 + 4 >> 2] + HEAP32[$10 + 28 >> 2] | 0, 1440);
 if (!(HEAP8[$10 + 11 | 0] & 1)) {
  HEAP32[$10 + 4 >> 2] = HEAP32[$10 + 4 >> 2] - HEAP32[$10 + 12 >> 2];
  if (!(HEAP8[$10 + 23 | 0] & 1)) {
   HEAP32[$10 + 4 >> 2] = HEAP32[$10 + 4 >> 2] - HEAP32[$10 + 16 >> 2];
  }
 }
 __stack_pointer = $10 + 48 | 0;
 return +HEAP32[$10 + 4 >> 2] * 60;
}

function _jswrap_promise_reaction_call($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 44 >> 2] = $0;
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 36 >> 2] = $2;
 HEAP32[$4 + 32 >> 2] = $3;
 HEAP32[$4 + 28 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 40 >> 2], 117121);
 HEAP32[$4 + 24 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 28 >> 2], 128686);
 if (HEAP32[$4 + 28 >> 2]) {
  if (HEAP32[$4 + 24 >> 2]) {
   HEAP8[$4 + 23 | 0] = 0;
   HEAP32[$4 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 40 >> 2], 135710);
   label$3: {
    if (HEAP32[$4 + 12 >> 2]) {
     HEAP32[$4 + 8 >> 2] = HEAP32[91094];
     HEAP32[$4 + 16 >> 2] = jspeFunctionCall(HEAP32[$4 + 12 >> 2], 0, HEAP32[$4 + 44 >> 2], 0, 1, $4 + 36 | 0);
     HEAP32[91094] = HEAP32[$4 + 8 >> 2];
     HEAP32[$4 + 4 >> 2] = jspGetException();
     if (HEAP32[$4 + 4 >> 2]) {
      HEAP8[$4 + 23 | 0] = 1;
      jsvUnLock(HEAP32[$4 + 16 >> 2]);
      HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 4 >> 2];
     }
     jsvUnLock(HEAP32[$4 + 12 >> 2]);
     break label$3;
    }
    if (!(jsvGetBool(HEAP32[$4 + 32 >> 2]) & 1)) {
     HEAP8[$4 + 23 | 0] = 1;
    }
    HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 36 >> 2];
   }
   _jswrap_prombox_resolve_or_reject(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 16 >> 2], (HEAPU8[$4 + 23 | 0] ^ -1) & 1);
   if (HEAP32[$4 + 12 >> 2]) {
    jsvUnLock(HEAP32[$4 + 16 >> 2]);
   }
   jsvUnLock(HEAP32[$4 + 24 >> 2]);
  }
  jsvUnLock(HEAP32[$4 + 28 >> 2]);
 }
 __stack_pointer = $4 + 48 | 0;
}

function jswrap_json_stringify($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 HEAP32[$3 + 32 >> 2] = 15568;
 HEAP32[$3 + 28 >> 2] = jsvNewFromEmptyString_7();
 if (HEAP32[$3 + 28 >> 2]) {
  HEAP8[$3 + 23 | 0] = 0;
  HEAP8[$3 + 24 | 0] = 0;
  HEAP8[$3 + 25 | 0] = 0;
  HEAP8[$3 + 26 | 0] = 0;
  HEAP32[$3 + 16 >> 2] = 0;
  HEAP32[$3 + 20 >> 2] = 0;
  label$2: {
   if (jsvIsUndefined(HEAP32[$3 + 36 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsNull(HEAP32[$3 + 36 >> 2]) & 1) {
    break label$2;
   }
   label$4: {
    if (jsvIsNumeric(HEAP32[$3 + 36 >> 2]) & 1) {
     HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 36 >> 2]);
     if (HEAP32[$3 + 12 >> 2] < 0) {
      HEAP32[$3 + 12 >> 2] = 0;
     }
     if (HEAP32[$3 + 12 >> 2] > 10) {
      HEAP32[$3 + 12 >> 2] = 10;
     }
     HEAP8[HEAP32[$3 + 12 >> 2] + ($3 + 16 | 0) | 0] = 0;
     while (1) {
      if (HEAP32[$3 + 12 >> 2]) {
       $0 = HEAP32[$3 + 12 >> 2] - 1 | 0;
       HEAP32[$3 + 12 >> 2] = $0;
       HEAP8[($3 + 16 | 0) + $0 | 0] = 32;
       continue;
      }
      break;
     }
     break label$4;
    }
    jsvGetString(HEAP32[$3 + 36 >> 2], $3 + 16 | 0, 10);
   }
  }
  if (strlen($3 + 16 | 0)) {
   HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] | 6;
  }
  jsfGetJSONWhitespace(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 28 >> 2], HEAP32[$3 + 32 >> 2], $3 + 16 | 0);
 }
 __stack_pointer = $3 + 48 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function st_yield_backref($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 4 >> 2] - HEAP32[HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2] >> 2];
 label$1: {
  if (HEAP32[$2 + 16 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   if (HEAPU16[HEAP32[$2 + 24 >> 2] + 4 >> 1] < HEAPU32[$2 + 16 >> 2]) {
    HEAP32[$2 + 16 >> 2] = HEAPU16[HEAP32[$2 + 24 >> 2] + 4 >> 1];
   }
   HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 24 >> 2] + 45;
   HEAP16[$2 + 6 >> 1] = 255;
   HEAP16[$2 + 4 >> 1] = HEAPU16[HEAP32[$2 + 24 >> 2] + 6 >> 1];
   HEAP32[$2 + 12 >> 2] = 0;
   while (1) {
    if (HEAPU32[$2 + 12 >> 2] < HEAPU32[$2 + 16 >> 2]) {
     HEAP8[$2 + 3 | 0] = HEAPU8[HEAP32[$2 + 8 >> 2] + (HEAPU16[$2 + 6 >> 1] & HEAPU16[HEAP32[$2 + 24 >> 2] + 8 >> 1] - HEAPU16[$2 + 4 >> 1]) | 0];
     push_byte(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAPU8[$2 + 3 | 0]);
     HEAP8[HEAP32[$2 + 8 >> 2] + (HEAPU16[HEAP32[$2 + 24 >> 2] + 8 >> 1] & HEAPU16[$2 + 6 >> 1]) | 0] = HEAPU8[$2 + 3 | 0];
     $0 = HEAP32[$2 + 24 >> 2];
     HEAP16[$0 + 8 >> 1] = HEAPU16[$0 + 8 >> 1] + 1;
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
     continue;
    }
    break;
   }
   $0 = HEAP32[$2 + 24 >> 2];
   HEAP16[$0 + 4 >> 1] = HEAPU16[$0 + 4 >> 1] - HEAP32[$2 + 16 >> 2];
   if (!HEAPU16[HEAP32[$2 + 24 >> 2] + 4 >> 1]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break label$1;
   }
  }
  HEAP32[$2 + 28 >> 2] = 6;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function _jswrap_graphics_getCharWidth($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (!(HEAP32[HEAP32[$2 + 8 >> 2] >> 2] | HEAP32[$2 + 4 >> 2] >= 256)) {
   HEAP32[$2 + 12 >> 2] = graphicsVectorCharWidth(HEAPU16[HEAP32[$2 + 8 >> 2] + 6 >> 1], HEAP32[$2 + 4 >> 2] << 24 >> 24);
   break label$1;
  }
  if (!(HEAP32[HEAP32[$2 + 8 >> 2] >> 2] != 8192 | HEAP32[$2 + 4 >> 2] >= 256)) {
   HEAP32[$2 + 12 >> 2] = HEAPU16[HEAP32[$2 + 8 >> 2] + 6 >> 1] << 2;
   break label$1;
  }
  if (!(HEAP32[HEAP32[$2 + 8 >> 2] >> 2] != 16384 | HEAP32[$2 + 4 >> 2] >= 256)) {
   HEAP32[$2 + 12 >> 2] = Math_imul(HEAPU16[HEAP32[$2 + 8 >> 2] + 6 >> 1], 6);
   break label$1;
  }
  if (HEAP32[HEAP32[$2 + 8 >> 2] >> 2] & 32768) {
   HEAP32[$2 >> 2] = 0;
   if (HEAP32[$2 + 4 >> 2] < 256) {
    label$7: {
     if (jsvIsString(HEAP32[HEAP32[$2 + 8 >> 2] + 12 >> 2]) & 1) {
      if (HEAP32[$2 + 4 >> 2] >= HEAPU8[HEAP32[$2 + 8 >> 2] + 10 | 0]) {
       HEAP32[$2 >> 2] = Math_imul(HEAPU16[HEAP32[$2 + 8 >> 2] + 6 >> 1], jsvGetCharInString(HEAP32[HEAP32[$2 + 8 >> 2] + 12 >> 2], HEAP32[$2 + 4 >> 2] - HEAPU8[HEAP32[$2 + 8 >> 2] + 10 | 0] | 0) & 255);
      }
      break label$7;
     }
     HEAP32[$2 >> 2] = Math_imul(HEAPU16[HEAP32[$2 + 8 >> 2] + 6 >> 1], jsvGetInteger(HEAP32[HEAP32[$2 + 8 >> 2] + 12 >> 2]));
    }
   }
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jsiDumpSerialInitialisation($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 44 >> 2] = $0;
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 36 >> 2] = $2;
 HEAP8[$4 + 35 | 0] = $3;
 HEAP32[$4 + 28 >> 2] = jsvFindChildFromString(HEAP32[91086], HEAP32[$4 + 36 >> 2]);
 HEAP32[$4 + 24 >> 2] = jsvSkipName(HEAP32[$4 + 28 >> 2]);
 if (HEAP32[$4 + 24 >> 2]) {
  if (HEAP8[$4 + 35 | 0] & 1) {
   jsiDumpObjectState(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2], HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2]);
  }
  HEAP32[$4 + 20 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 24 >> 2], 132026);
  HEAP32[$4 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 24 >> 2], 120075);
  if (HEAP32[$4 + 16 >> 2] ? 1 : HEAP32[$4 + 20 >> 2]) {
   HEAP32[$4 + 12 >> 2] = jsvGetInteger(HEAP32[$4 + 20 >> 2]);
   if (HEAP32[$4 + 12 >> 2] <= 0) {
    HEAP32[$4 + 12 >> 2] = 9600;
   }
   $0 = HEAP32[$4 + 44 >> 2];
   $1 = HEAP32[$4 + 40 >> 2];
   $2 = HEAP32[$4 + 36 >> 2];
   HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 12 >> 2];
   HEAP32[$4 >> 2] = $2;
   cbprintf($0, $1, 134570, $4);
   if (jsvIsObject(HEAP32[$4 + 16 >> 2]) & 1) {
    FUNCTION_TABLE[HEAP32[$4 + 44 >> 2]](146375, HEAP32[$4 + 40 >> 2]);
    jsfGetJSONWithCallback(HEAP32[$4 + 16 >> 2], 0, 32, 0, HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2]);
   }
   FUNCTION_TABLE[HEAP32[$4 + 44 >> 2]](147434, HEAP32[$4 + 40 >> 2]);
  }
  jsvUnLock3(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[$4 + 24 >> 2]);
 }
 jsvUnLock(HEAP32[$4 + 28 >> 2]);
 __stack_pointer = $4 + 48 | 0;
}

function jswrap_function_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = jsvNewWithFlags(7);
 label$1: {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  jsvObjectIteratorNew($1 + 16 | 0, HEAP32[$1 + 24 >> 2]);
  HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue_7($1 + 16 | 0);
  jsvObjectIteratorNext($1 + 16 | 0);
  while (1) {
   if (jsvObjectIteratorHasValue_7($1 + 16 | 0) & 1) {
    HEAP32[$1 + 8 >> 2] = jsvAsString(HEAP32[$1 + 12 >> 2]);
    if (HEAP32[$1 + 8 >> 2]) {
     HEAP32[$1 + 4 >> 2] = jsvNewFromString(113710);
     if (HEAP32[$1 + 4 >> 2]) {
      jsvAppendStringVarComplete(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2]);
      jsvAddFunctionParameter(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 4 >> 2], 0);
     }
     jsvUnLock(HEAP32[$1 + 8 >> 2]);
    }
    jsvUnLock(HEAP32[$1 + 12 >> 2]);
    HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue_7($1 + 16 | 0);
    jsvObjectIteratorNext($1 + 16 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_7($1 + 16 | 0);
  if (!(jsvIsString(HEAP32[$1 + 12 >> 2]) & 1)) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
   jsExceptionHere(3, 145242, $1);
   jsvUnLock2(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 20 >> 2]);
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 20 >> 2], 133204, HEAP32[$1 + 12 >> 2]);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function mbedtls_cipher_update($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 24 >> 2] = $0;
 HEAP32[$5 + 20 >> 2] = $1;
 HEAP32[$5 + 16 >> 2] = $2;
 HEAP32[$5 + 12 >> 2] = $3;
 HEAP32[$5 + 8 >> 2] = $4;
 label$1: {
  if (HEAP32[$5 + 8 >> 2] ? !HEAP32[$5 + 24 >> 2] | !HEAP32[HEAP32[$5 + 24 >> 2] >> 2] : 1) {
   HEAP32[$5 + 28 >> 2] = -24832;
   break label$1;
  }
  HEAP32[HEAP32[$5 + 8 >> 2] >> 2] = 0;
  if (HEAP32[HEAP32[HEAP32[$5 + 24 >> 2] >> 2] + 4 >> 2] == 1) {
   if (HEAP32[$5 + 16 >> 2] != (mbedtls_cipher_get_block_size(HEAP32[$5 + 24 >> 2]) | 0)) {
    HEAP32[$5 + 28 >> 2] = -25216;
    break label$1;
   }
   HEAP32[HEAP32[$5 + 8 >> 2] >> 2] = HEAP32[$5 + 16 >> 2];
   $0 = FUNCTION_TABLE[HEAP32[HEAP32[HEAP32[HEAP32[$5 + 24 >> 2] >> 2] + 28 >> 2] + 4 >> 2]](HEAP32[HEAP32[$5 + 24 >> 2] + 52 >> 2], HEAP32[HEAP32[$5 + 24 >> 2] + 8 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 12 >> 2]) | 0;
   HEAP32[$5 + 4 >> 2] = $0;
   if ($0) {
    HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 4 >> 2];
    break label$1;
   }
   HEAP32[$5 + 28 >> 2] = 0;
   break label$1;
  }
  label$7: {
   if (HEAP32[$5 + 20 >> 2] != HEAP32[$5 + 12 >> 2]) {
    break label$7;
   }
   if (!HEAP32[HEAP32[$5 + 24 >> 2] + 28 >> 2]) {
    if (!(HEAPU32[$5 + 16 >> 2] % (mbedtls_cipher_get_block_size(HEAP32[$5 + 24 >> 2]) >>> 0) | 0)) {
     break label$7;
    }
   }
   HEAP32[$5 + 28 >> 2] = -24832;
   break label$1;
  }
  HEAP32[$5 + 28 >> 2] = -24704;
 }
 __stack_pointer = $5 + 32 | 0;
 return HEAP32[$5 + 28 >> 2];
}

function jsvAsNumber($0) {
 var $1 = 0;
 $1 = __stack_pointer - 80 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 72 >> 2] = $0;
 label$1: {
  label$2: {
   if (!(jsvIsInt(HEAP32[$1 + 72 >> 2]) & 1)) {
    if (!(jsvIsFloat(HEAP32[$1 + 72 >> 2]) & 1)) {
     break label$2;
    }
   }
   HEAP32[$1 + 76 >> 2] = jsvLockAgain(HEAP32[$1 + 72 >> 2]);
   break label$1;
  }
  label$4: {
   label$5: {
    if (jsvIsBoolean(HEAP32[$1 + 72 >> 2]) & 1) {
     break label$5;
    }
    if (jsvIsPin(HEAP32[$1 + 72 >> 2]) & 1) {
     break label$5;
    }
    if (jsvIsNull(HEAP32[$1 + 72 >> 2]) & 1) {
     break label$5;
    }
    if (jsvIsBoolean(HEAP32[$1 + 72 >> 2]) & 1) {
     break label$5;
    }
    if (!(jsvIsArrayBufferName(HEAP32[$1 + 72 >> 2]) & 1)) {
     break label$4;
    }
   }
   HEAP32[$1 + 76 >> 2] = jsvNewFromInteger(jsvGetInteger(HEAP32[$1 + 72 >> 2]));
   break label$1;
  }
  label$6: {
   if (!(jsvIsString(HEAP32[$1 + 72 >> 2]) & 1)) {
    break label$6;
   }
   if (!(jsvIsEmptyString(HEAP32[$1 + 72 >> 2]) & 1)) {
    if (!(jsvIsStringNumericInt(HEAP32[$1 + 72 >> 2], 0) & 1)) {
     break label$6;
    }
   }
   if ((jsvGetString(HEAP32[$1 + 72 >> 2], $1, 64) | 0) == 64) {
    jsExceptionHere(1, 121368, 0);
    HEAP32[$1 + 76 >> 2] = jsvNewFromFloat(nan);
    break label$1;
   }
   HEAP32[$1 + 76 >> 2] = jsvNewFromLongInteger(stringToInt($1), i64toi32_i32$HIGH_BITS);
   break label$1;
  }
  HEAP32[$1 + 76 >> 2] = jsvNewFromFloat(jsvGetFloat(HEAP32[$1 + 72 >> 2]));
 }
 __stack_pointer = $1 + 80 | 0;
 return HEAP32[$1 + 76 >> 2];
}

function jswrap_graphics_getModified($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 96 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP8[$2 + 87 | 0] = $1;
 label$1: {
  if (!(graphicsGetFromVar($2 + 8 | 0, HEAP32[$2 + 88 >> 2]) & 1)) {
   HEAP32[$2 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 4 >> 2] = 0;
  if ((HEAPU8[$2 + 48 | 0] | HEAPU8[$2 + 49 | 0] << 8) << 16 >> 16 <= (HEAPU8[$2 + 52 | 0] | HEAPU8[$2 + 53 | 0] << 8) << 16 >> 16) {
   HEAP32[$2 + 4 >> 2] = jsvNewObject();
   if (HEAP32[$2 + 4 >> 2]) {
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 4 >> 2], 139857, jsvNewFromInteger((HEAPU8[$2 + 48 | 0] | HEAPU8[$2 + 49 | 0] << 8) << 16 >> 16));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 4 >> 2], 139854, jsvNewFromInteger((HEAPU8[$2 + 50 | 0] | HEAPU8[$2 + 51 | 0] << 8) << 16 >> 16));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 4 >> 2], 139550, jsvNewFromInteger((HEAPU8[$2 + 52 | 0] | HEAPU8[$2 + 53 | 0] << 8) << 16 >> 16));
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 4 >> 2], 139547, jsvNewFromInteger((HEAPU8[$2 + 54 | 0] | HEAPU8[$2 + 55 | 0] << 8) << 16 >> 16));
   }
  }
  if (HEAP8[$2 + 87 | 0] & 1) {
   HEAP8[$2 + 52 | 0] = 0;
   HEAP8[$2 + 53 | 0] = 128;
   HEAP8[$2 + 54 | 0] = 0;
   HEAP8[$2 + 55 | 0] = 128;
   HEAP8[$2 + 48 | 0] = 255;
   HEAP8[$2 + 49 | 0] = 127;
   HEAP8[$2 + 50 | 0] = 255;
   HEAP8[$2 + 51 | 0] = 127;
   graphicsSetVar($2 + 8 | 0);
  }
  HEAP32[$2 + 92 >> 2] = HEAP32[$2 + 4 >> 2];
 }
 __stack_pointer = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}

function jsvGetIndexOfFull($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 96 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 88 >> 2] = $0;
 HEAP32[$5 + 84 >> 2] = $1;
 HEAP8[$5 + 83 | 0] = $2;
 HEAP8[$5 + 82 | 0] = $3;
 HEAP32[$5 + 76 >> 2] = $4;
 label$1: {
  if (!(jsvIsIterable(HEAP32[$5 + 88 >> 2]) & 1)) {
   HEAP32[$5 + 92 >> 2] = 0;
   break label$1;
  }
  jsvIteratorNew($5 + 16 | 0, HEAP32[$5 + 88 >> 2], 0);
  while (1) {
   if (jsvIteratorHasElement($5 + 16 | 0) & 1) {
    HEAP32[$5 + 12 >> 2] = jsvIteratorGetKey($5 + 16 | 0);
    label$5: {
     if (HEAP8[$5 + 82 | 0] & 1) {
      if (!(jsvIsInt(HEAP32[$5 + 12 >> 2]) & 1)) {
       break label$5;
      }
      if ((jsvGetInteger(HEAP32[$5 + 12 >> 2]) | 0) < HEAP32[$5 + 76 >> 2]) {
       break label$5;
      }
     }
     HEAP32[$5 + 8 >> 2] = jsvIteratorGetValue($5 + 16 | 0);
     label$7: {
      if (HEAP32[$5 + 8 >> 2] != HEAP32[$5 + 84 >> 2]) {
       if (HEAP8[$5 + 83 | 0] & 1) {
        break label$7;
       }
       if (!(jsvMathsOpTypeEqual(HEAP32[$5 + 8 >> 2], HEAP32[$5 + 84 >> 2]) & 1)) {
        break label$7;
       }
      }
      jsvUnLock(HEAP32[$5 + 8 >> 2]);
      jsvIteratorFree($5 + 16 | 0);
      HEAP32[$5 + 92 >> 2] = HEAP32[$5 + 12 >> 2];
      break label$1;
     }
     jsvUnLock(HEAP32[$5 + 8 >> 2]);
    }
    jsvUnLock(HEAP32[$5 + 12 >> 2]);
    jsvIteratorNext($5 + 16 | 0);
    continue;
   }
   break;
  }
  jsvIteratorFree($5 + 16 | 0);
  HEAP32[$5 + 92 >> 2] = 0;
 }
 __stack_pointer = $5 + 96 | 0;
 return HEAP32[$5 + 92 >> 2];
}

function getDateFromDayNumber($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 28 >> 2] + 135081;
 HEAP32[$4 + 12 >> 2] = integerDivideFloor((HEAP32[$4 + 12 >> 2] - integerDivideFloor(HEAP32[$4 + 12 >> 2], 146097) | 0) + 146095 | 0, 36524);
 HEAP32[$4 + 12 >> 2] = (HEAP32[$4 + 28 >> 2] + HEAP32[$4 + 12 >> 2] | 0) - integerDivideFloor(HEAP32[$4 + 12 >> 2], 4);
 HEAP32[$4 + 8 >> 2] = integerDivideFloor((HEAP32[$4 + 12 >> 2] << 2) + 2877911 | 0, 1461);
 HEAP32[$4 + 4 >> 2] = ((HEAP32[$4 + 12 >> 2] + 719600 | 0) - Math_imul(HEAP32[$4 + 8 >> 2], 365) | 0) - integerDivideFloor(HEAP32[$4 + 8 >> 2], 4);
 HEAP32[$4 >> 2] = (Math_imul(HEAP32[$4 + 4 >> 2], 5) - 1 | 0) / 153;
 if (HEAP32[$4 + 16 >> 2]) {
  HEAP32[HEAP32[$4 + 16 >> 2] >> 2] = (HEAP32[$4 + 4 >> 2] - Math_imul(HEAP32[$4 >> 2], 30) | 0) - ((Math_imul(HEAP32[$4 >> 2], 3) | 0) / 5 | 0);
 }
 if (HEAP32[$4 + 20 >> 2]) {
  label$3: {
   if (HEAP32[$4 >> 2] < 14) {
    HEAP32[HEAP32[$4 + 20 >> 2] >> 2] = HEAP32[$4 >> 2] - 2;
    break label$3;
   }
   HEAP32[HEAP32[$4 + 20 >> 2] >> 2] = HEAP32[$4 >> 2] - 14;
  }
 }
 if (HEAP32[$4 + 24 >> 2]) {
  label$6: {
   if (HEAP32[$4 >> 2] > 13) {
    HEAP32[HEAP32[$4 + 24 >> 2] >> 2] = HEAP32[$4 + 8 >> 2] + 1;
    break label$6;
   }
   HEAP32[HEAP32[$4 + 24 >> 2] >> 2] = HEAP32[$4 + 8 >> 2];
  }
 }
 __stack_pointer = $4 + 32 | 0;
}

function __jspeConditionalExpression($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1: {
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 63) {
   jslGetNextToken();
   label$3: {
    if ((HEAP32[91094] & 63) != 1) {
     jsvUnLock(jspeAssignmentExpression());
     if (!(jslMatch(58) & 1)) {
      HEAP32[$1 + 28 >> 2] = 0;
      break label$1;
     }
     jsvUnLock(jspeAssignmentExpression());
     break label$3;
    }
    HEAP8[$1 + 23 | 0] = jsvGetBoolAndUnLock(jsvSkipName(HEAP32[$1 + 24 >> 2])) & 1;
    jsvUnLock(HEAP32[$1 + 24 >> 2]);
    label$6: {
     if (HEAP8[$1 + 23 | 0] & 1) {
      HEAP32[$1 + 24 >> 2] = jsvSkipNameAndUnLock(jspeAssignmentExpression());
      if (!(jslMatch(58) & 1)) {
       HEAP32[$1 + 28 >> 2] = 0;
       break label$1;
      }
      HEAP32[$1 + 16 >> 2] = HEAP32[91094];
      jspSetNoExecute();
      jsvUnLock(jspeAssignmentExpression());
      HEAP32[91094] = HEAP32[91094] & -1664 | HEAP32[$1 + 16 >> 2] & 1663;
      break label$6;
     }
     HEAP32[$1 + 12 >> 2] = HEAP32[91094];
     jspSetNoExecute();
     jsvUnLock(jspeAssignmentExpression());
     HEAP32[91094] = HEAP32[91094] & -1664 | HEAP32[$1 + 12 >> 2] & 1663;
     if (!(jslMatch(58) & 1)) {
      HEAP32[$1 + 28 >> 2] = 0;
      break label$1;
     }
     HEAP32[$1 + 24 >> 2] = jsvSkipNameAndUnLock(jspeAssignmentExpression());
    }
   }
  }
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 24 >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function jstExecuteFn($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer + -64 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 60 >> 2] = $0;
 HEAP32[$6 + 56 >> 2] = $1;
 HEAP32[$6 + 48 >> 2] = $2;
 HEAP32[$6 + 52 >> 2] = $3;
 HEAP32[$6 + 44 >> 2] = $4;
 HEAP32[$6 + 40 >> 2] = $5;
 $0 = HEAP32[$6 + 48 >> 2];
 HEAP8[$6 + 8 | 0] = $0;
 HEAP8[$6 + 9 | 0] = $0 >>> 8;
 HEAP8[$6 + 10 | 0] = $0 >>> 16;
 HEAP8[$6 + 11 | 0] = $0 >>> 24;
 $0 = HEAP32[$6 + 44 >> 2];
 HEAP8[$6 + 12 | 0] = $0;
 HEAP8[$6 + 13 | 0] = $0 >>> 8;
 HEAP8[$6 + 14 | 0] = $0 >>> 16;
 HEAP8[$6 + 15 | 0] = $0 >>> 24;
 HEAP8[$6 + 32 | 0] = 3;
 $0 = HEAP32[$6 + 60 >> 2];
 HEAP8[$6 + 16 | 0] = $0;
 HEAP8[$6 + 17 | 0] = $0 >>> 8;
 HEAP8[$6 + 18 | 0] = $0 >>> 16;
 HEAP8[$6 + 19 | 0] = $0 >>> 24;
 $0 = HEAP32[$6 + 56 >> 2];
 HEAP8[$6 + 20 | 0] = $0;
 HEAP8[$6 + 21 | 0] = $0 >>> 8;
 HEAP8[$6 + 22 | 0] = $0 >>> 16;
 HEAP8[$6 + 23 | 0] = $0 >>> 24;
 HEAP32[$6 + 4 >> 2] = 2e6;
 while (1) {
  $0 = 0;
  label$2: {
   if (!(utilTimerIsFull() & 1)) {
    break label$2;
   }
   $0 = 0;
   if (jspIsInterrupted() & 1) {
    break label$2;
   }
   $0 = HEAP32[$6 + 4 >> 2];
   HEAP32[$6 + 4 >> 2] = $0 - 1;
   $0 = ($0 | 0) > 0;
  }
  if ($0) {
   continue;
  }
  break;
 }
 label$3: {
  if (jspIsInterrupted() & 1) {
   jsExceptionHere(4, 121089, 0);
   break label$3;
  }
  if (HEAP32[$6 + 4 >> 2] <= 0) {
   jsExceptionHere(4, 121064, 0);
  }
 }
 $0 = utilTimerInsertTask($6 + 8 | 0, HEAP32[$6 + 40 >> 2]);
 __stack_pointer = $6 - -64 | 0;
 return $0 & 1;
}

function tflite__MicroAllocator__StartModelAllocation_28tflite__Model_20const__2c_20tflite__MicroOpResolver_20const__2c_20tflite__NodeAndRegistration___2c_20TfLiteEvalTensor___29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP32[$5 + 36 >> 2] = $1;
 HEAP32[$5 + 32 >> 2] = $2;
 HEAP32[$5 + 28 >> 2] = $3;
 HEAP32[$5 + 24 >> 2] = $4;
 $0 = HEAP32[$5 + 40 >> 2];
 label$1: {
  if (!HEAP32[$5 + 36 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (HEAP8[$0 + 12 | 0] & 1) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 8 >> 2], 128902, 0);
   HEAP32[$5 + 44 >> 2] = 1;
   break label$2;
  }
  HEAP8[$0 + 12 | 0] = 1;
  HEAP32[$5 + 20 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 28 >> 2]]($0, HEAP32[$5 + 36 >> 2], HEAP32[$5 + 24 >> 2]);
  if (HEAP32[$5 + 20 >> 2]) {
   HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 20 >> 2];
   break label$2;
  }
  HEAP32[$5 + 16 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 20 >> 2]]($0, HEAP32[$5 + 36 >> 2], HEAP32[$5 + 28 >> 2]);
  if (HEAP32[$5 + 16 >> 2]) {
   HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 16 >> 2];
   break label$2;
  }
  HEAP32[$5 + 12 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 24 >> 2]]($0, HEAP32[$5 + 36 >> 2], HEAP32[$5 + 32 >> 2], HEAP32[HEAP32[$5 + 28 >> 2] >> 2]);
  if (HEAP32[$5 + 12 >> 2]) {
   HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 12 >> 2];
   break label$2;
  }
  HEAP32[$5 + 44 >> 2] = 0;
 }
 __stack_pointer = $5 + 48 | 0;
 return HEAP32[$5 + 44 >> 2];
}

function graphicsDrawRect($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 28 >> 2] = $0;
 HEAP32[$5 + 24 >> 2] = $1;
 HEAP32[$5 + 20 >> 2] = $2;
 HEAP32[$5 + 16 >> 2] = $3;
 HEAP32[$5 + 12 >> 2] = $4;
 graphicsToDeviceCoordinates(HEAP32[$5 + 28 >> 2], $5 + 24 | 0, $5 + 20 | 0);
 graphicsToDeviceCoordinates(HEAP32[$5 + 28 >> 2], $5 + 16 | 0, $5 + 12 | 0);
 $0 = HEAP32[$5 + 28 >> 2];
 graphicsFillRectDevice(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 20 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
 $0 = HEAP32[$5 + 28 >> 2];
 graphicsFillRectDevice(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 12 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
 $0 = HEAP32[$5 + 28 >> 2];
 graphicsFillRectDevice(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 12 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
 $0 = HEAP32[$5 + 28 >> 2];
 graphicsFillRectDevice(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 12 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 20 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24));
 __stack_pointer = $5 + 32 | 0;
}

function int_20gemmlowp__SaturatingRoundingDoublingHighMul_int__28int_2c_20int_29($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP32[$2 + 40 >> 2] = $1;
 if (HEAP32[$2 + 44 >> 2] == HEAP32[$2 + 40 >> 2]) {
  $3 = HEAP32[$2 + 44 >> 2] == (std____2__numeric_limits_int___min_28_29() | 0);
 }
 HEAP8[$2 + 39 | 0] = $3;
 $1 = HEAP32[$2 + 44 >> 2];
 $0 = $1 >> 31;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 28 >> 2] = $0;
 $0 = HEAP32[$2 + 40 >> 2];
 $1 = $0 >> 31;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 $1 = HEAP32[$2 + 24 >> 2];
 $4 = $1;
 $1 = HEAP32[$2 + 20 >> 2];
 $3 = $1;
 $0 = HEAP32[$2 + 28 >> 2];
 $1 = $0;
 $0 = HEAP32[$2 + 16 >> 2];
 $5 = $0;
 $0 = $3;
 $0 = __wasm_i64_mul($4, $1, $5, $0);
 HEAP32[$2 + 8 >> 2] = $0;
 $1 = i64toi32_i32$HIGH_BITS;
 HEAP32[$2 + 12 >> 2] = $1;
 $1 = HEAP32[$2 + 8 >> 2];
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = ($0 | 0) > 0 | ($0 | 0) >= 0 ? 1073741824 : -1073741823;
 $3 = HEAP32[$2 + 8 >> 2];
 $4 = $3;
 $0 = HEAP32[$2 + 12 >> 2];
 $5 = $0;
 $0 = HEAP32[$2 + 4 >> 2];
 $3 = $0 >> 31;
 $1 = $0;
 $4 = $0 + $4 | 0;
 $0 = $3;
 $3 = $5;
 $0 = $0 + $3 | 0;
 $0 = $1 >>> 0 > $4 >>> 0 ? $0 + 1 | 0 : $0;
 $4 = __wasm_i64_sdiv($4, $0, -2147483648, 0);
 HEAP32[$2 >> 2] = $4;
 label$2: {
  if (HEAP8[$2 + 39 | 0] & 1) {
   $0 = std____2__numeric_limits_int___max_28_29();
   break label$2;
  }
  $0 = HEAP32[$2 >> 2];
 }
 __stack_pointer = $2 + 48 | 0;
 return $0;
}

function jsvStringIteratorLoadInline($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] + HEAP32[$0 + 8 >> 2];
 label$1: {
  if (jsvIsFlashString(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 1) {
   jsvStringIteratorLoadFlashString_1(HEAP32[$1 + 12 >> 2]);
   break label$1;
  }
  label$3: {
   if (!HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) {
    break label$3;
   }
   if (!(jsvGetLastChild(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 65535)) {
    break label$3;
   }
   HEAP32[$1 + 8 >> 2] = jsvLock(jsvGetLastChild(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 65535);
   jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
   HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] = HEAP32[$1 + 8 >> 2];
   HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = HEAP32[$1 + 8 >> 2];
   $0 = jsvGetCharactersInVar(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
   HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = $0;
   break label$1;
  }
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
  HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] = 0;
  HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = 0;
  HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 0;
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] >> 2] + HEAP32[$0 + 8 >> 2];
  HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
}

function jshSPISendMany($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 HEAP8[$5 + 47 | 0] = $0;
 HEAP32[$5 + 40 >> 2] = $1;
 HEAP32[$5 + 36 >> 2] = $2;
 HEAP32[$5 + 32 >> 2] = $3;
 HEAP32[$5 + 28 >> 2] = $4;
 HEAP32[$5 + 24 >> 2] = 0;
 HEAP32[$5 + 20 >> 2] = 0;
 while (1) {
  $0 = 0;
  if (HEAPU32[$5 + 24 >> 2] < HEAPU32[$5 + 32 >> 2]) {
   $0 = jspIsInterrupted() ^ -1;
  }
  if ($0 & 1) {
   $1 = HEAPU8[$5 + 47 | 0];
   $2 = HEAP32[$5 + 40 >> 2];
   $0 = HEAP32[$5 + 24 >> 2];
   HEAP32[$5 + 24 >> 2] = $0 + 1;
   HEAP32[$5 + 16 >> 2] = jshSPISend($1, HEAPU8[$2 + $0 | 0]);
   if (HEAP32[$5 + 36 >> 2] ? HEAP32[$5 + 16 >> 2] >= 0 : 0) {
    $1 = HEAP32[$5 + 16 >> 2];
    $2 = HEAP32[$5 + 36 >> 2];
    $0 = HEAP32[$5 + 20 >> 2];
    HEAP32[$5 + 20 >> 2] = $0 + 1;
    HEAP8[$2 + $0 | 0] = $1;
   }
   continue;
  }
  break;
 }
 label$6: {
  if (HEAP32[$5 + 36 >> 2]) {
   while (1) {
    $0 = 0;
    if (HEAPU32[$5 + 20 >> 2] < HEAPU32[$5 + 32 >> 2]) {
     $0 = jspIsInterrupted() ^ -1;
    }
    if ($0 & 1) {
     HEAP32[$5 + 12 >> 2] = jshSPISend(HEAPU8[$5 + 47 | 0], -1);
     $1 = HEAP32[$5 + 12 >> 2];
     $2 = HEAP32[$5 + 36 >> 2];
     $0 = HEAP32[$5 + 20 >> 2];
     HEAP32[$5 + 20 >> 2] = $0 + 1;
     HEAP8[$2 + $0 | 0] = $1;
     continue;
    }
    break;
   }
   break label$6;
  }
  jshSPIWait(HEAPU8[$5 + 47 | 0]);
 }
 if (HEAP32[$5 + 28 >> 2]) {
  FUNCTION_TABLE[HEAP32[$5 + 28 >> 2]]();
 }
 __stack_pointer = $5 + 48 | 0;
 return 1;
}

function jsfReadFile($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 96 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 88 >> 2] = $1;
 HEAP32[$3 + 84 >> 2] = $2;
 HEAP32[$3 + 32 >> 2] = HEAP32[$0 + 24 >> 2];
 $1 = $0;
 $0 = HEAP32[$1 + 16 >> 2];
 $2 = HEAP32[$1 + 20 >> 2];
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 28 >> 2] = $2;
 $0 = HEAP32[$1 + 12 >> 2];
 $2 = HEAP32[$1 + 8 >> 2];
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 20 >> 2] = $0;
 $2 = HEAP32[$1 + 4 >> 2];
 $0 = HEAP32[$1 >> 2];
 HEAP32[$3 + 8 >> 2] = $0;
 HEAP32[$3 + 12 >> 2] = $2;
 HEAP32[$3 + 44 >> 2] = jsfFindFile($3 + 8 | 0, $3 + 48 | 0);
 label$1: {
  if (!HEAP32[$3 + 44 >> 2]) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$3 + 88 >> 2] < 0) {
   HEAP32[$3 + 88 >> 2] = 0;
  }
  HEAP32[$3 + 40 >> 2] = jsfGetFileSize($3 + 48 | 0);
  if (HEAP32[$3 + 84 >> 2] <= 0) {
   HEAP32[$3 + 84 >> 2] = HEAP32[$3 + 40 >> 2];
  }
  if (HEAP32[$3 + 88 >> 2] > HEAP32[$3 + 40 >> 2]) {
   HEAP32[$3 + 88 >> 2] = HEAP32[$3 + 40 >> 2];
  }
  if (HEAP32[$3 + 40 >> 2] < (HEAP32[$3 + 88 >> 2] + HEAP32[$3 + 84 >> 2] | 0)) {
   HEAP32[$3 + 84 >> 2] = HEAP32[$3 + 40 >> 2] - HEAP32[$3 + 88 >> 2];
  }
  if (HEAP32[$3 + 84 >> 2] <= 0) {
   HEAP32[$3 + 92 >> 2] = jsvNewFromEmptyString_4();
   break label$1;
  }
  HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 88 >> 2] + HEAP32[$3 + 44 >> 2];
  HEAP32[$3 + 92 >> 2] = jsvAddressToVar(HEAP32[$3 + 44 >> 2], HEAP32[$3 + 84 >> 2]);
 }
 __stack_pointer = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}

function jswrap_stream_pushData($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP8[$3 + 23 | 0] = $2;
 HEAP8[$3 + 22 | 0] = 1;
 HEAP32[$3 + 16 >> 2] = jsvFindChildFromString(HEAP32[$3 + 28 >> 2], 135743);
 label$1: {
  if (HEAP32[$3 + 16 >> 2]) {
   if (!(jsiExecuteEventCallback(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 16 >> 2], 1, $3 + 24 | 0) & 1)) {
    jsError(140088, 0);
    HEAP8[364342] = HEAPU8[364342] | 4;
    jsvObjectRemoveChild(HEAP32[$3 + 28 >> 2], 135743);
   }
   jsvUnLock(HEAP32[$3 + 16 >> 2]);
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 28 >> 2], 130086);
  label$4: {
   if (!(jsvIsString(HEAP32[$3 + 12 >> 2]) & 1)) {
    jsvObjectSetChild(HEAP32[$3 + 28 >> 2], 130086, HEAP32[$3 + 24 >> 2]);
    break label$4;
   }
   HEAP32[$3 + 8 >> 2] = jsvGetStringLength(HEAP32[$3 + 12 >> 2]);
   HEAP32[$3 + 4 >> 2] = jsvGetStringLength(HEAP32[$3 + 24 >> 2]);
   if (HEAP32[$3 + 8 >> 2] + HEAP32[$3 + 4 >> 2] >>> 0 > 512) {
    if (HEAP8[$3 + 23 | 0] & 1) {
     HEAP8[364342] = HEAPU8[364342] | 2;
    }
    HEAP8[$3 + 22 | 0] = 0;
   }
   if (!(!(HEAP8[$3 + 23 | 0] & 1 ? 1 : HEAP8[$3 + 22 | 0] & 1) | HEAPU32[$3 + 8 >> 2] >= 512)) {
    jsvAppendStringVar(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 24 >> 2], 0, 512 - HEAP32[$3 + 8 >> 2] | 0);
   }
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
  }
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP8[$3 + 22 | 0] & 1;
}

function tflite___28anonymous_20namespace_29__FlatBufferIntVectorToArray_28int_2c_20flatbuffers__Vector_int__20const__2c_20int__2c_20tflite__ErrorReporter__2c_20char_20const__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer + -64 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 56 >> 2] = $0;
 HEAP32[$5 + 52 >> 2] = $1;
 HEAP32[$5 + 48 >> 2] = $2;
 HEAP32[$5 + 44 >> 2] = $3;
 HEAP32[$5 + 40 >> 2] = $4;
 label$1: {
  if (!HEAP32[$5 + 52 >> 2]) {
   $0 = HEAP32[$5 + 44 >> 2];
   HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 40 >> 2];
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 147945, $5 + 16 | 0);
   HEAP32[$5 + 60 >> 2] = 1;
   break label$1;
  }
  HEAP32[$5 + 36 >> 2] = flatbuffers__Vector_int___size_28_29_20const(HEAP32[$5 + 52 >> 2]);
  if (HEAPU32[$5 + 36 >> 2] > HEAP32[$5 + 56 >> 2] >>> 2 >>> 0) {
   $0 = HEAP32[$5 + 44 >> 2];
   HEAP32[$5 >> 2] = HEAP32[$5 + 40 >> 2];
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 147991, $5);
   HEAP32[$5 + 60 >> 2] = 1;
   break label$1;
  }
  HEAP32[$5 + 32 >> 2] = 0;
  while (1) {
   if (HEAPU32[$5 + 32 >> 2] < HEAPU32[$5 + 36 >> 2]) {
    $0 = flatbuffers__Vector_int___Get_28unsigned_20int_29_20const(HEAP32[$5 + 52 >> 2], HEAP32[$5 + 32 >> 2]);
    HEAP32[HEAP32[$5 + 48 >> 2] + (HEAP32[$5 + 32 >> 2] << 2) >> 2] = $0;
    HEAP32[$5 + 32 >> 2] = HEAP32[$5 + 32 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$5 + 60 >> 2] = 0;
 }
 __stack_pointer = $5 - -64 | 0;
 return HEAP32[$5 + 60 >> 2];
}

function tflite__SimpleMemoryAllocator__EnsureHeadSize_28unsigned_20long_2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 $0 = HEAP32[$3 + 40 >> 2];
 label$1: {
  if (HEAP32[$0 + 16 >> 2] != HEAP32[$0 + 24 >> 2]) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 4 >> 2], 141182, 0);
   HEAP32[$3 + 44 >> 2] = 1;
   break label$1;
  }
  HEAP32[$3 + 28 >> 2] = tflite__AlignPointerUp_28unsigned_20char__2c_20unsigned_20long_29(HEAP32[$0 + 8 >> 2], HEAP32[$3 + 32 >> 2]);
  if (HEAPU32[$0 + 16 >> 2] > HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 36 >> 2] >>> 0) {
   HEAP32[$3 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 24 >> 2] = HEAP32[$0 + 20 >> 2] - HEAP32[$3 + 28 >> 2];
  if (HEAPU32[$3 + 24 >> 2] < HEAPU32[$3 + 36 >> 2]) {
   $0 = HEAP32[$0 + 4 >> 2];
   $1 = HEAP32[$3 + 36 >> 2];
   $2 = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 36 >> 2] - HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 4 >> 2] = $2;
   HEAP32[$3 >> 2] = $1;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 117052, $3);
   HEAP32[$3 + 44 >> 2] = 1;
   break label$1;
  }
  HEAP32[$0 + 16 >> 2] = HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 36 >> 2];
  HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 16 >> 2];
  HEAP32[$3 + 44 >> 2] = 0;
 }
 __stack_pointer = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}

function graphicsFallbackScroll($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 var $7 = 0;
 $7 = __stack_pointer - 48 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 44 >> 2] = $0;
 HEAP32[$7 + 40 >> 2] = $1;
 HEAP32[$7 + 36 >> 2] = $2;
 HEAP32[$7 + 32 >> 2] = $3;
 HEAP32[$7 + 28 >> 2] = $4;
 HEAP32[$7 + 24 >> 2] = $5;
 HEAP32[$7 + 20 >> 2] = $6;
 label$1: {
  if (!(HEAP32[$7 + 40 >> 2] | HEAP32[$7 + 36 >> 2])) {
   break label$1;
  }
  if (HEAP32[$7 + 36 >> 2] <= 0) {
   HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 20 >> 2] + HEAP32[$7 + 36 >> 2];
   HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 28 >> 2];
   while (1) {
    if (HEAP32[$7 + 16 >> 2] <= HEAP32[$7 + 12 >> 2]) {
     graphicsFallbackScrollX(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2], HEAP32[$7 + 16 >> 2] - HEAP32[$7 + 36 >> 2] | 0, HEAP32[$7 + 16 >> 2], HEAP32[$7 + 32 >> 2], HEAP32[$7 + 24 >> 2]);
     HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] + 1;
     continue;
    }
    break;
   }
   break label$1;
  }
  HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 20 >> 2] - HEAP32[$7 + 36 >> 2];
  while (1) {
   if (HEAP32[$7 + 16 >> 2] >= HEAP32[$7 + 28 >> 2]) {
    graphicsFallbackScrollX(HEAP32[$7 + 44 >> 2], HEAP32[$7 + 40 >> 2], HEAP32[$7 + 16 >> 2], HEAP32[$7 + 16 >> 2] + HEAP32[$7 + 36 >> 2] | 0, HEAP32[$7 + 32 >> 2], HEAP32[$7 + 24 >> 2]);
    HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] - 1;
    continue;
   }
   break;
  }
 }
 __stack_pointer = $7 + 48 | 0;
}

function jswrap_graphics_getVectorFontPolys($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 128 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 124 >> 2] = $0;
 HEAP32[$3 + 120 >> 2] = $1;
 HEAP32[$3 + 116 >> 2] = $2;
 HEAP32[$3 + 112 >> 2] = 0;
 HEAP32[$3 + 108 >> 2] = 0;
 HEAP32[$3 + 104 >> 2] = 256;
 HEAP32[$3 + 100 >> 2] = 256;
 HEAP32[$3 + 48 >> 2] = 116522;
 HEAP16[$3 + 52 >> 1] = 10;
 HEAP32[$3 + 56 >> 2] = $3 + 112;
 HEAP32[$3 + 60 >> 2] = 116397;
 HEAP16[$3 + 64 >> 1] = 10;
 HEAP32[$3 + 68 >> 2] = $3 + 108;
 HEAP32[$3 + 72 >> 2] = 116775;
 HEAP16[$3 + 76 >> 1] = 10;
 HEAP32[$3 + 80 >> 2] = $3 + 104;
 HEAP32[$3 + 84 >> 2] = 129676;
 HEAP16[$3 + 88 >> 1] = 10;
 HEAP32[$3 + 92 >> 2] = $3 + 100;
 jsvReadConfigObject(HEAP32[$3 + 116 >> 2], $3 + 48 | 0, 4);
 HEAP32[$3 + 120 >> 2] = jsvAsString(HEAP32[$3 + 120 >> 2]);
 HEAP32[$3 + 44 >> 2] = jsvNewEmptyArray();
 jsvStringIteratorNew($3 + 8 | 0, HEAP32[$3 + 120 >> 2], 0);
 while (1) {
  if (jsvStringIteratorHasChar_12($3 + 8 | 0) & 1) {
   HEAP8[$3 + 7 | 0] = jsvStringIteratorGetCharAndNext($3 + 8 | 0);
   HEAP32[$3 + 112 >> 2] = graphicsGetVectorChar(664, HEAP32[$3 + 44 >> 2], HEAP32[$3 + 112 >> 2], HEAP32[$3 + 108 >> 2], HEAP32[$3 + 104 >> 2], HEAP32[$3 + 100 >> 2], HEAP8[$3 + 7 | 0]) + HEAP32[$3 + 112 >> 2];
   continue;
  }
  break;
 }
 jsvStringIteratorFree_16($3 + 8 | 0);
 jsvUnLock(HEAP32[$3 + 120 >> 2]);
 __stack_pointer = $3 + 128 | 0;
 return HEAP32[$3 + 44 >> 2];
}

function jspeStatementFunctionDecl($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 27 | 0] = $0;
 HEAP32[$1 + 20 >> 2] = 0;
 jslGetNextToken();
 HEAP8[$1 + 15 | 0] = (HEAP32[91094] & 63) == 1;
 label$1: {
  if (HEAP8[$1 + 15 | 0] & 1) {
   HEAP32[$1 + 20 >> 2] = jsvNewNameFromString(jslGetTokenValueAsString());
   if (!HEAP32[$1 + 20 >> 2]) {
    HEAP32[$1 + 28 >> 2] = 0;
    break label$1;
   }
  }
  if (!(jslMatch(128) & 1)) {
   jsvUnLock(HEAP32[$1 + 20 >> 2]);
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  label$5: {
   if (HEAP8[$1 + 27 | 0] & 1) {
    $0 = jspeClassDefinition(0);
    break label$5;
   }
   $0 = jspeFunctionDefinition(0);
  }
  HEAP32[$1 + 16 >> 2] = $0;
  if (HEAP8[$1 + 15 | 0] & 1) {
   HEAP32[$1 + 8 >> 2] = jsvFindChildFromVar(HEAP32[91089], HEAP32[$1 + 20 >> 2], 1);
   HEAP32[$1 + 4 >> 2] = jsvSkipName(HEAP32[$1 + 8 >> 2]);
   label$8: {
    if (jsvIsFunction(HEAP32[$1 + 4 >> 2]) & 1) {
     HEAP32[$1 + 16 >> 2] = jsvSkipNameAndUnLock(HEAP32[$1 + 16 >> 2]);
     jswrap_function_replaceWith(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 16 >> 2]);
     break label$8;
    }
    jsvReplaceWith(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 16 >> 2]);
   }
   jsvUnLock(HEAP32[$1 + 20 >> 2]);
   HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 8 >> 2];
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
  }
  jsvUnLock(HEAP32[$1 + 16 >> 2]);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function jspeFactorDelete() {
 var $0 = 0;
 $0 = __stack_pointer - 32 | 0;
 __stack_pointer = $0;
 jslGetNextToken();
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = jspeFactorMember(jspeFactor(), $0 + 28 | 0);
 HEAP32[$0 + 20 >> 2] = 0;
 if ((HEAP32[91094] & 63) == 1) {
  HEAP8[$0 + 19 | 0] = 0;
  label$2: {
   if (!(jsvIsName(HEAP32[$0 + 24 >> 2]) & 1)) {
    break label$2;
   }
   if (jsvIsNewChild(HEAP32[$0 + 24 >> 2]) & 1) {
    break label$2;
   }
   label$3: {
    if (HEAP32[$0 + 28 >> 2]) {
     break label$3;
    }
    if (!(jsvIsChild(HEAP32[91086], HEAP32[$0 + 24 >> 2]) & 1)) {
     break label$3;
    }
    HEAP32[$0 + 28 >> 2] = jsvLockAgain(HEAP32[91086]);
   }
   label$4: {
    if (!(jsvHasChildren(HEAP32[$0 + 28 >> 2]) & 1)) {
     break label$4;
    }
    if (!(jsvIsChild(HEAP32[$0 + 28 >> 2], HEAP32[$0 + 24 >> 2]) & 1)) {
     break label$4;
    }
    label$5: {
     if (jsvIsArray(HEAP32[$0 + 28 >> 2]) & 1) {
      HEAP32[$0 + 12 >> 2] = jsvGetArrayLength(HEAP32[$0 + 28 >> 2]);
      jsvRemoveChild(HEAP32[$0 + 28 >> 2], HEAP32[$0 + 24 >> 2]);
      jsvSetArrayLength(HEAP32[$0 + 28 >> 2], HEAP32[$0 + 12 >> 2], 0);
      break label$5;
     }
     jsvRemoveChild(HEAP32[$0 + 28 >> 2], HEAP32[$0 + 24 >> 2]);
    }
    HEAP8[$0 + 19 | 0] = 1;
   }
  }
  HEAP32[$0 + 20 >> 2] = jsvNewFromBool(HEAP8[$0 + 19 | 0] & 1);
 }
 jsvUnLock2(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 28 >> 2]);
 __stack_pointer = $0 + 32 | 0;
 return HEAP32[$0 + 20 >> 2];
}

function tflite__ops__micro__pooling___28anonymous_20namespace_29__CalculateOpData_28TfLiteContext_20const__2c_20TfLitePoolParams_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20tflite__ops__micro__pooling___28anonymous_20namespace_29__OpData__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer + -64 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 60 >> 2] = $0;
 HEAP32[$5 + 56 >> 2] = $1;
 HEAP32[$5 + 52 >> 2] = $2;
 HEAP32[$5 + 48 >> 2] = $3;
 HEAP32[$5 + 44 >> 2] = $4;
 HEAP32[$5 + 40 >> 2] = tflite__SizeOfDimension_28TfLiteTensor_20const__2c_20int_29(HEAP32[$5 + 52 >> 2], 1);
 HEAP32[$5 + 36 >> 2] = tflite__SizeOfDimension_28TfLiteTensor_20const__2c_20int_29(HEAP32[$5 + 52 >> 2], 2);
 tflite__ComputePaddingHeightWidth_28int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20TfLitePadding_2c_20int__2c_20int__29($5 + 8 | 0, HEAP32[HEAP32[$5 + 56 >> 2] + 8 >> 2], HEAP32[HEAP32[$5 + 56 >> 2] + 4 >> 2], 1, 1, HEAP32[$5 + 40 >> 2], HEAP32[$5 + 36 >> 2], HEAP32[HEAP32[$5 + 56 >> 2] + 16 >> 2], HEAP32[HEAP32[$5 + 56 >> 2] + 12 >> 2], HEAP32[HEAP32[$5 + 56 >> 2] >> 2], $5 + 32 | 0, $5 + 28 | 0);
 $0 = HEAP32[$5 + 12 >> 2];
 $1 = HEAP32[$5 + 8 >> 2];
 $3 = $1;
 $2 = HEAP32[$5 + 44 >> 2];
 $1 = $2;
 HEAP32[$1 >> 2] = $3;
 HEAP32[$1 + 4 >> 2] = $0;
 $1 = HEAP32[$5 + 20 >> 2];
 $0 = HEAP32[$5 + 16 >> 2];
 $3 = $0;
 $0 = $2;
 HEAP32[$0 + 8 >> 2] = $3;
 HEAP32[$0 + 12 >> 2] = $1;
 __stack_pointer = $5 - -64 | 0;
 return 0;
}

function jsvIteratorNew($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  label$2: {
   label$3: {
    if (jsvIsArray(HEAP32[$3 + 8 >> 2]) & 1) {
     break label$3;
    }
    if (jsvIsObject(HEAP32[$3 + 8 >> 2]) & 1) {
     break label$3;
    }
    if (jsvIsFunction(HEAP32[$3 + 8 >> 2]) & 1) {
     break label$3;
    }
    if (!(jsvIsGetterOrSetter(HEAP32[$3 + 8 >> 2]) & 1)) {
     break label$2;
    }
   }
   HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 2;
   if (!(!(jsvIsArray(HEAP32[$3 + 8 >> 2]) & 1) | !(HEAP32[$3 + 4 >> 2] & 1))) {
    HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 4;
    HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2] = 0;
    $0 = jsvLockAgain(HEAP32[$3 + 8 >> 2]);
    HEAP32[HEAP32[$3 + 12 >> 2] + 8 >> 2] = $0;
   }
   jsvObjectIteratorNew(HEAP32[$3 + 12 >> 2] + 4 | 0, HEAP32[$3 + 8 >> 2]);
   break label$1;
  }
  label$5: {
   if (jsvIsArrayBuffer(HEAP32[$3 + 8 >> 2]) & 1) {
    HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 3;
    jsvArrayBufferIteratorNew(HEAP32[$3 + 12 >> 2] + 4 | 0, HEAP32[$3 + 8 >> 2], 0);
    break label$5;
   }
   label$7: {
    if (jsvHasCharacterData(HEAP32[$3 + 8 >> 2]) & 1) {
     HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 1;
     jsvStringIteratorNew(HEAP32[$3 + 12 >> 2] + 4 | 0, HEAP32[$3 + 8 >> 2], 0);
     break label$7;
    }
    HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = 0;
   }
  }
 }
 __stack_pointer = $3 + 16 | 0;
}

function jsvArrayBufferIteratorNew($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[HEAP32[$3 + 12 >> 2] + 48 >> 2] = HEAP32[$3 + 4 >> 2];
 HEAP8[HEAP32[$3 + 12 >> 2] + 36 | 0] = HEAPU8[HEAP32[$3 + 8 >> 2] + 5 | 0];
 $0 = HEAP32[$3 + 8 >> 2];
 HEAP32[HEAP32[$3 + 12 >> 2] + 40 >> 2] = Math_imul(HEAPU8[HEAP32[$3 + 12 >> 2] + 36 | 0] & 15, HEAPU8[$0 + 4 | 0] << 16 | (HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8));
 $0 = HEAP32[$3 + 8 >> 2];
 HEAP32[HEAP32[$3 + 12 >> 2] + 44 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8;
 HEAP32[$3 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$3 + 8 >> 2], 0);
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP32[$0 + 40 >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 44 >> 2] + HEAP32[$0 + 40 >> 2];
 HEAP32[HEAP32[$3 + 12 >> 2] + 44 >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 44 >> 2] + Math_imul(HEAP32[$3 + 4 >> 2], HEAPU8[HEAP32[$3 + 12 >> 2] + 36 | 0] & 15);
 label$1: {
  if (HEAPU32[HEAP32[$3 + 12 >> 2] + 44 >> 2] >= (HEAP32[HEAP32[$3 + 12 >> 2] + 40 >> 2] + 1 | 0) - (HEAPU8[HEAP32[$3 + 12 >> 2] + 36 | 0] & 15) >>> 0) {
   jsvUnLock(HEAP32[$3 >> 2]);
   HEAP8[HEAP32[$3 + 12 >> 2] + 36 | 0] = 0;
   break label$1;
  }
  jsvStringIteratorNew(HEAP32[$3 + 12 >> 2], HEAP32[$3 >> 2], HEAP32[HEAP32[$3 + 12 >> 2] + 44 >> 2]);
  jsvUnLock(HEAP32[$3 >> 2]);
  HEAP8[HEAP32[$3 + 12 >> 2] + 52 | 0] = 0;
 }
 __stack_pointer = $3 + 16 | 0;
}

function jswrap_storagefile_erase($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 80 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 76 >> 2] = $0;
 jsfNameFromVarAndUnLock($1 + 48 | 0, jsvObjectGetChildIfExists(HEAP32[$1 + 76 >> 2], 132398));
 HEAP32[$1 + 44 >> 2] = 27;
 while (1) {
  $0 = 0;
  $0 = HEAP32[$1 + 44 >> 2] ? !HEAP8[(HEAP32[$1 + 44 >> 2] + $1 | 0) + 47 | 0] : $0;
  if ($0) {
   HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 44 >> 2] - 1;
   continue;
  }
  break;
 }
 HEAP32[$1 + 40 >> 2] = 1;
 HEAP8[$1 + 39 | 0] = 1;
 while (1) {
  if (HEAP8[$1 + 39 | 0] & 1) {
   HEAP8[HEAP32[$1 + 44 >> 2] + ($1 + 48 | 0) | 0] = HEAP32[$1 + 40 >> 2];
   HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 72 >> 2];
   $2 = HEAP32[$1 + 68 >> 2];
   $0 = HEAP32[$1 + 64 >> 2];
   HEAP32[$1 + 24 >> 2] = $0;
   HEAP32[$1 + 28 >> 2] = $2;
   $0 = HEAP32[$1 + 60 >> 2];
   $2 = HEAP32[$1 + 56 >> 2];
   HEAP32[$1 + 16 >> 2] = $2;
   HEAP32[$1 + 20 >> 2] = $0;
   $2 = HEAP32[$1 + 52 >> 2];
   $0 = HEAP32[$1 + 48 >> 2];
   HEAP32[$1 + 8 >> 2] = $0;
   HEAP32[$1 + 12 >> 2] = $2;
   HEAP8[$1 + 39 | 0] = jsfEraseFile($1 + 8 | 0) & 1;
   HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 40 >> 2] + 1;
   continue;
  }
  break;
 }
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 76 >> 2], 129088, jsvNewFromInteger(1));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 76 >> 2], 117864, jsvNewFromInteger(0));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 76 >> 2], 132782, jsvNewFromInteger(0));
 __stack_pointer = $1 + 80 | 0;
}

function jswrap_object_removeAllListeners($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1: {
  if (!(jsvHasChildren(HEAP32[$2 + 28 >> 2]) & 1)) {
   jsExceptionHere(3, 135617, 0);
   break label$1;
  }
  if (jsvIsString(HEAP32[$2 + 24 >> 2]) & 1) {
   HEAP32[$2 >> 2] = HEAP32[$2 + 24 >> 2];
   HEAP32[$2 + 20 >> 2] = jsvVarPrintf(116801, $2);
   if (!HEAP32[$2 + 20 >> 2]) {
    break label$1;
   }
   HEAP32[$2 + 16 >> 2] = jsvFindChildFromVar(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], 1);
   jsvUnLock(HEAP32[$2 + 20 >> 2]);
   if (HEAP32[$2 + 16 >> 2]) {
    jsvRemoveChildAndUnLock(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2]);
   }
   break label$1;
  }
  label$5: {
   if (jsvIsUndefined(HEAP32[$2 + 24 >> 2]) & 1) {
    jsvObjectIteratorNew($2 + 8 | 0, HEAP32[$2 + 28 >> 2]);
    while (1) {
     if (jsvObjectIteratorHasValue_9($2 + 8 | 0) & 1) {
      HEAP32[$2 + 4 >> 2] = jsvObjectIteratorGetKey_6($2 + 8 | 0);
      jsvObjectIteratorNext($2 + 8 | 0);
      if (jsvIsStringEqualOrStartsWith(HEAP32[$2 + 4 >> 2], 128471, 1) & 1) {
       jsvRemoveChild(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 4 >> 2]);
      }
      jsvUnLock(HEAP32[$2 + 4 >> 2]);
      continue;
     }
     break;
    }
    jsvObjectIteratorFree_9($2 + 8 | 0);
    break label$5;
   }
   jsExceptionHere(3, 133873, 0);
  }
 }
 __stack_pointer = $2 + 32 | 0;
}

function mbedtls_cipher_setkey($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 label$1: {
  if (!(HEAP32[HEAP32[$4 + 24 >> 2] >> 2] ? HEAP32[$4 + 24 >> 2] : 0)) {
   HEAP32[$4 + 28 >> 2] = -24832;
   break label$1;
  }
  if (!(HEAP32[HEAP32[HEAP32[$4 + 24 >> 2] >> 2] + 20 >> 2] & 2 | HEAP32[HEAP32[HEAP32[$4 + 24 >> 2] >> 2] + 8 >> 2] == HEAP32[$4 + 16 >> 2])) {
   HEAP32[$4 + 28 >> 2] = -24832;
   break label$1;
  }
  HEAP32[HEAP32[$4 + 24 >> 2] + 4 >> 2] = HEAP32[$4 + 16 >> 2];
  HEAP32[HEAP32[$4 + 24 >> 2] + 8 >> 2] = HEAP32[$4 + 12 >> 2];
  if (!(!(HEAP32[$4 + 12 >> 2] == 1 | HEAP32[HEAP32[HEAP32[$4 + 24 >> 2] >> 2] + 4 >> 2] == 3) & HEAP32[HEAP32[HEAP32[$4 + 24 >> 2] >> 2] + 4 >> 2] != 5)) {
   HEAP32[$4 + 28 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[HEAP32[HEAP32[$4 + 24 >> 2] >> 2] + 28 >> 2] + 8 >> 2]](HEAP32[HEAP32[$4 + 24 >> 2] + 52 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[HEAP32[$4 + 24 >> 2] + 4 >> 2]);
   break label$1;
  }
  if (!HEAP32[$4 + 12 >> 2]) {
   HEAP32[$4 + 28 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[HEAP32[HEAP32[$4 + 24 >> 2] >> 2] + 28 >> 2] + 12 >> 2]](HEAP32[HEAP32[$4 + 24 >> 2] + 52 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[HEAP32[$4 + 24 >> 2] + 4 >> 2]);
   break label$1;
  }
  HEAP32[$4 + 28 >> 2] = -24832;
 }
 __stack_pointer = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}

function jswrap_espruino_HSBtoRGB($0, $1, $2, $3) {
 $0 = +$0;
 $1 = +$1;
 $2 = +$2;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 80 | 0;
 __stack_pointer = $4;
 HEAPF64[$4 + 64 >> 3] = $0;
 HEAPF64[$4 + 56 >> 3] = $1;
 HEAPF64[$4 + 48 >> 3] = $2;
 HEAP32[$4 + 44 >> 2] = $3;
 HEAP32[$4 + 40 >> 2] = jswrap_espruino_HSBtoRGB_int(HEAPF64[$4 + 64 >> 3], HEAPF64[$4 + 56 >> 3], HEAPF64[$4 + 48 >> 3]);
 label$1: {
  if (!(HEAP32[$4 + 44 >> 2] != 24 ? HEAP32[$4 + 44 >> 2] : 0)) {
   HEAP32[$4 + 76 >> 2] = jsvNewFromInteger(HEAP32[$4 + 40 >> 2]);
   break label$1;
  }
  HEAP32[$4 + 36 >> 2] = HEAP32[$4 + 40 >> 2] & 255;
  HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 40 >> 2] >> 8 & 255;
  HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 40 >> 2] >> 16 & 255;
  if (HEAP32[$4 + 44 >> 2] == 16) {
   HEAP32[$4 + 76 >> 2] = jsvNewFromInteger(HEAP32[$4 + 32 >> 2] >> 2 << 5 | HEAP32[$4 + 28 >> 2] >> 3 | HEAP32[$4 + 36 >> 2] >> 3 << 11);
   break label$1;
  }
  if (HEAP32[$4 + 44 >> 2] != 1) {
   jsExceptionHere(1, 139488, 0);
   HEAP32[$4 + 76 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 16 >> 2] = jsvNewFromInteger(HEAP32[$4 + 36 >> 2]);
  HEAP32[$4 + 20 >> 2] = jsvNewFromInteger(HEAP32[$4 + 32 >> 2]);
  HEAP32[$4 + 24 >> 2] = jsvNewFromInteger(HEAP32[$4 + 28 >> 2]);
  HEAP32[$4 + 12 >> 2] = jsvNewArray($4 + 16 | 0, 3);
  jsvUnLockMany(3, $4 + 16 | 0);
  HEAP32[$4 + 76 >> 2] = HEAP32[$4 + 12 >> 2];
 }
 __stack_pointer = $4 + 80 | 0;
 return HEAP32[$4 + 76 >> 2];
}

function heatshrink_encoder_sink($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 label$1: {
  if (HEAP32[$4 + 12 >> 2] ? !HEAP32[$4 + 24 >> 2] | !HEAP32[$4 + 20 >> 2] : 1) {
   HEAP32[$4 + 28 >> 2] = -1;
   break label$1;
  }
  if (is_finishing(HEAP32[$4 + 24 >> 2])) {
   HEAP32[$4 + 28 >> 2] = -2;
   break label$1;
  }
  if (HEAPU8[HEAP32[$4 + 24 >> 2] + 12 | 0]) {
   HEAP32[$4 + 28 >> 2] = -2;
   break label$1;
  }
  HEAP16[$4 + 10 >> 1] = (get_input_offset(HEAP32[$4 + 24 >> 2]) & 65535) + HEAPU16[HEAP32[$4 + 24 >> 2] >> 1];
  HEAP16[$4 + 8 >> 1] = get_input_buffer_size(HEAP32[$4 + 24 >> 2]);
  HEAP16[$4 + 6 >> 1] = HEAPU16[$4 + 8 >> 1] - HEAPU16[HEAP32[$4 + 24 >> 2] >> 1];
  if (HEAPU16[$4 + 6 >> 1] < HEAPU32[$4 + 16 >> 2]) {
   $0 = HEAPU16[$4 + 6 >> 1];
  } else {
   $0 = HEAP32[$4 + 16 >> 2];
  }
  HEAP16[$4 + 4 >> 1] = $0;
  __memcpy(HEAPU16[$4 + 10 >> 1] + (HEAP32[$4 + 24 >> 2] + 15 | 0) | 0, HEAP32[$4 + 20 >> 2], HEAPU16[$4 + 4 >> 1]);
  HEAP32[HEAP32[$4 + 12 >> 2] >> 2] = HEAPU16[$4 + 4 >> 1];
  $0 = HEAP32[$4 + 24 >> 2];
  HEAP16[$0 >> 1] = HEAPU16[$4 + 4 >> 1] + HEAPU16[$0 >> 1];
  if (HEAPU16[$4 + 4 >> 1] == HEAPU16[$4 + 6 >> 1]) {
   HEAP8[HEAP32[$4 + 24 >> 2] + 12 | 0] = 1;
  }
  HEAP32[$4 + 28 >> 2] = 0;
 }
 __stack_pointer = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}

function jspExecuteFunction($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 60 >> 2] = $0;
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP32[$4 + 48 >> 2] = $3;
 HEAP32[$4 + 40 >> 2] = HEAP32[91094];
 $0 = HEAP32[91093];
 $1 = HEAP32[91092];
 HEAP32[$4 + 32 >> 2] = $1;
 HEAP32[$4 + 36 >> 2] = $0;
 $1 = HEAP32[91091];
 $0 = HEAP32[91090];
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 28 >> 2] = $1;
 $0 = HEAP32[91089];
 $1 = HEAP32[91088];
 HEAP32[$4 + 16 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $0;
 $1 = HEAP32[91087];
 $0 = HEAP32[91086];
 HEAP32[$4 + 8 >> 2] = $0;
 HEAP32[$4 + 12 >> 2] = $1;
 HEAP32[91088] = 0;
 HEAP32[91094] = 1;
 HEAP32[91092] = 0;
 HEAP32[$4 + 4 >> 2] = jspeFunctionCall(HEAP32[$4 + 60 >> 2], 0, HEAP32[$4 + 56 >> 2], 0, HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2]);
 jspeiClearScopes();
 HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 40 >> 2] | HEAP32[91094] & 6256;
 jspeiClearScopes();
 $0 = HEAP32[$4 + 12 >> 2];
 $1 = HEAP32[$4 + 8 >> 2];
 HEAP32[91086] = $1;
 HEAP32[91087] = $0;
 HEAP32[91094] = HEAP32[$4 + 40 >> 2];
 $1 = HEAP32[$4 + 36 >> 2];
 $0 = HEAP32[$4 + 32 >> 2];
 HEAP32[91092] = $0;
 HEAP32[91093] = $1;
 $0 = HEAP32[$4 + 28 >> 2];
 $1 = HEAP32[$4 + 24 >> 2];
 HEAP32[91090] = $1;
 HEAP32[91091] = $0;
 $1 = HEAP32[$4 + 20 >> 2];
 $0 = HEAP32[$4 + 16 >> 2];
 HEAP32[91088] = $0;
 HEAP32[91089] = $1;
 __stack_pointer = $4 - -64 | 0;
 return HEAP32[$4 + 4 >> 2];
}

function tflite__MicroAllocator__AllocateNodeAndRegistrations_28tflite__Model_20const__2c_20tflite__NodeAndRegistration___29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0, wasm2js_i32$3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 $0 = HEAP32[$3 + 24 >> 2];
 label$1: {
  if (!HEAP32[$3 + 16 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$3 + 12 >> 2] = tflite__MicroAllocator__GetSubGraphFromModel_28tflite__Model_20const__29($0, HEAP32[$3 + 20 >> 2]);
 label$2: {
  if (!HEAP32[$3 + 12 >> 2]) {
   break label$2;
  }
 }
 $1 = HEAP32[$0 + 4 >> 2];
 HEAP32[$3 + 8 >> 2] = (wasm2js_i32$1 = $1, wasm2js_i32$2 = Math_imul(flatbuffers__Vector_flatbuffers__Offset_tflite__Operator____size_28_29_20const(tflite__SubGraph__operators_28_29_20const(HEAP32[$3 + 12 >> 2])), 28), 
 wasm2js_i32$3 = 4, wasm2js_i32$0 = HEAP32[HEAP32[$1 >> 2] + 12 >> 2], FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$1 | 0, wasm2js_i32$2 | 0, wasm2js_i32$3 | 0) | 0);
 label$3: {
  if (!HEAP32[$3 + 8 >> 2]) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 8 >> 2], 140275, 0);
   HEAP32[$3 + 28 >> 2] = 1;
   break label$3;
  }
  HEAP32[HEAP32[$3 + 16 >> 2] >> 2] = HEAP32[$3 + 8 >> 2];
  HEAP32[$3 + 28 >> 2] = 0;
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function tflite__GetQuantizedConvolutionMultipler_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20double__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 80 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 72 >> 2] = $0;
 HEAP32[$6 + 68 >> 2] = $1;
 HEAP32[$6 + 64 >> 2] = $2;
 HEAP32[$6 + 60 >> 2] = $3;
 HEAP32[$6 + 56 >> 2] = $4;
 HEAP32[$6 + 52 >> 2] = $5;
 HEAPF64[$6 + 40 >> 3] = +HEAPF32[HEAP32[$6 + 68 >> 2] + 8 >> 2] * +HEAPF32[HEAP32[$6 + 64 >> 2] + 8 >> 2];
 label$1: {
  if (HEAP32[$6 + 60 >> 2]) {
   HEAPF64[$6 + 32 >> 3] = HEAPF32[HEAP32[$6 + 60 >> 2] + 8 >> 2];
   HEAPF64[$6 + 24 >> 3] = abs_28double_29(HEAPF64[$6 + 40 >> 3] - HEAPF64[$6 + 32 >> 3]);
   HEAPF64[$6 + 16 >> 3] = HEAPF32[HEAP32[$6 + 56 >> 2] + 8 >> 2];
   if (!(HEAPF64[$6 + 24 >> 3] / HEAPF64[$6 + 16 >> 3] <= .02)) {
    $0 = HEAP32[HEAP32[$6 + 72 >> 2] + 20 >> 2];
    $1 = HEAP32[$6 + 72 >> 2];
    HEAP32[$6 >> 2] = 139739;
    FUNCTION_TABLE[$0 | 0]($1, 140586, $6);
    HEAP32[$6 + 76 >> 2] = 1;
    break label$1;
   }
  }
  HEAP32[$6 + 76 >> 2] = tflite__GetQuantizedConvolutionMultipler_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20double__29(HEAP32[$6 + 72 >> 2], HEAP32[$6 + 68 >> 2], HEAP32[$6 + 64 >> 2], HEAP32[$6 + 56 >> 2], HEAP32[$6 + 52 >> 2]);
 }
 __stack_pointer = $6 + 80 | 0;
 return HEAP32[$6 + 76 >> 2];
}

function tflite__ops__micro__reshape__Eval_28TfLiteContext__2c_20TfLiteNode__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0);
 HEAP32[$2 + 12 >> 2] = tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], 0);
 HEAP32[$2 + 4 >> 2] = tflite__TfLiteTypeSizeOf_28TfLiteType_2c_20unsigned_20long__29(HEAP32[HEAP32[$2 + 16 >> 2] + 8 >> 2], $2 + 8 | 0);
 label$1: {
  if (HEAP32[$2 + 4 >> 2]) {
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 4 >> 2];
   break label$1;
  }
  HEAP32[$2 + 8 >> 2] = Math_imul(tflite__ElementCount_28TfLiteIntArray_20const__29(HEAP32[HEAP32[$2 + 16 >> 2] + 4 >> 2]), HEAP32[$2 + 8 >> 2]);
  if (HEAP32[HEAP32[$2 + 16 >> 2] >> 2] != HEAP32[HEAP32[$2 + 12 >> 2] >> 2]) {
   HEAP32[$2 >> 2] = 0;
   while (1) {
    if (HEAPU32[$2 >> 2] < HEAPU32[$2 + 8 >> 2]) {
     HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] >> 2] + HEAP32[$2 >> 2] | 0] = HEAPU8[HEAP32[HEAP32[$2 + 16 >> 2] >> 2] + HEAP32[$2 >> 2] | 0];
     HEAP32[$2 >> 2] = HEAP32[$2 >> 2] + 1;
     continue;
    }
    break;
   }
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jsvAsArrayIndex($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1: {
  label$2: {
   if (!(jsvIsSimpleInt(HEAP32[$1 + 24 >> 2]) & 1)) {
    break label$2;
   }
   if ((jsvGetInteger(HEAP32[$1 + 24 >> 2]) | 0) < 0) {
    break label$2;
   }
   HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 24 >> 2]);
   break label$1;
  }
  if (jsvIsString(HEAP32[$1 + 24 >> 2]) & 1) {
   if (jsvIsStringNumericStrict(HEAP32[$1 + 24 >> 2]) & 1) {
    HEAP32[$1 + 20 >> 2] = jsvNewFromInteger(jsvGetInteger(HEAP32[$1 + 24 >> 2]));
    HEAP32[$1 + 16 >> 2] = jsvAsString(HEAP32[$1 + 20 >> 2]);
    if (!jsvCompareString(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 16 >> 2], 0, 0, 0)) {
     jsvUnLock(HEAP32[$1 + 16 >> 2]);
     HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
     break label$1;
    }
    jsvUnLock2(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2]);
   }
   HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 24 >> 2]);
   break label$1;
  }
  if (jsvIsFloat(HEAP32[$1 + 24 >> 2]) & 1) {
   HEAPF64[$1 + 8 >> 3] = jsvGetFloat(HEAP32[$1 + 24 >> 2]);
   HEAP32[$1 + 4 >> 2] = jsvGetInteger(HEAP32[$1 + 24 >> 2]);
   if (HEAPF64[$1 + 8 >> 3] == +HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 28 >> 2] = jsvNewFromInteger(HEAP32[$1 + 4 >> 2]);
    break label$1;
   }
  }
  HEAP32[$1 + 28 >> 2] = jsvAsString(HEAP32[$1 + 24 >> 2]);
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function jsiGetHistoryLine($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 27 | 0] = $0;
 HEAP32[$1 + 20 >> 2] = jsiGetHistory();
 label$1: {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 16 >> 2] = 0;
  HEAP32[$1 + 12 >> 2] = jsvGetIndexOf(HEAP32[$1 + 20 >> 2], HEAP32[91104], 1);
  label$3: {
   if (HEAP32[$1 + 12 >> 2]) {
    label$5: {
     label$6: {
      if (!(HEAP8[$1 + 27 | 0] & 1)) {
       break label$6;
      }
      if (!(jsvGetPrevSibling(HEAP32[$1 + 12 >> 2]) & 65535)) {
       break label$6;
      }
      HEAP32[$1 + 16 >> 2] = jsvSkipNameAndUnLock(jsvLock(jsvGetPrevSibling(HEAP32[$1 + 12 >> 2]) & 65535));
      break label$5;
     }
     label$7: {
      if (HEAP8[$1 + 27 | 0] & 1) {
       break label$7;
      }
      if (!(jsvGetNextSibling(HEAP32[$1 + 12 >> 2]) & 65535)) {
       break label$7;
      }
      HEAP32[$1 + 16 >> 2] = jsvSkipNameAndUnLock(jsvLock(jsvGetNextSibling(HEAP32[$1 + 12 >> 2]) & 65535));
     }
    }
    jsvUnLock(HEAP32[$1 + 12 >> 2]);
    break label$3;
   }
   if (HEAP8[$1 + 27 | 0] & 1) {
    HEAP32[$1 + 16 >> 2] = jsvSkipNameAndUnLock(jsvGetArrayItem(HEAP32[$1 + 20 >> 2], jsvGetArrayLength(HEAP32[$1 + 20 >> 2]) - 1 | 0));
   }
  }
  jsvUnLock(HEAP32[$1 + 20 >> 2]);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 16 >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function mbedtls_ccm_auth_decrypt($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
 var $10 = 0;
 $10 = __stack_pointer - 80 | 0;
 __stack_pointer = $10;
 HEAP32[$10 + 72 >> 2] = $0;
 HEAP32[$10 + 68 >> 2] = $1;
 HEAP32[$10 + 64 >> 2] = $2;
 HEAP32[$10 + 60 >> 2] = $3;
 HEAP32[$10 + 56 >> 2] = $4;
 HEAP32[$10 + 52 >> 2] = $5;
 HEAP32[$10 + 48 >> 2] = $6;
 HEAP32[$10 + 44 >> 2] = $7;
 HEAP32[$10 + 40 >> 2] = $8;
 HEAP32[$10 + 36 >> 2] = $9;
 $0 = ccm_auth_crypt(HEAP32[$10 + 72 >> 2], 1, HEAP32[$10 + 68 >> 2], HEAP32[$10 + 64 >> 2], HEAP32[$10 + 60 >> 2], HEAP32[$10 + 56 >> 2], HEAP32[$10 + 52 >> 2], HEAP32[$10 + 48 >> 2], HEAP32[$10 + 44 >> 2], $10 + 16 | 0, HEAP32[$10 + 36 >> 2]);
 HEAP32[$10 + 32 >> 2] = $0;
 label$1: {
  if ($0) {
   HEAP32[$10 + 76 >> 2] = HEAP32[$10 + 32 >> 2];
   break label$1;
  }
  HEAP32[$10 + 8 >> 2] = 0;
  HEAP8[$10 + 15 | 0] = 0;
  while (1) {
   if (HEAPU8[$10 + 15 | 0] < HEAPU32[$10 + 36 >> 2]) {
    HEAP32[$10 + 8 >> 2] = HEAP32[$10 + 8 >> 2] | HEAPU8[HEAP32[$10 + 40 >> 2] + HEAPU8[$10 + 15 | 0] | 0] ^ HEAPU8[HEAPU8[$10 + 15 | 0] + ($10 + 16 | 0) | 0];
    HEAP8[$10 + 15 | 0] = HEAPU8[$10 + 15 | 0] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[$10 + 8 >> 2]) {
   mbedtls_zeroize_3(HEAP32[$10 + 44 >> 2], HEAP32[$10 + 68 >> 2]);
   HEAP32[$10 + 76 >> 2] = -15;
   break label$1;
  }
  HEAP32[$10 + 76 >> 2] = 0;
 }
 __stack_pointer = $10 + 80 | 0;
 return HEAP32[$10 + 76 >> 2];
}

function int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 $0 = HEAP32[$2 + 24 >> 2];
 $1 = $0 & 31;
 $0 = ($0 & 63) >>> 0 >= 32 ? 0 : 1 << $1;
 $1 = $0 - 1 | 0;
 HEAP32[$2 + 20 >> 2] = int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29($1);
 HEAP32[$2 + 16 >> 2] = int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(0);
 HEAP32[$2 + 12 >> 2] = int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(1);
 HEAP32[$2 + 8 >> 2] = int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2]);
 HEAP32[$2 + 4 >> 2] = int_20gemmlowp__Add_int__28int_2c_20int_29(int_20gemmlowp__ShiftRight_int__28int_2c_20int_29(HEAP32[$2 + 20 >> 2], 1), int_20gemmlowp__BitAnd_int__28int_2c_20int_29(int_20gemmlowp__MaskIfLessThan_int__28int_2c_20int_29(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2]), HEAP32[$2 + 12 >> 2]));
 $0 = int_20gemmlowp__Add_int__28int_2c_20int_29(int_20gemmlowp__ShiftRight_int__28int_2c_20int_29(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]), int_20gemmlowp__BitAnd_int__28int_2c_20int_29(int_20gemmlowp__MaskIfGreaterThan_int__28int_2c_20int_29(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]), HEAP32[$2 + 12 >> 2]));
 __stack_pointer = $2 + 32 | 0;
 return $0;
}

function jslGetNextCh() {
 var $0 = 0;
 $0 = jslNextCh();
 HEAP8[HEAP32[49079]] = $0;
 $0 = HEAP32[49079];
 HEAP32[$0 + 88 >> 2] = HEAP32[$0 + 88 >> 2] + 1;
 label$1: {
  if (HEAPU32[HEAP32[49079] + 88 >> 2] < HEAPU32[HEAP32[49079] + 92 >> 2]) {
   break label$1;
  }
  $0 = HEAP32[49079];
  HEAP32[$0 + 88 >> 2] = HEAP32[$0 + 88 >> 2] - HEAP32[HEAP32[49079] + 92 >> 2];
  $0 = HEAP32[49079];
  HEAP32[$0 + 96 >> 2] = HEAP32[HEAP32[49079] + 92 >> 2] + HEAP32[$0 + 96 >> 2];
  if (jsvIsFlashString(HEAP32[HEAP32[49079] + 100 >> 2]) & 1) {
   jsvStringIteratorLoadFlashString(HEAP32[49079] + 88 | 0);
   break label$1;
  }
  label$3: {
   label$4: {
    if (!HEAP32[HEAP32[49079] + 100 >> 2]) {
     break label$4;
    }
    if (!(jsvGetLastChild(HEAP32[HEAP32[49079] + 100 >> 2]) & 65535)) {
     break label$4;
    }
    $0 = _jsvGetAddressOf(jsvGetLastChild(HEAP32[HEAP32[49079] + 100 >> 2]) & 65535);
    HEAP32[HEAP32[49079] + 100 >> 2] = $0;
    HEAP32[HEAP32[49079] + 104 >> 2] = HEAP32[HEAP32[49079] + 100 >> 2];
    $0 = jsvGetCharactersInVar(HEAP32[HEAP32[49079] + 100 >> 2]);
    HEAP32[HEAP32[49079] + 92 >> 2] = $0;
    break label$3;
   }
   HEAP32[HEAP32[49079] + 100 >> 2] = 0;
   HEAP32[HEAP32[49079] + 104 >> 2] = 0;
   HEAP32[HEAP32[49079] + 92 >> 2] = 0;
   $0 = HEAP32[49079];
   HEAP32[$0 + 96 >> 2] = HEAP32[HEAP32[49079] + 88 >> 2] + HEAP32[$0 + 96 >> 2];
   HEAP32[HEAP32[49079] + 88 >> 2] = 0;
  }
 }
}

function jsfGetNextFileHeader($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = HEAP32[HEAP32[$3 + 24 >> 2] >> 2];
 HEAP32[HEAP32[$3 + 24 >> 2] >> 2] = 0;
 HEAP32[$3 + 8 >> 2] = (HEAP32[$3 + 12 >> 2] + jsfGetFileSize(HEAP32[$3 + 20 >> 2]) | 0) + 32;
 HEAP32[$3 + 8 >> 2] = jsfAlignAddress(HEAP32[$3 + 8 >> 2]);
 label$1: {
  if (HEAPU32[$3 + 8 >> 2] < HEAPU32[$3 + 12 >> 2]) {
   HEAP8[$3 + 31 | 0] = 0;
   break label$1;
  }
  if (HEAP32[$3 + 8 >> 2] + 32 >>> 0 > jsfGetBankEndAddress(HEAP32[$3 + 12 >> 2]) >>> 0) {
   HEAP8[$3 + 31 | 0] = 0;
   break label$1;
  }
  HEAP32[HEAP32[$3 + 24 >> 2] >> 2] = HEAP32[$3 + 8 >> 2];
  HEAP8[$3 + 7 | 0] = jsfGetFileHeader(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 20 >> 2], ((HEAP32[$3 + 16 >> 2] & 2) != 0 ^ -1) & 1) & 1;
  if (!(!(HEAP32[$3 + 16 >> 2] & 1) | HEAP8[$3 + 7 | 0] & 1)) {
   HEAP32[$3 + 8 >> 2] = jsfGetAddressOfNextPage(HEAP32[$3 + 8 >> 2]);
   HEAP32[HEAP32[$3 + 24 >> 2] >> 2] = HEAP32[$3 + 8 >> 2];
   if (!HEAP32[$3 + 8 >> 2]) {
    HEAP8[$3 + 31 | 0] = 0;
    break label$1;
   }
   HEAP8[$3 + 7 | 0] = jsfGetFileHeader(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 20 >> 2], ((HEAP32[$3 + 16 >> 2] & 2) != 0 ^ -1) & 1) & 1;
  }
  HEAP8[$3 + 31 | 0] = HEAP8[$3 + 7 | 0] & 1;
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP8[$3 + 31 | 0] & 1;
}

function jswrap_serial_unsetup($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 label$1: {
  if (!(jsvIsObject(HEAP32[$1 + 28 >> 2]) & 1)) {
   break label$1;
  }
  HEAP8[$1 + 27 | 0] = jsiGetDeviceFromClass(HEAP32[$1 + 28 >> 2]);
  HEAP32[$1 + 20 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 28 >> 2], 120075);
  HEAP32[$1 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 28 >> 2], 132026);
  if (HEAP32[$1 + 20 >> 2]) {
   jsserialPopulateUSARTInfo($1, HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
   if (HEAPU8[$1 + 6 | 0] != 255) {
    jshPinSetState(HEAPU8[$1 + 6 | 0], 0);
   }
   if (HEAPU8[$1 + 7 | 0] != 255) {
    jshPinSetState(HEAPU8[$1 + 7 | 0], 0);
   }
   if (HEAPU8[$1 + 4 | 0] != 255) {
    jshPinSetState(HEAPU8[$1 + 4 | 0], 0);
   }
   if (HEAPU8[$1 + 5 | 0] != 255) {
    jshPinSetState(HEAPU8[$1 + 5 | 0], 0);
   }
   if (!(HEAPU8[$1 + 27 | 0] <= 22 & HEAPU8[$1 + 27 | 0] >= 17)) {
    jsserialEventCallbackKill(HEAP32[$1 + 28 >> 2], $1);
   }
  }
  jsvUnLock2(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2]);
  jsvObjectRemoveChild(HEAP32[$1 + 28 >> 2], 132026);
  jsvObjectRemoveChild(HEAP32[$1 + 28 >> 2], 120075);
  if (HEAPU8[$1 + 27 | 0] < 17 | HEAPU8[$1 + 27 | 0] > 22) {
   break label$1;
  }
  jshUSARTUnSetup(HEAPU8[$1 + 27 | 0]);
  jshSetFlowControlEnabled(HEAPU8[$1 + 27 | 0], 0, 255);
 }
 __stack_pointer = $1 + 32 | 0;
}

function jswrap_graphics_imageMetrics($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 192 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 184 >> 2] = $0;
 HEAP32[$2 + 180 >> 2] = $1;
 label$1: {
  if (!(graphicsGetFromVar($2 + 104 | 0, HEAP32[$2 + 184 >> 2]) & 1)) {
   HEAP32[$2 + 188 >> 2] = 0;
   break label$1;
  }
  if (!(_jswrap_graphics_parseImage($2 + 104 | 0, HEAP32[$2 + 180 >> 2], 0, $2 + 16 | 0) & 1)) {
   HEAP32[$2 + 188 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvGetLength(HEAP32[$2 + 36 >> 2]) - HEAP32[$2 + 40 >> 2];
  _jswrap_graphics_freeImageInfo($2 + 16 | 0);
  HEAP32[$2 + 8 >> 2] = jsvNewObject();
  if (HEAP32[$2 + 8 >> 2]) {
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 129398, jsvNewFromInteger(HEAP32[$2 + 16 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 117745, jsvNewFromInteger(HEAP32[$2 + 20 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 121714, jsvNewFromInteger(HEAP32[$2 + 24 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 117520, jsvNewFromBool(HEAP8[$2 + 28 | 0] & 1));
   HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2] / HEAPU16[$2 + 66 >> 1];
   if (HEAP32[$2 + 4 >> 2] > 1) {
    jsvObjectSetChildAndUnLock(HEAP32[$2 + 8 >> 2], 120231, jsvNewFromInteger(HEAP32[$2 + 4 >> 2]));
   }
  }
  HEAP32[$2 + 188 >> 2] = HEAP32[$2 + 8 >> 2];
 }
 __stack_pointer = $2 + 192 | 0;
 return HEAP32[$2 + 188 >> 2];
}

function tflite__GreedyMemoryPlanner__NextSimultaneouslyActiveBuffer_28tflite__GreedyMemoryPlanner__ListEntry_20const__2c_20int_2c_20int_29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 $0 = HEAP32[$4 + 24 >> 2];
 HEAP32[$4 + 8 >> 2] = 0;
 label$1: {
  label$2: {
   if (!HEAP32[$4 + 20 >> 2]) {
    HEAP32[$4 + 4 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[$0 + 32 >> 2], 12);
    break label$2;
   }
   if (HEAP32[HEAP32[$4 + 20 >> 2] + 8 >> 2] == -1) {
    HEAP32[$4 + 28 >> 2] = 0;
    break label$1;
   }
   HEAP32[$4 + 4 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[HEAP32[$4 + 20 >> 2] + 8 >> 2], 12);
  }
  while (1) {
   label$6: {
    if (tflite__GreedyMemoryPlanner__DoesEntryOverlapInTime_28tflite__GreedyMemoryPlanner__ListEntry_20const__2c_20int_2c_20int_29_20const($0, HEAP32[$4 + 4 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[$4 + 12 >> 2]) & 1) {
     HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 4 >> 2];
     break label$6;
    }
    if (HEAP32[HEAP32[$4 + 4 >> 2] + 8 >> 2] == -1) {
     break label$6;
    }
    HEAP32[$4 + 4 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[HEAP32[$4 + 4 >> 2] + 8 >> 2], 12);
    continue;
   }
   break;
  }
  HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 8 >> 2];
 }
 __stack_pointer = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}

function push_bits($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP8[$4 + 27 | 0] = $1;
 HEAP8[$4 + 26 | 0] = $2;
 HEAP32[$4 + 20 >> 2] = $3;
 label$1: {
  if (!(HEAPU8[$4 + 27 | 0] != 8 | HEAPU8[HEAP32[$4 + 28 >> 2] + 14 | 0] != 128)) {
   $2 = HEAPU8[$4 + 26 | 0];
   $3 = HEAP32[HEAP32[$4 + 20 >> 2] >> 2];
   $0 = HEAP32[HEAP32[$4 + 20 >> 2] + 8 >> 2];
   $1 = HEAP32[$0 >> 2];
   HEAP32[$0 >> 2] = $1 + 1;
   HEAP8[$1 + $3 | 0] = $2;
   break label$1;
  }
  HEAP32[$4 + 16 >> 2] = HEAPU8[$4 + 27 | 0] - 1;
  while (1) {
   if (HEAP32[$4 + 16 >> 2] >= 0) {
    HEAP8[$4 + 15 | 0] = (HEAPU8[$4 + 26 | 0] & 1 << HEAP32[$4 + 16 >> 2]) != 0;
    if (HEAP8[$4 + 15 | 0] & 1) {
     $0 = HEAP32[$4 + 28 >> 2];
     HEAP8[$0 + 13 | 0] = HEAPU8[HEAP32[$4 + 28 >> 2] + 14 | 0] | HEAPU8[$0 + 13 | 0];
    }
    $0 = HEAP32[$4 + 28 >> 2];
    HEAP8[$0 + 14 | 0] = HEAPU8[$0 + 14 | 0] >>> 1;
    if (!HEAPU8[HEAP32[$4 + 28 >> 2] + 14 | 0]) {
     HEAP8[HEAP32[$4 + 28 >> 2] + 14 | 0] = 128;
     $2 = HEAPU8[HEAP32[$4 + 28 >> 2] + 13 | 0];
     $3 = HEAP32[HEAP32[$4 + 20 >> 2] >> 2];
     $0 = HEAP32[HEAP32[$4 + 20 >> 2] + 8 >> 2];
     $1 = HEAP32[$0 >> 2];
     HEAP32[$0 >> 2] = $1 + 1;
     HEAP8[$1 + $3 | 0] = $2;
     HEAP8[HEAP32[$4 + 28 >> 2] + 13 | 0] = 0;
    }
    HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 16 >> 2] - 1;
    continue;
   }
   break;
  }
 }
}

function jswrap_math_round($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 32 >> 3] = $0;
 $2 = __DOUBLE_BITS_6(HEAPF64[$1 + 32 >> 3]);
 $4 = $2;
 $3 = i64toi32_i32$HIGH_BITS;
 $2 = $3 & 2147483647;
 label$1: {
  label$2: {
   if (!(($2 | 0) == 2146435072 | $2 >>> 0 > 2146435072)) {
    if (!(isNegativeZero(HEAPF64[$1 + 32 >> 3]) & 1)) {
     break label$2;
    }
   }
   HEAP32[$1 + 44 >> 2] = jsvNewFromFloat(HEAPF64[$1 + 32 >> 3]);
   break label$1;
  }
  HEAPF64[$1 + 32 >> 3] = HEAPF64[$1 + 32 >> 3] + (HEAPF64[$1 + 32 >> 3] < 0 ? -.5 : .5);
  $2 = $1;
  $0 = HEAPF64[$1 + 32 >> 3];
  label$5: {
   if (Math_abs($0) < 0x8000000000000000) {
    $3 = Math_abs($0) >= 1 ? ~~($0 > 0 ? Math_min(Math_floor($0 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($0 - +(~~$0 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
    $5 = ~~$0 >>> 0;
    break label$5;
   }
   $3 = -2147483648;
  }
  HEAP32[$2 + 24 >> 2] = $5;
  HEAP32[$2 + 28 >> 2] = $3;
  $3 = HEAP32[$1 + 24 >> 2];
  $2 = HEAP32[$1 + 28 >> 2];
  if (!(!!($3 | $2) | !(HEAPF64[$1 + 32 >> 3] < 0))) {
   HEAP32[$1 + 44 >> 2] = jsvNewFromFloat(-0);
   break label$1;
  }
  $2 = HEAP32[$1 + 24 >> 2];
  $3 = HEAP32[$1 + 28 >> 2];
  HEAP32[$1 + 44 >> 2] = jsvNewFromLongInteger($2, $3);
 }
 __stack_pointer = $1 + 48 | 0;
 return HEAP32[$1 + 44 >> 2];
}

function jsvIteratorSetValue($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 label$1: {
  label$2: {
   switch (HEAP32[HEAP32[$2 + 12 >> 2] >> 2] - 1 | 0) {
   case 3:
    label$6: {
     if (!(jsvIsIntegerish(HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2]) & 1)) {
      break label$6;
     }
     if ((jsvGetInteger(HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2]) | 0) != HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]) {
      break label$6;
     }
     jsvObjectIteratorSetValue(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2]);
    }
    jsvSetArrayItem(HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2], HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2], HEAP32[$2 + 8 >> 2]);
    break label$1;

   case 1:
    jsvObjectIteratorSetValue(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2]);
    break label$1;

   case 0:
    $1 = HEAP32[$2 + 12 >> 2] + 4 | 0;
    label$7: {
     if (jsvIsString(HEAP32[$2 + 8 >> 2]) & 1) {
      $0 = HEAP8[HEAP32[$2 + 8 >> 2]];
      break label$7;
     }
     $0 = jsvGetInteger(HEAP32[$2 + 8 >> 2]) << 24 >> 24;
    }
    jsvStringIteratorSetChar($1, $0 << 24 >> 24);
    break label$1;

   case 2:
    break label$2;

   default:
    break label$1;
   }
  }
  jsvArrayBufferIteratorSetValueAndRewind(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 8 >> 2];
}

function gemmlowp__ImplSaturatingRoundingMultiplyByPOT_1_2c_20int_2c_201___eval_28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(std____2__numeric_limits_int___min_28_29());
 HEAP32[$1 + 20 >> 2] = int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(std____2__numeric_limits_int___max_28_29());
 HEAP32[$1 + 16 >> 2] = 32;
 HEAP32[$1 + 12 >> 2] = 1073741823;
 HEAP32[$1 + 8 >> 2] = int_20gemmlowp__MaskIfGreaterThan_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(1073741823));
 HEAP32[$1 + 4 >> 2] = int_20gemmlowp__MaskIfLessThan_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(-1073741823));
 HEAP32[$1 >> 2] = int_20gemmlowp__ShiftLeft_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], 1);
 HEAP32[$1 >> 2] = int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 >> 2]);
 HEAP32[$1 >> 2] = int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 24 >> 2], HEAP32[$1 >> 2]);
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 >> 2];
}

function gemmlowp__ImplSaturatingRoundingMultiplyByPOT_2_2c_20int_2c_201___eval_28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(std____2__numeric_limits_int___min_28_29());
 HEAP32[$1 + 20 >> 2] = int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(std____2__numeric_limits_int___max_28_29());
 HEAP32[$1 + 16 >> 2] = 32;
 HEAP32[$1 + 12 >> 2] = 536870911;
 HEAP32[$1 + 8 >> 2] = int_20gemmlowp__MaskIfGreaterThan_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(536870911));
 HEAP32[$1 + 4 >> 2] = int_20gemmlowp__MaskIfLessThan_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(-536870911));
 HEAP32[$1 >> 2] = int_20gemmlowp__ShiftLeft_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], 2);
 HEAP32[$1 >> 2] = int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 >> 2]);
 HEAP32[$1 >> 2] = int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 24 >> 2], HEAP32[$1 >> 2]);
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 >> 2];
}

function lcdFillRect_JS($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = __stack_pointer - 48 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 44 >> 2] = $0;
 HEAP32[$6 + 40 >> 2] = $1;
 HEAP32[$6 + 36 >> 2] = $2;
 HEAP32[$6 + 32 >> 2] = $3;
 HEAP32[$6 + 28 >> 2] = $4;
 HEAP32[$6 + 24 >> 2] = $5;
 $0 = HEAP32[$6 + 44 >> 2];
 HEAP32[$6 + 20 >> 2] = jsvObjectGetChildIfExists(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 117919);
 label$1: {
  if (HEAP32[$6 + 20 >> 2]) {
   HEAP32[$6 >> 2] = jsvNewFromInteger(HEAP32[$6 + 40 >> 2]);
   HEAP32[$6 + 4 >> 2] = jsvNewFromInteger(HEAP32[$6 + 36 >> 2]);
   HEAP32[$6 + 8 >> 2] = jsvNewFromInteger(HEAP32[$6 + 32 >> 2]);
   HEAP32[$6 + 12 >> 2] = jsvNewFromInteger(HEAP32[$6 + 28 >> 2]);
   HEAP32[$6 + 16 >> 2] = jsvNewFromInteger(HEAP32[$6 + 24 >> 2]);
   $0 = HEAP32[$6 + 44 >> 2];
   jsvUnLock(jspExecuteFunction(HEAP32[$6 + 20 >> 2], HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 5, $6));
   jsvUnLockMany(5, $6);
   jsvUnLock(HEAP32[$6 + 20 >> 2]);
   break label$1;
  }
  graphicsFallbackFillRect(HEAP32[$6 + 44 >> 2], HEAP32[$6 + 40 >> 2], HEAP32[$6 + 36 >> 2], HEAP32[$6 + 32 >> 2], HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2]);
 }
 __stack_pointer = $6 + 48 | 0;
}

function fflush($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0;
 if (!$0) {
  if (HEAP32[97836]) {
   $1 = fflush(HEAP32[97836]);
  }
  if (HEAP32[48968]) {
   $1 = fflush(HEAP32[48968]) | $1;
  }
  $0 = HEAP32[__ofl_lock() >> 2];
  if ($0) {
   while (1) {
    $2 = 0;
    if (HEAP32[$0 + 76 >> 2] >= 0) {
     $2 = __lockfile($0);
    }
    if (HEAP32[$0 + 20 >> 2] != HEAP32[$0 + 28 >> 2]) {
     $1 = fflush($0) | $1;
    }
    if ($2) {
     __unlockfile($0);
    }
    $0 = HEAP32[$0 + 56 >> 2];
    if ($0) {
     continue;
    }
    break;
   }
  }
  __ofl_unlock();
  return $1 | 0;
 }
 if (HEAP32[$0 + 76 >> 2] >= 0) {
  $2 = __lockfile($0);
 }
 label$10: {
  label$11: {
   label$12: {
    if (HEAP32[$0 + 20 >> 2] == HEAP32[$0 + 28 >> 2]) {
     break label$12;
    }
    FUNCTION_TABLE[HEAP32[$0 + 36 >> 2]]($0, 0, 0) | 0;
    if (HEAP32[$0 + 20 >> 2]) {
     break label$12;
    }
    $1 = -1;
    if ($2) {
     break label$11;
    }
    break label$10;
   }
   $1 = HEAP32[$0 + 4 >> 2];
   $3 = HEAP32[$0 + 8 >> 2];
   if (($1 | 0) != ($3 | 0)) {
    $1 = $1 - $3 | 0;
    FUNCTION_TABLE[HEAP32[$0 + 40 >> 2]]($0, $1, $1 >> 31, 1) | 0;
   }
   $1 = 0;
   HEAP32[$0 + 28 >> 2] = 0;
   HEAP32[$0 + 16 >> 2] = 0;
   HEAP32[$0 + 20 >> 2] = 0;
   HEAP32[$0 + 4 >> 2] = 0;
   HEAP32[$0 + 8 >> 2] = 0;
   if (!$2) {
    break label$10;
   }
  }
  __unlockfile($0);
 }
 return $1 | 0;
}

function graphicsFallbackBlit($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 var $7 = 0;
 $7 = __stack_pointer - 48 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 44 >> 2] = $0;
 HEAP32[$7 + 40 >> 2] = $1;
 HEAP32[$7 + 36 >> 2] = $2;
 HEAP32[$7 + 32 >> 2] = $3;
 HEAP32[$7 + 28 >> 2] = $4;
 HEAP32[$7 + 24 >> 2] = $5;
 HEAP32[$7 + 20 >> 2] = $6;
 HEAP32[$7 + 16 >> 2] = 0;
 while (1) {
  if (HEAP32[$7 + 16 >> 2] < HEAP32[$7 + 28 >> 2]) {
   HEAP32[$7 + 12 >> 2] = 0;
   while (1) {
    if (HEAP32[$7 + 12 >> 2] < HEAP32[$7 + 32 >> 2]) {
     $0 = HEAP32[$7 + 44 >> 2];
     $1 = HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24);
     $0 = HEAP32[$7 + 44 >> 2];
     FUNCTION_TABLE[$1 | 0](HEAP32[$7 + 44 >> 2], HEAP32[$7 + 12 >> 2] + HEAP32[$7 + 24 >> 2] | 0, HEAP32[$7 + 16 >> 2] + HEAP32[$7 + 20 >> 2] | 0, FUNCTION_TABLE[HEAPU8[$0 + 60 | 0] | HEAPU8[$0 + 61 | 0] << 8 | (HEAPU8[$0 + 62 | 0] << 16 | HEAPU8[$0 + 63 | 0] << 24)](HEAP32[$7 + 44 >> 2], HEAP32[$7 + 12 >> 2] + HEAP32[$7 + 40 >> 2] | 0, HEAP32[$7 + 16 >> 2] + HEAP32[$7 + 36 >> 2] | 0) | 0);
     HEAP32[$7 + 12 >> 2] = HEAP32[$7 + 12 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$7 + 16 >> 2] = HEAP32[$7 + 16 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $7 + 48 | 0;
}

function gemmlowp__ImplSaturatingRoundingMultiplyByPOT_5_2c_20int_2c_201___eval_28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(std____2__numeric_limits_int___min_28_29());
 HEAP32[$1 + 20 >> 2] = int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(std____2__numeric_limits_int___max_28_29());
 HEAP32[$1 + 16 >> 2] = 32;
 HEAP32[$1 + 12 >> 2] = 67108863;
 HEAP32[$1 + 8 >> 2] = int_20gemmlowp__MaskIfGreaterThan_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(67108863));
 HEAP32[$1 + 4 >> 2] = int_20gemmlowp__MaskIfLessThan_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(-67108863));
 HEAP32[$1 >> 2] = int_20gemmlowp__ShiftLeft_int__28int_2c_20int_29(HEAP32[$1 + 28 >> 2], 5);
 HEAP32[$1 >> 2] = int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 >> 2]);
 HEAP32[$1 >> 2] = int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 24 >> 2], HEAP32[$1 >> 2]);
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 >> 2];
}

function jsvUpdateMemoryAddress($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = 1;
 while (1) {
  if (HEAPU32[$3 + 16 >> 2] <= 12e3) {
   HEAP32[$3 + 12 >> 2] = jsvGetAddressOf(HEAP32[$3 + 16 >> 2] & 65535);
   label$3: {
    label$4: {
     if (!(jsvIsNativeString(HEAP32[$3 + 12 >> 2]) & 1)) {
      if (!(jsvIsFlashString(HEAP32[$3 + 12 >> 2]) & 1)) {
       break label$4;
      }
     }
     $0 = HEAP32[$3 + 12 >> 2];
     HEAP32[$3 + 8 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
     if (!(HEAPU32[$3 + 8 >> 2] < HEAPU32[$3 + 28 >> 2] | HEAPU32[$3 + 8 >> 2] >= HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 24 >> 2] >>> 0)) {
      $0 = HEAP32[$3 + 12 >> 2];
      $1 = (HEAP32[$3 + 8 >> 2] + HEAP32[$3 + 20 >> 2] | 0) - HEAP32[$3 + 28 >> 2] | 0;
      HEAP8[$0 | 0] = $1;
      HEAP8[$0 + 1 | 0] = $1 >>> 8;
      HEAP8[$0 + 2 | 0] = $1 >>> 16;
      HEAP8[$0 + 3 | 0] = $1 >>> 24;
     }
     break label$3;
    }
    if (jsvIsFlatString(HEAP32[$3 + 12 >> 2]) & 1) {
     HEAP32[$3 + 16 >> 2] = jsvGetFlatStringBlocks(HEAP32[$3 + 12 >> 2]) + HEAP32[$3 + 16 >> 2];
    }
   }
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $3 + 32 | 0;
}

function match($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 368 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 364 >> 2] = $0;
 HEAP32[$4 + 360 >> 2] = $1;
 HEAP32[$4 + 356 >> 2] = $2;
 HEAP8[$4 + 355 | 0] = $3;
 HEAP32[$4 + 264 >> 2] = HEAP32[$4 + 360 >> 2];
 HEAP32[$4 + 268 >> 2] = HEAP32[$4 + 356 >> 2];
 HEAP8[$4 + 272 | 0] = HEAP8[$4 + 355 | 0] & 1;
 HEAP8[$4 + 273 | 0] = 0;
 HEAP16[$4 + 274 >> 1] = 256;
 HEAP32[$4 + 276 >> 2] = 0;
 jsvStringIteratorNew($4 + 224 | 0, HEAP32[$4 + 360 >> 2], HEAP32[$4 + 356 >> 2]);
 jsvStringIteratorClone($4 + 184 | 0, $4 + 224 | 0);
 $0 = HEAP32[$4 + 364 >> 2];
 __memcpy($4 + 96 | 0, $4 + 264 | 0, 88);
 HEAP32[$4 + 260 >> 2] = matchhere($0, $4 + 184 | 0, $4 + 96 | 0);
 jsvStringIteratorFree_9($4 + 184 | 0);
 jsvStringIteratorNext($4 + 224 | 0);
 while (1) {
  $0 = 0;
  if (!HEAP32[$4 + 260 >> 2]) {
   $0 = jsvStringIteratorHasChar_7($4 + 224 | 0);
  }
  if ($0 & 1) {
   HEAP32[$4 + 268 >> 2] = HEAP32[$4 + 268 >> 2] + 1;
   jsvStringIteratorClone($4 + 184 | 0, $4 + 224 | 0);
   $0 = HEAP32[$4 + 364 >> 2];
   __memcpy($4 + 8 | 0, $4 + 264 | 0, 88);
   HEAP32[$4 + 260 >> 2] = matchhere($0, $4 + 184 | 0, $4 + 8 | 0);
   jsvStringIteratorFree_9($4 + 184 | 0);
   jsvStringIteratorNext($4 + 224 | 0);
   continue;
  }
  break;
 }
 jsvStringIteratorFree_9($4 + 224 | 0);
 __stack_pointer = $4 + 368 | 0;
 return HEAP32[$4 + 260 >> 2];
}

function tflite___28anonymous_20namespace_29__CommitPlan_28tflite__ErrorReporter__2c_20tflite__MemoryPlanner__2c_20unsigned_20char__2c_20tflite___28anonymous_20namespace_29__AllocationInfo_20const__2c_20unsigned_20long_29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP32[$5 + 36 >> 2] = $1;
 HEAP32[$5 + 32 >> 2] = $2;
 HEAP32[$5 + 28 >> 2] = $3;
 HEAP32[$5 + 24 >> 2] = $4;
 HEAP32[$5 + 20 >> 2] = 0;
 HEAP32[$5 + 16 >> 2] = 0;
 label$1: {
  while (1) {
   if (HEAPU32[$5 + 16 >> 2] < HEAPU32[$5 + 24 >> 2]) {
    HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 28 >> 2] + Math_imul(HEAP32[$5 + 16 >> 2], 24);
    if (HEAP8[HEAP32[$5 + 12 >> 2] + 20 | 0] & 1) {
     HEAP32[$5 + 8 >> 2] = -1;
     $0 = HEAP32[$5 + 36 >> 2];
     HEAP32[$5 + 4 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 20 >> 2]]($0, HEAP32[$5 + 40 >> 2], HEAP32[$5 + 20 >> 2], $5 + 8 | 0);
     if (HEAP32[$5 + 4 >> 2]) {
      HEAP32[$5 + 44 >> 2] = HEAP32[$5 + 4 >> 2];
      break label$1;
     }
     HEAP32[HEAP32[HEAP32[$5 + 12 >> 2] + 4 >> 2] >> 2] = HEAP32[$5 + 32 >> 2] + HEAP32[$5 + 8 >> 2];
     HEAP32[$5 + 20 >> 2] = HEAP32[$5 + 20 >> 2] + 1;
    }
    HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 16 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$5 + 44 >> 2] = 0;
 }
 __stack_pointer = $5 + 48 | 0;
 return HEAP32[$5 + 44 >> 2];
}

function jsvGetBool($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1: {
  if (jsvIsString(HEAP32[$1 + 24 >> 2]) & 1) {
   HEAP8[$1 + 31 | 0] = (jsvGetStringLength(HEAP32[$1 + 24 >> 2]) | 0) != 0;
   break label$1;
  }
  if (jsvIsPin(HEAP32[$1 + 24 >> 2]) & 1) {
   HEAP8[$1 + 31 | 0] = jshIsPinValid(jshGetPinFromVar(HEAP32[$1 + 24 >> 2]) & 255) & 1;
   break label$1;
  }
  label$4: {
   label$5: {
    if (jsvIsFunction(HEAP32[$1 + 24 >> 2]) & 1) {
     break label$5;
    }
    if (jsvIsArray(HEAP32[$1 + 24 >> 2]) & 1) {
     break label$5;
    }
    if (jsvIsObject(HEAP32[$1 + 24 >> 2]) & 1) {
     break label$5;
    }
    if (!(jsvIsArrayBuffer(HEAP32[$1 + 24 >> 2]) & 1)) {
     break label$4;
    }
   }
   HEAP8[$1 + 31 | 0] = 1;
   break label$1;
  }
  if (jsvIsFloat(HEAP32[$1 + 24 >> 2]) & 1) {
   HEAPF64[$1 + 16 >> 3] = jsvGetFloat(HEAP32[$1 + 24 >> 2]);
   $2 = __DOUBLE_BITS(HEAPF64[$1 + 16 >> 3]);
   $0 = $2;
   $3 = i64toi32_i32$HIGH_BITS;
   $2 = $3 & 2147483647;
   $3 = $0;
   HEAP8[$1 + 31 | 0] = ($2 | 0) == 2146435072 & ($3 | 0) != 0 | $2 >>> 0 > 2146435072 ? 0 : HEAPF64[$1 + 16 >> 3] != 0;
   break label$1;
  }
  HEAP8[$1 + 31 | 0] = (jsvGetInteger(HEAP32[$1 + 24 >> 2]) | 0) != 0;
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP8[$1 + 31 | 0] & 1;
}

function jswrap_io_peek($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 96 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP32[$3 + 80 >> 2] = $2;
 HEAP32[$3 + 76 >> 2] = jshFlashGetMemMapAddress(HEAP32[$3 + 88 >> 2]);
 label$1: {
  if (HEAP32[$3 + 84 >> 2] <= 1) {
   HEAP32[$3 + 92 >> 2] = jsvNewFromLongInteger(_jswrap_io_peek(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 80 >> 2]), 0);
   break label$1;
  }
  if (HEAP32[$3 + 80 >> 2] == 1) {
   HEAP8[$3 + 75 | 0] = 1;
  }
  if (HEAP32[$3 + 80 >> 2] == 2) {
   HEAP8[$3 + 75 | 0] = 2;
  }
  if (HEAP32[$3 + 80 >> 2] == 4) {
   HEAP8[$3 + 75 | 0] = 4;
  }
  HEAP32[$3 + 68 >> 2] = jsvNewTypedArray(HEAPU8[$3 + 75 | 0], HEAP32[$3 + 84 >> 2]);
  if (!HEAP32[$3 + 68 >> 2]) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  jsvArrayBufferIteratorNew($3 + 8 | 0, HEAP32[$3 + 68 >> 2], 0);
  while (1) {
   if (jsvArrayBufferIteratorHasElement($3 + 8 | 0) & 1) {
    jsvArrayBufferIteratorSetIntegerValue($3 + 8 | 0, _jswrap_io_peek(HEAP32[$3 + 76 >> 2], HEAP32[$3 + 80 >> 2]));
    HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 80 >> 2] + HEAP32[$3 + 76 >> 2];
    jsvArrayBufferIteratorNext($3 + 8 | 0);
    continue;
   }
   break;
  }
  jsvArrayBufferIteratorFree($3 + 8 | 0);
  HEAP32[$3 + 92 >> 2] = HEAP32[$3 + 68 >> 2];
 }
 __stack_pointer = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}

function jslGetRawString() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP8[$0 + 15 | 0] = HEAP16[HEAP32[49079] + 2 >> 1] == 210;
 HEAP16[HEAP32[49079] + 2 >> 1] = 131;
 HEAP32[$0 + 8 >> 2] = HEAPU8[HEAP32[49079]];
 if (HEAP8[$0 + 15 | 0] & 1) {
  jslGetNextCh();
  HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] | HEAPU8[HEAP32[49079]] << 8;
 }
 jsvUnLock(HEAP32[HEAP32[49079] + 76 >> 2]);
 label$2: {
  if (HEAPU32[$0 + 8 >> 2] > 9) {
   HEAP32[$0 + 4 >> 2] = jsvStringIteratorGetIndex(HEAP32[49079] + 88 | 0);
   $1 = jsvNewFromStringVar(HEAP32[HEAP32[49079] + 84 >> 2], HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2]);
   HEAP32[HEAP32[49079] + 76 >> 2] = $1;
   jsvLockAgain(HEAP32[HEAP32[49079] + 100 >> 2]);
   jsvStringIteratorGoto(HEAP32[49079] + 88 | 0, HEAP32[HEAP32[49079] + 84 >> 2], HEAP32[$0 + 4 >> 2] + HEAP32[$0 + 8 >> 2] | 0);
   jsvUnLock(HEAP32[HEAP32[49079] + 100 >> 2]);
   break label$2;
  }
  $1 = jsvNewWithFlags(HEAP32[$0 + 8 >> 2] + 28 & 65535);
  HEAP32[HEAP32[49079] + 76 >> 2] = $1;
  HEAP32[$0 >> 2] = 0;
  while (1) {
   if (HEAPU32[$0 >> 2] < HEAPU32[$0 + 8 >> 2]) {
    jslGetNextCh();
    HEAP8[HEAP32[HEAP32[49079] + 76 >> 2] + HEAP32[$0 >> 2] | 0] = HEAPU8[HEAP32[49079]];
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
    continue;
   }
   break;
  }
 }
 jslGetNextCh();
 __stack_pointer = $0 + 16 | 0;
}

function jswrap_i2c_writeTo($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 $3 = $4;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1: {
  if (!(jsvIsObject(HEAP32[$3 + 28 >> 2]) & 1)) {
   break label$1;
  }
  HEAP8[$3 + 19 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 28 >> 2]);
  HEAP8[$3 + 18 | 0] = 1;
  HEAP32[$3 + 12 >> 2] = i2c_get_address(HEAP32[$3 + 24 >> 2], $3 + 18 | 0);
  HEAP32[$3 + 8 >> 2] = 0;
  HEAP32[$3 + 4 >> 2] = jsvGetDataPointer(HEAP32[$3 + 20 >> 2], $3 + 8 | 0);
  if (!(HEAP32[$3 + 4 >> 2] | !HEAP32[$3 + 20 >> 2])) {
   HEAP32[$3 + 8 >> 2] = jsvIterateCallbackCount(HEAP32[$3 + 20 >> 2]);
   label$3: {
    if (HEAP32[$3 + 8 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
     jsExceptionHere(1, 135807, 0);
     break label$3;
    }
    $4 = $4 - (HEAP32[$3 + 8 >> 2] + 15 & -16) | 0;
    __stack_pointer = $4;
    HEAP32[$3 + 4 >> 2] = $4;
    jsvIterateCallbackToBytes(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$3 + 8 >> 2]);
   }
  }
  if (!HEAP32[$3 + 4 >> 2] | !HEAP32[$3 + 8 >> 2]) {
   break label$1;
  }
  _jswrap_i2c_writeTo(HEAP32[$3 + 28 >> 2], HEAPU8[$3 + 19 | 0], HEAP32[$3 + 12 >> 2], HEAP8[$3 + 18 | 0] & 1, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 }
 __stack_pointer = $3 + 32 | 0;
}

function jswrap_string_trim($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 80 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 72 >> 2] = $0;
 HEAP32[$1 + 68 >> 2] = jsvAsString(HEAP32[$1 + 72 >> 2]);
 label$1: {
  if (!HEAP32[$1 + 68 >> 2]) {
   HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 68 >> 2];
   break label$1;
  }
  HEAP32[$1 + 64 >> 2] = 0;
  HEAP32[$1 + 60 >> 2] = -1;
  jsvStringIteratorNew($1 + 24 | 0, HEAP32[$1 + 68 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar_8($1 + 24 | 0) & 1) {
    HEAP32[$1 + 20 >> 2] = jsvStringIteratorGetIndex_5($1 + 24 | 0);
    HEAP8[$1 + 19 | 0] = isWhitespace(jsvStringIteratorGetCharAndNext($1 + 24 | 0) << 24 >> 24) & 1;
    if (!(HEAP8[$1 + 19 | 0] & 1)) {
     if (HEAP32[$1 + 60 >> 2] < 0) {
      HEAP32[$1 + 64 >> 2] = HEAP32[$1 + 20 >> 2];
     }
     HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 20 >> 2];
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree_10($1 + 24 | 0);
  HEAP32[$1 + 12 >> 2] = 0;
  if (HEAP32[$1 + 60 >> 2] >= HEAP32[$1 + 64 >> 2]) {
   HEAP32[$1 + 12 >> 2] = (HEAP32[$1 + 60 >> 2] + 1 | 0) - HEAP32[$1 + 64 >> 2];
  }
  HEAP32[$1 + 8 >> 2] = jsvNewFromStringVar(HEAP32[$1 + 68 >> 2], HEAP32[$1 + 64 >> 2], HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 68 >> 2]);
  HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 8 >> 2];
 }
 __stack_pointer = $1 + 80 | 0;
 return HEAP32[$1 + 76 >> 2];
}

function jsvArrayInsertBefore($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1: {
  if (HEAP32[$3 + 24 >> 2]) {
   HEAP32[$3 + 16 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(0), HEAP32[$3 + 20 >> 2]);
   if (!HEAP32[$3 + 16 >> 2]) {
    break label$1;
   }
   HEAP16[$3 + 14 >> 1] = jsvGetRef(jsvRef(HEAP32[$3 + 16 >> 2]));
   HEAP16[$3 + 12 >> 1] = jsvGetPrevSibling(HEAP32[$3 + 24 >> 2]);
   label$3: {
    if (HEAPU16[$3 + 12 >> 1]) {
     HEAP32[$3 + 8 >> 2] = jsvRef(jsvLock(HEAPU16[$3 + 12 >> 1]));
     jsvSetInteger(HEAP32[$3 + 16 >> 2], jsvGetInteger(HEAP32[$3 + 8 >> 2]) + 1 | 0);
     jsvSetNextSibling(HEAP32[$3 + 8 >> 2], HEAPU16[$3 + 14 >> 1]);
     jsvUnLock(HEAP32[$3 + 8 >> 2]);
     jsvSetPrevSibling(HEAP32[$3 + 16 >> 2], HEAPU16[$3 + 12 >> 1]);
     break label$3;
    }
    jsvSetPrevSibling(HEAP32[$3 + 16 >> 2], 0);
    jsvSetFirstChild(HEAP32[$3 + 28 >> 2], HEAPU16[$3 + 14 >> 1]);
   }
   jsvSetPrevSibling(HEAP32[$3 + 24 >> 2], HEAPU16[$3 + 14 >> 1]);
   jsvSetNextSibling(HEAP32[$3 + 16 >> 2], jsvGetRef(jsvRef(HEAP32[$3 + 24 >> 2])) & 65535);
   jsvUnLock(HEAP32[$3 + 16 >> 2]);
   break label$1;
  }
  jsvArrayPush(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 20 >> 2]);
 }
 __stack_pointer = $3 + 32 | 0;
}

function jspNewObject($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = jspNewPrototype(HEAP32[$2 + 20 >> 2], 0);
 HEAP32[$2 + 12 >> 2] = jsvNewObject();
 label$1: {
  if (!HEAP32[$2 + 12 >> 2]) {
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$2 + 24 >> 2]) {
   HEAP8[$2 + 11 | 0] = jshFromDeviceString(HEAP32[$2 + 24 >> 2]);
   if (HEAPU8[$2 + 11 | 0]) {
    HEAP8[HEAP32[$2 + 12 >> 2]] = 68;
    HEAP8[HEAP32[$2 + 12 >> 2] + 1 | 0] = 69;
    HEAP8[HEAP32[$2 + 12 >> 2] + 2 | 0] = 86;
    HEAP8[HEAP32[$2 + 12 >> 2] + 3 | 0] = HEAPU8[$2 + 11 | 0];
   }
  }
  jsvAddNamedChildAndUnLock(HEAP32[$2 + 12 >> 2], jsvSkipNameAndUnLock(HEAP32[$2 + 16 >> 2]), 135865);
  if (HEAP32[$2 + 24 >> 2]) {
   HEAP32[$2 + 4 >> 2] = jsvFindOrAddChildFromString(HEAP32[91086], HEAP32[$2 + 24 >> 2]);
   if (HEAP32[$2 + 4 >> 2]) {
    jsvSetValueOfName(HEAP32[$2 + 4 >> 2], HEAP32[$2 + 12 >> 2]);
   }
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   if (!HEAP32[$2 + 4 >> 2]) {
    HEAP32[$2 + 28 >> 2] = 0;
    break label$1;
   }
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 4 >> 2];
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jswrap_array_sort($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 72 >> 2] = $0;
 HEAP32[$2 + 68 >> 2] = $1;
 label$1: {
  label$2: {
   if (jsvIsUndefined(HEAP32[$2 + 68 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsFunction(HEAP32[$2 + 68 >> 2]) & 1) {
    break label$2;
   }
   HEAP32[$2 >> 2] = HEAP32[$2 + 68 >> 2];
   jsExceptionHere(1, 118792, $2);
   HEAP32[$2 + 76 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 4 >> 2] = 0;
  label$3: {
   label$4: {
    if (!(jsvIsArray(HEAP32[$2 + 72 >> 2]) & 1)) {
     if (!(jsvIsObject(HEAP32[$2 + 72 >> 2]) & 1)) {
      break label$4;
     }
    }
    jsvIteratorNew($2 + 8 | 0, HEAP32[$2 + 72 >> 2], 1);
    while (1) {
     if (jsvIteratorHasElement($2 + 8 | 0) & 1) {
      HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
      jsvIteratorNext($2 + 8 | 0);
      continue;
     }
     break;
    }
    jsvIteratorFree($2 + 8 | 0);
    break label$3;
   }
   HEAP32[$2 + 4 >> 2] = jsvGetLength(HEAP32[$2 + 72 >> 2]);
  }
  jsvIteratorNew($2 + 8 | 0, HEAP32[$2 + 72 >> 2], 1);
  _jswrap_array_sort($2 + 8 | 0, HEAP32[$2 + 4 >> 2], HEAP32[$2 + 68 >> 2]);
  jsvIteratorFree($2 + 8 | 0);
  HEAP32[$2 + 76 >> 2] = jsvLockAgain(HEAP32[$2 + 72 >> 2]);
 }
 __stack_pointer = $2 + 80 | 0;
 return HEAP32[$2 + 76 >> 2];
}

function jswrap_flash_read($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 72 >> 2] = $0;
 HEAP32[$2 + 68 >> 2] = $1;
 label$1: {
  if (HEAP32[$2 + 72 >> 2] <= 0) {
   HEAP32[$2 + 76 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 64 >> 2] = jsvNewTypedArray(1, HEAP32[$2 + 72 >> 2]);
  if (!HEAP32[$2 + 64 >> 2]) {
   HEAP32[$2 + 76 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 56 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$2 + 64 >> 2], $2 + 60 | 0);
  if (HEAP32[$2 + 56 >> 2]) {
   jsvStringIteratorNew($2 + 16 | 0, HEAP32[$2 + 56 >> 2], HEAP32[$2 + 60 >> 2]);
   while (1) {
    $0 = 0;
    if (HEAP32[$2 + 72 >> 2] > 0) {
     $0 = jsvStringIteratorHasChar_10($2 + 16 | 0);
    }
    if ($0 & 1) {
     HEAP32[$2 + 8 >> 2] = 0;
     jsvStringIteratorGetPtrAndNext($2 + 16 | 0, $2 + 12 | 0, $2 + 8 | 0);
     jshFlashRead(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 68 >> 2], HEAP32[$2 + 8 >> 2]);
     HEAP32[$2 + 68 >> 2] = HEAP32[$2 + 8 >> 2] + HEAP32[$2 + 68 >> 2];
     HEAP32[$2 + 72 >> 2] = HEAP32[$2 + 72 >> 2] - HEAP32[$2 + 8 >> 2];
     continue;
    }
    break;
   }
   jsvStringIteratorFree_12($2 + 16 | 0);
   jsvUnLock(HEAP32[$2 + 56 >> 2]);
  }
  HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 64 >> 2];
 }
 __stack_pointer = $2 + 80 | 0;
 return HEAP32[$2 + 76 >> 2];
}

function jsvArrayPop($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP32[$1 + 4 >> 2] = jsvGetArrayLength(HEAP32[$1 + 12 >> 2]);
 if (HEAP32[$1 + 4 >> 2] > 0) {
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] - 1;
  if (jsvGetLastChild(HEAP32[$1 + 12 >> 2]) & 65535) {
   HEAP16[$1 + 2 >> 1] = jsvGetLastChild(HEAP32[$1 + 12 >> 2]);
   HEAP32[$1 + 8 >> 2] = jsvLock(HEAPU16[$1 + 2 >> 1]);
   while (1) {
    $0 = 0;
    if (HEAP32[$1 + 8 >> 2]) {
     $0 = jsvIsInt(HEAP32[$1 + 8 >> 2]) ^ -1;
    }
    if ($0 & 1) {
     HEAP16[$1 + 2 >> 1] = jsvGetPrevSibling(HEAP32[$1 + 8 >> 2]);
     jsvUnLock(HEAP32[$1 + 8 >> 2]);
     label$6: {
      if (HEAPU16[$1 + 2 >> 1]) {
       HEAP32[$1 + 8 >> 2] = jsvLock(HEAPU16[$1 + 2 >> 1]);
       break label$6;
      }
      HEAP32[$1 + 8 >> 2] = 0;
     }
     continue;
    }
    break;
   }
   if (HEAP32[$1 + 8 >> 2]) {
    label$9: {
     if ((jsvGetInteger(HEAP32[$1 + 8 >> 2]) | 0) == HEAP32[$1 + 4 >> 2]) {
      jsvRemoveChild(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2]);
      break label$9;
     }
     jsvUnLock(HEAP32[$1 + 8 >> 2]);
     HEAP32[$1 + 8 >> 2] = 0;
    }
   }
  }
  jsvSetArrayLength(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 4 >> 2], 0);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function OneWireWrite($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP8[$4 + 31 | 0] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 20 >> 2] = $3;
 jshPinSetState(HEAPU8[$4 + 31 | 0], 3);
 HEAP32[$4 + 8 >> 2] = 1;
 HEAP32[$4 + 12 >> 2] = 0;
 while (1) {
  $0 = HEAP32[$4 + 24 >> 2];
  HEAP32[$4 + 24 >> 2] = $0 - 1;
  if (($0 | 0) > 0) {
   $3 = HEAP32[$4 + 16 >> 2];
   $5 = $3;
   $0 = HEAP32[$4 + 20 >> 2];
   $2 = $0;
   $3 = HEAP32[$4 + 12 >> 2];
   $6 = $3;
   $0 = HEAP32[$4 + 8 >> 2];
   $1 = $0;
   $3 = $2;
   $0 = $6;
   $0 = $3 & $0;
   $3 = $1 & $5;
   label$3: {
    if ($3 | $0) {
     jshInterruptOff();
     jshPinSetValue(HEAPU8[$4 + 31 | 0], 0);
     jshDelayMicroseconds(10);
     jshPinSetValue(HEAPU8[$4 + 31 | 0], 1);
     jshInterruptOn();
     jshDelayMicroseconds(55);
     break label$3;
    }
    jshInterruptOff();
    jshPinSetValue(HEAPU8[$4 + 31 | 0], 0);
    jshDelayMicroseconds(65);
    jshPinSetValue(HEAPU8[$4 + 31 | 0], 1);
    jshInterruptOn();
    jshDelayMicroseconds(5);
   }
   $0 = HEAP32[$4 + 12 >> 2];
   $3 = HEAP32[$4 + 8 >> 2];
   $1 = $3;
   $3 = $0 << 1 | $3 >>> 31;
   $0 = $1 << 1;
   HEAP32[$4 + 8 >> 2] = $0;
   HEAP32[$4 + 12 >> 2] = $3;
   continue;
  }
  break;
 }
 __stack_pointer = $4 + 32 | 0;
}

function jspeUnaryExpression() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 label$1: {
  label$2: {
   if (!(HEAP16[HEAP32[49079] + 2 >> 1] == 33 | HEAP16[HEAP32[49079] + 2 >> 1] == 126 | HEAP16[HEAP32[49079] + 2 >> 1] == 45)) {
    if (HEAP16[HEAP32[49079] + 2 >> 1] != 43) {
     break label$2;
    }
   }
   HEAP16[$0 + 10 >> 1] = HEAPU16[HEAP32[49079] + 2 >> 1];
   jslGetNextToken();
   if ((HEAP32[91094] & 63) != 1) {
    HEAP32[$0 + 12 >> 2] = jspeUnaryExpression();
    break label$1;
   }
   HEAP32[$0 + 4 >> 2] = jsvSkipNameAndUnLock(jspeUnaryExpression());
   if (HEAP16[$0 + 10 >> 1] == 33) {
    HEAP32[$0 + 12 >> 2] = jsvNewFromBool((jsvGetBoolAndUnLock(HEAP32[$0 + 4 >> 2]) ^ -1) & 1);
    break label$1;
   }
   if (HEAP16[$0 + 10 >> 1] == 126) {
    HEAP32[$0 + 12 >> 2] = jsvNewFromInteger(jsvGetIntegerAndUnLock(HEAP32[$0 + 4 >> 2]) ^ -1);
    break label$1;
   }
   if (HEAP16[$0 + 10 >> 1] == 45) {
    HEAP32[$0 + 12 >> 2] = jsvNegateAndUnLock(HEAP32[$0 + 4 >> 2]);
    break label$1;
   }
   if (HEAP16[$0 + 10 >> 1] == 43) {
    HEAP32[$0 + 12 >> 2] = jsvAsNumberAndUnLock(HEAP32[$0 + 4 >> 2]);
    break label$1;
   }
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = jspePostfixExpression();
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function jsfGetBootCodeFromFlash($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 144 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 139 | 0] = $0;
 jsfNameFromString($1 + 104 | 0, 117304);
 HEAP32[$1 + 64 >> 2] = HEAP32[$1 + 128 >> 2];
 $2 = HEAP32[$1 + 124 >> 2];
 $0 = HEAP32[$1 + 120 >> 2];
 HEAP32[$1 + 56 >> 2] = $0;
 HEAP32[$1 + 60 >> 2] = $2;
 $0 = HEAP32[$1 + 116 >> 2];
 $2 = HEAP32[$1 + 112 >> 2];
 HEAP32[$1 + 48 >> 2] = $2;
 HEAP32[$1 + 52 >> 2] = $0;
 $2 = HEAP32[$1 + 108 >> 2];
 $0 = HEAP32[$1 + 104 >> 2];
 HEAP32[$1 + 40 >> 2] = $0;
 HEAP32[$1 + 44 >> 2] = $2;
 HEAP32[$1 + 132 >> 2] = jsfReadFile($1 + 40 | 0, 0, 0);
 label$1: {
  if (HEAP32[$1 + 132 >> 2] ? 1 : HEAP8[$1 + 139 | 0] & 1) {
   HEAP32[$1 + 140 >> 2] = HEAP32[$1 + 132 >> 2];
   break label$1;
  }
  jsfNameFromString($1 + 72 | 0, 132787);
  HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 96 >> 2];
  $0 = HEAP32[$1 + 92 >> 2];
  $2 = HEAP32[$1 + 88 >> 2];
  HEAP32[$1 + 24 >> 2] = $2;
  HEAP32[$1 + 28 >> 2] = $0;
  $2 = HEAP32[$1 + 84 >> 2];
  $0 = HEAP32[$1 + 80 >> 2];
  HEAP32[$1 + 16 >> 2] = $0;
  HEAP32[$1 + 20 >> 2] = $2;
  $0 = HEAP32[$1 + 76 >> 2];
  $2 = HEAP32[$1 + 72 >> 2];
  HEAP32[$1 + 8 >> 2] = $2;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 140 >> 2] = jsfReadFile($1 + 8 | 0, 0, 0);
 }
 __stack_pointer = $1 + 144 | 0;
 return HEAP32[$1 + 140 >> 2];
}

function jswrap_stream_read($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (!(jsvIsObject(HEAP32[$2 + 24 >> 2]) & 1)) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 24 >> 2], 130086);
  HEAP32[$2 + 12 >> 2] = 0;
  label$3: {
   if (jsvIsString(HEAP32[$2 + 16 >> 2]) & 1) {
    HEAP32[$2 + 8 >> 2] = jsvGetStringLength(HEAP32[$2 + 16 >> 2]);
    label$5: {
     if (!(HEAPU32[$2 + 20 >> 2] < HEAPU32[$2 + 8 >> 2] & HEAP32[$2 + 20 >> 2] > 0)) {
      HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 16 >> 2];
      HEAP32[$2 + 16 >> 2] = 0;
      jsvObjectRemoveChild(HEAP32[$2 + 24 >> 2], 130086);
      break label$5;
     }
     HEAP32[$2 + 12 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 16 >> 2], 0, HEAP32[$2 + 20 >> 2]);
     HEAP32[$2 + 4 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2], 2147483647);
     jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 130086, HEAP32[$2 + 4 >> 2]);
    }
    break label$3;
   }
   HEAP32[$2 + 12 >> 2] = jsvNewFromEmptyString_13();
  }
  jsvUnLock(HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jsvArrayBufferIteratorSetValue($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP8[$3 + 23 | 0] = $2;
 label$1: {
  if (!HEAPU8[HEAP32[$3 + 28 >> 2] + 36 | 0]) {
   break label$1;
  }
  HEAP32[$3 + 4 >> 2] = HEAPU8[HEAP32[$3 + 28 >> 2] + 36 | 0] & 15;
  label$2: {
   if (HEAPU8[HEAP32[$3 + 28 >> 2] + 36 | 0] & 32) {
    jsvArrayBufferIteratorFloatToData($3 + 12 | 0, HEAP32[$3 + 4 >> 2], HEAPU8[HEAP32[$3 + 28 >> 2] + 36 | 0], jsvGetFloat(HEAP32[$3 + 24 >> 2]));
    break label$2;
   }
   jsvArrayBufferIteratorIntToData($3 + 12 | 0, HEAP32[$3 + 4 >> 2], HEAPU8[HEAP32[$3 + 28 >> 2] + 36 | 0], jsvGetInteger(HEAP32[$3 + 24 >> 2]));
  }
  if (HEAP8[$3 + 23 | 0] & 1) {
   reverseBytes($3 + 12 | 0, HEAP32[$3 + 4 >> 2]);
  }
  HEAP32[$3 + 8 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 8 >> 2] < HEAP32[$3 + 4 >> 2]) {
    jsvStringIteratorSetChar(HEAP32[$3 + 28 >> 2], HEAP8[HEAP32[$3 + 8 >> 2] + ($3 + 12 | 0) | 0]);
    if (HEAP32[$3 + 4 >> 2] != 1) {
     jsvStringIteratorNext(HEAP32[$3 + 28 >> 2]);
    }
    HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 8 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[$3 + 4 >> 2] == 1) {
   break label$1;
  }
  HEAP8[HEAP32[$3 + 28 >> 2] + 52 | 0] = 1;
 }
 __stack_pointer = $3 + 32 | 0;
}

function jsspiSend8bit($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP8[$4 + 15 | 0] = $0;
 HEAP8[$4 + 14 | 0] = $1;
 HEAP32[$4 + 8 >> 2] = $2;
 HEAP32[$4 + 4 >> 2] = $3;
 $2 = HEAPU8[$4 + 15 | 0];
 if (HEAPU8[$4 + 14 | 0] >>> 6 & 1) {
  $0 = HEAP32[$4 + 4 >> 2];
 } else {
  $0 = HEAP32[$4 + 8 >> 2];
 }
 if (HEAPU8[$4 + 14 | 0] >>> 7 | 0) {
  $1 = HEAP32[$4 + 4 >> 2];
 } else {
  $1 = HEAP32[$4 + 8 >> 2];
 }
 jshSPISend($2, $0 | $1 << 8);
 $2 = HEAPU8[$4 + 15 | 0];
 if (HEAPU8[$4 + 14 | 0] >>> 4 & 1) {
  $0 = HEAP32[$4 + 4 >> 2];
 } else {
  $0 = HEAP32[$4 + 8 >> 2];
 }
 if (HEAPU8[$4 + 14 | 0] >>> 5 & 1) {
  $1 = HEAP32[$4 + 4 >> 2];
 } else {
  $1 = HEAP32[$4 + 8 >> 2];
 }
 jshSPISend($2, $0 | $1 << 8);
 $2 = HEAPU8[$4 + 15 | 0];
 if (HEAPU8[$4 + 14 | 0] >>> 2 & 1) {
  $0 = HEAP32[$4 + 4 >> 2];
 } else {
  $0 = HEAP32[$4 + 8 >> 2];
 }
 if (HEAPU8[$4 + 14 | 0] >>> 3 & 1) {
  $1 = HEAP32[$4 + 4 >> 2];
 } else {
  $1 = HEAP32[$4 + 8 >> 2];
 }
 jshSPISend($2, $0 | $1 << 8);
 $2 = HEAPU8[$4 + 15 | 0];
 if (HEAP8[$4 + 14 | 0] & 1) {
  $0 = HEAP32[$4 + 4 >> 2];
 } else {
  $0 = HEAP32[$4 + 8 >> 2];
 }
 if (HEAPU8[$4 + 14 | 0] >>> 1 & 1) {
  $1 = HEAP32[$4 + 4 >> 2];
 } else {
  $1 = HEAP32[$4 + 8 >> 2];
 }
 jshSPISend($2, $0 | $1 << 8);
 __stack_pointer = $4 + 16 | 0;
}

function jsiAppendStringToInputLine($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsiIsAboutToEditInputLine();
 HEAP32[$1 + 8 >> 2] = 1;
 while (1) {
  if (HEAPU8[HEAP32[$1 + 12 >> 2] + HEAP32[$1 + 8 >> 2] | 0]) {
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 label$3: {
  if (HEAP32[91106] >= HEAP32[48917]) {
   HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 12 >> 2];
   while (1) {
    if (HEAPU8[HEAP32[$1 + 4 >> 2]]) {
     $0 = HEAP32[$1 + 4 >> 2];
     HEAP32[$1 + 4 >> 2] = $0 + 1;
     jsiAppendToInputLine(HEAP8[$0 | 0]);
     continue;
    }
    break;
   }
   break label$3;
  }
  HEAP32[$1 >> 2] = jsvNewFromEmptyString_5();
  if (HEAP32[91106]) {
   jsvAppendStringVar(HEAP32[$1 >> 2], HEAP32[91104], 0, HEAP32[91106]);
  }
  jsvAppendString(HEAP32[$1 >> 2], HEAP32[$1 + 12 >> 2]);
  jsvAppendStringVar(HEAP32[$1 >> 2], HEAP32[91104], HEAP32[91106], 2147483647);
  jsiInputLineCursorMoved();
  jsvUnLock(HEAP32[91104]);
  HEAP32[91104] = HEAP32[$1 >> 2];
  if (jsiShowInputLine() & 1) {
   jsiConsolePrintStringVarUntilEOL(HEAP32[91104], HEAP32[91106], -1, 1);
  }
 }
 HEAP32[91106] = HEAP32[$1 + 8 >> 2] + HEAP32[91106];
 if (jsiShowInputLine() & 1) {
  jsiConsolePrintString(HEAP32[$1 + 12 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_promise_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 40 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 40 >> 2]) {
   jsExceptionHere(1, 120826, 0);
   HEAP32[$1 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 32 >> 2] = jspromise_create_prombox($1 + 36 | 0);
  if (!HEAP32[$1 + 32 >> 2]) {
   HEAP32[$1 + 44 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$1 + 36 >> 2]) {
   HEAP32[$1 + 28 >> 2] = _jswrap_promise_native_with_prombox(652, HEAP32[$1 + 32 >> 2]);
   HEAP32[$1 + 24 >> 2] = _jswrap_promise_native_with_prombox(653, HEAP32[$1 + 32 >> 2]);
   HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 28 >> 2];
   HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 24 >> 2];
   HEAP32[$1 + 12 >> 2] = HEAP32[91094];
   jsvUnLock(jspeFunctionCall(HEAP32[$1 + 40 >> 2], 0, HEAP32[$1 + 36 >> 2], 0, 2, $1 + 16 | 0));
   HEAP32[91094] = HEAP32[$1 + 12 >> 2];
   HEAP32[$1 + 8 >> 2] = jspGetException();
   if (HEAP32[$1 + 8 >> 2]) {
    _jswrap_prombox_queuereject(HEAP32[$1 + 32 >> 2], HEAP32[$1 + 8 >> 2]);
    jsvUnLock(HEAP32[$1 + 8 >> 2]);
   }
   jsvUnLock2(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 24 >> 2]);
  }
  jsvUnLock(HEAP32[$1 + 32 >> 2]);
  HEAP32[$1 + 44 >> 2] = jsvLockAgain(HEAP32[$1 + 36 >> 2]);
 }
 __stack_pointer = $1 + 48 | 0;
 return HEAP32[$1 + 44 >> 2];
}

function _jswrap_graphics_getVectorFontPolys_cb($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 28 >> 2];
 label$1: {
  if (!HEAP32[$3 + 16 >> 2]) {
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 12 >> 2] < HEAP32[$3 + 24 >> 2] << 1) {
    HEAP16[HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 12 >> 2] << 1) >> 1] = HEAP16[HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 12 >> 2] << 1) >> 1] + 8 << 16 >> 20;
    HEAP16[HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 12 >> 2] + 1 << 1) >> 1] = HEAP16[HEAP32[$3 + 20 >> 2] + (HEAP32[$3 + 12 >> 2] + 1 << 1) >> 1] + 8 << 16 >> 20;
    HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 2;
    continue;
   }
   break;
  }
  HEAP32[$3 + 8 >> 2] = jsvNewTypedArray(18, HEAP32[$3 + 24 >> 2] << 1);
  if (!HEAP32[$3 + 8 >> 2]) {
   break label$1;
  }
  HEAP32[$3 + 4 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$3 + 8 >> 2], 0);
  if (HEAP32[$3 + 4 >> 2]) {
   jsvSetString(HEAP32[$3 + 4 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 24 >> 2] << 2);
   jsvUnLock(HEAP32[$3 + 4 >> 2]);
  }
  jsvArrayPushAndUnLock(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 8 >> 2]);
 }
 __stack_pointer = $3 + 32 | 0;
}

function tflite__ReverseSortInPlace_28int__2c_20int__2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 while (1) {
  HEAP8[$3 + 19 | 0] = 0;
  HEAP32[$3 + 12 >> 2] = 1;
  while (1) {
   if (HEAP32[$3 + 12 >> 2] < HEAP32[$3 + 20 >> 2]) {
    if (HEAP32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 12 >> 2] - 1 << 2) >> 2] < HEAP32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) >> 2]) {
     HEAP32[$3 + 8 >> 2] = HEAP32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 12 >> 2] - 1 << 2) >> 2];
     HEAP32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 12 >> 2] - 1 << 2) >> 2] = HEAP32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) >> 2];
     HEAP32[HEAP32[$3 + 28 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) >> 2] = HEAP32[$3 + 8 >> 2];
     HEAP32[$3 + 4 >> 2] = HEAP32[HEAP32[$3 + 24 >> 2] + (HEAP32[$3 + 12 >> 2] - 1 << 2) >> 2];
     HEAP32[HEAP32[$3 + 24 >> 2] + (HEAP32[$3 + 12 >> 2] - 1 << 2) >> 2] = HEAP32[HEAP32[$3 + 24 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) >> 2];
     HEAP32[HEAP32[$3 + 24 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) >> 2] = HEAP32[$3 + 4 >> 2];
     HEAP8[$3 + 19 | 0] = 1;
    }
    HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP8[$3 + 19 | 0] & 1) {
   continue;
  }
  break;
 }
}

function jsvGetIndexFromLineAndCol($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 80 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 72 >> 2] = $0;
 HEAP32[$3 + 68 >> 2] = $1;
 HEAP32[$3 + 64 >> 2] = $2;
 HEAP32[$3 + 60 >> 2] = 1;
 HEAP32[$3 + 56 >> 2] = 1;
 HEAP32[$3 + 52 >> 2] = 0;
 jsvStringIteratorNew($3 + 16 | 0, HEAP32[$3 + 72 >> 2], 0);
 label$1: {
  while (1) {
   if (jsvStringIteratorHasChar_1($3 + 16 | 0) & 1) {
    HEAP8[$3 + 15 | 0] = jsvStringIteratorGetCharAndNext($3 + 16 | 0);
    if (!(!(HEAP32[$3 + 56 >> 2] == HEAP32[$3 + 68 >> 2] & HEAPU32[$3 + 60 >> 2] >= HEAPU32[$3 + 64 >> 2]) & HEAPU32[$3 + 56 >> 2] <= HEAPU32[$3 + 68 >> 2])) {
     jsvStringIteratorFree_1($3 + 16 | 0);
     if (HEAPU32[$3 + 56 >> 2] > HEAPU32[$3 + 68 >> 2]) {
      $0 = HEAP32[$3 + 52 >> 2] - 1 | 0;
     } else {
      $0 = HEAP32[$3 + 52 >> 2];
     }
     HEAP32[$3 + 76 >> 2] = $0;
     break label$1;
    }
    HEAP32[$3 + 60 >> 2] = HEAP32[$3 + 60 >> 2] + 1;
    if (HEAP8[$3 + 15 | 0] == 10) {
     HEAP32[$3 + 60 >> 2] = 1;
     HEAP32[$3 + 56 >> 2] = HEAP32[$3 + 56 >> 2] + 1;
    }
    HEAP32[$3 + 52 >> 2] = HEAP32[$3 + 52 >> 2] + 1;
    continue;
   }
   break;
  }
  jsvStringIteratorFree_1($3 + 16 | 0);
  HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 52 >> 2];
 }
 __stack_pointer = $3 + 80 | 0;
 return HEAP32[$3 + 76 >> 2];
}

function jstUtilTimerSetupBuffer($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 $0 = _jsvGetAddressOf(HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
 $2 = HEAP32[$1 + 12 >> 2];
 HEAP8[$2 + 8 | 0] = $0;
 HEAP8[$2 + 9 | 0] = $0 >>> 8;
 HEAP8[$2 + 10 | 0] = $0 >>> 16;
 HEAP8[$2 + 11 | 0] = $0 >>> 24;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1: {
  if (jsvIsFlatString(HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 1) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP8[$0 + 18 | 0] = 14;
   HEAP8[$0 + 19 | 0] = 0;
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = jsvGetCharactersInVar(HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24));
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = $2 + 14 | 0;
   HEAP8[$0 + 20 | 0] = $2;
   HEAP8[$0 + 21 | 0] = $2 >>> 8;
   break label$1;
  }
  $0 = HEAP32[$1 + 12 >> 2];
  HEAP8[$0 + 18 | 0] = 0;
  HEAP8[$0 + 19 | 0] = 0;
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = jsvGetCharactersInVar(HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24));
  $2 = HEAP32[$1 + 12 >> 2];
  HEAP8[$2 + 20 | 0] = $0;
  HEAP8[$2 + 21 | 0] = $0 >>> 8;
 }
 __stack_pointer = $1 + 16 | 0;
}

function tflite__MicroAllocator__AllocatePersistentTfLiteTensor_28tflite__Model_20const__2c_20TfLiteEvalTensor__2c_20int_29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 $0 = HEAP32[$4 + 24 >> 2];
 HEAP32[$4 + 8 >> 2] = tflite__MicroAllocator__GetSubGraphFromModel_28tflite__Model_20const__29($0, HEAP32[$4 + 20 >> 2]);
 label$1: {
  if (!HEAP32[$4 + 8 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$4 + 4 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 36 >> 2]]($0, HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[$4 + 12 >> 2]);
 label$2: {
  if (FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 40 >> 2]]($0, HEAP32[$4 + 20 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 + 12 >> 2], 0) | 0) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 8 >> 2], 145870, 0);
   HEAP32[$4 + 28 >> 2] = 0;
   break label$2;
  }
  if (HEAP32[$4 + 16 >> 2]) {
   HEAP32[HEAP32[$4 + 4 >> 2] + 16 >> 2] = HEAP32[HEAP32[$4 + 16 >> 2] + Math_imul(HEAP32[$4 + 12 >> 2], 12) >> 2];
  }
  HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 4 >> 2];
 }
 __stack_pointer = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}

function jswGetBasicObjectPrototypeName($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!strcmp(HEAP32[$1 + 8 >> 2], 116290)) {
   HEAP32[$1 + 12 >> 2] = 116752;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 116272)) {
   HEAP32[$1 + 12 >> 2] = 116752;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 116301)) {
   HEAP32[$1 + 12 >> 2] = 116752;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 116311)) {
   HEAP32[$1 + 12 >> 2] = 116752;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 116323)) {
   HEAP32[$1 + 12 >> 2] = 116752;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 116347)) {
   HEAP32[$1 + 12 >> 2] = 116752;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 116359)) {
   HEAP32[$1 + 12 >> 2] = 116752;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 116371)) {
   HEAP32[$1 + 12 >> 2] = 116752;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 116382)) {
   HEAP32[$1 + 12 >> 2] = 116752;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 116334)) {
   HEAP32[$1 + 12 >> 2] = 116752;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = strcmp(HEAP32[$1 + 8 >> 2], 117903) ? 117903 : 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvGetStringLength($0) {
 var $1 = 0;
 $1 = __stack_pointer + -64 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 HEAP32[$1 + 52 >> 2] = 0;
 label$1: {
  if (jsvIsUTF8String(HEAP32[$1 + 56 >> 2]) & 1) {
   jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 56 >> 2], 0);
   while (1) {
    if (jsvStringIteratorHasChar_1($1 + 16 | 0) & 1) {
     jsvStringIteratorNextUTF8($1 + 16 | 0);
     HEAP32[$1 + 52 >> 2] = HEAP32[$1 + 52 >> 2] + 1;
     continue;
    }
    break;
   }
   jsvStringIteratorFree_1($1 + 16 | 0);
   HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 52 >> 2];
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 56 >> 2];
  HEAP32[$1 + 8 >> 2] = 0;
  if (!(jsvHasCharacterData(HEAP32[$1 + 56 >> 2]) & 1)) {
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  while (1) {
   if (HEAP32[$1 + 12 >> 2]) {
    HEAP16[$1 + 6 >> 1] = jsvGetLastChild(HEAP32[$1 + 12 >> 2]);
    HEAP32[$1 + 52 >> 2] = jsvGetCharactersInVar(HEAP32[$1 + 12 >> 2]) + HEAP32[$1 + 52 >> 2];
    jsvUnLock(HEAP32[$1 + 8 >> 2]);
    $0 = jsvLockSafe(HEAPU16[$1 + 6 >> 1]);
    HEAP32[$1 + 8 >> 2] = $0;
    HEAP32[$1 + 12 >> 2] = $0;
    continue;
   }
   break;
  }
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
  HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 52 >> 2];
 }
 __stack_pointer = $1 - -64 | 0;
 return HEAP32[$1 + 60 >> 2];
}

function getTimeFromMilliSeconds($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAPF64[$3 + 24 >> 3] = $1;
 HEAP8[$3 + 23 | 0] = $2;
 if (HEAP8[$3 + 23 | 0] & 1) {
  $2 = 0;
 } else {
  $2 = jsdGetEffectiveTimeZone(HEAPF64[$3 + 24 >> 3], 0, $0 + 24 | 0);
 }
 HEAP32[$0 + 20 >> 2] = $2;
 HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 24 >> 3] + +(Math_imul(HEAP32[$0 + 20 >> 2], 6e4) | 0);
 $1 = HEAPF64[$3 + 24 >> 3] / 864e5;
 label$3: {
  if (Math_abs($1) < 2147483648) {
   $2 = ~~$1;
   break label$3;
  }
  $2 = -2147483648;
 }
 HEAP32[$0 >> 2] = $2;
 if (HEAP8[$3 + 23 | 0] & 1) {
  HEAP8[$0 + 24 | 0] = 0;
 }
 $1 = +HEAP32[$0 >> 2] * -864e5 + HEAPF64[$3 + 24 >> 3];
 label$6: {
  if (Math_abs($1) < 2147483648) {
   $2 = ~~$1;
   break label$6;
  }
  $2 = -2147483648;
 }
 HEAP32[$3 + 16 >> 2] = $2;
 if (HEAP32[$3 + 16 >> 2] < 0) {
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 864e5;
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - 1;
 }
 HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 16 >> 2] / 1e3;
 HEAP32[$0 + 4 >> 2] = HEAP32[$3 + 16 >> 2] % 1e3;
 HEAP32[$0 + 16 >> 2] = HEAP32[$3 + 12 >> 2] / 3600;
 HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] % 3600;
 HEAP32[$0 + 12 >> 2] = HEAP32[$3 + 12 >> 2] / 60;
 HEAP32[$0 + 8 >> 2] = HEAP32[$3 + 12 >> 2] % 60;
 __stack_pointer = $3 + 32 | 0;
}

function jsvGetCommonCharacters($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 112 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 104 >> 2] = $0;
 HEAP32[$2 + 100 >> 2] = $1;
 HEAP32[$2 + 96 >> 2] = jsvNewFromEmptyString_1();
 label$1: {
  if (!HEAP32[$2 + 96 >> 2]) {
   HEAP32[$2 + 108 >> 2] = 0;
   break label$1;
  }
  jsvStringIteratorNewUTF8($2 + 56 | 0, HEAP32[$2 + 104 >> 2], 0);
  jsvStringIteratorNewUTF8($2 + 16 | 0, HEAP32[$2 + 100 >> 2], 0);
  HEAP32[$2 + 12 >> 2] = jsvStringIteratorGetUTF8CharAndNext($2 + 56 | 0);
  HEAP32[$2 + 8 >> 2] = jsvStringIteratorGetUTF8CharAndNext($2 + 16 | 0);
  while (1) {
   $0 = 0;
   label$4: {
    if (HEAP32[$2 + 12 >> 2] <= 0) {
     break label$4;
    }
    $0 = 0;
    if (HEAP32[$2 + 8 >> 2] <= 0) {
     break label$4;
    }
    $0 = HEAP32[$2 + 12 >> 2] == HEAP32[$2 + 8 >> 2];
   }
   if ($0) {
    jsvAppendCharacter(HEAP32[$2 + 96 >> 2], HEAP32[$2 + 12 >> 2] << 24 >> 24);
    HEAP32[$2 + 12 >> 2] = jsvStringIteratorGetUTF8CharAndNext($2 + 56 | 0);
    HEAP32[$2 + 8 >> 2] = jsvStringIteratorGetUTF8CharAndNext($2 + 16 | 0);
    continue;
   }
   break;
  }
  jsvStringIteratorFree_1($2 + 56 | 0);
  jsvStringIteratorFree_1($2 + 16 | 0);
  HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 96 >> 2];
 }
 __stack_pointer = $2 + 112 | 0;
 return HEAP32[$2 + 108 >> 2];
}

function tflite__reference_ops__DepthwiseConv_28tflite__DepthwiseParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0;
 $9 = __stack_pointer - 48 | 0;
 __stack_pointer = $9;
 HEAP32[$9 + 44 >> 2] = $0;
 HEAP32[$9 + 40 >> 2] = $1;
 HEAP32[$9 + 36 >> 2] = $2;
 HEAP32[$9 + 32 >> 2] = $3;
 HEAP32[$9 + 28 >> 2] = $4;
 HEAP32[$9 + 24 >> 2] = $5;
 HEAP32[$9 + 20 >> 2] = $6;
 HEAP32[$9 + 16 >> 2] = $7;
 HEAP32[$9 + 12 >> 2] = $8;
 tflite__reference_ops__depthwise_conv__DepthwiseConvBasicKernel__28tflite__DepthwiseConvOutputRounding_291___Run_28tflite__DepthwiseParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20int_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char__29(HEAP32[$9 + 44 >> 2], HEAP32[$9 + 40 >> 2], HEAP32[$9 + 36 >> 2], HEAP32[$9 + 32 >> 2], HEAP32[$9 + 28 >> 2], HEAP32[$9 + 24 >> 2], HEAP32[$9 + 20 >> 2], HEAP32[$9 + 16 >> 2], HEAP32[$9 + 12 >> 2]);
 __stack_pointer = $9 + 48 | 0;
}

function std____2__vector_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29_____vector_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$1 + 8 >> 2] = 0;
 std____2____compressed_pair_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29___2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29_______compressed_pair_std__nullptr_t_2c_20std____2____default_init_tag__28std__nullptr_t___2c_20std____2____default_init_tag___29($0 + 8 | 0, $1 + 8 | 0, $1);
 void_20std____2____debug_db_insert_c_std____2__vector_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29_____28std____2__vector_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29_____29($0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_object_getOwnPropertyDescriptors($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 40 >> 2] = $0;
 label$1: {
  if (!(jsvHasChildren(HEAP32[$1 + 40 >> 2]) & 1)) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 40 >> 2];
   jsExceptionHere(3, 118483, $1);
   HEAP32[$1 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 36 >> 2] = jsvNewObject();
  if (!HEAP32[$1 + 36 >> 2]) {
   HEAP32[$1 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 32 >> 2] = jswrap_object_keys_or_property_names(HEAP32[$1 + 40 >> 2], 1);
  jsvObjectIteratorNew($1 + 24 | 0, HEAP32[$1 + 32 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_9($1 + 24 | 0) & 1) {
    HEAP32[$1 + 20 >> 2] = jsvObjectIteratorGetValue_9($1 + 24 | 0);
    HEAP32[$1 + 16 >> 2] = jswrap_object_getOwnPropertyDescriptor(HEAP32[$1 + 40 >> 2], HEAP32[$1 + 20 >> 2]);
    jsvObjectSetChildVar(HEAP32[$1 + 36 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2]);
    jsvUnLock2(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2]);
    jsvObjectIteratorNext($1 + 24 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_9($1 + 24 | 0);
  jsvUnLock(HEAP32[$1 + 32 >> 2]);
  HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 36 >> 2];
 }
 __stack_pointer = $1 + 48 | 0;
 return HEAP32[$1 + 44 >> 2];
}

function jsiSetConsoleDevice($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 47 | 0] = $0;
 HEAP8[$2 + 46 | 0] = $1;
 label$1: {
  if (HEAP8[$2 + 46 | 0] & 1) {
   HEAP16[182206] = HEAPU16[182206] | 256;
   break label$1;
  }
  HEAP16[182206] = HEAPU16[182206] & -257;
 }
 label$3: {
  if (HEAPU8[$2 + 47 | 0] == HEAPU8[195664]) {
   break label$3;
  }
  label$4: {
   if (HEAPU8[$2 + 47 | 0] < 22 | HEAPU8[$2 + 47 | 0] > 22) {
    break label$4;
   }
   if (jshIsDeviceInitialised(HEAPU8[$2 + 47 | 0]) & 1) {
    break label$4;
   }
   jshUSARTInitInfo($2 + 32 | 0);
   jshUSARTSetup(HEAPU8[$2 + 47 | 0], $2 + 32 | 0);
  }
  HEAP8[$2 + 31 | 0] = jsiEcho() & 1;
  if (HEAPU8[195664] == 19) {
   HEAP8[$2 + 31 | 0] = 0;
   jshTransmitMove(19, HEAPU8[$2 + 47 | 0]);
   jshUSARTKick(HEAPU8[$2 + 47 | 0]);
  }
  if (HEAP8[$2 + 31 | 0] & 1) {
   jsiConsoleRemoveInputLine();
   HEAP32[$2 + 16 >> 2] = jshGetDeviceString(HEAPU8[$2 + 47 | 0]);
   jsiConsolePrintf(146635, $2 + 16 | 0);
  }
  HEAP8[$2 + 30 | 0] = HEAPU8[195664];
  HEAP8[195664] = HEAPU8[$2 + 47 | 0];
  if (!(HEAP8[$2 + 31 | 0] & 1)) {
   break label$3;
  }
  HEAP32[$2 >> 2] = jshGetDeviceString(HEAPU8[$2 + 30 | 0]);
  jsiConsolePrintf(146642, $2);
 }
 __stack_pointer = $2 + 48 | 0;
}

function graphicsVectorCharWidth($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP8[$2 + 39 | 0] = $1;
 HEAP32[$2 + 28 >> 2] = vfGetCharPtr(HEAP8[$2 + 39 | 0], $2 + 32 | 0);
 label$1: {
  if (!HEAP32[$2 + 28 >> 2]) {
   HEAP32[$2 + 44 >> 2] = HEAP32[$2 + 40 >> 2] >>> 1;
   break label$1;
  }
  HEAP32[$2 + 24 >> 2] = 0;
  HEAP32[$2 + 20 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 20 >> 2] < HEAP32[$2 + 32 >> 2]) {
    HEAP32[$2 + 12 >> 2] = vfGetPolyPtr(HEAPU8[HEAP32[$2 + 28 >> 2] + HEAP32[$2 + 20 >> 2] | 0], $2 + 16 | 0);
    HEAP32[$2 + 8 >> 2] = 0;
    while (1) {
     if (HEAP32[$2 + 8 >> 2] < HEAP32[$2 + 16 >> 2]) {
      HEAP8[$2 + 7 | 0] = HEAPU8[HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 8 >> 2] | 0];
      HEAP32[$2 >> 2] = HEAPU8[$2 + 7 | 0] % 13;
      if (HEAP32[$2 >> 2] > HEAP32[$2 + 24 >> 2]) {
       HEAP32[$2 + 24 >> 2] = HEAP32[$2 >> 2];
      }
      HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] + 1;
      continue;
     }
     break;
    }
    HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$2 + 44 >> 2] = (Math_imul(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 24 >> 2] + 2 | 0) << 4 >>> 4 | 0) + 7 >>> 4;
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function jswrap_graphics_drawLineAA($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = +$2;
 $3 = +$3;
 $4 = +$4;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = __stack_pointer - 112 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 104 >> 2] = $0;
 HEAPF64[$5 + 96 >> 3] = $1;
 HEAPF64[$5 + 88 >> 3] = $2;
 HEAPF64[$5 + 80 >> 3] = $3;
 HEAPF64[$5 + 72 >> 3] = $4;
 label$1: {
  if (!(graphicsGetFromVar($5, HEAP32[$5 + 104 >> 2]) & 1)) {
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  $1 = HEAPF64[$5 + 96 >> 3] * 16 + .5;
  label$3: {
   if (Math_abs($1) < 2147483648) {
    $6 = ~~$1;
    break label$3;
   }
   $6 = -2147483648;
  }
  $1 = HEAPF64[$5 + 88 >> 3] * 16 + .5;
  label$5: {
   if (Math_abs($1) < 2147483648) {
    $7 = ~~$1;
    break label$5;
   }
   $7 = -2147483648;
  }
  $1 = HEAPF64[$5 + 80 >> 3] * 16 + .5;
  label$7: {
   if (Math_abs($1) < 2147483648) {
    $0 = ~~$1;
    break label$7;
   }
   $0 = -2147483648;
  }
  $1 = HEAPF64[$5 + 72 >> 3] * 16 + .5;
  label$9: {
   if (Math_abs($1) < 2147483648) {
    $8 = ~~$1;
    break label$9;
   }
   $8 = -2147483648;
  }
  graphicsDrawLineAA($5, $6, $7, $0, $8);
  graphicsSetVar($5);
  HEAP32[$5 + 108 >> 2] = jsvLockAgain(HEAP32[$5 + 104 >> 2]);
 }
 __stack_pointer = $5 + 112 | 0;
 return HEAP32[$5 + 108 >> 2];
}

function tflite__MicroAllocator__AllocateTempTfLiteTensor_28tflite__Model_20const__2c_20TfLiteEvalTensor__2c_20int_29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 $0 = HEAP32[$4 + 24 >> 2];
 HEAP32[$4 + 8 >> 2] = tflite__MicroAllocator__GetSubGraphFromModel_28tflite__Model_20const__29($0, HEAP32[$4 + 20 >> 2]);
 label$1: {
  if (!HEAP32[$4 + 8 >> 2]) {
   break label$1;
  }
 }
 $1 = HEAP32[$0 + 4 >> 2];
 HEAP32[$4 + 4 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$1 >> 2] + 16 >> 2]]($1, 40, 4);
 label$2: {
  if (FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 40 >> 2]]($0, HEAP32[$4 + 20 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 + 12 >> 2], 1) | 0) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 8 >> 2], 145944, 0);
   HEAP32[$4 + 28 >> 2] = 0;
   break label$2;
  }
  if (HEAP32[$4 + 16 >> 2]) {
   HEAP32[HEAP32[$4 + 4 >> 2] + 16 >> 2] = HEAP32[HEAP32[$4 + 16 >> 2] + Math_imul(HEAP32[$4 + 12 >> 2], 12) >> 2];
  }
  HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 4 >> 2];
 }
 __stack_pointer = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}

function jsiCountBracketsInInput() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 144 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 140 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = jslSetLex($0 + 16 | 0);
 jslInit(HEAP32[91104]);
 while (1) {
  label$2: {
   $1 = 0;
   label$3: {
    if (!HEAP16[$0 + 18 >> 1]) {
     break label$3;
    }
    $1 = 0;
    if (HEAP16[$0 + 18 >> 1] == 137) {
     break label$3;
    }
    $1 = 0;
    if (HEAP16[$0 + 18 >> 1] == 132) {
     break label$3;
    }
    $1 = HEAP16[$0 + 18 >> 1] != 134;
   }
   if (!$1) {
    break label$2;
   }
   if (!(!(HEAP16[$0 + 18 >> 1] == 123 | HEAP16[$0 + 18 >> 1] == 91) & HEAP16[$0 + 18 >> 1] != 40)) {
    HEAP32[$0 + 140 >> 2] = HEAP32[$0 + 140 >> 2] + 1;
   }
   if (!(!(HEAP16[$0 + 18 >> 1] == 125 | HEAP16[$0 + 18 >> 1] == 93) & HEAP16[$0 + 18 >> 1] != 41)) {
    HEAP32[$0 + 140 >> 2] = HEAP32[$0 + 140 >> 2] - 1;
   }
   if (HEAP32[$0 + 140 >> 2] < 0) {
    break label$2;
   }
   jslGetNextToken();
   continue;
  }
  break;
 }
 if (HEAP16[$0 + 18 >> 1] == 132) {
  HEAP32[$0 + 140 >> 2] = 0;
 }
 if (!(HEAP16[$0 + 18 >> 1] != 137 & HEAP16[$0 + 18 >> 1] != 134)) {
  HEAP32[$0 + 140 >> 2] = 1e3;
 }
 jslKill();
 jslSetLex(HEAP32[$0 + 12 >> 2]);
 __stack_pointer = $0 + 144 | 0;
 return HEAP32[$0 + 140 >> 2];
}

function jswrap_espruino_setConsole($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 112 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 108 >> 2] = $0;
 HEAP32[$2 + 104 >> 2] = $1;
 HEAP8[$2 + 103 | 0] = 0;
 HEAP32[$2 + 88 >> 2] = 132803;
 HEAP16[$2 + 92 >> 1] = 12;
 HEAP32[$2 + 96 >> 2] = $2 + 103;
 label$1: {
  if (!(jsvReadConfigObject(HEAP32[$2 + 104 >> 2], $2 + 88 | 0, 1) & 1)) {
   break label$1;
  }
  HEAP8[$2 + 87 | 0] = 0;
  label$2: {
   if (jsvIsObject(HEAP32[$2 + 108 >> 2]) & 1) {
    HEAP8[$2 + 87 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 108 >> 2]);
    break label$2;
   }
   if (jsvIsString(HEAP32[$2 + 108 >> 2]) & 1) {
    jsvGetString(HEAP32[$2 + 108 >> 2], $2 + 16 | 0, 64);
    HEAP8[$2 + 87 | 0] = jshFromDeviceString($2 + 16 | 0);
   }
  }
  label$5: {
   if (HEAPU8[$2 + 87 | 0]) {
    break label$5;
   }
   if (jsvIsNull(HEAP32[$2 + 108 >> 2]) & 1) {
    break label$5;
   }
   HEAP32[$2 >> 2] = HEAPU8[$2 + 87 | 0];
   jsExceptionHere(1, 121558, $2);
   break label$1;
  }
  if (!(!HEAPU8[$2 + 87 | 0] | HEAPU8[$2 + 87 | 0] <= 22 & HEAPU8[$2 + 87 | 0] >= 17)) {
   jsExceptionHere(1, 120342, 0);
   break label$1;
  }
  jsiSetConsoleDevice(HEAPU8[$2 + 87 | 0], HEAP8[$2 + 103 | 0] & 1);
 }
 __stack_pointer = $2 + 112 | 0;
}

function tflite__MicroAllocator__FinishModelAllocation_28tflite__Model_20const__2c_20TfLiteEvalTensor__29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 $0 = HEAP32[$3 + 24 >> 2];
 label$1: {
  if (!(HEAP8[$0 + 12 | 0] & 1)) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 8 >> 2], 128827, 0);
   HEAP32[$3 + 28 >> 2] = 1;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = tflite__MicroAllocator__GetSubGraphFromModel_28tflite__Model_20const__29($0, HEAP32[$3 + 20 >> 2]);
  label$3: {
   if (!HEAP32[$3 + 12 >> 2]) {
    break label$3;
   }
  }
  HEAP32[$3 + 8 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 44 >> 2]]($0, HEAP32[$3 + 20 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2]);
  if (HEAP32[$3 + 8 >> 2]) {
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 8 >> 2];
   break label$1;
  }
  HEAP32[$3 + 4 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 32 >> 2]]($0, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2]);
  if (HEAP32[$3 + 4 >> 2]) {
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 4 >> 2];
   break label$1;
  }
  HEAP8[$0 + 12 | 0] = 0;
  HEAP32[$3 + 28 >> 2] = 0;
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jsvMathsOpTypeEqual($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP8[$2 + 7 | 0] = (!HEAP32[$2 + 12 >> 2] | 0) == (!HEAP32[$2 + 8 >> 2] | 0);
 if (!(!HEAP32[$2 + 12 >> 2] | !HEAP32[$2 + 8 >> 2])) {
  label$2: {
   label$3: {
    if (!(jsvIsInt(HEAP32[$2 + 12 >> 2]) & 1)) {
     if (!(jsvIsFloat(HEAP32[$2 + 12 >> 2]) & 1)) {
      break label$3;
     }
    }
    $0 = 1;
    if (jsvIsInt(HEAP32[$2 + 8 >> 2]) & 1) {
     break label$2;
    }
    $0 = 1;
    if (jsvIsFloat(HEAP32[$2 + 8 >> 2]) & 1) {
     break label$2;
    }
   }
   if (jsvIsString(HEAP32[$2 + 12 >> 2]) & 1) {
    $0 = 1;
    if (jsvIsString(HEAP32[$2 + 8 >> 2]) & 1) {
     break label$2;
    }
   }
   $0 = HEAP32[$2 + 12 >> 2];
   $1 = HEAP32[$2 + 8 >> 2];
   $0 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63);
  }
  HEAP8[$2 + 7 | 0] = $0;
 }
 if (HEAP8[$2 + 7 | 0] & 1) {
  HEAP32[$2 >> 2] = jsvMathsOp(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 138);
  if (!(jsvGetBool(HEAP32[$2 >> 2]) & 1)) {
   HEAP8[$2 + 7 | 0] = 0;
  }
  jsvUnLock(HEAP32[$2 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP8[$2 + 7 | 0] & 1;
}

function jsiTabComplete_printCommon($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 28 >> 2];
 label$1: {
  if (jsvGetStringLength(HEAP32[$2 + 24 >> 2]) >>> 0 <= HEAPU32[HEAP32[$2 + 20 >> 2] >> 2]) {
   break label$1;
  }
  if (jsvCompareString(HEAP32[HEAP32[$2 + 20 >> 2] + 4 >> 2], HEAP32[$2 + 24 >> 2], 0, 0, 1)) {
   break label$1;
  }
  label$2: {
   if (!HEAP32[HEAP32[$2 + 20 >> 2] + 16 >> 2]) {
    HEAP32[$2 >> 2] = HEAP32[$2 + 24 >> 2];
    jsiConsolePrintf(116903, $2);
    $0 = jsvGetStringLength(HEAP32[$2 + 24 >> 2]);
    HEAP32[HEAP32[$2 + 20 >> 2] + 16 >> 2] = $0;
    break label$2;
   }
   if (HEAPU32[HEAP32[$2 + 20 >> 2] + 16 >> 2] >= 20) {
    HEAP32[HEAP32[$2 + 20 >> 2] + 16 >> 2] = 19;
   }
   while (1) {
    if (HEAPU32[HEAP32[$2 + 20 >> 2] + 16 >> 2] < 20) {
     jsiConsolePrintChar(32);
     $0 = HEAP32[$2 + 20 >> 2];
     HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 24 >> 2];
   jsiConsolePrintf(146531, $2 + 16 | 0);
   HEAP32[HEAP32[$2 + 20 >> 2] + 16 >> 2] = 0;
  }
 }
 __stack_pointer = $2 + 32 | 0;
}

function jsiExtractIOEventData($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 60 >> 2] = $0;
 HEAP32[$2 + 56 >> 2] = $1;
 HEAP32[HEAP32[$2 + 56 >> 2] >> 2] = 0;
 HEAP32[$2 + 52 >> 2] = jsvNewFromEmptyString_5();
 if (HEAP32[$2 + 52 >> 2]) {
  jsvStringIteratorNew($2 + 16 | 0, HEAP32[$2 + 52 >> 2], 0);
  HEAP32[$2 + 8 >> 2] = ((HEAPU8[HEAP32[$2 + 60 >> 2]] & 96) >>> 5 | 0) + 1;
  while (1) {
   if (HEAP32[$2 + 8 >> 2]) {
    HEAP32[$2 + 12 >> 2] = 0;
    while (1) {
     if (HEAP32[$2 + 12 >> 2] < HEAP32[$2 + 8 >> 2]) {
      jsvStringIteratorAppend($2 + 16 | 0, HEAP8[HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 60 >> 2] + 1 | 0) | 0]);
      HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
      continue;
     }
     break;
    }
    label$6: {
     if (jshIsTopEvent(HEAPU8[HEAP32[$2 + 60 >> 2]] & 31) & 1) {
      jshPopIOEvent(HEAP32[$2 + 60 >> 2]);
      $0 = HEAP32[$2 + 56 >> 2];
      HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
      HEAP32[$2 + 8 >> 2] = ((HEAPU8[HEAP32[$2 + 60 >> 2]] & 96) >>> 5 | 0) + 1;
      break label$6;
     }
     HEAP32[$2 + 8 >> 2] = 0;
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree_5($2 + 16 | 0);
 }
 __stack_pointer = $2 - -64 | 0;
 return HEAP32[$2 + 52 >> 2];
}

function jswrap_object_assign($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = 0;
 jsvObjectIteratorNew($1 + 16 | 0, HEAP32[$1 + 28 >> 2]);
 HEAP8[$1 + 15 | 0] = 0;
 while (1) {
  $0 = 0;
  if (!(HEAP8[$1 + 15 | 0] & 1)) {
   $0 = jsvObjectIteratorHasValue_9($1 + 16 | 0);
  }
  if ($0 & 1) {
   HEAP32[$1 + 8 >> 2] = jsvObjectIteratorGetValue_9($1 + 16 | 0);
   label$4: {
    if (jsvIsUndefined(HEAP32[$1 + 8 >> 2]) & 1) {
     break label$4;
    }
    if (jsvIsNull(HEAP32[$1 + 8 >> 2]) & 1) {
     break label$4;
    }
    label$6: {
     if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
      HEAP32[$1 >> 2] = HEAP32[$1 + 8 >> 2];
      jsExceptionHere(3, 118458, $1);
      HEAP8[$1 + 15 | 0] = 1;
      break label$6;
     }
     label$8: {
      if (!HEAP32[$1 + 24 >> 2]) {
       HEAP32[$1 + 24 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
       break label$8;
      }
      jsvObjectAppendAll(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 8 >> 2]);
     }
    }
   }
   jsvUnLock(HEAP32[$1 + 8 >> 2]);
   jsvObjectIteratorNext($1 + 16 | 0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree_9($1 + 16 | 0);
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 24 >> 2];
}

function jsvArrayBufferIteratorClone($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 12 >> 2] = $0;
 HEAP32[$5 + 8 >> 2] = $1;
 $3 = HEAP32[$5 + 8 >> 2];
 $0 = HEAP32[$3 >> 2];
 $2 = HEAP32[$3 + 4 >> 2];
 $4 = $0;
 $1 = HEAP32[$5 + 12 >> 2];
 $0 = $1;
 HEAP32[$0 >> 2] = $4;
 HEAP32[$0 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 52 >> 2];
 $2 = HEAP32[$3 + 48 >> 2];
 $4 = $2;
 $2 = $1;
 HEAP32[$2 + 48 >> 2] = $4;
 HEAP32[$2 + 52 >> 2] = $0;
 $2 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$3 + 40 >> 2];
 $4 = $0;
 $0 = $1;
 HEAP32[$0 + 40 >> 2] = $4;
 HEAP32[$0 + 44 >> 2] = $2;
 $0 = HEAP32[$3 + 36 >> 2];
 $2 = HEAP32[$3 + 32 >> 2];
 $4 = $2;
 $2 = $1;
 HEAP32[$2 + 32 >> 2] = $4;
 HEAP32[$2 + 36 >> 2] = $0;
 $2 = HEAP32[$3 + 28 >> 2];
 $0 = HEAP32[$3 + 24 >> 2];
 $4 = $0;
 $0 = $1;
 HEAP32[$0 + 24 >> 2] = $4;
 HEAP32[$0 + 28 >> 2] = $2;
 $0 = HEAP32[$3 + 20 >> 2];
 $2 = HEAP32[$3 + 16 >> 2];
 $4 = $2;
 $2 = $1;
 HEAP32[$2 + 16 >> 2] = $4;
 HEAP32[$2 + 20 >> 2] = $0;
 $2 = HEAP32[$3 + 12 >> 2];
 $0 = HEAP32[$3 + 8 >> 2];
 $4 = $0;
 $0 = $1;
 HEAP32[$0 + 8 >> 2] = $4;
 HEAP32[$0 + 12 >> 2] = $2;
 jsvStringIteratorClone(HEAP32[$5 + 12 >> 2], HEAP32[$5 + 8 >> 2]);
 __stack_pointer = $5 + 16 | 0;
}

function jswrap_storage_write($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 96 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 92 >> 2] = $0;
 HEAP32[$4 + 88 >> 2] = $1;
 HEAP32[$4 + 84 >> 2] = $2;
 HEAP32[$4 + 80 >> 2] = $3;
 label$1: {
  if (jsvIsObject(HEAP32[$4 + 88 >> 2]) & 1) {
   HEAP32[$4 + 76 >> 2] = jswrap_json_stringify(HEAP32[$4 + 88 >> 2], 0, 0);
   HEAP32[$4 + 84 >> 2] = 0;
   HEAP32[$4 + 80 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 76 >> 2] = jsvLockAgainSafe(HEAP32[$4 + 88 >> 2]);
 }
 jsfNameFromVar($4 + 40 | 0, HEAP32[$4 + 92 >> 2]);
 $2 = HEAP32[$4 + 76 >> 2];
 $3 = HEAP32[$4 + 84 >> 2];
 $5 = HEAP32[$4 + 80 >> 2];
 HEAP32[$4 + 32 >> 2] = HEAP32[$4 + 64 >> 2];
 $1 = HEAP32[$4 + 60 >> 2];
 $0 = HEAP32[$4 + 56 >> 2];
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 28 >> 2] = $1;
 $0 = HEAP32[$4 + 52 >> 2];
 $1 = HEAP32[$4 + 48 >> 2];
 HEAP32[$4 + 16 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $0;
 $1 = HEAP32[$4 + 44 >> 2];
 $0 = HEAP32[$4 + 40 >> 2];
 HEAP32[$4 + 8 >> 2] = $0;
 HEAP32[$4 + 12 >> 2] = $1;
 HEAP8[$4 + 75 | 0] = jsfWriteFile($4 + 8 | 0, $2, 0, $3, $5) & 1;
 jsvUnLock(HEAP32[$4 + 76 >> 2]);
 __stack_pointer = $4 + 96 | 0;
 return HEAP8[$4 + 75 | 0] & 1;
}

function expf($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = Math_fround(0), $5 = 0, $6 = 0, $7 = 0;
 label$1: {
  label$2: {
   $1 = top12($0) & 2047;
   if ($1 >>> 0 < top12(Math_fround(88)) >>> 0) {
    break label$2;
   }
   $4 = Math_fround(0);
   if (((wasm2js_scratch_store_f32($0), wasm2js_scratch_load_i32(2)) | 0) == -8388608) {
    break label$1;
   }
   if (top12(Math_fround(infinity)) >>> 0 <= $1 >>> 0) {
    return Math_fround($0 + $0);
   }
   if ($0 > Math_fround(88.72283172607422)) {
    return __math_oflowf(0);
   }
   if (!($0 < Math_fround(-103.97207641601562))) {
    break label$2;
   }
   return __math_uflowf(0);
  }
  $2 = HEAPF64[24095] * +$0;
  $5 = HEAPF64[24094];
  $6 = $2 + $5;
  $2 = $2 - ($6 - $5);
  $2 = (HEAPF64[24096] * $2 + HEAPF64[24097]) * ($2 * $2) + (HEAPF64[24098] * $2 + 1);
  wasm2js_scratch_store_f64(+$6);
  wasm2js_scratch_load_i32(1) | 0;
  $3 = wasm2js_scratch_load_i32(0) | 0;
  $1 = (($3 & 31) << 3) + 192464 | 0;
  $7 = HEAP32[$1 >> 2];
  $3 = HEAP32[$1 + 4 >> 2] + ($3 << 15) | 0;
  $1 = 0;
  $1 = $7 + $1 | 0;
  wasm2js_scratch_store_i32(0, $1 | 0);
  $3 = $7 >>> 0 > $1 >>> 0 ? $3 + 1 | 0 : $3;
  wasm2js_scratch_store_i32(1, $3 | 0);
  $4 = Math_fround($2 * +wasm2js_scratch_load_f64());
 }
 return $4;
}

function jspGetNamedField($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP8[$3 + 19 | 0] = $2;
 HEAP32[$3 + 12 >> 2] = 0;
 if (jsvHasChildren(HEAP32[$3 + 24 >> 2]) & 1) {
  HEAP32[$3 + 12 >> 2] = jsvFindChildFromString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
 }
 if (!HEAP32[$3 + 12 >> 2]) {
  HEAP8[$3 + 11 | 0] = !strcmp(HEAP32[$3 + 20 >> 2], 132159);
  if (!(HEAP8[$3 + 11 | 0] & 1)) {
   HEAP32[$3 + 12 >> 2] = jspGetNamedFieldInParents(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP8[$3 + 19 | 0] & 1);
  }
  label$4: {
   if (HEAP32[$3 + 12 >> 2]) {
    break label$4;
   }
   if (!(jsvIsFunction(HEAP32[$3 + 24 >> 2]) & 1) | !(HEAP8[$3 + 11 | 0] & 1)) {
    break label$4;
   }
   HEAP32[$3 + 4 >> 2] = jsvNewObject();
   HEAP32[$3 + 12 >> 2] = jsvAddNamedChild(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 4 >> 2], 132159);
   jsvUnLock(HEAP32[$3 + 4 >> 2]);
  }
 }
 label$5: {
  if (HEAP8[$3 + 19 | 0] & 1) {
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
   break label$5;
  }
  HEAP32[$3 + 28 >> 2] = jsvSkipNameAndUnLock(HEAP32[$3 + 12 >> 2]);
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jsvStringIteratorLoadFlashString_1($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] >> 2] + HEAP32[$0 + 8 >> 2];
 HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
 $0 = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
 label$1: {
  if (HEAPU32[HEAP32[$1 + 12 >> 2] + 8 >> 2] >= HEAPU32[$1 + 8 >> 2]) {
   HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = 0;
   HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 0;
   break label$1;
  }
  HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = HEAP32[$1 + 8 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
  if (HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2] > 16) {
   HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 16;
  }
  $0 = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
  jshFlashRead(HEAP32[$1 + 12 >> 2] + 20 | 0, HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0, HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]);
  HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = HEAP32[$1 + 12 >> 2] + 20;
 }
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_date_toString($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $1 = __stack_pointer - 112 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 108 >> 2] = $0;
 getTimeFromDateVar($1 + 80 | 0, HEAP32[$1 + 108 >> 2], 0);
 getCalendarDate($1 + 56 | 0, HEAP32[$1 + 80 >> 2]);
 label$1: {
  if (HEAP32[$1 + 100 >> 2] < 0) {
   HEAP32[$1 + 48 >> 2] = 0 - HEAP32[$1 + 100 >> 2];
   HEAP8[$1 + 55 | 0] = 45;
   break label$1;
  }
  HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 100 >> 2];
  HEAP8[$1 + 55 | 0] = 43;
 }
 $0 = HEAP32[48928];
 $2 = HEAP32[$1 + 72 >> 2] << 2;
 $3 = HEAP32[48927];
 $4 = HEAP32[$1 + 64 >> 2] << 2;
 $5 = HEAP32[$1 + 60 >> 2];
 $6 = HEAP32[$1 + 68 >> 2];
 $7 = HEAP32[$1 + 96 >> 2];
 $8 = HEAP32[$1 + 92 >> 2];
 $9 = HEAP32[$1 + 88 >> 2];
 $10 = HEAP8[$1 + 55 | 0];
 HEAP32[$1 + 32 >> 2] = Math_imul(HEAP32[$1 + 48 >> 2] / 60 | 0, 100) + (HEAP32[$1 + 48 >> 2] % 60 | 0);
 HEAP32[$1 + 28 >> 2] = $10;
 HEAP32[$1 + 24 >> 2] = $9;
 HEAP32[$1 + 20 >> 2] = $8;
 HEAP32[$1 + 16 >> 2] = $7;
 HEAP32[$1 + 12 >> 2] = $6;
 HEAP32[$1 + 8 >> 2] = $5;
 HEAP32[$1 + 4 >> 2] = $3 + $4;
 HEAP32[$1 >> 2] = $0 + $2;
 $0 = jsvVarPrintf(134474, $1);
 __stack_pointer = $1 + 112 | 0;
 return $0 | 0;
}

function jsvStringIteratorLoadFlashString($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] >> 2] + HEAP32[$0 + 8 >> 2];
 HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
 $0 = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
 label$1: {
  if (HEAPU32[HEAP32[$1 + 12 >> 2] + 8 >> 2] >= HEAPU32[$1 + 8 >> 2]) {
   HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = 0;
   HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 0;
   break label$1;
  }
  HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = HEAP32[$1 + 8 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
  if (HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2] > 16) {
   HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 16;
  }
  $0 = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
  jshFlashRead(HEAP32[$1 + 12 >> 2] + 20 | 0, HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) | 0, HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]);
  HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = HEAP32[$1 + 12 >> 2] + 20;
 }
 __stack_pointer = $1 + 16 | 0;
}

function matchfound($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = jsvNewEmptyArray();
 HEAP32[$2 + 20 >> 2] = jsvStringIteratorGetIndex_4(HEAP32[$2 + 28 >> 2]);
 HEAP32[$2 + 16 >> 2] = jsvNewFromStringVar(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], HEAP32[$2 + 20 >> 2] - HEAP32[$1 + 4 >> 2] | 0);
 jsvSetArrayItem(HEAP32[$2 + 24 >> 2], 0, HEAP32[$2 + 16 >> 2]);
 jsvUnLock(HEAP32[$2 + 16 >> 2]);
 HEAP32[$2 + 12 >> 2] = 0;
 while (1) {
  if (HEAP32[$2 + 12 >> 2] < HEAP32[$1 + 12 >> 2]) {
   HEAP32[$2 + 16 >> 2] = jsvNewFromStringVar(HEAP32[$1 >> 2], HEAP32[($1 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2], HEAP32[($1 + 52 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] - HEAP32[($1 + 16 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2] | 0);
   jsvSetArrayItem(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 12 >> 2] + 1 | 0, HEAP32[$2 + 16 >> 2]);
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 jsvObjectSetChildAndUnLock(HEAP32[$2 + 24 >> 2], 116439, jsvNewFromInteger(HEAP32[$1 + 4 >> 2]));
 jsvObjectSetChild(HEAP32[$2 + 24 >> 2], 117136, HEAP32[$1 >> 2]);
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}

function jswrap_process_env() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = jsvNewObject();
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 137061, jsvNewFromString(139436));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 136701, jsvNewFromString(130179));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 137923, jsvNewFromString(139631));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 137294, jsvNewFromInteger(0));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 137601, jsvNewFromInteger(8388608));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 137598, jsvNewFromInteger(8388608));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 137059, jsvNewFromInteger(2));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 137846, jsvNewFromInteger(8388608));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 137426, jswrap_interface_getSerial());
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 137802, jswrap_espruino_getConsole());
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 136819, jsvNewFromString(jswGetBuiltInLibraryNames()));
 jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 136831, jsvNewFromInteger(188496));
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function jswrap_object_defineProperties($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = $1;
 label$1: {
  if (!(jsvIsObject(HEAP32[$2 + 40 >> 2]) & 1)) {
   HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 40 >> 2];
   jsExceptionHere(1, 118483, $2 + 16 | 0);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  if (!(jsvIsObject(HEAP32[$2 + 36 >> 2]) & 1)) {
   HEAP32[$2 >> 2] = HEAP32[$2 + 36 >> 2];
   jsExceptionHere(1, 118521, $2);
   HEAP32[$2 + 44 >> 2] = 0;
   break label$1;
  }
  jsvObjectIteratorNew($2 + 32 | 0, HEAP32[$2 + 36 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_9($2 + 32 | 0) & 1) {
    HEAP32[$2 + 28 >> 2] = jsvObjectIteratorGetKey_6($2 + 32 | 0);
    HEAP32[$2 + 24 >> 2] = jsvObjectIteratorGetValue_9($2 + 32 | 0);
    jsvUnLock3(jswrap_object_defineProperty(HEAP32[$2 + 40 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]), HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]);
    jsvObjectIteratorNext($2 + 32 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_9($2 + 32 | 0);
  HEAP32[$2 + 44 >> 2] = jsvLockAgain(HEAP32[$2 + 40 >> 2]);
 }
 __stack_pointer = $2 + 48 | 0;
 return HEAP32[$2 + 44 >> 2];
}

function itostr_extra($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP8[$4 + 23 | 0] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 label$1: {
  if (!(!(HEAP8[$4 + 23 | 0] & 1) | HEAP32[$4 + 28 >> 2] >= 0)) {
   $0 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 + 24 >> 2] = $0 + 1;
   HEAP8[$0 | 0] = 45;
   HEAP32[$4 + 12 >> 2] = 0 - HEAP32[$4 + 28 >> 2];
   break label$1;
  }
  HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 28 >> 2];
 }
 HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 12 >> 2];
 HEAP32[$4 + 4 >> 2] = 1;
 while (1) {
  if (HEAPU32[$4 + 8 >> 2] >= HEAPU32[$4 + 16 >> 2]) {
   HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 4 >> 2] + 1;
   HEAP32[$4 + 8 >> 2] = HEAPU32[$4 + 8 >> 2] / HEAPU32[$4 + 16 >> 2];
   continue;
  }
  break;
 }
 HEAP32[$4 >> 2] = HEAP32[$4 + 4 >> 2] - 1;
 while (1) {
  if (HEAP32[$4 >> 2] >= 0) {
   $0 = itoch(HEAPU32[$4 + 12 >> 2] % HEAPU32[$4 + 16 >> 2] | 0);
   HEAP8[HEAP32[$4 + 24 >> 2] + HEAP32[$4 >> 2] | 0] = $0;
   HEAP32[$4 + 12 >> 2] = HEAPU32[$4 + 12 >> 2] / HEAPU32[$4 + 16 >> 2];
   HEAP32[$4 >> 2] = HEAP32[$4 >> 2] - 1;
   continue;
  }
  break;
 }
 HEAP8[HEAP32[$4 + 24 >> 2] + HEAP32[$4 + 4 >> 2] | 0] = 0;
 __stack_pointer = $4 + 32 | 0;
}

function mbedtls_sha256_starts($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = 0;
 HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2] = 0;
 label$1: {
  if (!HEAP32[$2 + 8 >> 2]) {
   HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2] = 1779033703;
   HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = -1150833019;
   HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = 1013904242;
   HEAP32[HEAP32[$2 + 12 >> 2] + 20 >> 2] = -1521486534;
   HEAP32[HEAP32[$2 + 12 >> 2] + 24 >> 2] = 1359893119;
   HEAP32[HEAP32[$2 + 12 >> 2] + 28 >> 2] = -1694144372;
   HEAP32[HEAP32[$2 + 12 >> 2] + 32 >> 2] = 528734635;
   HEAP32[HEAP32[$2 + 12 >> 2] + 36 >> 2] = 1541459225;
   break label$1;
  }
  HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2] = -1056596264;
  HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = 914150663;
  HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = 812702999;
  HEAP32[HEAP32[$2 + 12 >> 2] + 20 >> 2] = -150054599;
  HEAP32[HEAP32[$2 + 12 >> 2] + 24 >> 2] = -4191439;
  HEAP32[HEAP32[$2 + 12 >> 2] + 28 >> 2] = 1750603025;
  HEAP32[HEAP32[$2 + 12 >> 2] + 32 >> 2] = 1694076839;
  HEAP32[HEAP32[$2 + 12 >> 2] + 36 >> 2] = -1090891868;
 }
 HEAP32[HEAP32[$2 + 12 >> 2] + 104 >> 2] = HEAP32[$2 + 8 >> 2];
}

function jsfIsErased($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 160 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 152 >> 2] = $0;
 HEAP32[$2 + 148 >> 2] = $1;
 HEAP32[$2 + 12 >> 2] = 0;
 label$1: {
  while (1) {
   if (HEAP32[$2 + 148 >> 2]) {
    HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 148 >> 2];
    if (HEAPU32[$2 + 8 >> 2] > 128) {
     HEAP32[$2 + 8 >> 2] = 128;
    }
    jshFlashRead($2 + 16 | 0, HEAP32[$2 + 152 >> 2], HEAP32[$2 + 8 >> 2]);
    HEAP32[$2 + 4 >> 2] = 0;
    while (1) {
     if (HEAPU32[$2 + 4 >> 2] < HEAPU32[$2 + 8 >> 2]) {
      if (HEAPU8[HEAP32[$2 + 4 >> 2] + ($2 + 16 | 0) | 0] != 255) {
       HEAP8[$2 + 159 | 0] = 0;
       break label$1;
      } else {
       HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
       continue;
      }
     }
     break;
    }
    HEAP32[$2 + 152 >> 2] = HEAP32[$2 + 8 >> 2] + HEAP32[$2 + 152 >> 2];
    HEAP32[$2 + 148 >> 2] = HEAP32[$2 + 148 >> 2] - HEAP32[$2 + 8 >> 2];
    $0 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $0 + 1;
    if (($0 | 0) > 500) {
     jshKickWatchDog();
     jshKickSoftWatchDog();
     HEAP32[$2 + 12 >> 2] = 0;
    }
    continue;
   }
   break;
  }
  HEAP8[$2 + 159 | 0] = 1;
 }
 __stack_pointer = $2 + 160 | 0;
 return HEAP8[$2 + 159 | 0] & 1;
}

function jswrap_string_endsWith($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1: {
  if (!(jsvIsString(HEAP32[$3 + 24 >> 2]) & 1)) {
   HEAP8[$3 + 31 | 0] = 0;
   break label$1;
  }
  label$3: {
   if (jsvIsNumeric(HEAP32[$3 + 16 >> 2]) & 1) {
    $0 = jsvGetInteger(HEAP32[$3 + 16 >> 2]);
    break label$3;
   }
   $0 = jsvGetStringLength(HEAP32[$3 + 24 >> 2]);
  }
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = jsvAsString(HEAP32[$3 + 20 >> 2]);
  $0 = jsvGetStringLength(HEAP32[$3 + 8 >> 2]);
  HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] - $0;
  HEAP8[$3 + 7 | 0] = 0;
  label$5: {
   if (HEAP32[$3 + 12 >> 2] < 0) {
    break label$5;
   }
   if ((jsvGetStringLength(HEAP32[$3 + 8 >> 2]) + HEAP32[$3 + 12 >> 2] | 0) > (jsvGetStringLength(HEAP32[$3 + 24 >> 2]) | 0)) {
    break label$5;
   }
   HEAP8[$3 + 7 | 0] = !jsvCompareString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 12 >> 2], 0, 1);
  }
  jsvUnLock(HEAP32[$3 + 8 >> 2]);
  HEAP8[$3 + 31 | 0] = HEAP8[$3 + 7 | 0] & 1;
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP8[$3 + 31 | 0] & 1;
}

function std____2____compressed_pair_TfLiteFullyConnectedParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_____compressed_pair_TfLiteFullyConnectedParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28TfLiteFullyConnectedParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 std____2____compressed_pair_elem_TfLiteFullyConnectedParams__2c_200_2c_20false_____compressed_pair_elem_TfLiteFullyConnectedParams___2c_20void__28TfLiteFullyConnectedParams___29($0, HEAP32[$3 + 8 >> 2]);
 std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_20void__28tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0 + 4 | 0, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function jswrap_date_toLocalISOString($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $1 = __stack_pointer - 112 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 108 >> 2] = $0;
 getTimeFromDateVar($1 + 80 | 0, HEAP32[$1 + 108 >> 2], 0);
 getCalendarDate($1 + 56 | 0, HEAP32[$1 + 80 >> 2]);
 label$1: {
  if (HEAP32[$1 + 100 >> 2] < 0) {
   HEAP32[$1 + 48 >> 2] = 0 - HEAP32[$1 + 100 >> 2];
   HEAP8[$1 + 55 | 0] = 45;
   break label$1;
  }
  HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 100 >> 2];
  HEAP8[$1 + 55 | 0] = 43;
 }
 HEAP32[$1 + 48 >> 2] = Math_imul(HEAP32[$1 + 48 >> 2] / 60 | 0, 100) + (HEAP32[$1 + 48 >> 2] % 60 | 0);
 $0 = HEAP32[$1 + 68 >> 2];
 $2 = HEAP32[$1 + 64 >> 2];
 $3 = HEAP32[$1 + 60 >> 2];
 $4 = HEAP32[$1 + 96 >> 2];
 $5 = HEAP32[$1 + 92 >> 2];
 $6 = HEAP32[$1 + 88 >> 2];
 $7 = HEAP32[$1 + 84 >> 2];
 $8 = HEAP8[$1 + 55 | 0];
 HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 48 >> 2];
 HEAP32[$1 + 28 >> 2] = $8;
 HEAP32[$1 + 24 >> 2] = $7;
 HEAP32[$1 + 20 >> 2] = $6;
 HEAP32[$1 + 16 >> 2] = $5;
 HEAP32[$1 + 12 >> 2] = $4;
 HEAP32[$1 + 8 >> 2] = $3;
 HEAP32[$1 + 4 >> 2] = $2 + 1;
 HEAP32[$1 >> 2] = $0;
 $0 = jsvVarPrintf(134435, $1);
 __stack_pointer = $1 + 112 | 0;
 return $0 | 0;
}

function jswrap_dataview_get($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 96 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 88 >> 2] = $0;
 HEAP8[$4 + 87 | 0] = $1;
 HEAP32[$4 + 80 >> 2] = $2;
 HEAP8[$4 + 79 | 0] = $3;
 HEAP32[$4 + 72 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 88 >> 2], 121187);
 label$1: {
  if (!(jsvIsArrayBuffer(HEAP32[$4 + 72 >> 2]) & 1)) {
   jsvUnLock(HEAP32[$4 + 72 >> 2]);
   HEAP32[$4 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 80 >> 2] = jsvObjectGetIntegerChild(HEAP32[$4 + 88 >> 2], 117871) + HEAP32[$4 + 80 >> 2];
  HEAP32[$4 + 68 >> 2] = HEAPU8[$4 + 87 | 0] & 15;
  HEAP32[$4 + 64 >> 2] = jswrap_typedarray_constructor(HEAPU8[$4 + 87 | 0], HEAP32[$4 + 72 >> 2], HEAP32[$4 + 80 >> 2], HEAP32[$4 + 68 >> 2]);
  jsvUnLock(HEAP32[$4 + 72 >> 2]);
  if (!HEAP32[$4 + 64 >> 2]) {
   HEAP32[$4 + 92 >> 2] = 0;
   break label$1;
  }
  jsvArrayBufferIteratorNew($4 + 8 | 0, HEAP32[$4 + 64 >> 2], 0);
  HEAP32[$4 + 4 >> 2] = jsvArrayBufferIteratorGetValue($4 + 8 | 0, (HEAPU8[$4 + 79 | 0] ^ -1) & 1);
  jsvArrayBufferIteratorFree($4 + 8 | 0);
  jsvUnLock(HEAP32[$4 + 64 >> 2]);
  HEAP32[$4 + 92 >> 2] = HEAP32[$4 + 4 >> 2];
 }
 __stack_pointer = $4 + 96 | 0;
 return HEAP32[$4 + 92 >> 2];
}

function int_20gemmlowp__RoundingHalfSum_int__28int_2c_20int_29($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $5 = __stack_pointer - 48 | 0;
 HEAP32[$5 + 44 >> 2] = $0;
 HEAP32[$5 + 40 >> 2] = $1;
 $0 = $5;
 $1 = HEAP32[$0 + 44 >> 2];
 $2 = $1 >> 31;
 HEAP32[$0 + 32 >> 2] = $1;
 HEAP32[$0 + 36 >> 2] = $2;
 $2 = HEAP32[$0 + 40 >> 2];
 $1 = $2 >> 31;
 HEAP32[$0 + 24 >> 2] = $2;
 HEAP32[$0 + 28 >> 2] = $1;
 $1 = HEAP32[$0 + 32 >> 2];
 $6 = $1;
 $2 = HEAP32[$0 + 36 >> 2];
 $3 = $2;
 $2 = HEAP32[$0 + 24 >> 2];
 $4 = $2;
 $1 = HEAP32[$0 + 28 >> 2];
 $2 = $1;
 $1 = $3;
 $3 = $1 + $2 | 0;
 $0 = $6;
 $1 = $4;
 $4 = $0 + $1 | 0;
 $0 = $5;
 HEAP32[$0 + 16 >> 2] = $4;
 $3 = $4 >>> 0 < $1 >>> 0 ? $3 + 1 | 0 : $3;
 HEAP32[$0 + 20 >> 2] = $3;
 $0 = HEAP32[$0 + 20 >> 2];
 $0 = ($0 | 0) > 0 | ($0 | 0) >= 0 ? 1 : -1;
 $1 = $0 >> 31;
 $2 = $0;
 $0 = $5;
 HEAP32[$0 + 8 >> 2] = $2;
 HEAP32[$0 + 12 >> 2] = $1;
 $1 = HEAP32[$0 + 16 >> 2];
 $3 = $1;
 $0 = HEAP32[$0 + 20 >> 2];
 $4 = $0;
 $0 = HEAP32[$5 + 8 >> 2];
 $2 = $0;
 $1 = HEAP32[$5 + 12 >> 2];
 $0 = $1;
 $1 = $4;
 $4 = $1 + $0 | 0;
 $1 = $3;
 $3 = $2;
 $2 = $1 + $3 | 0;
 $4 = $2 >>> 0 < $3 >>> 0 ? $4 + 1 | 0 : $4;
 $1 = __wasm_i64_sdiv($2, $4, 2, 0);
 return $1;
}

function touchSwipeRotate($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if ((HEAPU8[366808] | HEAPU8[366809] << 8 | (HEAPU8[366810] << 16 | HEAPU8[366811] << 24)) & 32) {
  label$2: {
   if (HEAP32[$1 + 12 >> 2] == 1) {
    HEAP32[$1 + 12 >> 2] = 2;
    break label$2;
   }
   if (HEAP32[$1 + 12 >> 2] == 2) {
    HEAP32[$1 + 12 >> 2] = 1;
   }
  }
 }
 if ((HEAPU8[366808] | HEAPU8[366809] << 8 | (HEAPU8[366810] << 16 | HEAPU8[366811] << 24)) & 64) {
  label$6: {
   if (HEAP32[$1 + 12 >> 2] == 3) {
    HEAP32[$1 + 12 >> 2] = 4;
    break label$6;
   }
   if (HEAP32[$1 + 12 >> 2] == 4) {
    HEAP32[$1 + 12 >> 2] = 3;
   }
  }
 }
 if ((HEAPU8[366808] | HEAPU8[366809] << 8 | (HEAPU8[366810] << 16 | HEAPU8[366811] << 24)) & 16) {
  label$10: {
   if (HEAP32[$1 + 12 >> 2] == 1) {
    HEAP32[$1 + 12 >> 2] = 3;
    break label$10;
   }
   label$12: {
    if (HEAP32[$1 + 12 >> 2] == 2) {
     HEAP32[$1 + 12 >> 2] = 4;
     break label$12;
    }
    label$14: {
     if (HEAP32[$1 + 12 >> 2] == 3) {
      HEAP32[$1 + 12 >> 2] = 1;
      break label$14;
     }
     if (HEAP32[$1 + 12 >> 2] == 4) {
      HEAP32[$1 + 12 >> 2] = 2;
     }
    }
   }
  }
 }
 return HEAP32[$1 + 12 >> 2];
}

function std____2____compressed_pair_TfLiteDepthwiseConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_____compressed_pair_TfLiteDepthwiseConvParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28TfLiteDepthwiseConvParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 std____2____compressed_pair_elem_TfLiteDepthwiseConvParams__2c_200_2c_20false_____compressed_pair_elem_TfLiteDepthwiseConvParams___2c_20void__28TfLiteDepthwiseConvParams___29($0, HEAP32[$3 + 8 >> 2]);
 std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_20void__28tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0 + 4 | 0, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function jsfEraseFile($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 112 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 64 >> 2] = HEAP32[$0 + 24 >> 2];
 $2 = HEAP32[$0 + 16 >> 2];
 $3 = HEAP32[$0 + 20 >> 2];
 HEAP32[$1 + 56 >> 2] = $2;
 HEAP32[$1 + 60 >> 2] = $3;
 $2 = HEAP32[$0 + 12 >> 2];
 $3 = HEAP32[$0 + 8 >> 2];
 HEAP32[$1 + 48 >> 2] = $3;
 HEAP32[$1 + 52 >> 2] = $2;
 $3 = HEAP32[$0 + 4 >> 2];
 $2 = HEAP32[$0 >> 2];
 HEAP32[$1 + 40 >> 2] = $2;
 HEAP32[$1 + 44 >> 2] = $3;
 HEAP32[$1 + 68 >> 2] = jsfFindFile($1 + 40 | 0, $1 + 72 | 0);
 label$1: {
  if (!HEAP32[$1 + 68 >> 2]) {
   HEAP8[$1 + 111 | 0] = 0;
   break label$1;
  }
  HEAP32[$1 + 32 >> 2] = HEAP32[$0 + 24 >> 2];
  $3 = HEAP32[$0 + 16 >> 2];
  $2 = HEAP32[$0 + 20 >> 2];
  HEAP32[$1 + 24 >> 2] = $3;
  HEAP32[$1 + 28 >> 2] = $2;
  $3 = HEAP32[$0 + 12 >> 2];
  $2 = HEAP32[$0 + 8 >> 2];
  HEAP32[$1 + 16 >> 2] = $2;
  HEAP32[$1 + 20 >> 2] = $3;
  $2 = HEAP32[$0 + 4 >> 2];
  $3 = HEAP32[$0 >> 2];
  HEAP32[$1 + 8 >> 2] = $3;
  HEAP32[$1 + 12 >> 2] = $2;
  jsfCacheClearFile($1 + 8 | 0);
  jsfEraseFileInternal(HEAP32[$1 + 68 >> 2], $1 + 72 | 0, 1);
  HEAP8[$1 + 111 | 0] = 1;
 }
 __stack_pointer = $1 + 112 | 0;
 return HEAP8[$1 + 111 | 0] & 1;
}

function void_20tflite__reference_ops__Dequantize_unsigned_20char_2c_20float__28tflite__DequantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20unsigned_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 44 >> 2] = $0;
 HEAP32[$5 + 40 >> 2] = $1;
 HEAP32[$5 + 36 >> 2] = $2;
 HEAP32[$5 + 32 >> 2] = $3;
 HEAP32[$5 + 28 >> 2] = $4;
 HEAP32[$5 + 24 >> 2] = HEAP32[HEAP32[$5 + 44 >> 2] + 8 >> 2];
 HEAPF64[$5 + 16 >> 3] = HEAPF64[HEAP32[$5 + 44 >> 2] >> 3];
 HEAP32[$5 + 12 >> 2] = tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 40 >> 2], HEAP32[$5 + 32 >> 2]);
 HEAP32[$5 + 8 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 8 >> 2] < HEAP32[$5 + 12 >> 2]) {
   HEAP32[$5 + 4 >> 2] = HEAPU8[HEAP32[$5 + 36 >> 2] + HEAP32[$5 + 8 >> 2] | 0];
   HEAPF32[$5 >> 2] = HEAPF64[$5 + 16 >> 3] * +(HEAP32[$5 + 4 >> 2] - HEAP32[$5 + 24 >> 2] | 0);
   HEAPF32[HEAP32[$5 + 28 >> 2] + (HEAP32[$5 + 8 >> 2] << 2) >> 2] = HEAPF32[$5 >> 2];
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 48 | 0;
}

function jsvGetFirstChildSigned($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 8 >> 2] = $0;
 $0 = HEAP32[$3 + 8 >> 2];
 $1 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
 $2 = HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24);
 $0 = $1;
 $2 = ($2 & 268435455) << 4 | $0 >>> 28;
 label$1: {
  if (($2 & 16383) >>> 0 > 8191) {
   $1 = HEAP32[$3 + 8 >> 2];
   $0 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
   $2 = HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24);
   $1 = $0;
   $2 = ($2 & 268435455) << 4 | $1 >>> 28;
   HEAP16[$3 + 14 >> 1] = ($2 & 16383) - 16384;
   break label$1;
  }
  $0 = HEAP32[$3 + 8 >> 2];
  $1 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
  $2 = HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24);
  $0 = $1;
  $2 = ($2 & 268435455) << 4 | $0 >>> 28;
  HEAP16[$3 + 14 >> 1] = $2 & 16383;
 }
 return HEAP16[$3 + 14 >> 1];
}

function void_20tflite__reference_ops__Dequantize_signed_20char_2c_20float__28tflite__DequantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20signed_20char_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 44 >> 2] = $0;
 HEAP32[$5 + 40 >> 2] = $1;
 HEAP32[$5 + 36 >> 2] = $2;
 HEAP32[$5 + 32 >> 2] = $3;
 HEAP32[$5 + 28 >> 2] = $4;
 HEAP32[$5 + 24 >> 2] = HEAP32[HEAP32[$5 + 44 >> 2] + 8 >> 2];
 HEAPF64[$5 + 16 >> 3] = HEAPF64[HEAP32[$5 + 44 >> 2] >> 3];
 HEAP32[$5 + 12 >> 2] = tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 40 >> 2], HEAP32[$5 + 32 >> 2]);
 HEAP32[$5 + 8 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 8 >> 2] < HEAP32[$5 + 12 >> 2]) {
   HEAP32[$5 + 4 >> 2] = HEAP8[HEAP32[$5 + 36 >> 2] + HEAP32[$5 + 8 >> 2] | 0];
   HEAPF32[$5 >> 2] = HEAPF64[$5 + 16 >> 3] * +(HEAP32[$5 + 4 >> 2] - HEAP32[$5 + 24 >> 2] | 0);
   HEAPF32[HEAP32[$5 + 28 >> 2] + (HEAP32[$5 + 8 >> 2] << 2) >> 2] = HEAPF32[$5 >> 2];
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 48 | 0;
}

function _jswrap_array_sort_compare($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 label$1: {
  if (jsvIsUndefined(HEAP32[$3 + 40 >> 2]) & 1) {
   HEAP32[$3 + 44 >> 2] = 1;
   break label$1;
  }
  if (jsvIsUndefined(HEAP32[$3 + 36 >> 2]) & 1) {
   HEAP32[$3 + 44 >> 2] = -1;
   break label$1;
  }
  if (HEAP32[$3 + 32 >> 2]) {
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 40 >> 2];
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 36 >> 2];
   HEAPF64[$3 + 16 >> 3] = jsvGetFloatAndUnLock(jspeFunctionCall(HEAP32[$3 + 32 >> 2], 0, 0, 0, 2, $3 + 24 | 0));
   if (HEAPF64[$3 + 16 >> 3] == 0) {
    HEAP32[$3 + 44 >> 2] = 0;
    break label$1;
   }
   HEAP32[$3 + 44 >> 2] = HEAPF64[$3 + 16 >> 3] < 0 ? -1 : 1;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvAsString(HEAP32[$3 + 40 >> 2]);
  HEAP32[$3 + 8 >> 2] = jsvAsString(HEAP32[$3 + 36 >> 2]);
  HEAP32[$3 + 4 >> 2] = jsvCompareString(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 0, 0, 0);
  jsvUnLock2(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
  HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 4 >> 2];
 }
 __stack_pointer = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}

function jswrap_io_shiftOutCallback($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 24 >> 2];
 HEAP32[$2 + 12 >> 2] = 0;
 while (1) {
  if (HEAP32[$2 + 12 >> 2] < HEAP32[HEAP32[$2 + 20 >> 2] + 16 >> 2]) {
   HEAP32[$2 + 16 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2] - 1;
   while (1) {
    if (HEAP32[$2 + 16 >> 2] >= 0) {
     if (jshIsPinValid(HEAPU8[HEAP32[$2 + 20 >> 2] + HEAP32[$2 + 16 >> 2] | 0]) & 1) {
      jshPinSetValue(HEAPU8[HEAP32[$2 + 20 >> 2] + HEAP32[$2 + 16 >> 2] | 0], HEAP32[$2 + 28 >> 2] & 1);
     }
     HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 28 >> 2] >> 1;
     HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] - 1;
     continue;
    }
    break;
   }
   if (jshIsPinValid(HEAPU8[HEAP32[$2 + 20 >> 2] + 8 | 0]) & 1) {
    jshPinSetValue(HEAPU8[HEAP32[$2 + 20 >> 2] + 8 | 0], HEAP8[HEAP32[$2 + 20 >> 2] + 9 | 0] & 1);
    jshPinSetValue(HEAPU8[HEAP32[$2 + 20 >> 2] + 8 | 0], (HEAPU8[HEAP32[$2 + 20 >> 2] + 9 | 0] ^ -1) & 1);
   }
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $2 + 32 | 0;
}

function jswrap_graphics_setFontAlign($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 96 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 88 >> 2] = $0;
 HEAP32[$4 + 84 >> 2] = $1;
 HEAP32[$4 + 80 >> 2] = $2;
 HEAP32[$4 + 76 >> 2] = $3;
 label$1: {
  if (!(graphicsGetFromVar($4, HEAP32[$4 + 88 >> 2]) & 1)) {
   HEAP32[$4 + 92 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$4 + 84 >> 2] < -1) {
   HEAP32[$4 + 84 >> 2] = -1;
  }
  if (HEAP32[$4 + 84 >> 2] > 1) {
   HEAP32[$4 + 84 >> 2] = 1;
  }
  if (HEAP32[$4 + 80 >> 2] < -1) {
   HEAP32[$4 + 80 >> 2] = -1;
  }
  if (HEAP32[$4 + 80 >> 2] > 1) {
   HEAP32[$4 + 80 >> 2] = 1;
  }
  if (HEAP32[$4 + 76 >> 2] < 0) {
   HEAP32[$4 + 76 >> 2] = 0;
  }
  if (HEAP32[$4 + 76 >> 2] > 3) {
   HEAP32[$4 + 76 >> 2] = 3;
  }
  HEAP8[$4 + 31 | 0] = HEAPU8[$4 + 84 | 0] & 3 | HEAPU8[$4 + 31 | 0] & 252;
  HEAP8[$4 + 31 | 0] = HEAPU8[$4 + 31 | 0] & 243 | (HEAPU8[$4 + 80 | 0] & 3) << 2;
  HEAP8[$4 + 31 | 0] = HEAPU8[$4 + 31 | 0] & -49 | (HEAPU8[$4 + 76 | 0] & 3) << 4;
  graphicsSetVar($4);
  HEAP32[$4 + 92 >> 2] = jsvLockAgain(HEAP32[$4 + 88 >> 2]);
 }
 __stack_pointer = $4 + 96 | 0;
 return HEAP32[$4 + 92 >> 2];
}

function jsvCompareString($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 112 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 104 >> 2] = $0;
 HEAP32[$5 + 100 >> 2] = $1;
 HEAP32[$5 + 96 >> 2] = $2;
 HEAP32[$5 + 92 >> 2] = $3;
 HEAP8[$5 + 91 | 0] = $4;
 jsvStringIteratorNewUTF8($5 + 48 | 0, HEAP32[$5 + 104 >> 2], HEAP32[$5 + 96 >> 2]);
 jsvStringIteratorNewUTF8($5 + 8 | 0, HEAP32[$5 + 100 >> 2], HEAP32[$5 + 92 >> 2]);
 while (1) {
  label$2: {
   HEAP32[$5 + 4 >> 2] = jsvStringIteratorGetUTF8CharAndNext($5 + 48 | 0);
   HEAP32[$5 >> 2] = jsvStringIteratorGetUTF8CharAndNext($5 + 8 | 0);
   if (HEAP32[$5 + 4 >> 2] != HEAP32[$5 >> 2]) {
    jsvStringIteratorFree_1($5 + 48 | 0);
    jsvStringIteratorFree_1($5 + 8 | 0);
    if (!(!(HEAP8[$5 + 91 | 0] & 1) | (HEAP32[$5 + 4 >> 2] | HEAP32[$5 >> 2]) >= 0)) {
     HEAP32[$5 + 108 >> 2] = 0;
     break label$2;
    }
    HEAP32[$5 + 108 >> 2] = HEAP32[$5 + 4 >> 2] - HEAP32[$5 >> 2];
    break label$2;
   }
   if (HEAP32[$5 + 4 >> 2] >= 0) {
    continue;
   }
   jsvStringIteratorFree_1($5 + 48 | 0);
   jsvStringIteratorFree_1($5 + 8 | 0);
   HEAP32[$5 + 108 >> 2] = 0;
  }
  break;
 }
 __stack_pointer = $5 + 112 | 0;
 return HEAP32[$5 + 108 >> 2];
}

function void_20tflite__reference_ops__Dequantize_short_2c_20float__28tflite__DequantizationParams_20const__2c_20tflite__RuntimeShape_20const__2c_20short_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 44 >> 2] = $0;
 HEAP32[$5 + 40 >> 2] = $1;
 HEAP32[$5 + 36 >> 2] = $2;
 HEAP32[$5 + 32 >> 2] = $3;
 HEAP32[$5 + 28 >> 2] = $4;
 HEAP32[$5 + 24 >> 2] = HEAP32[HEAP32[$5 + 44 >> 2] + 8 >> 2];
 HEAPF64[$5 + 16 >> 3] = HEAPF64[HEAP32[$5 + 44 >> 2] >> 3];
 HEAP32[$5 + 12 >> 2] = tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29(HEAP32[$5 + 40 >> 2], HEAP32[$5 + 32 >> 2]);
 HEAP32[$5 + 8 >> 2] = 0;
 while (1) {
  if (HEAP32[$5 + 8 >> 2] < HEAP32[$5 + 12 >> 2]) {
   HEAP32[$5 + 4 >> 2] = HEAP16[HEAP32[$5 + 36 >> 2] + (HEAP32[$5 + 8 >> 2] << 1) >> 1];
   HEAPF32[$5 >> 2] = HEAPF64[$5 + 16 >> 3] * +(HEAP32[$5 + 4 >> 2] - HEAP32[$5 + 24 >> 2] | 0);
   HEAPF32[HEAP32[$5 + 28 >> 2] + (HEAP32[$5 + 8 >> 2] << 2) >> 2] = HEAPF32[$5 >> 2];
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 48 | 0;
}

function jswrap_string_toUpperLowerCase($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 112 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 104 >> 2] = $0;
 HEAP8[$2 + 103 | 0] = $1;
 HEAP32[$2 + 96 >> 2] = jsvNewFromEmptyString_8();
 label$1: {
  if (!HEAP32[$2 + 96 >> 2]) {
   HEAP32[$2 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 92 >> 2] = jsvAsString(HEAP32[$2 + 104 >> 2]);
  jsvStringIteratorNew($2 + 56 | 0, HEAP32[$2 + 92 >> 2], 0);
  jsvStringIteratorNew($2 + 16 | 0, HEAP32[$2 + 96 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar_8($2 + 56 | 0) & 1) {
    HEAP8[$2 + 15 | 0] = jsvStringIteratorGetCharAndNext($2 + 56 | 0);
    label$5: {
     if (HEAP8[$2 + 103 | 0] & 1) {
      $0 = charToUpperCase(HEAP8[$2 + 15 | 0]) << 24 >> 24;
      break label$5;
     }
     $0 = charToLowerCase(HEAP8[$2 + 15 | 0]) << 24 >> 24;
    }
    HEAP8[$2 + 15 | 0] = $0;
    jsvStringIteratorAppend($2 + 16 | 0, HEAP8[$2 + 15 | 0]);
    continue;
   }
   break;
  }
  jsvStringIteratorFree_10($2 + 56 | 0);
  jsvStringIteratorFree_10($2 + 16 | 0);
  jsvUnLock(HEAP32[$2 + 92 >> 2]);
  HEAP32[$2 + 108 >> 2] = HEAP32[$2 + 96 >> 2];
 }
 __stack_pointer = $2 + 112 | 0;
 return HEAP32[$2 + 108 >> 2];
}

function jswrap_object_removeListener($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1: {
  if (!(jsvHasChildren(HEAP32[$3 + 28 >> 2]) & 1)) {
   jsExceptionHere(3, 135617, 0);
   break label$1;
  }
  if (jsvIsString(HEAP32[$3 + 24 >> 2]) & 1) {
   HEAP32[$3 >> 2] = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 16 >> 2] = jsvVarPrintf(116801, $3);
   if (!HEAP32[$3 + 16 >> 2]) {
    break label$1;
   }
   HEAP32[$3 + 12 >> 2] = jsvFindChildFromVar(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 16 >> 2], 1);
   jsvUnLock(HEAP32[$3 + 16 >> 2]);
   HEAP32[$3 + 8 >> 2] = jsvSkipName(HEAP32[$3 + 12 >> 2]);
   if (HEAP32[$3 + 8 >> 2]) {
    if (jsvIsArray(HEAP32[$3 + 8 >> 2]) & 1) {
     HEAP32[$3 + 4 >> 2] = jsvGetIndexOf(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 20 >> 2], 1);
     if (HEAP32[$3 + 4 >> 2]) {
      jsvRemoveChildAndUnLock(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
     }
    }
    jsvUnLock(HEAP32[$3 + 8 >> 2]);
   }
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   break label$1;
  }
  jsExceptionHere(3, 129842, 0);
 }
 __stack_pointer = $3 + 32 | 0;
}

function jswrap_onewire_read($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 72 >> 2] = $0;
 HEAP32[$2 + 68 >> 2] = $1;
 HEAP8[$2 + 67 | 0] = onewire_getpin(HEAP32[$2 + 72 >> 2]);
 label$1: {
  if (!(jshIsPinValid(HEAPU8[$2 + 67 | 0]) & 1)) {
   HEAP32[$2 + 76 >> 2] = 0;
   break label$1;
  }
  if (jsvIsNumeric(HEAP32[$2 + 68 >> 2]) & 1) {
   HEAP32[$2 + 60 >> 2] = jsvGetInteger(HEAP32[$2 + 68 >> 2]);
   HEAP32[$2 + 56 >> 2] = jsvNewTypedArray(1, HEAP32[$2 + 60 >> 2]);
   if (!HEAP32[$2 + 56 >> 2]) {
    HEAP32[$2 + 76 >> 2] = 0;
    break label$1;
   }
   jsvArrayBufferIteratorNew($2, HEAP32[$2 + 56 >> 2], 0);
   while (1) {
    $0 = HEAP32[$2 + 60 >> 2];
    HEAP32[$2 + 60 >> 2] = $0 - 1;
    if ($0) {
     jsvArrayBufferIteratorSetByteValue($2, OneWireRead(HEAPU8[$2 + 67 | 0], 8) << 24 >> 24);
     jsvArrayBufferIteratorNext($2);
     continue;
    }
    break;
   }
   jsvArrayBufferIteratorFree($2);
   HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 56 >> 2];
   break label$1;
  }
  HEAP32[$2 + 76 >> 2] = jsvNewFromInteger(OneWireRead(HEAPU8[$2 + 67 | 0], 8));
 }
 __stack_pointer = $2 + 80 | 0;
 return HEAP32[$2 + 76 >> 2];
}

function jswrap_object_fromEntries($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1: {
  if (!(jsvIsArray(HEAP32[$1 + 24 >> 2]) & 1)) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 20 >> 2] = jsvNewObject();
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  jsvObjectIteratorNew($1 + 16 | 0, HEAP32[$1 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_9($1 + 16 | 0) & 1) {
    HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue_9($1 + 16 | 0);
    if (jsvIsArray(HEAP32[$1 + 12 >> 2]) & 1) {
     HEAP32[$1 + 8 >> 2] = jsvGetArrayItem(HEAP32[$1 + 12 >> 2], 0);
     HEAP32[$1 + 4 >> 2] = jsvGetArrayItem(HEAP32[$1 + 12 >> 2], 1);
     if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
      jsvObjectSetChildVar(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2]);
     }
     jsvUnLock2(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2]);
    }
    jsvUnLock(HEAP32[$1 + 12 >> 2]);
    jsvObjectIteratorNext($1 + 16 | 0);
    continue;
   }
   break;
  }
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function jsvClearEmptyVarList() {
 var $0 = 0, $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[196322] = 1;
 HEAP16[98162] = 0;
 HEAP16[$1 + 14 >> 1] = 1;
 while (1) {
  if (HEAPU16[$1 + 14 >> 1] <= 12e3) {
   HEAP32[$1 + 8 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 14 >> 1]);
   $0 = HEAP32[$1 + 8 >> 2];
   label$3: {
    if (!((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63)) {
     $0 = HEAP32[$1 + 8 >> 2];
     HEAP8[$0 | 0] = 0;
     HEAP8[$0 + 1 | 0] = 0;
     HEAP8[$0 + 2 | 0] = 0;
     HEAP8[$0 + 3 | 0] = 0;
     HEAP8[$0 + 4 | 0] = 0;
     HEAP8[$0 + 5 | 0] = 0;
     HEAP8[$0 + 6 | 0] = 0;
     HEAP8[$0 + 7 | 0] = 0;
     HEAP8[$0 + 6 | 0] = 0;
     HEAP8[$0 + 7 | 0] = 0;
     HEAP8[$0 + 8 | 0] = 0;
     HEAP8[$0 + 9 | 0] = 0;
     HEAP8[$0 + 10 | 0] = 0;
     HEAP8[$0 + 11 | 0] = 0;
     HEAP8[$0 + 12 | 0] = 0;
     HEAP8[$0 + 13 | 0] = 0;
     break label$3;
    }
    if (jsvIsFlatString(HEAP32[$1 + 8 >> 2]) & 1) {
     HEAP16[$1 + 14 >> 1] = HEAPU16[$1 + 14 >> 1] + jsvGetFlatStringBlocks(HEAP32[$1 + 8 >> 2]);
    }
   }
   HEAP16[$1 + 14 >> 1] = HEAPU16[$1 + 14 >> 1] + 1;
   continue;
  }
  break;
 }
 HEAP8[196322] = 0;
 __stack_pointer = $1 + 16 | 0;
}

function tflite__GreedyMemoryPlanner__GetMaximumMemorySize_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 $0 = HEAP32[$1 + 24 >> 2];
 tflite__GreedyMemoryPlanner__CalculateOffsetsIfNeeded_28_29($0);
 label$1: {
  if (!HEAP32[$0 + 8 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 20 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[$0 + 32 >> 2], 12);
  HEAP32[$1 + 16 >> 2] = 0;
  while (1) {
   label$4: {
    if (!HEAP32[$1 + 20 >> 2]) {
     break label$4;
    }
    HEAP32[$1 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + (HEAP32[HEAP32[$1 + 20 >> 2] + 4 >> 2] << 4);
    HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 20 >> 2] >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
    if (HEAPU32[$1 + 8 >> 2] > HEAPU32[$1 + 16 >> 2]) {
     HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 8 >> 2];
    }
    if (HEAP32[HEAP32[$1 + 20 >> 2] + 8 >> 2] == -1) {
     break label$4;
    }
    HEAP32[$1 + 20 >> 2] = HEAP32[$0 + 24 >> 2] + Math_imul(HEAP32[HEAP32[$1 + 20 >> 2] + 8 >> 2], 12);
    continue;
   }
   break;
  }
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 16 >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function jsvArrayBufferIteratorSetIntegerValue($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1: {
  if (!HEAPU8[HEAP32[$2 + 28 >> 2] + 36 | 0]) {
   break label$1;
  }
  HEAP32[$2 + 8 >> 2] = HEAPU8[HEAP32[$2 + 28 >> 2] + 36 | 0] & 15;
  label$2: {
   if (HEAPU8[HEAP32[$2 + 28 >> 2] + 36 | 0] & 32) {
    jsvArrayBufferIteratorFloatToData($2 + 16 | 0, HEAP32[$2 + 8 >> 2], HEAPU8[HEAP32[$2 + 28 >> 2] + 36 | 0], +HEAP32[$2 + 24 >> 2]);
    break label$2;
   }
   jsvArrayBufferIteratorIntToData($2 + 16 | 0, HEAP32[$2 + 8 >> 2], HEAPU8[HEAP32[$2 + 28 >> 2] + 36 | 0], HEAP32[$2 + 24 >> 2]);
  }
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAPU32[$2 + 12 >> 2] < HEAPU32[$2 + 8 >> 2]) {
    jsvStringIteratorSetChar(HEAP32[$2 + 28 >> 2], HEAP8[HEAP32[$2 + 12 >> 2] + ($2 + 16 | 0) | 0]);
    if (HEAP32[$2 + 8 >> 2] != 1) {
     jsvStringIteratorNext(HEAP32[$2 + 28 >> 2]);
    }
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[$2 + 8 >> 2] == 1) {
   break label$1;
  }
  HEAP8[HEAP32[$2 + 28 >> 2] + 52 | 0] = 1;
 }
 __stack_pointer = $2 + 32 | 0;
}

function graphicsSetModified($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 32 | 0;
 HEAP32[$5 + 28 >> 2] = $0;
 HEAP32[$5 + 24 >> 2] = $1;
 HEAP32[$5 + 20 >> 2] = $2;
 HEAP32[$5 + 16 >> 2] = $3;
 HEAP32[$5 + 12 >> 2] = $4;
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[$5 + 24 >> 2] < (HEAPU8[$0 + 40 | 0] | HEAPU8[$0 + 41 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$5 + 28 >> 2];
  $1 = HEAP32[$5 + 24 >> 2];
  HEAP8[$0 + 40 | 0] = $1;
  HEAP8[$0 + 41 | 0] = $1 >>> 8;
 }
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[$5 + 16 >> 2] > (HEAPU8[$0 + 44 | 0] | HEAPU8[$0 + 45 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$5 + 28 >> 2];
  $1 = HEAP32[$5 + 16 >> 2];
  HEAP8[$0 + 44 | 0] = $1;
  HEAP8[$0 + 45 | 0] = $1 >>> 8;
 }
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[$5 + 20 >> 2] < (HEAPU8[$0 + 42 | 0] | HEAPU8[$0 + 43 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$5 + 28 >> 2];
  $1 = HEAP32[$5 + 20 >> 2];
  HEAP8[$0 + 42 | 0] = $1;
  HEAP8[$0 + 43 | 0] = $1 >>> 8;
 }
 $0 = HEAP32[$5 + 28 >> 2];
 if (HEAP32[$5 + 12 >> 2] > (HEAPU8[$0 + 46 | 0] | HEAPU8[$0 + 47 | 0] << 8) << 16 >> 16) {
  $0 = HEAP32[$5 + 28 >> 2];
  $1 = HEAP32[$5 + 12 >> 2];
  HEAP8[$0 + 46 | 0] = $1;
  HEAP8[$0 + 47 | 0] = $1 >>> 8;
 }
}

function jswrap_math_minmax($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP8[$2 + 43 | 0] = $1 & 1;
 HEAPF64[$2 + 32 >> 3] = HEAP8[$2 + 43 | 0] & 1 ? Math_fround(-infinity) : Math_fround(infinity);
 jsvObjectIteratorNew($2 + 24 | 0, HEAP32[$2 + 44 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue_12($2 + 24 | 0) & 1) {
   HEAPF64[$2 + 16 >> 3] = jsvGetFloatAndUnLock(jsvObjectIteratorGetValue_11($2 + 24 | 0));
   label$3: {
    label$4: {
     if (HEAP8[$2 + 43 | 0] & 1 & HEAPF64[$2 + 16 >> 3] > HEAPF64[$2 + 32 >> 3] | !(HEAP8[$2 + 43 | 0] & 1) & HEAPF64[$2 + 16 >> 3] < HEAPF64[$2 + 32 >> 3]) {
      break label$4;
     }
     $1 = __DOUBLE_BITS_6(HEAPF64[$2 + 16 >> 3]);
     $0 = $1;
     $3 = i64toi32_i32$HIGH_BITS;
     $1 = $3 & 2147483647;
     $3 = $0;
     if (($1 | 0) == 2146435072 & ($3 | 0) != 0 | $1 >>> 0 > 2146435072) {
      break label$4;
     }
     break label$3;
    }
    HEAPF64[$2 + 32 >> 3] = HEAPF64[$2 + 16 >> 3];
   }
   jsvObjectIteratorNext($2 + 24 | 0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree_12($2 + 24 | 0);
 __stack_pointer = $2 + 48 | 0;
 return HEAPF64[$2 + 32 >> 3];
}

function _jswrap_drawImageLayerNextY($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 172 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 168 >> 2] + HEAP32[$0 + 172 >> 2];
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 176 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 164 >> 2] + HEAP32[$0 + 176 >> 2];
 if (HEAP8[HEAP32[$1 + 12 >> 2] + 33 | 0] & 1) {
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 172 >> 2] < 0) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 172 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 156 >> 2] + HEAP32[$0 + 172 >> 2];
  }
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 172 >> 2] >= HEAP32[HEAP32[$1 + 12 >> 2] + 156 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 172 >> 2] = HEAP32[$0 + 172 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 156 >> 2];
  }
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 176 >> 2] < 0) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 176 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2] + HEAP32[$0 + 176 >> 2];
  }
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 176 >> 2] >= HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 176 >> 2] = HEAP32[$0 + 176 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2];
  }
 }
}

function lcdFillRect_ArrayBuffer_flat8($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = __stack_pointer - 48 | 0;
 HEAP32[$6 + 44 >> 2] = $0;
 HEAP32[$6 + 40 >> 2] = $1;
 HEAP32[$6 + 36 >> 2] = $2;
 HEAP32[$6 + 32 >> 2] = $3;
 HEAP32[$6 + 28 >> 2] = $4;
 HEAP32[$6 + 24 >> 2] = $5;
 HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 36 >> 2];
 while (1) {
  if (HEAP32[$6 + 20 >> 2] <= HEAP32[$6 + 28 >> 2]) {
   $1 = HEAP32[$6 + 44 >> 2];
   $0 = HEAP32[$6 + 44 >> 2];
   HEAP32[$6 + 16 >> 2] = (HEAP32[$6 + 40 >> 2] + Math_imul(HEAP32[$6 + 20 >> 2], HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) | 0) + (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24));
   HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 40 >> 2];
   while (1) {
    if (HEAP32[$6 + 12 >> 2] <= HEAP32[$6 + 32 >> 2]) {
     $1 = HEAP32[$6 + 24 >> 2];
     $0 = HEAP32[$6 + 16 >> 2];
     HEAP32[$6 + 16 >> 2] = $0 + 1;
     HEAP8[$0 | 0] = $1;
     HEAP32[$6 + 12 >> 2] = HEAP32[$6 + 12 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$6 + 20 >> 2] = HEAP32[$6 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
}

function jspeConstruct($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP8[$3 + 19 | 0] = $2;
 label$1: {
  if (!(jsvIsFunction(HEAP32[$3 + 24 >> 2]) & 1)) {
   HEAP32[$3 >> 2] = HEAP32[$3 + 24 >> 2];
   jsExceptionHere(1, 119150, $3);
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvNewObject();
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 8 >> 2] = jsvFindOrAddChildFromString(HEAP32[$3 + 24 >> 2], 132159);
  jspEnsureIsPrototype(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 8 >> 2]);
  jsvAddNamedChildAndUnLock(HEAP32[$3 + 12 >> 2], jsvSkipNameAndUnLock(HEAP32[$3 + 8 >> 2]), 135865);
  HEAP32[$3 + 4 >> 2] = jspeFunctionCall(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 12 >> 2], HEAP8[$3 + 19 | 0] & 1, 0, 0);
  label$4: {
   if (HEAP32[$3 + 4 >> 2]) {
    jsvUnLock(HEAP32[$3 + 12 >> 2]);
    HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 4 >> 2];
    break label$4;
   }
   jsvUnLock(HEAP32[$3 + 4 >> 2]);
  }
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jswrap_espruino_getPowerUsage() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 32 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 24 >> 2] = jsvNewObject();
 label$1: {
  if (!HEAP32[$0 + 24 >> 2]) {
   HEAP32[$0 + 28 >> 2] = 0;
   break label$1;
  }
  jsvGetProcessorPowerUsage(HEAP32[$0 + 24 >> 2]);
  if (jshPinGetState(8) & 16) {
   jsvObjectSetChildAndUnLock(HEAP32[$0 + 24 >> 2], 139922, jsvNewFromInteger(8e3));
  }
  jswGetPowerUsage(HEAP32[$0 + 24 >> 2]);
  HEAPF64[$0 + 16 >> 3] = 0;
  jsvObjectIteratorNew($0 + 8 | 0, HEAP32[$0 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_13($0 + 8 | 0) & 1) {
    $1 = jsvGetFloatAndUnLock(jsvObjectIteratorGetValue_12($0 + 8 | 0));
    HEAPF64[$0 + 16 >> 3] = HEAPF64[$0 + 16 >> 3] + $1;
    jsvObjectIteratorNext($0 + 8 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_13($0 + 8 | 0);
  HEAP32[$0 + 4 >> 2] = jsvNewObject();
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 4 >> 2], 132876, HEAP32[$0 + 24 >> 2]);
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 4 >> 2], 129052, jsvNewFromFloat(HEAPF64[$0 + 16 >> 3]));
  HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 4 >> 2];
 }
 __stack_pointer = $0 + 32 | 0;
 return HEAP32[$0 + 28 >> 2];
}

function _jswrap_espruino_FFT_setData($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 96 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 92 >> 2] = $0;
 HEAP32[$4 + 88 >> 2] = $1;
 HEAP32[$4 + 84 >> 2] = $2;
 HEAP32[$4 + 80 >> 2] = $3;
 jsvIteratorNew($4 + 16 | 0, HEAP32[$4 + 92 >> 2], 1);
 HEAP32[$4 + 12 >> 2] = 0;
 while (1) {
  $0 = 0;
  if (HEAPU32[$4 + 12 >> 2] < HEAPU32[$4 + 80 >> 2]) {
   $0 = jsvIteratorHasElement($4 + 16 | 0);
  }
  if ($0 & 1) {
   label$4: {
    if (HEAP32[$4 + 84 >> 2]) {
     HEAPF64[$4 >> 3] = jswrap_math_sqrt(HEAPF64[HEAP32[$4 + 88 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 3] * HEAPF64[HEAP32[$4 + 88 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 3] + HEAPF64[HEAP32[$4 + 84 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 3] * HEAPF64[HEAP32[$4 + 84 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 3]);
     break label$4;
    }
    HEAPF64[$4 >> 3] = HEAPF64[HEAP32[$4 + 88 >> 2] + (HEAP32[$4 + 12 >> 2] << 3) >> 3];
   }
   jsvUnLock(jsvIteratorSetValue($4 + 16 | 0, jsvNewFromFloat(HEAPF64[$4 >> 3])));
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] + 1;
   jsvIteratorNext($4 + 16 | 0);
   continue;
  }
  break;
 }
 jsvIteratorFree($4 + 16 | 0);
 __stack_pointer = $4 + 96 | 0;
}

function jsvIteratorGetValue($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  label$2: {
   switch (HEAP32[HEAP32[$1 + 8 >> 2] >> 2] - 1 | 0) {
   case 3:
    label$7: {
     if (!(jsvIsIntegerish(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) & 1)) {
      break label$7;
     }
     if ((jsvGetInteger(HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2]) | 0) != HEAP32[HEAP32[$1 + 8 >> 2] + 12 >> 2]) {
      break label$7;
     }
     HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue_1(HEAP32[$1 + 8 >> 2] + 4 | 0);
     break label$1;
    }
    HEAP32[$1 + 12 >> 2] = 0;
    break label$1;

   case 1:
    HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue_1(HEAP32[$1 + 8 >> 2] + 4 | 0);
    break label$1;

   case 0:
    HEAP8[$1 + 7 | 0] = jsvStringIteratorGetChar_2(HEAP32[$1 + 8 >> 2] + 4 | 0);
    HEAP32[$1 + 12 >> 2] = jsvNewStringOfLength(1, $1 + 7 | 0);
    break label$1;

   case 2:
    HEAP32[$1 + 12 >> 2] = jsvArrayBufferIteratorGetValueAndRewind(HEAP32[$1 + 8 >> 2] + 4 | 0);
    break label$1;

   default:
    break label$2;
   }
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function std____2____compressed_pair_TfLiteSoftmaxParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_____compressed_pair_TfLiteSoftmaxParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28TfLiteSoftmaxParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 std____2____compressed_pair_elem_TfLiteSoftmaxParams__2c_200_2c_20false_____compressed_pair_elem_TfLiteSoftmaxParams___2c_20void__28TfLiteSoftmaxParams___29($0, HEAP32[$3 + 8 >> 2]);
 std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_20void__28tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0 + 4 | 0, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function std____2____compressed_pair_TfLiteReshapeParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_____compressed_pair_TfLiteReshapeParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28TfLiteReshapeParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 std____2____compressed_pair_elem_TfLiteReshapeParams__2c_200_2c_20false_____compressed_pair_elem_TfLiteReshapeParams___2c_20void__28TfLiteReshapeParams___29($0, HEAP32[$3 + 8 >> 2]);
 std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_20void__28tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0 + 4 | 0, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function jspeBlockNoBrackets() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = jspeBlockStart();
 label$1: {
  if ((HEAP32[91094] & 63) == 1) {
   while (1) {
    $1 = 0;
    label$5: {
     $1 = HEAP16[HEAP32[49079] + 2 >> 1] ? HEAP16[HEAP32[49079] + 2 >> 1] != 125 : $1;
     if (!$1) {
      break label$5;
     }
     HEAP32[$0 + 8 >> 2] = jspeStatement();
     jsvCheckReferenceError(HEAP32[$0 + 8 >> 2]);
     jsvUnLock(HEAP32[$0 + 8 >> 2]);
     if (!HEAP32[49079] | HEAP32[91094] & 128 ? 0 : HEAP32[91094] & 112) {
      HEAP32[91094] = HEAP32[91094] | 128;
      HEAP32[$0 + 4 >> 2] = jsvObjectGetChild(HEAP32[91087], 132883, 28);
      if (HEAP32[$0 + 4 >> 2]) {
       jsvAppendPrintf(HEAP32[$0 + 4 >> 2], 146080, 0);
       jspAppendStackTrace(HEAP32[$0 + 4 >> 2]);
       jsvUnLock(HEAP32[$0 + 4 >> 2]);
      }
     }
     if (HEAP32[91094] & 80) {
      break label$5;
     }
     if ((HEAP32[91094] & 63) != 1) {
      jspeSkipBlock();
      break label$5;
     }
     continue;
    }
    break;
   }
   break label$1;
  }
  jspeSkipBlock();
 }
 jspeBlockEnd(HEAP32[$0 + 12 >> 2]);
 __stack_pointer = $0 + 16 | 0;
}

function jspNewPrototype($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP8[$2 + 23 | 0] = $1;
 HEAP32[$2 + 16 >> 2] = jsvFindOrAddChildFromString(HEAP32[91086], HEAP32[$2 + 24 >> 2]);
 label$1: {
  if (!HEAP32[$2 + 16 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvSkipName(HEAP32[$2 + 16 >> 2]);
  if (!HEAP32[$2 + 12 >> 2]) {
   HEAP32[$2 + 12 >> 2] = jspNewBuiltin(HEAP32[$2 + 24 >> 2]);
   if (!HEAP32[$2 + 12 >> 2]) {
    jsvUnLock(HEAP32[$2 + 16 >> 2]);
    HEAP32[$2 + 28 >> 2] = 0;
    break label$1;
   }
   jsvSetValueOfName(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2]);
  }
  HEAP32[$2 + 8 >> 2] = jsvFindOrAddChildFromString(HEAP32[$2 + 12 >> 2], 132159);
  jspEnsureIsPrototype(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  if (HEAP8[$2 + 23 | 0] & 1) {
   $0 = HEAP32[$2 + 8 >> 2];
  } else {
   $0 = HEAP32[$2 + 12 >> 2];
  }
  jsvUnLock2($0, HEAP32[$2 + 16 >> 2]);
  if (HEAP8[$2 + 23 | 0] & 1) {
   $0 = HEAP32[$2 + 12 >> 2];
  } else {
   $0 = HEAP32[$2 + 8 >> 2];
  }
  HEAP32[$2 + 28 >> 2] = $0;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jsvNewWithFlags($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP16[$1 + 10 >> 1] = $0;
 label$1: {
  if (HEAPU8[196322]) {
   HEAP8[364342] = HEAPU8[364342] | 32;
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = 0;
  jshInterruptOff();
  if (HEAPU16[98162]) {
   HEAP32[$1 + 4 >> 2] = jsvGetAddressOf(HEAPU16[98162]);
   HEAP16[98162] = jsvGetNextSibling(HEAP32[$1 + 4 >> 2]);
   HEAP8[196321] = 1;
  }
  jshInterruptOn();
  if (HEAP32[$1 + 4 >> 2]) {
   jsvResetVariable(HEAP32[$1 + 4 >> 2], HEAPU16[$1 + 10 >> 1]);
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
   break label$1;
  }
  HEAP8[364342] = HEAPU8[364342] | 8;
  if (jshIsInInterrupt() & 1) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  if (jsvGarbageCollect()) {
   HEAP32[$1 + 12 >> 2] = jsvNewWithFlags(HEAPU16[$1 + 10 >> 1]);
   break label$1;
  }
  if (jsiFreeMoreMemory() & 1) {
   HEAP32[$1 + 12 >> 2] = jsvNewWithFlags(HEAPU16[$1 + 10 >> 1]);
   break label$1;
  }
  HEAP8[364342] = HEAPU8[364342] | 16;
  jspSetInterrupted(1);
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_object_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1: {
  label$2: {
   label$3: {
    if (jsvIsObject(HEAP32[$1 + 24 >> 2]) & 1) {
     break label$3;
    }
    if (jsvIsArray(HEAP32[$1 + 24 >> 2]) & 1) {
     break label$3;
    }
    if (!(jsvIsFunction(HEAP32[$1 + 24 >> 2]) & 1)) {
     break label$2;
    }
   }
   HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 24 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 20 >> 2] = jswGetBasicObjectName(HEAP32[$1 + 24 >> 2]);
  label$4: {
   if (HEAP32[$1 + 20 >> 2]) {
    $0 = jspGetNamedVariable(HEAP32[$1 + 20 >> 2]);
    break label$4;
   }
   $0 = 0;
  }
  HEAP32[$1 + 16 >> 2] = $0;
  if (!HEAP32[$1 + 16 >> 2]) {
   HEAP32[$1 + 28 >> 2] = jsvNewObject();
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[$1 + 16 >> 2]);
  HEAP32[$1 + 8 >> 2] = jspeFunctionCall(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 16 >> 2], 0, 0, 1, $1 + 24 | 0);
  jsvUnLock2(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2]);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 8 >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function tflite__TfLiteEvalTensorByteLength_28TfLiteEvalTensor_20const__2c_20unsigned_20long__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (!HEAP32[$2 + 20 >> 2]) {
   break label$1;
  }
 }
 HEAP32[$2 + 16 >> 2] = 1;
 if (HEAP32[HEAP32[$2 + 24 >> 2] + 4 >> 2]) {
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 12 >> 2] < HEAP32[HEAP32[HEAP32[$2 + 24 >> 2] + 4 >> 2] >> 2]) {
    HEAP32[$2 + 16 >> 2] = Math_imul(HEAP32[(HEAP32[HEAP32[$2 + 24 >> 2] + 4 >> 2] + 4 | 0) + (HEAP32[$2 + 12 >> 2] << 2) >> 2], HEAP32[$2 + 16 >> 2]);
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
 }
 HEAP32[$2 + 4 >> 2] = tflite__TfLiteTypeSizeOf_28TfLiteType_2c_20unsigned_20long__29(HEAP32[HEAP32[$2 + 24 >> 2] + 8 >> 2], $2 + 8 | 0);
 label$5: {
  if (HEAP32[$2 + 4 >> 2]) {
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 4 >> 2];
   break label$5;
  }
  HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = Math_imul(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 8 >> 2]);
  HEAP32[$2 + 28 >> 2] = 0;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jsvSetCharactersInVar($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 2 >> 1] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & -64;
 label$1: {
  if (HEAPU32[$2 + 4 >> 2] <= 27) {
   if (HEAPU32[$2 + 4 >> 2] <= 22) {
    $0 = HEAP32[$2 + 12 >> 2];
    $1 = HEAPU16[$2 + 2 >> 1] | HEAP32[$2 + 8 >> 2] + 18;
    HEAP8[$0 + 12 | 0] = $1;
    HEAP8[$0 + 13 | 0] = $1 >>> 8;
    break label$1;
   }
   $0 = HEAP32[$2 + 12 >> 2];
   $1 = HEAPU16[$2 + 2 >> 1] | HEAP32[$2 + 8 >> 2] + 23;
   HEAP8[$0 + 12 | 0] = $1;
   HEAP8[$0 + 13 | 0] = $1 >>> 8;
   break label$1;
  }
  label$4: {
   if (HEAPU32[$2 + 4 >> 2] <= 37) {
    $0 = HEAP32[$2 + 12 >> 2];
    $1 = HEAPU16[$2 + 2 >> 1] | HEAP32[$2 + 8 >> 2] + 28;
    HEAP8[$0 + 12 | 0] = $1;
    HEAP8[$0 + 13 | 0] = $1 >>> 8;
    break label$4;
   }
   $0 = HEAP32[$2 + 12 >> 2];
   $1 = HEAPU16[$2 + 2 >> 1] | HEAP32[$2 + 8 >> 2] + 41;
   HEAP8[$0 + 12 | 0] = $1;
   HEAP8[$0 + 13 | 0] = $1 >>> 8;
  }
 }
}

function tflite__GreedyMemoryPlanner__AddBuffer_28tflite__ErrorReporter__2c_20int_2c_20int_2c_20int_29($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 24 >> 2] = $0;
 HEAP32[$5 + 20 >> 2] = $1;
 HEAP32[$5 + 16 >> 2] = $2;
 HEAP32[$5 + 12 >> 2] = $3;
 HEAP32[$5 + 8 >> 2] = $4;
 $0 = HEAP32[$5 + 24 >> 2];
 label$1: {
  if (HEAP32[$0 + 8 >> 2] >= HEAP32[$0 + 4 >> 2]) {
   $1 = HEAP32[$5 + 20 >> 2];
   HEAP32[$5 >> 2] = HEAP32[$0 + 4 >> 2];
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($1, 143168, $5);
   HEAP32[$5 + 28 >> 2] = 1;
   break label$1;
  }
  HEAP32[$5 + 4 >> 2] = HEAP32[$0 + 12 >> 2] + (HEAP32[$0 + 8 >> 2] << 4);
  HEAP32[HEAP32[$5 + 4 >> 2] >> 2] = HEAP32[$5 + 16 >> 2];
  HEAP32[HEAP32[$5 + 4 >> 2] + 8 >> 2] = HEAP32[$5 + 12 >> 2];
  HEAP32[HEAP32[$5 + 4 >> 2] + 12 >> 2] = HEAP32[$5 + 8 >> 2];
  HEAP32[HEAP32[$5 + 4 >> 2] + 4 >> 2] = -1;
  HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 1;
  HEAP8[$0 + 40 | 0] = 1;
  HEAP32[$5 + 28 >> 2] = 0;
 }
 __stack_pointer = $5 + 32 | 0;
 return HEAP32[$5 + 28 >> 2];
}

function std____2____compressed_pair_TfLitePoolParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_____compressed_pair_TfLitePoolParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28TfLitePoolParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 std____2____compressed_pair_elem_TfLitePoolParams__2c_200_2c_20false_____compressed_pair_elem_TfLitePoolParams___2c_20void__28TfLitePoolParams___29($0, HEAP32[$3 + 8 >> 2]);
 std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_20void__28tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0 + 4 | 0, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_____compressed_pair_TfLiteConvParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28TfLiteConvParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 std____2____compressed_pair_elem_TfLiteConvParams__2c_200_2c_20false_____compressed_pair_elem_TfLiteConvParams___2c_20void__28TfLiteConvParams___29($0, HEAP32[$3 + 8 >> 2]);
 std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_20void__28tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0 + 4 | 0, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function tflite__MicroAllocator__PopulateTfLiteTensorFromFlatbuffer_28tflite__Model_20const__2c_20tflite__SubGraph_20const__2c_20TfLiteTensor__2c_20int_2c_20bool_29($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = __stack_pointer - 32 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP8[$6 + 11 | 0] = $5;
 $0 = HEAP32[$6 + 28 >> 2];
 $0 = tflite__internal__InitializeTfLiteTensorFromFlatbuffer_28tflite__SimpleMemoryAllocator__2c_20bool_2c_20tflite__Tensor_20const__2c_20flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer___20const__2c_20tflite__ErrorReporter__2c_20TfLiteTensor__29(HEAP32[$0 + 4 >> 2], HEAP8[$6 + 11 | 0] & 1, flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor____Get_28unsigned_20int_29_20const(tflite__SubGraph__tensors_28_29_20const(HEAP32[$6 + 20 >> 2]), HEAP32[$6 + 12 >> 2]), tflite__Model__buffers_28_29_20const(HEAP32[$6 + 24 >> 2]), HEAP32[$0 + 8 >> 2], HEAP32[$6 + 16 >> 2]);
 __stack_pointer = $6 + 32 | 0;
 return $0 | 0;
}

function jspeGetBinaryExpressionPrecedence($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  label$2: {
   switch (HEAP32[$1 + 8 >> 2] - 37 | 0) {
   case 123:
   case 171:
    HEAP32[$1 + 12 >> 2] = 1;
    break label$1;

   case 121:
    HEAP32[$1 + 12 >> 2] = 2;
    break label$1;

   case 87:
    HEAP32[$1 + 12 >> 2] = 3;
    break label$1;

   case 57:
    HEAP32[$1 + 12 >> 2] = 4;
    break label$1;

   case 1:
    HEAP32[$1 + 12 >> 2] = 5;
    break label$1;

   case 101:
   case 102:
   case 103:
   case 104:
    HEAP32[$1 + 12 >> 2] = 6;
    break label$1;

   case 23:
   case 25:
   case 105:
   case 108:
   case 149:
    HEAP32[$1 + 12 >> 2] = 7;
    break label$1;

   case 148:
    HEAP32[$1 + 12 >> 2] = HEAP32[91094] & 256 ? 0 : 7;
    break label$1;

   case 106:
   case 109:
   case 110:
    HEAP32[$1 + 12 >> 2] = 8;
    break label$1;

   case 6:
   case 8:
    HEAP32[$1 + 12 >> 2] = 9;
    break label$1;

   case 0:
   case 5:
   case 10:
    HEAP32[$1 + 12 >> 2] = 10;
    break label$1;

   default:
    break label$2;
   }
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 return HEAP32[$1 + 12 >> 2];
}
function jswrap_heatshrink_compress($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 128 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 120 >> 2] = $0;
 label$1: {
  if (!(jsvIsIterable(HEAP32[$1 + 120 >> 2]) & 1)) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 120 >> 2];
   jsExceptionHere(3, 118982, $1);
   HEAP32[$1 + 124 >> 2] = 0;
   break label$1;
  }
  jsvIteratorNew($1 + 56 | 0, HEAP32[$1 + 120 >> 2], 1);
  HEAP32[$1 + 12 >> 2] = heatshrink_encode_cb(660, $1 + 56 | 0, 0, 0);
  jsvIteratorFree($1 + 56 | 0);
  HEAP32[$1 + 8 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 12 >> 2], 0);
  if (!HEAP32[$1 + 8 >> 2]) {
   jsError(117639, 0);
   HEAP32[$1 + 124 >> 2] = 0;
   break label$1;
  }
  jsvIteratorNew($1 + 56 | 0, HEAP32[$1 + 120 >> 2], 1);
  jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 8 >> 2], 0);
  heatshrink_encode_cb(660, $1 + 56 | 0, 661, $1 + 16 | 0);
  jsvStringIteratorFree_15($1 + 16 | 0);
  jsvIteratorFree($1 + 56 | 0);
  HEAP32[$1 + 4 >> 2] = jsvNewArrayBufferFromString(HEAP32[$1 + 8 >> 2], 0);
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
  HEAP32[$1 + 124 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 __stack_pointer = $1 + 128 | 0;
 return HEAP32[$1 + 124 >> 2];
}

function jswrap_promise_resolve($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = 0;
 label$1: {
  if (_jswrap_promise_is_promise(HEAP32[$1 + 24 >> 2]) & 1) {
   HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 24 >> 2]);
   break label$1;
  }
  if (jsvIsObject(HEAP32[$1 + 24 >> 2]) & 1) {
   HEAP32[$1 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 24 >> 2], 128541);
   if (jsvIsFunction(HEAP32[$1 + 16 >> 2]) & 1) {
    HEAP32[$1 + 20 >> 2] = jswrap_promise_constructor(HEAP32[$1 + 16 >> 2]);
   }
   jsvUnLock(HEAP32[$1 + 16 >> 2]);
   if (HEAP32[$1 + 20 >> 2]) {
    HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
    break label$1;
   }
  }
  HEAP32[$1 + 12 >> 2] = jspromise_create_prombox($1 + 20 | 0);
  if (!HEAP32[$1 + 12 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$1 + 20 >> 2]) {
   _jswrap_prombox_queueresolve(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 24 >> 2]);
  }
  jsvUnLock(HEAP32[$1 + 12 >> 2]);
  HEAP32[$1 + 28 >> 2] = jsvLockAgainSafe(HEAP32[$1 + 20 >> 2]);
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function nomatchfound($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 144 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 136 >> 2] = $0;
 label$1: {
  if (!(jspCheckStackPosition() & 1)) {
   HEAP32[$2 + 140 >> 2] = 0;
   break label$1;
  }
  while (1) {
   $0 = 0;
   $0 = HEAP8[HEAP32[$2 + 136 >> 2]] ? HEAP8[HEAP32[$2 + 136 >> 2]] != 124 : $0;
   if ($0) {
    if (HEAP8[HEAP32[$2 + 136 >> 2]] == 92) {
     HEAP32[$2 + 136 >> 2] = HEAP32[$2 + 136 >> 2] + 1;
     if (!HEAPU8[HEAP32[$2 + 136 >> 2]]) {
      HEAP32[$2 + 140 >> 2] = 0;
      break label$1;
     }
    }
    HEAP32[$2 + 136 >> 2] = HEAP32[$2 + 136 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP8[HEAP32[$2 + 136 >> 2]] != 124) {
   HEAP32[$2 + 140 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 136 >> 2] = HEAP32[$2 + 136 >> 2] + 1;
  jsvStringIteratorNew($2 + 96 | 0, HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2]);
  $0 = HEAP32[$2 + 136 >> 2];
  __memcpy($2 + 4 | 0, $1, 88);
  HEAP32[$2 + 92 >> 2] = matchhere($0, $2 + 96 | 0, $2 + 4 | 0);
  jsvStringIteratorFree_9($2 + 96 | 0);
  HEAP32[$2 + 140 >> 2] = HEAP32[$2 + 92 >> 2];
 }
 __stack_pointer = $2 + 144 | 0;
 return HEAP32[$2 + 140 >> 2];
}

function jsvNewFlatStringFromStringVar($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 96 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 92 >> 2] = $0;
 HEAP32[$3 + 88 >> 2] = $1;
 HEAP32[$3 + 84 >> 2] = $2;
 HEAP32[$3 + 80 >> 2] = jsvGetStringLength(HEAP32[$3 + 92 >> 2]);
 label$1: {
  if (HEAPU32[$3 + 88 >> 2] > HEAPU32[$3 + 80 >> 2]) {
   HEAP32[$3 + 80 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 80 >> 2] = HEAP32[$3 + 80 >> 2] - HEAP32[$3 + 88 >> 2];
 }
 if (HEAPU32[$3 + 80 >> 2] > HEAPU32[$3 + 84 >> 2]) {
  HEAP32[$3 + 80 >> 2] = HEAP32[$3 + 84 >> 2];
 }
 HEAP32[$3 + 76 >> 2] = jsvNewFlatStringOfLength(HEAP32[$3 + 80 >> 2]);
 if (HEAP32[$3 + 76 >> 2]) {
  jsvStringIteratorNew($3 + 40 | 0, HEAP32[$3 + 92 >> 2], HEAP32[$3 + 88 >> 2]);
  jsvStringIteratorNew($3, HEAP32[$3 + 76 >> 2], 0);
  while (1) {
   $0 = HEAP32[$3 + 80 >> 2];
   HEAP32[$3 + 80 >> 2] = $0 - 1;
   if ($0) {
    jsvStringIteratorSetCharAndNext($3, jsvStringIteratorGetCharAndNext($3 + 40 | 0) << 24 >> 24);
    continue;
   }
   break;
  }
  jsvStringIteratorFree_1($3 + 40 | 0);
  jsvStringIteratorFree_1($3);
 }
 __stack_pointer = $3 + 96 | 0;
 return HEAP32[$3 + 76 >> 2];
}

function tflite__SimpleMemoryAllocator__AllocateFromTail_28unsigned_20long_2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 $0 = HEAP32[$3 + 40 >> 2];
 HEAP32[$3 + 28 >> 2] = tflite__AlignPointerDown_28unsigned_20char__2c_20unsigned_20long_29(HEAP32[$0 + 20 >> 2] - HEAP32[$3 + 36 >> 2] | 0, HEAP32[$3 + 32 >> 2]);
 label$1: {
  if (HEAPU32[$3 + 28 >> 2] < HEAPU32[$0 + 16 >> 2]) {
   HEAP32[$3 + 24 >> 2] = HEAP32[$0 + 16 >> 2] - HEAP32[$3 + 28 >> 2];
   $0 = HEAP32[$0 + 4 >> 2];
   $1 = HEAP32[$3 + 36 >> 2];
   $2 = HEAP32[$3 + 36 >> 2];
   $4 = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 4 >> 2] = $2 - $4;
   HEAP32[$3 >> 2] = $1;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 116979, $3);
   HEAP32[$3 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 20 >> 2] = HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 28 >> 2];
 }
 __stack_pointer = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}

function jswrap_heatshrink_decompress($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 128 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 120 >> 2] = $0;
 label$1: {
  if (!(jsvIsIterable(HEAP32[$1 + 120 >> 2]) & 1)) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 120 >> 2];
   jsExceptionHere(3, 118982, $1);
   HEAP32[$1 + 124 >> 2] = 0;
   break label$1;
  }
  jsvIteratorNew($1 + 56 | 0, HEAP32[$1 + 120 >> 2], 1);
  HEAP32[$1 + 12 >> 2] = heatshrink_decode(660, $1 + 56 | 0, 0);
  jsvIteratorFree($1 + 56 | 0);
  HEAP32[$1 + 8 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 12 >> 2], 0);
  if (!HEAP32[$1 + 8 >> 2]) {
   jsError(117639, 0);
   HEAP32[$1 + 124 >> 2] = 0;
   break label$1;
  }
  jsvIteratorNew($1 + 56 | 0, HEAP32[$1 + 120 >> 2], 1);
  jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 8 >> 2], 0);
  heatshrink_decode_cb(660, $1 + 56 | 0, 661, $1 + 16 | 0);
  jsvStringIteratorFree_15($1 + 16 | 0);
  jsvIteratorFree($1 + 56 | 0);
  HEAP32[$1 + 4 >> 2] = jsvNewArrayBufferFromString(HEAP32[$1 + 8 >> 2], 0);
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
  HEAP32[$1 + 124 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 __stack_pointer = $1 + 128 | 0;
 return HEAP32[$1 + 124 >> 2];
}

function jswrap_graphics_setPixel($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 112 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 104 >> 2] = $0;
 HEAP32[$4 + 100 >> 2] = $1;
 HEAP32[$4 + 96 >> 2] = $2;
 HEAP32[$4 + 92 >> 2] = $3;
 label$1: {
  if (!(graphicsGetFromVar($4 + 16 | 0, HEAP32[$4 + 104 >> 2]) & 1)) {
   HEAP32[$4 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 12 >> 2] = HEAPU8[$4 + 33 | 0] | HEAPU8[$4 + 34 | 0] << 8 | (HEAPU8[$4 + 35 | 0] << 16 | HEAPU8[$4 + 36 | 0] << 24);
  if (!(jsvIsUndefined(HEAP32[$4 + 92 >> 2]) & 1)) {
   HEAP32[$4 + 12 >> 2] = jswrap_graphics_toColor(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 92 >> 2], 0, 0);
  }
  graphicsSetPixel($4 + 16 | 0, HEAP32[$4 + 100 >> 2], HEAP32[$4 + 96 >> 2], HEAP32[$4 + 12 >> 2]);
  $0 = HEAP32[$4 + 100 >> 2];
  HEAP8[$4 + 43 | 0] = $0;
  HEAP8[$4 + 44 | 0] = $0 >>> 8;
  $0 = HEAP32[$4 + 96 >> 2];
  HEAP8[$4 + 45 | 0] = $0;
  HEAP8[$4 + 46 | 0] = $0 >>> 8;
  graphicsSetVar($4 + 16 | 0);
  HEAP32[$4 + 108 >> 2] = jsvLockAgain(HEAP32[$4 + 104 >> 2]);
 }
 __stack_pointer = $4 + 112 | 0;
 return HEAP32[$4 + 108 >> 2];
}

function jspeFunctionArguments($0) {
 var $1 = 0;
 $1 = __stack_pointer - 96 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 88 >> 2] = $0;
 label$1: {
  if (!(jslMatch(40) & 1)) {
   HEAP8[$1 + 95 | 0] = 0;
   break label$1;
  }
  while (1) {
   if (HEAP16[HEAP32[49079] + 2 >> 1] != 41) {
    if (HEAP32[$1 + 88 >> 2]) {
     HEAP8[$1 + 16 | 0] = 255;
     strcpy($1 + 17 | 0, jslGetTokenValueAsString());
     HEAP32[$1 + 12 >> 2] = jsvAddNamedChild(HEAP32[$1 + 88 >> 2], 0, $1 + 16 | 0);
     if (!HEAP32[$1 + 12 >> 2]) {
      jspSetError(0);
      HEAP8[$1 + 95 | 0] = 0;
      break label$1;
     }
     HEAP32[$1 + 12 >> 2] = jsvMakeFunctionParameter(HEAP32[$1 + 12 >> 2]);
     jsvUnLock(HEAP32[$1 + 12 >> 2]);
    }
    if (!(jslMatch(128) & 1)) {
     HEAP8[$1 + 95 | 0] = 0;
     break label$1;
    }
    if (HEAP16[HEAP32[49079] + 2 >> 1] != 41) {
     if (!(jslMatch(44) & 1)) {
      HEAP8[$1 + 95 | 0] = 0;
      break label$1;
     }
    }
    continue;
   }
   break;
  }
  if (!(jslMatch(41) & 1)) {
   HEAP8[$1 + 95 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 95 | 0] = 1;
 }
 __stack_pointer = $1 + 96 | 0;
 return HEAP8[$1 + 95 | 0] & 1;
}

function jshSetFlowControlXON($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 if (!(HEAPU8[$2 + 15 | 0] < 21 | HEAPU8[$2 + 15 | 0] > 22)) {
  if (!(HEAP8[$2 + 14 | 0] & 1)) {
   HEAP8[366352] = 1;
  }
  HEAP32[$2 + 8 >> 2] = HEAPU8[$2 + 15 | 0] - 21;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2] + 364488;
  if (HEAPU8[HEAP32[$2 + 4 >> 2]] & 8) {
   label$4: {
    if (HEAP8[$2 + 14 | 0] & 1) {
     if ((HEAPU8[HEAP32[$2 + 4 >> 2]] & 6) == 4) {
      jshInterruptOff();
      $0 = HEAP32[$2 + 4 >> 2];
      HEAP8[$0 | 0] = HEAPU8[$0 | 0] | 2;
      jshInterruptOn();
      jshUSARTKick(HEAPU8[$2 + 15 | 0]);
     }
     break label$4;
    }
    if (!(HEAPU8[HEAP32[$2 + 4 >> 2]] & 5)) {
     jshInterruptOff();
     $0 = HEAP32[$2 + 4 >> 2];
     HEAP8[$0 | 0] = HEAPU8[$0 | 0] | 1;
     jshInterruptOn();
     jshUSARTKick(HEAPU8[$2 + 15 | 0]);
    }
   }
  }
  HEAP8[$2 + 3 | 0] = HEAPU8[HEAP32[$2 + 8 >> 2] + 364490 | 0];
  if (HEAPU8[$2 + 3 | 0] != 255) {
   jshPinSetValue(HEAPU8[$2 + 3 | 0], (HEAPU8[$2 + 14 | 0] ^ -1) & 1);
  }
 }
 __stack_pointer = $2 + 16 | 0;
}

function jshGetPinFromString($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(!HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] | !(HEAP8[HEAP32[$1 + 8 >> 2]] <= 73 & HEAP8[HEAP32[$1 + 8 >> 2]] >= 65) & HEAP8[HEAP32[$1 + 8 >> 2]] != 86)) {
   HEAP32[$1 + 4 >> 2] = HEAP8[HEAP32[$1 + 8 >> 2]] == 86 ? 10 : HEAP8[HEAP32[$1 + 8 >> 2]] + -64 | 0;
   HEAP32[$1 >> 2] = -1;
   if (!(HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] < 48 | HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] > 57)) {
    label$8: {
     if (!HEAPU8[HEAP32[$1 + 8 >> 2] + 2 | 0]) {
      HEAP32[$1 >> 2] = HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] - 48;
      break label$8;
     }
     if (!(HEAPU8[HEAP32[$1 + 8 >> 2] + 3 | 0] ? 1 : HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] < 48 | HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] > 57)) {
      HEAP32[$1 >> 2] = (HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] + Math_imul(HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0], 10) | 0) - 528;
     }
    }
   }
   if (HEAP32[$1 + 4 >> 2] == 4 & HEAP32[$1 >> 2] < 48 & HEAP32[$1 >> 2] >= 0) {
    HEAP8[$1 + 15 | 0] = HEAP32[$1 >> 2];
    break label$1;
   }
  }
  HEAP8[$1 + 15 | 0] = 255;
 }
 return HEAPU8[$1 + 15 | 0];
}

function jsvStringTrimRight($0) {
 var $1 = 0;
 $1 = __stack_pointer - 96 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 92 >> 2] = $0;
 HEAP32[$1 + 12 >> 2] = jsvNewFromEmptyString_1();
 jsvStringIteratorNew($1 + 56 | 0, HEAP32[$1 + 92 >> 2], 0);
 jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 12 >> 2], 0);
 HEAP32[$1 + 8 >> 2] = 0;
 while (1) {
  if (jsvStringIteratorHasChar_1($1 + 56 | 0) & 1) {
   HEAP8[$1 + 7 | 0] = jsvStringIteratorGetCharAndNext($1 + 56 | 0);
   label$3: {
    if (HEAP8[$1 + 7 | 0] == 32) {
     HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
     break label$3;
    }
    label$5: {
     if (HEAP8[$1 + 7 | 0] == 10) {
      HEAP32[$1 + 8 >> 2] = 0;
      break label$5;
     }
     while (1) {
      if (HEAP32[$1 + 8 >> 2] > 0) {
       jsvStringIteratorAppend($1 + 16 | 0, 32);
       HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] - 1;
       continue;
      }
      break;
     }
    }
    jsvStringIteratorAppend($1 + 16 | 0, HEAP8[$1 + 7 | 0]);
   }
   continue;
  }
  break;
 }
 jsvStringIteratorFree_1($1 + 56 | 0);
 jsvStringIteratorFree_1($1 + 16 | 0);
 __stack_pointer = $1 + 96 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsi2cRead($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP8[$5 + 39 | 0] = $1;
 HEAP32[$5 + 32 >> 2] = $2;
 HEAP32[$5 + 28 >> 2] = $3;
 HEAP8[$5 + 27 | 0] = $4;
 label$1: {
  if (!(HEAPU8[HEAP32[$5 + 40 >> 2] + 4 | 0] != 255 & HEAPU8[HEAP32[$5 + 40 >> 2] + 5 | 0] != 255)) {
   HEAP8[$5 + 47 | 0] = 0;
   break label$1;
  }
  i2c_initstruct($5 + 8 | 0, HEAP32[$5 + 40 >> 2]);
  i2c_start($5 + 8 | 0);
  if (!(i2c_wr($5 + 8 | 0, HEAPU8[$5 + 39 | 0] << 1 | 1) & 1)) {
   HEAP8[$5 + 47 | 0] = 0;
   break label$1;
  }
  HEAP32[$5 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$5 + 4 >> 2] < HEAP32[$5 + 32 >> 2]) {
    $0 = i2c_rd($5 + 8 | 0, HEAP32[$5 + 4 >> 2] == (HEAP32[$5 + 32 >> 2] - 1 | 0));
    HEAP8[HEAP32[$5 + 28 >> 2] + HEAP32[$5 + 4 >> 2] | 0] = $0;
    HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP8[$5 + 27 | 0] & 1) {
   i2c_stop($5 + 8 | 0);
  }
  HEAP8[HEAP32[$5 + 40 >> 2] + 6 | 0] = HEAP8[$5 + 10 | 0] & 1;
  HEAP8[$5 + 47 | 0] = 1;
 }
 __stack_pointer = $5 + 48 | 0;
 return HEAP8[$5 + 47 | 0] & 1;
}

function jsvGetTypeOf($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (jsvIsUndefined(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 133948;
   break label$1;
  }
  label$3: {
   label$4: {
    if (jsvIsNull(HEAP32[$1 + 8 >> 2]) & 1) {
     break label$4;
    }
    if (jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1) {
     break label$4;
    }
    if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
     break label$4;
    }
    if (!(jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1)) {
     break label$3;
    }
   }
   HEAP32[$1 + 12 >> 2] = 117896;
   break label$1;
  }
  if (jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 128345;
   break label$1;
  }
  if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 129769;
   break label$1;
  }
  if (jsvIsBoolean(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 128546;
   break label$1;
  }
  if (jsvIsNumeric(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 121439;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 138351;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function lcdMemLCD_init($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 $0 = HEAP32[$1 + 28 >> 2];
 HEAP8[$0 + 12 | 0] = 176;
 HEAP8[$0 + 13 | 0] = 0;
 $0 = HEAP32[$1 + 28 >> 2];
 HEAP8[$0 + 14 | 0] = 176;
 HEAP8[$0 + 15 | 0] = 0;
 HEAP8[HEAP32[$1 + 28 >> 2] + 16 | 0] = 16;
 memset(378848, 0, 12104);
 HEAP32[$1 + 24 >> 2] = 0;
 while (1) {
  if (HEAP32[$1 + 24 >> 2] < 176) {
   $0 = jswrap_espruino_reverseByte(128);
   HEAP8[Math_imul(HEAP32[$1 + 24 >> 2], 68) + 378848 | 0] = $0;
   $0 = jswrap_espruino_reverseByte(HEAP32[$1 + 24 >> 2] + 1 | 0);
   HEAP8[(Math_imul(HEAP32[$1 + 24 >> 2], 68) + 1 | 0) + 378848 | 0] = $0;
   HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 24 >> 2] + 1;
   continue;
  }
  break;
 }
 jshPinOutput(5, 0);
 jshPinOutput(26, 1);
 jshPinOutput(27, 1);
 jshPinOutput(7, 1);
 jshPinOutput(6, 1);
 jshSPIInitInfo($1 + 8 | 0);
 HEAP8[$1 + 8 | 0] = 0;
 HEAP8[$1 + 9 | 0] = 9;
 HEAP8[$1 + 10 | 0] = 61;
 HEAP8[$1 + 11 | 0] = 0;
 HEAP8[$1 + 15 | 0] = 27;
 HEAP8[$1 + 13 | 0] = 26;
 HEAP8[$1 + 17 | 0] = 0;
 jshSPISetup(26, $1 + 8 | 0);
 __stack_pointer = $1 + 32 | 0;
}

function _jswrap_object_keys_or_property_names_iterator($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1: {
  if (!HEAP32[$3 + 28 >> 2]) {
   break label$1;
  }
  HEAP8[$3 + 15 | 0] = HEAPU8[HEAP32[$3 + 28 >> 2] + 8 | 0];
  HEAP32[$3 + 16 >> 2] = 0;
  while (1) {
   if (HEAPU32[$3 + 16 >> 2] >= HEAPU8[$3 + 15 | 0]) {
    break label$1;
   }
   $0 = HEAP32[$3 + 28 >> 2];
   $0 = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) + (HEAP32[$3 + 16 >> 2] << 3) | 0;
   HEAP16[$3 + 12 >> 1] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8;
   $0 = HEAP32[$3 + 28 >> 2];
   HEAP32[$3 + 8 >> 2] = jsvNewFromString(HEAPU16[$3 + 12 >> 1] + (HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) | 0);
   FUNCTION_TABLE[HEAP32[$3 + 24 >> 2]](HEAP32[$3 + 20 >> 2], HEAP32[$3 + 8 >> 2]);
   jsvUnLock(HEAP32[$3 + 8 >> 2]);
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
   continue;
  }
 }
 __stack_pointer = $3 + 32 | 0;
}

function jsspiFastSoftwareFunc($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 16 >> 2];
 HEAP32[$4 + 8 >> 2] = 0;
 while (1) {
  if (HEAPU32[$4 + 8 >> 2] < HEAPU32[$4 + 20 >> 2]) {
   HEAP32[$4 + 4 >> 2] = HEAPU8[HEAP32[$4 + 28 >> 2] + HEAP32[$4 + 8 >> 2] | 0];
   $0 = HEAP32[$4 + 12 >> 2];
   HEAP32[$4 >> 2] = (HEAPU8[$0 + 10 | 0] | HEAPU8[$0 + 11 | 0] << 8 | (HEAPU8[$0 + 12 | 0] << 16 | HEAPU8[$0 + 13 | 0] << 24)) - 1;
   while (1) {
    if (HEAP32[$4 >> 2] >= 0) {
     jshPinSetValue(HEAPU8[HEAP32[$4 + 12 >> 2] + 7 | 0], HEAP32[$4 + 4 >> 2] >> HEAP32[$4 >> 2] & 1);
     jshPinSetValue(HEAPU8[HEAP32[$4 + 12 >> 2] + 5 | 0], 1);
     jshPinSetValue(HEAPU8[HEAP32[$4 + 12 >> 2] + 5 | 0], 0);
     HEAP32[$4 >> 2] = HEAP32[$4 >> 2] - 1;
     continue;
    }
    break;
   }
   HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $4 + 32 | 0;
}

function graphicsToDeviceCoordinates16x($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 16) {
  HEAP32[$3 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] >> 2];
  HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
  HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = HEAP32[$3 >> 2];
 }
 $0 = HEAP32[$3 + 12 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 32) {
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - 1 << 4) - HEAP32[HEAP32[$3 + 8 >> 2] >> 2];
 }
 $0 = HEAP32[$3 + 12 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 64) {
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = ((HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) - 1 << 4) - HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
 }
}

function TfLiteTypeGetName($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  label$2: {
   switch (HEAP32[$1 + 8 >> 2]) {
   case 0:
    HEAP32[$1 + 12 >> 2] = 137787;
    break label$1;

   case 1:
    HEAP32[$1 + 12 >> 2] = 139731;
    break label$1;

   case 7:
    HEAP32[$1 + 12 >> 2] = 139399;
    break label$1;

   case 2:
    HEAP32[$1 + 12 >> 2] = 139725;
    break label$1;

   case 3:
    HEAP32[$1 + 12 >> 2] = 139145;
    break label$1;

   case 9:
    HEAP32[$1 + 12 >> 2] = 139146;
    break label$1;

   case 4:
    HEAP32[$1 + 12 >> 2] = 139474;
    break label$1;

   case 6:
    HEAP32[$1 + 12 >> 2] = 137311;
    break label$1;

   case 8:
    HEAP32[$1 + 12 >> 2] = 139464;
    break label$1;

   case 12:
    HEAP32[$1 + 12 >> 2] = 139158;
    break label$1;

   case 5:
    HEAP32[$1 + 12 >> 2] = 137627;
    break label$1;

   case 10:
    HEAP32[$1 + 12 >> 2] = 139405;
    break label$1;

   case 11:
    HEAP32[$1 + 12 >> 2] = 139480;
    break label$1;

   default:
    break label$2;
   }
  }
  HEAP32[$1 + 12 >> 2] = 132330;
 }
 return HEAP32[$1 + 12 >> 2];
}

function std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteFullyConnectedParams__28_29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $1;
 $1 = HEAP32[$2 + 12 >> 2];
 $3 = TfLiteFullyConnectedParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteFullyConnectedParams__28_29(HEAP32[$1 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__BuiltinDataDeleter_28tflite__BuiltinDataAllocator__29($2 + 8 | 0, HEAP32[$1 >> 2]);
 std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteFullyConnectedParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $3, $2 + 8 | 0);
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_object_hasOwnProperty($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 76 >> 2] = $0;
 HEAP32[$2 + 72 >> 2] = $1;
 HEAP32[$2 + 68 >> 2] = jsvAsArrayIndex(HEAP32[$2 + 72 >> 2]);
 HEAP8[$2 + 67 | 0] = 0;
 if (jsvHasChildren(HEAP32[$2 + 76 >> 2]) & 1) {
  HEAP32[$2 + 60 >> 2] = jsvFindChildFromVar(HEAP32[$2 + 76 >> 2], HEAP32[$2 + 68 >> 2], 0);
  if (HEAP32[$2 + 60 >> 2]) {
   HEAP8[$2 + 67 | 0] = 1;
   jsvUnLock(HEAP32[$2 + 60 >> 2]);
  }
 }
 label$3: {
  if (HEAP8[$2 + 67 | 0] & 1) {
   break label$3;
  }
  if (jsvIsObject(HEAP32[$2 + 76 >> 2]) & 1) {
   break label$3;
  }
  HEAP32[$2 + 56 >> 2] = jswGetSymbolListForObject(HEAP32[$2 + 76 >> 2]);
  if (HEAP32[$2 + 56 >> 2]) {
   jsvGetString(HEAP32[$2 + 68 >> 2], $2 + 16 | 0, 32);
   HEAP32[$2 + 12 >> 2] = jswBinarySearch(HEAP32[$2 + 56 >> 2], HEAP32[$2 + 76 >> 2], $2 + 16 | 0);
   if (HEAP32[$2 + 12 >> 2]) {
    HEAP8[$2 + 67 | 0] = 1;
   }
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
  }
 }
 jsvUnLock(HEAP32[$2 + 68 >> 2]);
 __stack_pointer = $2 + 80 | 0;
 return HEAP8[$2 + 67 | 0] & 1;
}

function jswrap_array_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1: {
  if ((jsvGetArrayLength(HEAP32[$1 + 24 >> 2]) | 0) == 1) {
   HEAP32[$1 + 20 >> 2] = jsvSkipNameAndUnLock(jsvGetArrayItem(HEAP32[$1 + 24 >> 2], 0));
   if (jsvIsNumeric(HEAP32[$1 + 20 >> 2]) & 1) {
    HEAPF64[$1 + 8 >> 3] = jsvGetFloat(HEAP32[$1 + 20 >> 2]);
    HEAP32[$1 + 4 >> 2] = jsvGetInteger(HEAP32[$1 + 20 >> 2]);
    jsvUnLock(HEAP32[$1 + 20 >> 2]);
    if (!(HEAP32[$1 + 4 >> 2] >= 0 & HEAPF64[$1 + 8 >> 3] == +HEAP32[$1 + 4 >> 2])) {
     jsExceptionHere(1, 129349, 0);
     HEAP32[$1 + 28 >> 2] = 0;
     break label$1;
    }
    HEAP32[$1 >> 2] = jsvNewEmptyArray();
    if (!HEAP32[$1 >> 2]) {
     HEAP32[$1 + 28 >> 2] = 0;
     break label$1;
    }
    jsvSetArrayLength(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], 0);
    HEAP32[$1 + 28 >> 2] = HEAP32[$1 >> 2];
    break label$1;
   }
   jsvUnLock(HEAP32[$1 + 20 >> 2]);
  }
  HEAP32[$1 + 28 >> 2] = jsvLockAgain(HEAP32[$1 + 24 >> 2]);
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function tflite__SimpleMemoryAllocator__AllocateTemp_28unsigned_20long_2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 40 >> 2] = $0;
 HEAP32[$3 + 36 >> 2] = $1;
 HEAP32[$3 + 32 >> 2] = $2;
 $0 = HEAP32[$3 + 40 >> 2];
 HEAP32[$3 + 28 >> 2] = tflite__AlignPointerUp_28unsigned_20char__2c_20unsigned_20long_29(HEAP32[$0 + 24 >> 2], HEAP32[$3 + 32 >> 2]);
 HEAP32[$3 + 24 >> 2] = HEAP32[$0 + 20 >> 2] - HEAP32[$3 + 28 >> 2];
 label$1: {
  if (HEAPU32[$3 + 24 >> 2] < HEAPU32[$3 + 36 >> 2]) {
   $0 = HEAP32[$0 + 4 >> 2];
   $1 = HEAP32[$3 + 36 >> 2];
   $2 = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 36 >> 2] - HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 4 >> 2] = $2;
   HEAP32[$3 >> 2] = $1;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 116906, $3);
   HEAP32[$3 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 24 >> 2] = HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 36 >> 2];
  HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 28 >> 2];
 }
 __stack_pointer = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}

function jswrap_graphics_stringMetrics($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 128 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 120 >> 2] = $0;
 HEAP32[$2 + 116 >> 2] = $1;
 label$1: {
  if (!(graphicsGetFromVar($2 + 40 | 0, HEAP32[$2 + 120 >> 2]) & 1)) {
   HEAP32[$2 + 124 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvNewObject();
  if (HEAP32[$2 + 12 >> 2]) {
   _jswrap_graphics_stringMetrics($2 + 40 | 0, HEAP32[$2 + 116 >> 2], -1, $2 + 16 | 0);
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 129398, jsvNewFromInteger(HEAP32[$2 + 16 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 117745, jsvNewFromInteger(HEAP32[$2 + 20 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 120051, jsvNewFromBool(HEAP8[$2 + 24 | 0] & 1));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 117437, jsvNewFromInteger(HEAP32[$2 + 28 >> 2]));
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 12 >> 2], 117752, jsvNewFromInteger(HEAP32[$2 + 32 >> 2]));
  }
  HEAP32[$2 + 124 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 + 128 | 0;
 return HEAP32[$2 + 124 >> 2];
}

function graphicsToDeviceCoordinates($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 16) {
  HEAP32[$3 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] >> 2];
  HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
  HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = HEAP32[$3 >> 2];
 }
 $0 = HEAP32[$3 + 12 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 32) {
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - (HEAP32[HEAP32[$3 + 8 >> 2] >> 2] + 1 | 0);
 }
 $0 = HEAP32[$3 + 12 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 64) {
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) - (HEAP32[HEAP32[$3 + 4 >> 2] >> 2] + 1 | 0);
 }
}

function deviceToGraphicsCoordinates($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 32) {
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - (HEAP32[HEAP32[$3 + 8 >> 2] >> 2] + 1 | 0);
 }
 $0 = HEAP32[$3 + 12 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 64) {
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8) - (HEAP32[HEAP32[$3 + 4 >> 2] >> 2] + 1 | 0);
 }
 $0 = HEAP32[$3 + 12 >> 2];
 if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 16) {
  HEAP32[$3 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] >> 2];
  HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
  HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = HEAP32[$3 >> 2];
 }
}

function jswrap_dataview_set($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 96 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 92 >> 2] = $0;
 HEAP8[$5 + 91 | 0] = $1;
 HEAP32[$5 + 84 >> 2] = $2;
 HEAP32[$5 + 80 >> 2] = $3;
 HEAP8[$5 + 79 | 0] = $4;
 HEAP32[$5 + 72 >> 2] = jsvObjectGetChildIfExists(HEAP32[$5 + 92 >> 2], 121187);
 label$1: {
  if (!(jsvIsArrayBuffer(HEAP32[$5 + 72 >> 2]) & 1)) {
   jsvUnLock(HEAP32[$5 + 72 >> 2]);
   break label$1;
  }
  HEAP32[$5 + 84 >> 2] = jsvObjectGetIntegerChild(HEAP32[$5 + 92 >> 2], 117871) + HEAP32[$5 + 84 >> 2];
  HEAP32[$5 + 68 >> 2] = HEAPU8[$5 + 91 | 0] & 15;
  HEAP32[$5 + 64 >> 2] = jswrap_typedarray_constructor(HEAPU8[$5 + 91 | 0], HEAP32[$5 + 72 >> 2], HEAP32[$5 + 84 >> 2], HEAP32[$5 + 68 >> 2]);
  jsvUnLock(HEAP32[$5 + 72 >> 2]);
  if (!HEAP32[$5 + 64 >> 2]) {
   break label$1;
  }
  jsvArrayBufferIteratorNew($5 + 8 | 0, HEAP32[$5 + 64 >> 2], 0);
  jsvArrayBufferIteratorSetValue($5 + 8 | 0, HEAP32[$5 + 80 >> 2], (HEAPU8[$5 + 79 | 0] ^ -1) & 1);
  jsvArrayBufferIteratorFree($5 + 8 | 0);
  jsvUnLock(HEAP32[$5 + 64 >> 2]);
 }
 __stack_pointer = $5 + 96 | 0;
}

function std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteDepthwiseConvParams__28_29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $1;
 $1 = HEAP32[$2 + 12 >> 2];
 $3 = TfLiteDepthwiseConvParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteDepthwiseConvParams__28_29(HEAP32[$1 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__BuiltinDataDeleter_28tflite__BuiltinDataAllocator__29($2 + 8 | 0, HEAP32[$1 >> 2]);
 std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteDepthwiseConvParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $3, $2 + 8 | 0);
 __stack_pointer = $2 + 16 | 0;
}

function i2c_start($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP8[HEAP32[$1 + 12 >> 2] + 2 | 0] & 1) {
  i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]);
  dly(HEAP32[$1 + 12 >> 2]);
  i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2]]);
  HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
  while (1) {
   $0 = 0;
   if (!(jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2]]) & 1)) {
    $0 = HEAP32[$1 + 8 >> 2] != 0;
   }
   if ($0) {
    HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] - 1;
    continue;
   }
   break;
  }
  if (!(HEAP32[$1 + 8 >> 2] | !HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2])) {
   err(142712);
  }
  dly(HEAP32[$1 + 12 >> 2]);
 }
 label$6: {
  if (!HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2]) {
   break label$6;
  }
  if (jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]) & 1) {
   break label$6;
  }
  err(142728);
 }
 i2c_pin_wr0(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]);
 dly(HEAP32[$1 + 12 >> 2]);
 i2c_pin_wr0(HEAPU8[HEAP32[$1 + 12 >> 2]]);
 dly(HEAP32[$1 + 12 >> 2]);
 HEAP8[HEAP32[$1 + 12 >> 2] + 2 | 0] = 1;
 __stack_pointer = $1 + 16 | 0;
}

function jshGetPinStateString($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 11 | 0] = $0;
 HEAP8[$1 + 10 | 0] = HEAPU8[$1 + 11 | 0] & 15;
 HEAP32[$1 + 4 >> 2] = 0;
 label$1: {
  label$2: {
   switch (HEAPU8[$1 + 10 | 0] - 1 | 0) {
   case 6:
    HEAP32[$1 + 4 >> 2] = 129682;
    break label$1;

   case 3:
    HEAP32[$1 + 4 >> 2] = 117136;
    break label$1;

   case 4:
    HEAP32[$1 + 4 >> 2] = 121684;
    break label$1;

   case 5:
    HEAP32[$1 + 4 >> 2] = 128061;
    break label$1;

   case 0:
    HEAP32[$1 + 4 >> 2] = 117129;
    break label$1;

   case 1:
    HEAP32[$1 + 4 >> 2] = 128501;
    break label$1;

   case 2:
    HEAP32[$1 + 4 >> 2] = 121697;
    break label$1;

   case 7:
    HEAP32[$1 + 4 >> 2] = 117126;
    break label$1;

   case 8:
    break label$2;

   default:
    break label$1;
   }
  }
  HEAP32[$1 + 4 >> 2] = 128498;
 }
 label$11: {
  if (HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = jsvNewFromString(HEAP32[$1 + 4 >> 2]);
   break label$11;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_string_slice($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 if (jsvIsUndefined(HEAP32[$3 + 16 >> 2]) & 1) {
  $0 = 2147483647;
 } else {
  $0 = jsvGetInteger(HEAP32[$3 + 16 >> 2]);
 }
 HEAP32[$3 + 12 >> 2] = $0;
 if (HEAP32[$3 + 20 >> 2] < 0) {
  HEAP32[$3 + 20 >> 2] = jsvGetStringLength(HEAP32[$3 + 24 >> 2]) + HEAP32[$3 + 20 >> 2];
 }
 if (HEAP32[$3 + 12 >> 2] < 0) {
  HEAP32[$3 + 12 >> 2] = jsvGetStringLength(HEAP32[$3 + 24 >> 2]) + HEAP32[$3 + 12 >> 2];
 }
 if (HEAP32[$3 + 20 >> 2] < 0) {
  HEAP32[$3 + 20 >> 2] = 0;
 }
 if (HEAP32[$3 + 12 >> 2] < 0) {
  HEAP32[$3 + 12 >> 2] = 0;
 }
 label$7: {
  if (HEAP32[$3 + 12 >> 2] <= HEAP32[$3 + 20 >> 2]) {
   HEAP32[$3 + 28 >> 2] = jsvNewFromEmptyString_8();
   break label$7;
  }
  HEAP32[$3 + 28 >> 2] = jsvNewFromStringVar(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 12 >> 2] - HEAP32[$3 + 20 >> 2] | 0);
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jsiConsolePrintStringVarUntilEOL($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 60 >> 2] = $0;
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP8[$4 + 51 | 0] = $3;
 HEAP32[$4 + 44 >> 2] = 0;
 jsvStringIteratorNew($4 + 8 | 0, HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2]);
 while (1) {
  $0 = 0;
  if (jsvStringIteratorHasChar_5($4 + 8 | 0) & 1) {
   $0 = HEAPU32[$4 + 44 >> 2] < HEAPU32[$4 + 52 >> 2];
  }
  label$3: {
   if (!$0) {
    break label$3;
   }
   HEAP8[$4 + 7 | 0] = jsvStringIteratorGetCharAndNext($4 + 8 | 0);
   if (HEAP8[$4 + 7 | 0] == 10) {
    break label$3;
   }
   jsiConsolePrintChar(HEAP8[$4 + 7 | 0]);
   HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 44 >> 2] + 1;
   continue;
  }
  break;
 }
 jsvStringIteratorFree_5($4 + 8 | 0);
 if (HEAP8[$4 + 51 | 0] & 1) {
  jsiConsolePrintChar(32);
  HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 44 >> 2] + 1;
  while (1) {
   $0 = HEAP32[$4 + 44 >> 2];
   HEAP32[$4 + 44 >> 2] = $0 - 1;
   if ($0) {
    jsiConsolePrintChar(8);
    continue;
   }
   break;
  }
 }
 __stack_pointer = $4 - -64 | 0;
}

function jswrap_object_length($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  label$2: {
   if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
    HEAP32[$1 + 4 >> 2] = jsvGetArrayLength(HEAP32[$1 + 8 >> 2]);
    break label$2;
   }
   label$4: {
    if (jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1) {
     HEAP32[$1 + 4 >> 2] = jsvGetArrayBufferLength(HEAP32[$1 + 8 >> 2]);
     break label$4;
    }
    label$6: {
     if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
      HEAP32[$1 + 4 >> 2] = jsvGetStringLength(HEAP32[$1 + 8 >> 2]);
      break label$6;
     }
     label$8: {
      if (jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1) {
       HEAP32[$1 >> 2] = jsvGetFunctionArgumentLength(HEAP32[$1 + 8 >> 2]);
       HEAP32[$1 + 4 >> 2] = jsvGetArrayLength(HEAP32[$1 >> 2]);
       jsvUnLock(HEAP32[$1 >> 2]);
       break label$8;
      }
      HEAP32[$1 + 12 >> 2] = 0;
      break label$1;
     }
    }
   }
  }
  HEAP32[$1 + 12 >> 2] = jsvNewFromInteger(HEAP32[$1 + 4 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_banglejs_project($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer + -64 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 60 >> 2] = $0;
 HEAPF64[$1 + 48 >> 3] = .017453292519943295;
 HEAPF64[$1 + 40 >> 3] = 85.0511287798;
 HEAPF64[$1 + 32 >> 3] = 6378137;
 HEAPF64[$1 + 24 >> 3] = jsvObjectGetFloatChild(HEAP32[$1 + 60 >> 2], 117936);
 HEAPF64[$1 + 16 >> 3] = jsvObjectGetFloatChild(HEAP32[$1 + 60 >> 2], 128111);
 if (HEAPF64[$1 + 24 >> 3] > 85.0511287798) {
  HEAPF64[$1 + 24 >> 3] = 85.0511287798;
 }
 if (HEAPF64[$1 + 24 >> 3] < -85.0511287798) {
  HEAPF64[$1 + 24 >> 3] = -85.0511287798;
 }
 HEAPF64[$1 + 8 >> 3] = jswrap_math_sin(HEAPF64[$1 + 24 >> 3] * .017453292519943295);
 HEAP32[$1 + 4 >> 2] = jsvNewObject();
 if (HEAP32[$1 + 4 >> 2]) {
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 4 >> 2], 116522, jsvNewFromFloat(HEAPF64[$1 + 16 >> 3] * 6378137 * .017453292519943295));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 4 >> 2], 116397, jsvNewFromFloat(log((HEAPF64[$1 + 8 >> 3] + 1) / (1 - HEAPF64[$1 + 8 >> 3])) * 6378137 * .5));
 }
 __stack_pointer = $1 - -64 | 0;
 return HEAP32[$1 + 4 >> 2];
}

function jsvIteratorGetFloatValue($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 4 >> 2] = $0;
 label$1: {
  label$2: {
   switch (HEAP32[HEAP32[$1 + 4 >> 2] >> 2] - 2 | 0) {
   case 2:
    label$6: {
     if (!(jsvIsIntegerish(HEAP32[HEAP32[$1 + 4 >> 2] + 4 >> 2]) & 1)) {
      break label$6;
     }
     if ((jsvGetInteger(HEAP32[HEAP32[$1 + 4 >> 2] + 4 >> 2]) | 0) != HEAP32[HEAP32[$1 + 4 >> 2] + 12 >> 2]) {
      break label$6;
     }
     HEAPF64[$1 + 8 >> 3] = jsvGetFloatAndUnLock(jsvObjectIteratorGetValue_1(HEAP32[$1 + 4 >> 2] + 4 | 0));
     break label$1;
    }
    HEAPF64[$1 + 8 >> 3] = nan;
    break label$1;

   case 0:
    HEAPF64[$1 + 8 >> 3] = jsvGetFloatAndUnLock(jsvObjectIteratorGetValue_1(HEAP32[$1 + 4 >> 2] + 4 | 0));
    break label$1;

   case 1:
    HEAPF64[$1 + 8 >> 3] = jsvArrayBufferIteratorGetFloatValue(HEAP32[$1 + 4 >> 2] + 4 | 0);
    break label$1;

   default:
    break label$2;
   }
  }
  HEAPF64[$1 + 8 >> 3] = jsvIteratorGetIntegerValue(HEAP32[$1 + 4 >> 2]) | 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAPF64[$1 + 8 >> 3];
}

function std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___reset_28TfLiteFullyConnectedParams__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[std____2____compressed_pair_TfLiteFullyConnectedParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2];
 $1 = HEAP32[$2 + 8 >> 2];
 HEAP32[std____2____compressed_pair_TfLiteFullyConnectedParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2] = $1;
 if (HEAP32[$2 + 4 >> 2]) {
  tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__operator_28_29_28void__29(std____2____compressed_pair_TfLiteFullyConnectedParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___second_28_29($0), HEAP32[$2 + 4 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function jsfRemoveCodeFromFlash() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = __stack_pointer - 128 | 0;
 __stack_pointer = $0;
 jsiConsolePrintString(140731);
 jsfNameFromString($0 + 96 | 0, 132787);
 HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 120 >> 2];
 $1 = HEAP32[$0 + 116 >> 2];
 $2 = HEAP32[$0 + 112 >> 2];
 HEAP32[$0 + 16 >> 2] = $2;
 HEAP32[$0 + 20 >> 2] = $1;
 $2 = HEAP32[$0 + 108 >> 2];
 $1 = HEAP32[$0 + 104 >> 2];
 HEAP32[$0 + 8 >> 2] = $1;
 HEAP32[$0 + 12 >> 2] = $2;
 $1 = HEAP32[$0 + 100 >> 2];
 $2 = HEAP32[$0 + 96 >> 2];
 HEAP32[$0 >> 2] = $2;
 HEAP32[$0 + 4 >> 2] = $1;
 jsfEraseFile($0);
 jsfNameFromString($0 - -64 | 0, 117304);
 HEAP32[$0 + 56 >> 2] = HEAP32[$0 + 88 >> 2];
 $2 = HEAP32[$0 + 84 >> 2];
 $1 = HEAP32[$0 + 80 >> 2];
 HEAP32[$0 + 48 >> 2] = $1;
 HEAP32[$0 + 52 >> 2] = $2;
 $1 = HEAP32[$0 + 76 >> 2];
 $2 = HEAP32[$0 + 72 >> 2];
 HEAP32[$0 + 40 >> 2] = $2;
 HEAP32[$0 + 44 >> 2] = $1;
 $2 = HEAP32[$0 + 68 >> 2];
 $1 = HEAP32[$0 + 64 >> 2];
 HEAP32[$0 + 32 >> 2] = $1;
 HEAP32[$0 + 36 >> 2] = $2;
 jsfEraseFile($0 + 32 | 0);
 jsiConsolePrintString(148257);
 __stack_pointer = $0 + 128 | 0;
}

function jsfFlashContainsCode() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = __stack_pointer - 128 | 0;
 __stack_pointer = $0;
 jsfNameFromString($0 + 96 | 0, 132787);
 HEAP32[$0 + 56 >> 2] = HEAP32[$0 + 120 >> 2];
 $2 = HEAP32[$0 + 116 >> 2];
 $1 = HEAP32[$0 + 112 >> 2];
 HEAP32[$0 + 48 >> 2] = $1;
 HEAP32[$0 + 52 >> 2] = $2;
 $1 = HEAP32[$0 + 108 >> 2];
 $2 = HEAP32[$0 + 104 >> 2];
 HEAP32[$0 + 40 >> 2] = $2;
 HEAP32[$0 + 44 >> 2] = $1;
 $2 = HEAP32[$0 + 100 >> 2];
 $1 = HEAP32[$0 + 96 >> 2];
 HEAP32[$0 + 32 >> 2] = $1;
 HEAP32[$0 + 36 >> 2] = $2;
 $1 = 1;
 if (!jsfFindFile($0 + 32 | 0, 0)) {
  jsfNameFromString($0 - -64 | 0, 117304);
  HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 88 >> 2];
  $1 = HEAP32[$0 + 84 >> 2];
  $2 = HEAP32[$0 + 80 >> 2];
  HEAP32[$0 + 16 >> 2] = $2;
  HEAP32[$0 + 20 >> 2] = $1;
  $2 = HEAP32[$0 + 76 >> 2];
  $1 = HEAP32[$0 + 72 >> 2];
  HEAP32[$0 + 8 >> 2] = $1;
  HEAP32[$0 + 12 >> 2] = $2;
  $1 = HEAP32[$0 + 68 >> 2];
  $2 = HEAP32[$0 + 64 >> 2];
  HEAP32[$0 >> 2] = $2;
  HEAP32[$0 + 4 >> 2] = $1;
  $1 = (jsfFindFile($0, 0) | 0) != 0;
 }
 __stack_pointer = $0 + 128 | 0;
 return $1;
}

function std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___reset_28TfLiteDepthwiseConvParams__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[std____2____compressed_pair_TfLiteDepthwiseConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2];
 $1 = HEAP32[$2 + 8 >> 2];
 HEAP32[std____2____compressed_pair_TfLiteDepthwiseConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2] = $1;
 if (HEAP32[$2 + 4 >> 2]) {
  tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__operator_28_29_28void__29(std____2____compressed_pair_TfLiteDepthwiseConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___second_28_29($0), HEAP32[$2 + 4 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function tflite__TfLiteTypeSizeOf_28TfLiteType_2c_20unsigned_20long__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  label$2: {
   label$3: {
    switch (HEAP32[$2 + 8 >> 2] - 1 | 0) {
    case 0:
     HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 4;
     break label$2;

    case 6:
     HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 2;
     break label$2;

    case 1:
     HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 4;
     break label$2;

    case 2:
     HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 1;
     break label$2;

    case 8:
     HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 1;
     break label$2;

    case 3:
     HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 8;
     break label$2;

    case 5:
     HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 1;
     break label$2;

    case 7:
     HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 8;
     break label$2;

    case 11:
     HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 16;
     break label$2;

    default:
     break label$3;
    }
   }
   HEAP32[$2 + 12 >> 2] = 1;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 0;
 }
 return HEAP32[$2 + 12 >> 2];
}

function jswrap_graphics_setColorX($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 112 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 104 >> 2] = $0;
 HEAP32[$5 + 100 >> 2] = $1;
 HEAP32[$5 + 96 >> 2] = $2;
 HEAP32[$5 + 92 >> 2] = $3;
 HEAP8[$5 + 91 | 0] = $4;
 label$1: {
  if (!(graphicsGetFromVar($5 + 16 | 0, HEAP32[$5 + 104 >> 2]) & 1)) {
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$5 + 12 >> 2] = jswrap_graphics_toColor(HEAP32[$5 + 104 >> 2], HEAP32[$5 + 100 >> 2], HEAP32[$5 + 96 >> 2], HEAP32[$5 + 92 >> 2]);
  label$3: {
   if (HEAP8[$5 + 91 | 0] & 1) {
    $0 = HEAP32[$5 + 12 >> 2];
    HEAP8[$5 + 33 | 0] = $0;
    HEAP8[$5 + 34 | 0] = $0 >>> 8;
    HEAP8[$5 + 35 | 0] = $0 >>> 16;
    HEAP8[$5 + 36 | 0] = $0 >>> 24;
    break label$3;
   }
   $0 = HEAP32[$5 + 12 >> 2];
   HEAP8[$5 + 37 | 0] = $0;
   HEAP8[$5 + 38 | 0] = $0 >>> 8;
   HEAP8[$5 + 39 | 0] = $0 >>> 16;
   HEAP8[$5 + 40 | 0] = $0 >>> 24;
  }
  graphicsSetVar($5 + 16 | 0);
  HEAP32[$5 + 108 >> 2] = jsvLockAgain(HEAP32[$5 + 104 >> 2]);
 }
 __stack_pointer = $5 + 112 | 0;
 return HEAP32[$5 + 108 >> 2];
}

function jsvGetValueOfName($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP16[$1 + 6 >> 1] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  if (HEAPU16[$1 + 6 >> 1] == 14) {
   HEAP32[$1 + 12 >> 2] = jsvArrayBufferGetFromName(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  if (!((HEAPU16[$1 + 6 >> 1] < 18 | HEAPU16[$1 + 6 >> 1] > 22) & HEAPU16[$1 + 6 >> 1] != 16)) {
   HEAP32[$1 + 12 >> 2] = jsvNewFromInteger(jsvGetFirstChildSigned(HEAP32[$1 + 8 >> 2]) << 16 >> 16);
   break label$1;
  }
  if (HEAPU16[$1 + 6 >> 1] == 17) {
   HEAP32[$1 + 12 >> 2] = jsvNewFromBool((jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535) != 0);
   break label$1;
  }
  if (!(HEAPU16[$1 + 6 >> 1] < 14 | HEAPU16[$1 + 6 >> 1] > 27)) {
   HEAP32[$1 + 12 >> 2] = jsvLockSafe(jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535);
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function tflite___28anonymous_20namespace_29__AllocationInfoBuilder__AddScratchBuffers_28tflite__internal__ScratchBufferHandle__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 $0 = HEAP32[$2 + 28 >> 2];
 HEAP32[$2 + 20 >> 2] = HEAP32[$0 + 8 >> 2];
 while (1) {
  if (HEAPU32[$2 + 20 >> 2] < HEAP32[$0 + 8 >> 2] + HEAP32[$0 + 12 >> 2] >>> 0) {
   HEAP32[$2 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + Math_imul(HEAP32[$2 + 20 >> 2], 24);
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 24 >> 2] + Math_imul(HEAP32[$2 + 20 >> 2] - HEAP32[$0 + 8 >> 2] | 0, 12);
   HEAP32[HEAP32[$2 + 16 >> 2] + 4 >> 2] = HEAP32[$2 + 12 >> 2];
   HEAP32[HEAP32[$2 + 16 >> 2] >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2];
   HEAP32[HEAP32[$2 + 16 >> 2] + 8 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2];
   HEAP32[HEAP32[$2 + 16 >> 2] + 12 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2];
   HEAP8[HEAP32[$2 + 16 >> 2] + 20 | 0] = 1;
   HEAP32[HEAP32[$2 + 16 >> 2] + 16 >> 2] = -1;
   HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
 return 0;
}

function jshTransmitMove($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 label$1: {
  if (!(HEAPU8[$2 + 14 | 0] != 17 & HEAPU8[$2 + 14 | 0] != 18)) {
   HEAP8[$2 + 13 | 0] = HEAPU8[$2 + 14 | 0] == 18 ? 17 : 18;
   HEAP32[$2 + 8 >> 2] = jshGetCharToTransmit(HEAPU8[$2 + 15 | 0]);
   while (1) {
    if (HEAP32[$2 + 8 >> 2] >= 0) {
     jshPushIOCharEvent(HEAPU8[$2 + 13 | 0], HEAP32[$2 + 8 >> 2] << 24 >> 24);
     HEAP32[$2 + 8 >> 2] = jshGetCharToTransmit(HEAPU8[$2 + 15 | 0]);
     continue;
    }
    break;
   }
   break label$1;
  }
  jshInterruptOff();
  HEAP8[$2 + 7 | 0] = HEAPU8[364485];
  while (1) {
   if (HEAPU8[$2 + 7 | 0] != HEAPU8[364484]) {
    if (HEAPU8[$2 + 15 | 0] == (HEAPU8[(HEAPU8[$2 + 7 | 0] << 1) + 364560 | 0] & 31)) {
     HEAP8[(HEAPU8[$2 + 7 | 0] << 1) + 364560 | 0] = HEAPU8[$2 + 14 | 0] | HEAPU8[(HEAPU8[$2 + 7 | 0] << 1) + 364560 | 0] & -32;
    }
    HEAP8[$2 + 7 | 0] = HEAPU8[$2 + 7 | 0] + 1;
    continue;
   }
   break;
  }
  jshInterruptOn();
 }
 __stack_pointer = $2 + 16 | 0;
}

function jsvGetCharactersInVar($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 HEAP32[$1 + 4 >> 2] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
 label$1: {
  if (HEAP32[$1 + 4 >> 2] == 38) {
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP32[$1 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   break label$1;
  }
  if (!(HEAP32[$1 + 4 >> 2] != 39 & HEAP32[$1 + 4 >> 2] != 40)) {
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP32[$1 + 12 >> 2] = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
   break label$1;
  }
  if (HEAPU32[$1 + 4 >> 2] <= 27) {
   if (HEAPU32[$1 + 4 >> 2] <= 22) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2] - 18;
    break label$1;
   }
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2] - 23;
   break label$1;
  }
  if (HEAPU32[$1 + 4 >> 2] <= 37) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2] - 28;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2] - 41;
 }
 return HEAP32[$1 + 12 >> 2];
}

function jsvStringIteratorClone($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $3 = HEAP32[$2 + 8 >> 2];
 $0 = HEAP32[$3 >> 2];
 $1 = HEAP32[$3 + 4 >> 2];
 $4 = $0;
 $5 = HEAP32[$2 + 12 >> 2];
 $0 = $5;
 HEAP32[$0 >> 2] = $4;
 HEAP32[$0 + 4 >> 2] = $1;
 HEAP32[$0 + 32 >> 2] = HEAP32[$3 + 32 >> 2];
 $0 = HEAP32[$3 + 28 >> 2];
 $1 = HEAP32[$3 + 24 >> 2];
 $4 = $1;
 $1 = $5;
 HEAP32[$1 + 24 >> 2] = $4;
 HEAP32[$1 + 28 >> 2] = $0;
 $1 = HEAP32[$3 + 20 >> 2];
 $0 = HEAP32[$3 + 16 >> 2];
 $4 = $0;
 $0 = $5;
 HEAP32[$0 + 16 >> 2] = $4;
 HEAP32[$0 + 20 >> 2] = $1;
 $0 = HEAP32[$3 + 12 >> 2];
 $1 = HEAP32[$3 + 8 >> 2];
 $4 = $1;
 $1 = $5;
 HEAP32[$1 + 8 >> 2] = $4;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]) {
  jsvLockAgain(HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2]);
  if (HEAP32[HEAP32[$2 + 8 >> 2] + 16 >> 2] == (HEAP32[$2 + 8 >> 2] + 20 | 0)) {
   HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = HEAP32[$2 + 12 >> 2] + 20;
  }
 }
 __stack_pointer = $2 + 16 | 0;
}

function heatshrink_decoder_sink($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 label$1: {
  if (HEAP32[$4 + 12 >> 2] ? !HEAP32[$4 + 24 >> 2] | !HEAP32[$4 + 20 >> 2] : 1) {
   HEAP32[$4 + 28 >> 2] = -1;
   break label$1;
  }
  HEAP32[$4 + 8 >> 2] = 32 - HEAPU16[HEAP32[$4 + 24 >> 2] >> 1];
  if (!HEAP32[$4 + 8 >> 2]) {
   HEAP32[HEAP32[$4 + 12 >> 2] >> 2] = 0;
   HEAP32[$4 + 28 >> 2] = 1;
   break label$1;
  }
  if (HEAPU32[$4 + 8 >> 2] < HEAPU32[$4 + 16 >> 2]) {
   $0 = HEAP32[$4 + 8 >> 2];
  } else {
   $0 = HEAP32[$4 + 16 >> 2];
  }
  HEAP32[$4 + 16 >> 2] = $0;
  __memcpy(HEAPU16[HEAP32[$4 + 24 >> 2] >> 1] + (HEAP32[$4 + 24 >> 2] + 13 | 0) | 0, HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
  $0 = HEAP32[$4 + 24 >> 2];
  HEAP16[$0 >> 1] = HEAP32[$4 + 16 >> 2] + HEAPU16[$0 >> 1];
  HEAP32[HEAP32[$4 + 12 >> 2] >> 2] = HEAP32[$4 + 16 >> 2];
  HEAP32[$4 + 28 >> 2] = 0;
 }
 __stack_pointer = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}

function jswrap_storage_writeJSON($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 72 >> 2] = $0;
 HEAP32[$2 + 68 >> 2] = $1;
 HEAP32[$2 + 64 >> 2] = jsvNewFromEmptyString_11();
 label$1: {
  if (!HEAP32[$2 + 64 >> 2]) {
   HEAP8[$2 + 79 | 0] = 0;
   break label$1;
  }
  jsfGetJSON(HEAP32[$2 + 68 >> 2], HEAP32[$2 + 64 >> 2], 14032);
  jsfNameFromVar($2 + 32 | 0, HEAP32[$2 + 72 >> 2]);
  $3 = HEAP32[$2 + 64 >> 2];
  HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 56 >> 2];
  $1 = HEAP32[$2 + 52 >> 2];
  $0 = HEAP32[$2 + 48 >> 2];
  HEAP32[$2 + 16 >> 2] = $0;
  HEAP32[$2 + 20 >> 2] = $1;
  $0 = HEAP32[$2 + 44 >> 2];
  $1 = HEAP32[$2 + 40 >> 2];
  HEAP32[$2 + 8 >> 2] = $1;
  HEAP32[$2 + 12 >> 2] = $0;
  $1 = HEAP32[$2 + 36 >> 2];
  $0 = HEAP32[$2 + 32 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP8[$2 + 63 | 0] = jsfWriteFile($2, $3, 0, 0, 0) & 1;
  jsvUnLock(HEAP32[$2 + 64 >> 2]);
  HEAP8[$2 + 79 | 0] = HEAP8[$2 + 63 | 0] & 1;
 }
 __stack_pointer = $2 + 80 | 0;
 return HEAP8[$2 + 79 | 0] & 1;
}

function jswrap_dataview_constructor($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1: {
  if (!(jsvIsArrayBuffer(HEAP32[$3 + 24 >> 2]) & 1 & HEAPU8[HEAP32[$3 + 24 >> 2] + 5 | 0] == 129)) {
   HEAP32[$3 >> 2] = HEAP32[$3 + 24 >> 2];
   jsExceptionHere(3, 118641, $3);
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jspNewObject(0, 116768);
  if (HEAP32[$3 + 12 >> 2]) {
   jsvObjectSetChild(HEAP32[$3 + 12 >> 2], 121187, HEAP32[$3 + 24 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$3 + 12 >> 2], 117871, jsvNewFromInteger(HEAP32[$3 + 20 >> 2]));
   $1 = HEAP32[$3 + 12 >> 2];
   if (HEAP32[$3 + 16 >> 2]) {
    $0 = HEAP32[$3 + 16 >> 2];
   } else {
    $0 = jsvGetArrayBufferLength(HEAP32[$3 + 24 >> 2]);
   }
   jsvObjectSetChildAndUnLock($1, 129387, jsvNewFromInteger($0));
  }
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jswrap_graphics_setFontSizeX($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 96 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP8[$3 + 83 | 0] = $2;
 label$1: {
  if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  if (HEAP8[$3 + 83 | 0] & 1) {
   if (HEAP32[$3 + 84 >> 2] <= 0) {
    HEAP32[$3 + 84 >> 2] = 1;
   }
   if (HEAP32[$3 + 84 >> 2] > 8191) {
    HEAP32[$3 + 84 >> 2] = 8191;
   }
  }
  if (!(!((HEAPU8[$3 + 33 | 0] | HEAPU8[$3 + 34 | 0] << 8) & 32768) | HEAP32[$3 + 84 >> 2] & 32768)) {
   jsvObjectRemoveChild(HEAP32[$3 + 88 >> 2], 138138);
   jsvObjectRemoveChild(HEAP32[$3 + 88 >> 2], 136497);
   jsvObjectRemoveChild(HEAP32[$3 + 88 >> 2], 137559);
   jsvObjectRemoveChild(HEAP32[$3 + 88 >> 2], 139860);
  }
  $0 = HEAP32[$3 + 84 >> 2];
  HEAP8[$3 + 33 | 0] = $0;
  HEAP8[$3 + 34 | 0] = $0 >>> 8;
  graphicsSetVar($3 + 8 | 0);
  HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
 }
 __stack_pointer = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}

function std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteSoftmaxParams__28_29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $1;
 $1 = HEAP32[$2 + 12 >> 2];
 $3 = TfLiteSoftmaxParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteSoftmaxParams__28_29(HEAP32[$1 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__BuiltinDataDeleter_28tflite__BuiltinDataAllocator__29($2 + 8 | 0, HEAP32[$1 >> 2]);
 std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteSoftmaxParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $3, $2 + 8 | 0);
 __stack_pointer = $2 + 16 | 0;
}

function std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteReshapeParams__28_29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $1;
 $1 = HEAP32[$2 + 12 >> 2];
 $3 = TfLiteReshapeParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteReshapeParams__28_29(HEAP32[$1 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__BuiltinDataDeleter_28tflite__BuiltinDataAllocator__29($2 + 8 | 0, HEAP32[$1 >> 2]);
 std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteReshapeParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $3, $2 + 8 | 0);
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_flash_write($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 $2 = $3;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 label$1: {
  if (jsvIsUndefined(HEAP32[$2 + 12 >> 2]) & 1) {
   jsExceptionHere(1, 133976, 0);
   break label$1;
  }
  HEAP32[$2 + 4 >> 2] = 0;
  HEAP32[$2 >> 2] = jsvGetDataPointer(HEAP32[$2 + 12 >> 2], $2 + 4 | 0);
  if (!(HEAP32[$2 >> 2] | !HEAP32[$2 + 12 >> 2])) {
   HEAP32[$2 + 4 >> 2] = jsvIterateCallbackCount(HEAP32[$2 + 12 >> 2]);
   label$4: {
    if (HEAP32[$2 + 4 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
     jsExceptionHere(1, 135807, 0);
     break label$4;
    }
    $3 = $3 - (HEAP32[$2 + 4 >> 2] + 15 & -16) | 0;
    __stack_pointer = $3;
    HEAP32[$2 >> 2] = $3;
    jsvIterateCallbackToBytes(HEAP32[$2 + 12 >> 2], HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
   }
  }
  if (!HEAP32[$2 >> 2] | !HEAP32[$2 + 4 >> 2]) {
   break label$1;
  }
  jshFlashWriteAligned(HEAP32[$2 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function jsvIsStringNumericStrict($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer + -64 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 jsvStringIteratorNew($1 + 16 | 0, HEAP32[$1 + 56 >> 2], 0);
 HEAP8[$1 + 15 | 0] = 0;
 HEAP8[$1 + 14 | 0] = 0;
 HEAP32[$1 + 8 >> 2] = 0;
 label$1: {
  while (1) {
   if (jsvStringIteratorHasChar_1($1 + 16 | 0) & 1) {
    HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
    HEAP8[$1 + 7 | 0] = jsvStringIteratorGetCharAndNext($1 + 16 | 0);
    if (!(isNumeric(HEAP8[$1 + 7 | 0]) & 1)) {
     jsvStringIteratorFree_1($1 + 16 | 0);
     HEAP8[$1 + 63 | 0] = 0;
     break label$1;
    }
    if (!(HEAP8[$1 + 15 | 0] & 1 | HEAP8[$1 + 7 | 0] != 48)) {
     HEAP8[$1 + 14 | 0] = 1;
    }
    if (HEAP8[$1 + 7 | 0] != 48) {
     HEAP8[$1 + 15 | 0] = 1;
    }
    continue;
   }
   break;
  }
  jsvStringIteratorFree_1($1 + 16 | 0);
  if (HEAP32[$1 + 8 >> 2] > 0) {
   $2 = 1;
   $2 = HEAP8[$1 + 14 | 0] & 1 ? HEAP32[$1 + 8 >> 2] == 1 : $2;
  }
  HEAP8[$1 + 63 | 0] = $2 & 1;
 }
 __stack_pointer = $1 - -64 | 0;
 return HEAP8[$1 + 63 | 0] & 1;
}

function jspEnsureIsPrototype($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 if (HEAP32[$2 + 24 >> 2]) {
  HEAP32[$2 + 20 >> 2] = jsvSkipName(HEAP32[$2 + 24 >> 2]);
  label$2: {
   if (jsvIsObject(HEAP32[$2 + 20 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsFunction(HEAP32[$2 + 20 >> 2]) & 1) {
    break label$2;
   }
   if (!(jsvIsUndefined(HEAP32[$2 + 20 >> 2]) & 1)) {
    HEAP32[$2 >> 2] = HEAP32[$2 + 20 >> 2];
    jsExceptionHere(3, 118420, $2);
   }
   jsvUnLock(HEAP32[$2 + 20 >> 2]);
   HEAP32[$2 + 20 >> 2] = jsvNewObject();
   HEAP32[$2 + 16 >> 2] = jsvSkipToLastName(HEAP32[$2 + 24 >> 2]);
   jsvSetValueOfName(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2]);
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
  }
  HEAP32[$2 + 12 >> 2] = jsvFindOrAddChildFromString(HEAP32[$2 + 20 >> 2], 120855);
  if (HEAP32[$2 + 12 >> 2]) {
   jsvSetValueOfName(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 28 >> 2]);
  }
  jsvUnLock2(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 20 >> 2]);
 }
 __stack_pointer = $2 + 32 | 0;
}

function _jswrap_i2c_writeTo($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 48 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 44 >> 2] = $0;
 HEAP8[$6 + 43 | 0] = $1;
 HEAP32[$6 + 36 >> 2] = $2;
 HEAP8[$6 + 35 | 0] = $3;
 HEAP32[$6 + 28 >> 2] = $4;
 HEAP32[$6 + 24 >> 2] = $5;
 label$1: {
  if (!(HEAPU8[$6 + 43 | 0] < 27 | HEAPU8[$6 + 43 | 0] > 27)) {
   jshI2CWrite(HEAPU8[$6 + 43 | 0], HEAP32[$6 + 36 >> 2] & 255, HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP8[$6 + 35 | 0] & 1);
   break label$1;
  }
  if (!HEAPU8[$6 + 43 | 0]) {
   HEAP32[$6 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$6 + 44 >> 2], 120075);
   if (jsi2cPopulateI2CInfo($6 + 16 | 0, HEAP32[$6 + 12 >> 2]) & 1) {
    HEAP8[$6 + 22 | 0] = jsvObjectGetBoolChild(HEAP32[$6 + 44 >> 2], 133568) & 1;
    jsi2cWrite($6 + 16 | 0, HEAP32[$6 + 36 >> 2] & 255, HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP8[$6 + 35 | 0] & 1);
   }
   jsvUnLock2(jsvObjectSetChild(HEAP32[$6 + 44 >> 2], 133568, jsvNewFromBool(HEAP8[$6 + 22 | 0] & 1)), HEAP32[$6 + 12 >> 2]);
  }
 }
 __stack_pointer = $6 + 48 | 0;
}

function std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___reset_28TfLiteSoftmaxParams__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[std____2____compressed_pair_TfLiteSoftmaxParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2];
 $1 = HEAP32[$2 + 8 >> 2];
 HEAP32[std____2____compressed_pair_TfLiteSoftmaxParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2] = $1;
 if (HEAP32[$2 + 4 >> 2]) {
  tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__operator_28_29_28void__29(std____2____compressed_pair_TfLiteSoftmaxParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___second_28_29($0), HEAP32[$2 + 4 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___reset_28TfLiteReshapeParams__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[std____2____compressed_pair_TfLiteReshapeParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2];
 $1 = HEAP32[$2 + 8 >> 2];
 HEAP32[std____2____compressed_pair_TfLiteReshapeParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2] = $1;
 if (HEAP32[$2 + 4 >> 2]) {
  tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__operator_28_29_28void__29(std____2____compressed_pair_TfLiteReshapeParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___second_28_29($0), HEAP32[$2 + 4 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function jsi2cWrite($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP8[$5 + 39 | 0] = $1;
 HEAP32[$5 + 32 >> 2] = $2;
 HEAP32[$5 + 28 >> 2] = $3;
 HEAP8[$5 + 27 | 0] = $4;
 label$1: {
  if (!(HEAPU8[HEAP32[$5 + 40 >> 2] + 4 | 0] != 255 & HEAPU8[HEAP32[$5 + 40 >> 2] + 5 | 0] != 255)) {
   HEAP8[$5 + 47 | 0] = 0;
   break label$1;
  }
  i2c_initstruct($5 + 8 | 0, HEAP32[$5 + 40 >> 2]);
  i2c_start($5 + 8 | 0);
  if (!(i2c_wr($5 + 8 | 0, HEAPU8[$5 + 39 | 0] << 1) & 1)) {
   HEAP8[$5 + 47 | 0] = 0;
   break label$1;
  }
  HEAP32[$5 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$5 + 4 >> 2] < HEAP32[$5 + 32 >> 2]) {
    i2c_wr($5 + 8 | 0, HEAPU8[HEAP32[$5 + 28 >> 2] + HEAP32[$5 + 4 >> 2] | 0]);
    HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP8[$5 + 27 | 0] & 1) {
   i2c_stop($5 + 8 | 0);
  }
  HEAP8[HEAP32[$5 + 40 >> 2] + 6 | 0] = HEAP8[$5 + 10 | 0] & 1;
  HEAP8[$5 + 47 | 0] = 1;
 }
 __stack_pointer = $5 + 48 | 0;
 return HEAP8[$5 + 47 | 0] & 1;
}

function tflite__GreedyMemoryPlanner__GreedyMemoryPlanner_28unsigned_20char__2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 tflite__MemoryPlanner__MemoryPlanner_28_29($0);
 HEAP32[$0 >> 2] = 19e4;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP8[$0 + 40 | 0] = 1;
 HEAP32[$0 + 4 >> 2] = HEAPU32[$3 + 4 >> 2] / (tflite__GreedyMemoryPlanner__per_buffer_size_28_29() >>> 0);
 HEAP32[$3 >> 2] = HEAP32[$3 + 8 >> 2];
 HEAP32[$0 + 12 >> 2] = HEAP32[$3 >> 2];
 HEAP32[$3 >> 2] = HEAP32[$3 >> 2] + (HEAP32[$0 + 4 >> 2] << 4);
 HEAP32[$0 + 16 >> 2] = HEAP32[$3 >> 2];
 HEAP32[$3 >> 2] = HEAP32[$3 >> 2] + (HEAP32[$0 + 4 >> 2] << 2);
 HEAP32[$0 + 20 >> 2] = HEAP32[$3 >> 2];
 HEAP32[$3 >> 2] = HEAP32[$3 >> 2] + (HEAP32[$0 + 4 >> 2] << 2);
 HEAP32[$0 + 24 >> 2] = HEAP32[$3 >> 2];
 HEAP32[$3 >> 2] = HEAP32[$3 >> 2] + Math_imul(HEAP32[$0 + 4 >> 2], 12);
 HEAP32[$0 + 36 >> 2] = HEAP32[$3 >> 2];
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function jswrap_storage_getStats($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 43 | 0] = $0;
 HEAP32[$1 + 36 >> 2] = jsvNewObject();
 label$1: {
  if (!HEAP32[$1 + 36 >> 2]) {
   HEAP32[$1 + 44 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 32 >> 2] = 0;
  jsfGetStorageStats($1, HEAP32[$1 + 32 >> 2], 1);
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 120178, jsvNewFromInteger(HEAP32[$1 + 16 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 120210, jsvNewFromInteger(HEAP32[$1 + 20 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 120200, jsvNewFromInteger(HEAP32[$1 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 117414, jsvNewFromInteger(HEAP32[$1 + 4 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 120189, jsvNewFromInteger(HEAP32[$1 + 8 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 36 >> 2], 117366, jsvNewFromInteger(HEAP32[$1 + 12 >> 2]));
  HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 36 >> 2];
 }
 __stack_pointer = $1 + 48 | 0;
 return HEAP32[$1 + 44 >> 2];
}

function void_20tflite__CalculateActivationRange_float__28TfLiteFusedActivation_2c_20float__2c_20float__29($0, $1, $2) {
 var $3 = 0, $4 = Math_fround(0);
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (HEAP32[$3 + 12 >> 2] == 1) {
   HEAPF32[HEAP32[$3 + 8 >> 2] >> 2] = 0;
   $4 = std____2__numeric_limits_float___max_28_29();
   HEAPF32[HEAP32[$3 + 4 >> 2] >> 2] = $4;
   break label$1;
  }
  label$3: {
   if (HEAP32[$3 + 12 >> 2] == 3) {
    HEAPF32[HEAP32[$3 + 8 >> 2] >> 2] = 0;
    HEAPF32[HEAP32[$3 + 4 >> 2] >> 2] = 6;
    break label$3;
   }
   label$5: {
    if (HEAP32[$3 + 12 >> 2] == 2) {
     HEAPF32[HEAP32[$3 + 8 >> 2] >> 2] = -1;
     HEAPF32[HEAP32[$3 + 4 >> 2] >> 2] = 1;
     break label$5;
    }
    $4 = std____2__numeric_limits_float___lowest_28_29();
    HEAPF32[HEAP32[$3 + 8 >> 2] >> 2] = $4;
    $4 = std____2__numeric_limits_float___max_28_29();
    HEAPF32[HEAP32[$3 + 4 >> 2] >> 2] = $4;
   }
  }
 }
 __stack_pointer = $3 + 16 | 0;
}

function std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLitePoolParams__28_29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $1;
 $1 = HEAP32[$2 + 12 >> 2];
 $3 = TfLitePoolParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLitePoolParams__28_29(HEAP32[$1 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__BuiltinDataDeleter_28tflite__BuiltinDataAllocator__29($2 + 8 | 0, HEAP32[$1 >> 2]);
 std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLitePoolParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $3, $2 + 8 | 0);
 __stack_pointer = $2 + 16 | 0;
}

function std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteFullyConnectedParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 std____2____compressed_pair_TfLiteFullyConnectedParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_____compressed_pair_TfLiteFullyConnectedParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28TfLiteFullyConnectedParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, $3 + 8 | 0, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__Allocate_TfLiteConvParams__28_29($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $1;
 $1 = HEAP32[$2 + 12 >> 2];
 $3 = TfLiteConvParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteConvParams__28_29(HEAP32[$1 >> 2]);
 tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__BuiltinDataDeleter_28tflite__BuiltinDataAllocator__29($2 + 8 | 0, HEAP32[$1 >> 2]);
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteConvParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $3, $2 + 8 | 0);
 __stack_pointer = $2 + 16 | 0;
}

function jsvObjectGetChild($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP16[$3 + 18 >> 1] = $2;
 label$1: {
  if (!HEAP32[$3 + 24 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  label$3: {
   if (HEAPU16[$3 + 18 >> 1]) {
    $0 = jsvFindOrAddChildFromString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
    break label$3;
   }
   $0 = jsvFindChildFromString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
  }
  HEAP32[$3 + 12 >> 2] = $0;
  HEAP32[$3 + 8 >> 2] = jsvSkipName(HEAP32[$3 + 12 >> 2]);
  if (!(!HEAP32[$3 + 12 >> 2] | (HEAP32[$3 + 8 >> 2] | !HEAPU16[$3 + 18 >> 1]))) {
   HEAP32[$3 + 8 >> 2] = jsvNewWithFlags(HEAPU16[$3 + 18 >> 1]);
   jsvSetValueOfName(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 8 >> 2];
   break label$1;
  }
  jsvUnLock(HEAP32[$3 + 12 >> 2]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 8 >> 2];
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function numericEscapeChar($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP32[$3 + 12 >> 2] = $0 + 1;
 HEAP8[$0 | 0] = 92;
 label$1: {
  if (HEAP8[$3 + 7 | 0] & 1) {
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $0 + 1;
   HEAP8[$0 | 0] = 117;
   $1 = dtohex(HEAP32[$3 + 8 >> 2] >> 12);
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $0 + 1;
   HEAP8[$0 | 0] = $1;
   $1 = dtohex(HEAP32[$3 + 8 >> 2] >> 8);
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $0 + 1;
   HEAP8[$0 | 0] = $1;
   break label$1;
  }
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[$3 + 12 >> 2] = $0 + 1;
  HEAP8[$0 | 0] = 120;
 }
 $1 = dtohex(HEAP32[$3 + 8 >> 2] >> 4);
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP32[$3 + 12 >> 2] = $0 + 1;
 HEAP8[$0 | 0] = $1;
 $1 = dtohex(HEAP32[$3 + 8 >> 2]);
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP32[$3 + 12 >> 2] = $0 + 1;
 HEAP8[$0 | 0] = $1;
 __stack_pointer = $3 + 16 | 0;
 return HEAP32[$3 + 12 >> 2];
}

function jsvGetLineAndCol($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 80 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 76 >> 2] = $0;
 HEAP32[$4 + 72 >> 2] = $1;
 HEAP32[$4 + 68 >> 2] = $2;
 HEAP32[$4 + 64 >> 2] = $3;
 HEAP32[$4 + 60 >> 2] = 1;
 HEAP32[$4 + 56 >> 2] = 1;
 HEAP32[$4 + 52 >> 2] = 0;
 jsvStringIteratorNew($4 + 16 | 0, HEAP32[$4 + 76 >> 2], 0);
 while (1) {
  label$2: {
   if (!(jsvStringIteratorHasChar_1($4 + 16 | 0) & 1)) {
    break label$2;
   }
   HEAP8[$4 + 15 | 0] = jsvStringIteratorGetCharAndNext($4 + 16 | 0);
   if (HEAP32[$4 + 52 >> 2] == HEAP32[$4 + 72 >> 2]) {
    break label$2;
   }
   HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 60 >> 2] + 1;
   if (HEAP8[$4 + 15 | 0] == 10) {
    HEAP32[$4 + 60 >> 2] = 1;
    HEAP32[$4 + 56 >> 2] = HEAP32[$4 + 56 >> 2] + 1;
   }
   HEAP32[$4 + 52 >> 2] = HEAP32[$4 + 52 >> 2] + 1;
   continue;
  }
  break;
 }
 jsvStringIteratorFree_1($4 + 16 | 0);
 HEAP32[HEAP32[$4 + 68 >> 2] >> 2] = HEAP32[$4 + 56 >> 2];
 HEAP32[HEAP32[$4 + 64 >> 2] >> 2] = HEAP32[$4 + 60 >> 2];
 __stack_pointer = $4 + 80 | 0;
}

function jshPushIOWatchEvent($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 31 | 0] = $0;
 HEAP8[$1 + 30 | 0] = jshGetWatchedPinState(HEAPU8[$1 + 31 | 0]) & 1;
 HEAP32[$1 + 24 >> 2] = HEAPU8[$1 + 31 | 0] - 1;
 label$1: {
  if (HEAP32[(HEAP32[$1 + 24 >> 2] << 2) + 364496 >> 2]) {
   label$3: {
    if ((HEAP32[(HEAP32[$1 + 24 >> 2] << 2) + 364496 >> 2] & -256) == -256) {
     HEAP8[$1 + 23 | 0] = HEAP32[(HEAP32[$1 + 24 >> 2] << 2) + 364496 >> 2];
     if (jshPinGetValue(HEAPU8[$1 + 23 | 0]) & 1) {
      HEAP8[$1 + 31 | 0] = HEAPU8[$1 + 31 | 0] | 64;
     }
     break label$3;
    }
    FUNCTION_TABLE[HEAP32[(HEAP32[$1 + 24 >> 2] << 2) + 364496 >> 2]](HEAP8[$1 + 30 | 0] & 1, HEAPU8[$1 + 31 | 0]);
    break label$1;
   }
  }
  if (HEAP8[$1 + 30 | 0] & 1) {
   HEAP8[$1 + 31 | 0] = HEAPU8[$1 + 31 | 0] | 32;
  }
  HEAP32[$1 + 8 >> 2] = jshGetSystemTime();
  HEAP32[$1 + 12 >> 2] = i64toi32_i32$HIGH_BITS;
  jshPushIOEvent(HEAPU8[$1 + 31 | 0], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
 }
 __stack_pointer = $1 + 32 | 0;
}

function tflite__ops__micro__activations__SoftmaxFloat_28TfLiteEvalTensor_20const__2c_20TfLiteEvalTensor__2c_20tflite__SoftmaxParams_20const__29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 HEAP32[$3 + 52 >> 2] = $2;
 $0 = HEAP32[$3 + 52 >> 2];
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3 + 24 | 0, HEAP32[$3 + 60 >> 2]);
 $1 = float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29(HEAP32[$3 + 60 >> 2]);
 tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($3, HEAP32[$3 + 56 >> 2]);
 tflite__reference_ops__Softmax_28tflite__SoftmaxParams_20const__2c_20tflite__RuntimeShape_20const__2c_20float_20const__2c_20tflite__RuntimeShape_20const__2c_20float__29($0, $3 + 24 | 0, $1, $3, float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29(HEAP32[$3 + 56 >> 2]));
 tflite__RuntimeShape___RuntimeShape_28_29($3);
 tflite__RuntimeShape___RuntimeShape_28_29($3 + 24 | 0);
 __stack_pointer = $3 - -64 | 0;
}

function std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteDepthwiseConvParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 std____2____compressed_pair_TfLiteDepthwiseConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_____compressed_pair_TfLiteDepthwiseConvParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28TfLiteDepthwiseConvParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, $3 + 8 | 0, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function tflite__MicroAllocator__Create_28unsigned_20char__2c_20unsigned_20long_2c_20tflite__ErrorReporter__29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = tflite__AlignPointerUp_28unsigned_20char__2c_20unsigned_20long_29(HEAP32[$3 + 28 >> 2], 16);
 if (HEAP32[$3 + 16 >> 2] != HEAP32[$3 + 28 >> 2]) {
  $0 = HEAP32[$3 + 20 >> 2];
  HEAP32[$3 >> 2] = HEAP32[$3 + 16 >> 2] - HEAP32[$3 + 28 >> 2];
  tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 140847, $3);
 }
 HEAP32[$3 + 12 >> 2] = (HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 24 >> 2] | 0) - HEAP32[$3 + 16 >> 2];
 $0 = tflite__MicroAllocator__Create_28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__29(tflite__SimpleMemoryAllocator__Create_28tflite__ErrorReporter__2c_20unsigned_20char__2c_20unsigned_20long_29(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2]), HEAP32[$3 + 20 >> 2]);
 __stack_pointer = $3 + 32 | 0;
 return $0;
}

function std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___reset_28TfLitePoolParams__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[std____2____compressed_pair_TfLitePoolParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2];
 $1 = HEAP32[$2 + 8 >> 2];
 HEAP32[std____2____compressed_pair_TfLitePoolParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2] = $1;
 if (HEAP32[$2 + 4 >> 2]) {
  tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__operator_28_29_28void__29(std____2____compressed_pair_TfLitePoolParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___second_28_29($0), HEAP32[$2 + 4 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___reset_28TfLiteConvParams__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2];
 $1 = HEAP32[$2 + 8 >> 2];
 HEAP32[std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2] = $1;
 if (HEAP32[$2 + 4 >> 2]) {
  tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__operator_28_29_28void__29(std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___second_28_29($0), HEAP32[$2 + 4 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function jsvArrayBufferIteratorGetValueAndRewind($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 jsvStringIteratorClone($1 + 8 | 0, HEAP32[$1 + 44 >> 2]);
 HEAP32[$1 + 4 >> 2] = jsvArrayBufferIteratorGetValue(HEAP32[$1 + 44 >> 2], 0);
 jsvStringIteratorFree_2(HEAP32[$1 + 44 >> 2]);
 $2 = HEAP32[$1 + 12 >> 2];
 $0 = HEAP32[$1 + 8 >> 2];
 $3 = $0;
 $4 = HEAP32[$1 + 44 >> 2];
 $0 = $4;
 HEAP32[$0 >> 2] = $3;
 HEAP32[$0 + 4 >> 2] = $2;
 HEAP32[$0 + 32 >> 2] = HEAP32[$1 + 40 >> 2];
 $0 = HEAP32[$1 + 36 >> 2];
 $2 = HEAP32[$1 + 32 >> 2];
 $3 = $2;
 $2 = $4;
 HEAP32[$2 + 24 >> 2] = $3;
 HEAP32[$2 + 28 >> 2] = $0;
 $2 = HEAP32[$1 + 28 >> 2];
 $0 = HEAP32[$1 + 24 >> 2];
 $3 = $0;
 $0 = $4;
 HEAP32[$0 + 16 >> 2] = $3;
 HEAP32[$0 + 20 >> 2] = $2;
 $0 = HEAP32[$1 + 20 >> 2];
 $2 = HEAP32[$1 + 16 >> 2];
 $3 = $2;
 $2 = $4;
 HEAP32[$2 + 8 >> 2] = $3;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[HEAP32[$1 + 44 >> 2] + 52 | 0] = 0;
 __stack_pointer = $1 + 48 | 0;
 return HEAP32[$1 + 4 >> 2];
}

function mbedtls_ccm_setkey($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 HEAP32[$4 + 4 >> 2] = mbedtls_cipher_info_from_values(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 12 >> 2], 1);
 label$1: {
  if (!HEAP32[$4 + 4 >> 2]) {
   HEAP32[$4 + 28 >> 2] = -13;
   break label$1;
  }
  if (HEAP32[HEAP32[$4 + 4 >> 2] + 24 >> 2] != 16) {
   HEAP32[$4 + 28 >> 2] = -13;
   break label$1;
  }
  mbedtls_cipher_free(HEAP32[$4 + 24 >> 2]);
  $0 = mbedtls_cipher_setup(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 4 >> 2]);
  HEAP32[$4 + 8 >> 2] = $0;
  if ($0) {
   HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 8 >> 2];
   break label$1;
  }
  $0 = mbedtls_cipher_setkey(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[$4 + 12 >> 2], 1);
  HEAP32[$4 + 8 >> 2] = $0;
  if ($0) {
   HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 8 >> 2];
   break label$1;
  }
  HEAP32[$4 + 28 >> 2] = 0;
 }
 __stack_pointer = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}

function mbedtls_cipher_setup($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (!(HEAP32[$2 + 8 >> 2] ? HEAP32[$2 + 4 >> 2] : 0)) {
   HEAP32[$2 + 12 >> 2] = -24832;
   break label$1;
  }
  $0 = HEAP32[$2 + 8 >> 2];
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
  HEAP32[$0 + 48 >> 2] = 0;
  HEAP32[$0 + 52 >> 2] = 0;
  HEAP32[$0 + 40 >> 2] = 0;
  HEAP32[$0 + 44 >> 2] = 0;
  HEAP32[$0 + 32 >> 2] = 0;
  HEAP32[$0 + 36 >> 2] = 0;
  HEAP32[$0 + 24 >> 2] = 0;
  HEAP32[$0 + 28 >> 2] = 0;
  HEAP32[$0 + 16 >> 2] = 0;
  HEAP32[$0 + 20 >> 2] = 0;
  HEAP32[$0 + 8 >> 2] = 0;
  HEAP32[$0 + 12 >> 2] = 0;
  $0 = FUNCTION_TABLE[HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 28 >> 2] + 16 >> 2]]() | 0;
  HEAP32[HEAP32[$2 + 8 >> 2] + 52 >> 2] = $0;
  if (!$0) {
   HEAP32[$2 + 12 >> 2] = -24960;
   break label$1;
  }
  HEAP32[HEAP32[$2 + 8 >> 2] >> 2] = HEAP32[$2 + 4 >> 2];
  HEAP32[$2 + 12 >> 2] = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jsvIteratorClone($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
 label$1: {
  label$2: {
   switch (HEAP32[HEAP32[$2 + 8 >> 2] >> 2] - 1 | 0) {
   case 3:
    HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] + 12 >> 2];
    $0 = jsvLockAgain(HEAP32[HEAP32[$2 + 8 >> 2] + 8 >> 2]);
    HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2] = $0;
    jsvObjectIteratorClone(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2] + 4 | 0);
    break label$1;

   case 1:
    jsvObjectIteratorClone(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2] + 4 | 0);
    break label$1;

   case 0:
    jsvStringIteratorClone(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2] + 4 | 0);
    break label$1;

   case 2:
    break label$2;

   default:
    break label$1;
   }
  }
  jsvArrayBufferIteratorClone(HEAP32[$2 + 12 >> 2] + 4 | 0, HEAP32[$2 + 8 >> 2] + 4 | 0);
 }
 __stack_pointer = $2 + 16 | 0;
}

function graphicsBlendColorRGB565($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 HEAP16[$3 + 46 >> 1] = $0;
 HEAP16[$3 + 44 >> 1] = $1;
 HEAP32[$3 + 40 >> 2] = $2;
 HEAP32[$3 + 36 >> 2] = HEAPU16[$3 + 44 >> 1] >>> 11;
 HEAP32[$3 + 32 >> 2] = HEAPU16[$3 + 44 >> 1] >>> 5 & 63;
 HEAP32[$3 + 28 >> 2] = HEAPU16[$3 + 44 >> 1] & 31;
 HEAP32[$3 + 24 >> 2] = HEAPU16[$3 + 46 >> 1] >>> 11;
 HEAP32[$3 + 20 >> 2] = HEAPU16[$3 + 46 >> 1] >>> 5 & 63;
 HEAP32[$3 + 16 >> 2] = HEAPU16[$3 + 46 >> 1] & 31;
 HEAP32[$3 + 12 >> 2] = Math_imul(HEAP32[$3 + 36 >> 2], 256 - HEAP32[$3 + 40 >> 2] | 0) + Math_imul(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 40 >> 2]) >>> 8;
 HEAP32[$3 + 8 >> 2] = Math_imul(HEAP32[$3 + 32 >> 2], 256 - HEAP32[$3 + 40 >> 2] | 0) + Math_imul(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 40 >> 2]) >>> 8;
 HEAP32[$3 + 4 >> 2] = Math_imul(HEAP32[$3 + 28 >> 2], 256 - HEAP32[$3 + 40 >> 2] | 0) + Math_imul(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 40 >> 2]) >>> 8;
 return (HEAP32[$3 + 4 >> 2] | HEAP32[$3 + 8 >> 2] << 5 | HEAP32[$3 + 12 >> 2] << 11) & 65535;
}

function tflite__MatchingFlatSize_28tflite__RuntimeShape_20const__2c_20tflite__RuntimeShape_20const__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 label$1: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$2 + 12 >> 2]) | 0) != (tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$2 + 8 >> 2]) | 0)) {
   break label$1;
  }
 }
 HEAP32[$2 + 4 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$2 + 12 >> 2]);
 HEAP32[$2 >> 2] = 0;
 while (1) {
  if (HEAP32[$2 >> 2] < HEAP32[$2 + 4 >> 2]) {
   label$4: {
    if ((tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$2 + 12 >> 2], HEAP32[$2 >> 2]) | 0) != (tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$2 + 8 >> 2], HEAP32[$2 >> 2]) | 0)) {
     break label$4;
    }
   }
   HEAP32[$2 >> 2] = HEAP32[$2 >> 2] + 1;
   continue;
  }
  break;
 }
 $0 = tflite__RuntimeShape__FlatSize_28_29_20const(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function _jswrap_graphics_getFontHeightInternal($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (!HEAP32[HEAP32[$2 + 4 >> 2] >> 2]) {
   HEAP32[$2 + 12 >> 2] = HEAPU16[HEAP32[$2 + 4 >> 2] + 8 >> 1];
   break label$1;
  }
  if (HEAP32[HEAP32[$2 + 4 >> 2] >> 2] == 8192) {
   HEAP32[$2 + 12 >> 2] = Math_imul(HEAPU16[HEAP32[$2 + 4 >> 2] + 8 >> 1], 6);
   break label$1;
  }
  if (HEAP32[HEAP32[$2 + 4 >> 2] >> 2] == 16384) {
   HEAP32[$2 + 12 >> 2] = HEAPU16[HEAP32[$2 + 4 >> 2] + 8 >> 1] << 3;
   break label$1;
  }
  if (HEAP32[HEAP32[$2 + 4 >> 2] >> 2] & 32768) {
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP32[$2 + 12 >> 2] = Math_imul(HEAPU16[HEAP32[$2 + 4 >> 2] + 8 >> 1], jsvGetIntegerAndUnLock(jsvObjectGetChildIfExists(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 137559)));
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jswrap_banglejs_setLCDPower($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jswrap_banglejs_setLCDPowerController(HEAP8[$1 + 15 | 0] & 1);
 jswrap_banglejs_setLCDPowerBacklight(HEAP8[$1 + 15 | 0] & 1);
 if ((HEAP8[$1 + 15 | 0] & 1) != ((HEAP32[97749] & 65536) != 0 | 0)) {
  HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[91086], 132487);
  if (HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 4 >> 2] = jsvNewFromBool(HEAP8[$1 + 15 | 0] & 1);
   jsiQueueObjectCallbacks(HEAP32[$1 + 8 >> 2], 120987, $1 + 4 | 0, 1);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
  }
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
 }
 label$3: {
  if (HEAP8[$1 + 15 | 0] & 1) {
   if (!(HEAP32[97751] <= 0 & HEAP32[97753] <= 0)) {
    HEAP16[195510] = 0;
   }
   HEAP32[97749] = HEAP32[97749] | 65536;
   break label$3;
  }
  HEAP32[97749] = HEAP32[97749] & -65537;
  if (!(HEAP32[97754] <= 0 | HEAP32[97754] > HEAP32[97751])) {
   _jswrap_banglejs_setLocked(1, 134145);
  }
 }
 __stack_pointer = $1 + 16 | 0;
}

function jsiIsWatchingPin($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 30 | 0] = $0;
 label$1: {
  if (jshGetPinShouldStayWatched(HEAPU8[$1 + 30 | 0]) & 1) {
   HEAP8[$1 + 31 | 0] = 1;
   break label$1;
  }
  HEAP8[$1 + 29 | 0] = 0;
  HEAP32[$1 + 24 >> 2] = jsvLock(HEAPU16[182205]);
  jsvObjectIteratorNew($1 + 16 | 0, HEAP32[$1 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_3($1 + 16 | 0) & 1) {
    HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue_3($1 + 16 | 0);
    HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 12 >> 2], 128488);
    if ((jshGetPinFromVar(HEAP32[$1 + 8 >> 2]) & 255) == HEAPU8[$1 + 30 | 0]) {
     HEAP8[$1 + 29 | 0] = 1;
    }
    jsvUnLock2(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
    jsvObjectIteratorNext($1 + 16 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_3($1 + 16 | 0);
  jsvUnLock(HEAP32[$1 + 24 >> 2]);
  HEAP8[$1 + 31 | 0] = HEAP8[$1 + 29 | 0] & 1;
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP8[$1 + 31 | 0] & 1;
}

function jsiExecuteEvents() {
 var $0 = 0;
 $0 = __stack_pointer - 32 | 0;
 __stack_pointer = $0;
 HEAP8[$0 + 31 | 0] = (jsvArrayIsEmpty(HEAP32[91101]) ^ -1) & 1;
 if (HEAP8[$0 + 31 | 0] & 1) {
  jsiSetBusy(1, 1);
 }
 while (1) {
  if ((jsvArrayIsEmpty(HEAP32[91101]) ^ -1) & 1) {
   HEAP32[$0 + 24 >> 2] = jsvSkipNameAndUnLock(jsvArrayPopFirst(HEAP32[91101]));
   HEAP32[$0 + 20 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 24 >> 2], 135671);
   HEAP32[$0 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 24 >> 2], 120152);
   HEAP32[$0 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$0 + 24 >> 2], 120162);
   jsvUnLock(HEAP32[$0 + 24 >> 2]);
   jsiExecuteEventCallbackArgsArray(HEAP32[$0 + 16 >> 2], HEAP32[$0 + 20 >> 2], HEAP32[$0 + 12 >> 2]);
   jsvUnLock(HEAP32[$0 + 12 >> 2]);
   jsvUnLock2(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 16 >> 2]);
   continue;
  }
  break;
 }
 if (HEAP8[$0 + 31 | 0] & 1) {
  jsiSetBusy(1, 0);
  if (jspIsInterrupted() & 1) {
   HEAP16[182206] = HEAPU16[182206] | 32768;
  }
 }
 __stack_pointer = $0 + 32 | 0;
}

function jswrap_modules_getCached() {
 var $0 = 0;
 $0 = __stack_pointer - 32 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 24 >> 2] = jsvNewEmptyArray();
 label$1: {
  if (!HEAP32[$0 + 24 >> 2]) {
   HEAP32[$0 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 20 >> 2] = jswrap_modules_getModuleList();
  if (!HEAP32[$0 + 20 >> 2]) {
   HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
   break label$1;
  }
  jsvObjectIteratorNew($0 + 16 | 0, HEAP32[$0 + 20 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_11($0 + 16 | 0) & 1) {
    HEAP32[$0 + 12 >> 2] = jsvObjectIteratorGetKey_7($0 + 16 | 0);
    HEAP32[$0 + 8 >> 2] = jsvCopyNameOnly(HEAP32[$0 + 12 >> 2], 0, 0);
    jsvArrayPushAndUnLock(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 8 >> 2]);
    jsvUnLock(HEAP32[$0 + 12 >> 2]);
    jsvObjectIteratorNext($0 + 16 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_11($0 + 16 | 0);
  jsvUnLock(HEAP32[$0 + 20 >> 2]);
  HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 24 >> 2];
 }
 __stack_pointer = $0 + 32 | 0;
 return HEAP32[$0 + 28 >> 2];
}

function std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteSoftmaxParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 std____2____compressed_pair_TfLiteSoftmaxParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_____compressed_pair_TfLiteSoftmaxParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28TfLiteSoftmaxParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, $3 + 8 | 0, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteReshapeParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 std____2____compressed_pair_TfLiteReshapeParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_____compressed_pair_TfLiteReshapeParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28TfLiteReshapeParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, $3 + 8 | 0, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function tflite__MatchingFlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$3 + 28 >> 2]);
 HEAP32[$3 + 12 >> 2] = 0;
 while (1) {
  if (HEAP32[$3 + 12 >> 2] < HEAP32[$3 + 16 >> 2]) {
   if (HEAP32[$3 + 12 >> 2] != HEAP32[$3 + 24 >> 2]) {
    label$4: {
     if ((tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 12 >> 2]) | 0) != (tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 12 >> 2]) | 0)) {
      break label$4;
     }
    }
   }
   HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 $0 = tflite__FlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_29(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
 __stack_pointer = $3 + 32 | 0;
 return $0;
}

function jslSkipWhiteSpace() {
 var $0 = 0;
 while (1) {
  label$2: {
   while (1) {
    if (isWhitespaceInline(HEAP8[HEAP32[49079]]) & 1) {
     jslGetNextCh();
     continue;
    }
    break;
   }
   if (HEAP8[HEAP32[49079]] != 47) {
    break label$2;
   }
   if ((jslNextCh() & 255) == 47) {
    while (1) {
     $0 = 0;
     $0 = HEAP8[HEAP32[49079]] ? HEAP8[HEAP32[49079]] != 10 : $0;
     if ($0) {
      jslGetNextCh();
      continue;
     }
     break;
    }
    jslGetNextCh();
    continue;
   }
   if ((jslNextCh() & 255) == 42) {
    jslGetNextCh();
    jslGetNextCh();
    while (1) {
     $0 = 0;
     if (HEAP8[HEAP32[49079]]) {
      $0 = 0;
      if (HEAP8[HEAP32[49079]] == 42) {
       $0 = (jslNextCh() & 255) == 47;
      }
      $0 = $0 ^ -1;
     }
     if ($0 & 1) {
      jslGetNextCh();
      continue;
     }
     break;
    }
    if (!HEAPU8[HEAP32[49079]]) {
     HEAP16[HEAP32[49079] + 2 >> 1] = 137;
     break label$2;
    }
    jslGetNextCh();
    jslGetNextCh();
    continue;
   }
  }
  break;
 }
}

function getDayNumberFromDate($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1: {
  if (!(HEAP32[$3 + 24 >> 2] < 125e4 & HEAP32[$3 + 24 >> 2] >= -125e4)) {
   jsExceptionHere(1, 120451, 0);
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  while (1) {
   if (HEAP32[$3 + 20 >> 2] < 2) {
    HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] - 1;
    HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] + 12;
    continue;
   }
   break;
  }
  HEAP32[$3 + 12 >> 2] = integerDivideFloor(HEAP32[$3 + 24 >> 2], 100);
  HEAP32[$3 + 28 >> 2] = ((((((Math_imul(HEAP32[$3 + 24 >> 2], 365) + integerDivideFloor(HEAP32[$3 + 24 >> 2], 4) | 0) - HEAP32[$3 + 12 >> 2] | 0) + integerDivideFloor(HEAP32[$3 + 12 >> 2], 4) | 0) + Math_imul(HEAP32[$3 + 20 >> 2], 30) | 0) + ((Math_imul(HEAP32[$3 + 20 >> 2], 3) + 6 | 0) / 5 | 0) | 0) + HEAP32[$3 + 16 >> 2] | 0) - 719531;
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function graphicsStructInit($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP8[$0 + 8 | 0] = 0;
 HEAP8[$0 + 9 | 0] = 0;
 HEAP8[$0 + 10 | 0] = 0;
 HEAP8[$0 + 11 | 0] = 0;
 $0 = HEAP32[$4 + 12 >> 2];
 $1 = HEAP32[$4 + 8 >> 2];
 HEAP8[$0 + 12 | 0] = $1;
 HEAP8[$0 + 13 | 0] = $1 >>> 8;
 $0 = HEAP32[$4 + 12 >> 2];
 $1 = HEAP32[$4 + 4 >> 2];
 HEAP8[$0 + 14 | 0] = $1;
 HEAP8[$0 + 15 | 0] = $1 >>> 8;
 HEAP8[HEAP32[$4 + 12 >> 2] + 16 | 0] = HEAP32[$4 >> 2];
 graphicsStructResetState(HEAP32[$4 + 12 >> 2]);
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP8[$0 + 44 | 0] = 0;
 HEAP8[$0 + 45 | 0] = 128;
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP8[$0 + 46 | 0] = 0;
 HEAP8[$0 + 47 | 0] = 128;
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP8[$0 + 40 | 0] = 255;
 HEAP8[$0 + 41 | 0] = 127;
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP8[$0 + 42 | 0] = 255;
 HEAP8[$0 + 43 | 0] = 127;
 __stack_pointer = $4 + 16 | 0;
}

function jswrap_graphics_theme($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvNewObject();
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 130040, jsvNewFromInteger(HEAPU8[366785] | HEAPU8[366786] << 8));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 130044, jsvNewFromInteger(HEAPU8[366787] | HEAPU8[366788] << 8));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 139561, jsvNewFromInteger(HEAPU8[366789] | HEAPU8[366790] << 8));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 139565, jsvNewFromInteger(HEAPU8[366791] | HEAPU8[366792] << 8));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 137564, jsvNewFromInteger(HEAPU8[366793] | HEAPU8[366794] << 8));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 137568, jsvNewFromInteger(HEAPU8[366795] | HEAPU8[366796] << 8));
 jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 129083, jsvNewFromBool(HEAP8[366797] & 1));
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jsiExecuteEventCallbackArgsArray($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 $3 = $4;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = 0;
 HEAP32[$3 + 8 >> 2] = 0;
 label$1: {
  if (HEAP32[$3 + 16 >> 2]) {
   HEAP32[$3 + 12 >> 2] = jsvGetArrayLength(HEAP32[$3 + 16 >> 2]);
   if (HEAP32[$3 + 12 >> 2]) {
    $4 = $4 - ((HEAP32[$3 + 12 >> 2] << 2) + 15 & -16) | 0;
    __stack_pointer = $4;
    HEAP32[$3 + 8 >> 2] = $4;
    if (!HEAP32[$3 + 8 >> 2]) {
     HEAP8[$3 + 31 | 0] = 0;
     break label$1;
    }
    jsvGetArrayItems(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
   }
  }
  HEAP8[$3 + 7 | 0] = jsiExecuteEventCallback(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]) & 1;
  jsvUnLockMany(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
  HEAP8[$3 + 31 | 0] = HEAP8[$3 + 7 | 0] & 1;
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP8[$3 + 31 | 0] & 1;
}

function std____2____compressed_pair_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29___2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29_______compressed_pair_std__nullptr_t_2c_20std____2____default_init_tag__28std__nullptr_t___2c_20std____2____default_init_tag___29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 std____2____compressed_pair_elem_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29___2c_200_2c_20false_____compressed_pair_elem_std__nullptr_t_2c_20void__28std__nullptr_t___29($0, HEAP32[$3 + 8 >> 2]);
 std____2____compressed_pair_elem_std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29___2c_201_2c_20true_____compressed_pair_elem_28std____2____default_init_tag_29($0);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function jswrap_pipe_close_listener($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1: {
  if (!(jsvIsObject(HEAP32[$2 + 28 >> 2]) & 1)) {
   break label$1;
  }
  HEAP32[$2 + 20 >> 2] = pipeGetArray(0);
  if (!HEAP32[$2 + 20 >> 2]) {
   break label$1;
  }
  jsvObjectIteratorNew($2 + 16 | 0, HEAP32[$2 + 20 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_16($2 + 16 | 0) & 1) {
    HEAP32[$2 + 12 >> 2] = jsvObjectIteratorGetValue_15($2 + 16 | 0);
    HEAP32[$2 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 24 >> 2]);
    if (HEAP32[$2 + 8 >> 2] == HEAP32[$2 + 28 >> 2]) {
     handlePipeClose(HEAP32[$2 + 20 >> 2], $2 + 16 | 0, HEAP32[$2 + 12 >> 2]);
    }
    jsvUnLock2(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2]);
    jsvObjectIteratorNext($2 + 16 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_16($2 + 16 | 0);
  jsvUnLock(HEAP32[$2 + 20 >> 2]);
 }
 __stack_pointer = $2 + 32 | 0;
}

function _jswrap_espruino_FFT_getData($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 80 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 76 >> 2] = $0;
 HEAP32[$3 + 72 >> 2] = $1;
 HEAP32[$3 + 68 >> 2] = $2;
 HEAP32[$3 + 4 >> 2] = 0;
 if (jsvIsIterable(HEAP32[$3 + 72 >> 2]) & 1) {
  jsvIteratorNew($3 + 8 | 0, HEAP32[$3 + 72 >> 2], 1);
  while (1) {
   $0 = 0;
   if (HEAPU32[$3 + 4 >> 2] < HEAPU32[$3 + 68 >> 2]) {
    $0 = jsvIteratorHasElement($3 + 8 | 0);
   }
   if ($0 & 1) {
    $4 = jsvIteratorGetFloatValue($3 + 8 | 0);
    $1 = HEAP32[$3 + 76 >> 2];
    $0 = HEAP32[$3 + 4 >> 2];
    HEAP32[$3 + 4 >> 2] = $0 + 1;
    HEAPF64[($0 << 3) + $1 >> 3] = $4;
    jsvIteratorNext($3 + 8 | 0);
    continue;
   }
   break;
  }
  jsvIteratorFree($3 + 8 | 0);
 }
 while (1) {
  if (HEAPU32[$3 + 4 >> 2] < HEAPU32[$3 + 68 >> 2]) {
   $1 = HEAP32[$3 + 76 >> 2];
   $0 = HEAP32[$3 + 4 >> 2];
   HEAP32[$3 + 4 >> 2] = $0 + 1;
   HEAPF64[($0 << 3) + $1 >> 3] = 0;
   continue;
  }
  break;
 }
 __stack_pointer = $3 + 80 | 0;
}

function nativeCallGetCType() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 label$1: {
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 192) {
   jslMatch(192);
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 128) {
   HEAP32[$0 + 8 >> 2] = -1;
   HEAP32[$0 + 4 >> 2] = jslGetTokenValueAsString();
   if (!strcmp(HEAP32[$0 + 4 >> 2], 117516)) {
    HEAP32[$0 + 8 >> 2] = 4;
   }
   if (!strcmp(HEAP32[$0 + 4 >> 2], 132494)) {
    HEAP32[$0 + 8 >> 2] = 7;
   }
   if (!strcmp(HEAP32[$0 + 4 >> 2], 128717)) {
    HEAP32[$0 + 8 >> 2] = 3;
   }
   if (!strcmp(HEAP32[$0 + 4 >> 2], 128511)) {
    HEAP32[$0 + 8 >> 2] = 5;
   }
   if (!strcmp(HEAP32[$0 + 4 >> 2], 121462)) {
    HEAP32[$0 + 8 >> 2] = 1;
   }
   if (!strcmp(HEAP32[$0 + 4 >> 2], 117929)) {
    HEAP32[$0 + 8 >> 2] = 6;
   }
   jslMatch(128);
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = -1;
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function jsvStringIteratorGotoEnd($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 while (1) {
  if (jsvGetLastChild(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 65535) {
   HEAP32[$1 + 8 >> 2] = jsvLock(jsvGetLastChild(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 65535);
   jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
   HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] = HEAP32[$1 + 8 >> 2];
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] + HEAP32[$0 + 8 >> 2];
   $0 = jsvGetCharactersInVar(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
   HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = $0;
   continue;
  }
  break;
 }
 HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
 label$3: {
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) {
   HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] - 1;
   break label$3;
  }
  HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
}

function _jswrap_prombox_all_resolve($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 28 >> 2], 128686);
 if (HEAP32[$3 + 16 >> 2]) {
  HEAP32[$3 + 12 >> 2] = jsvObjectGetIntegerChild(HEAP32[$3 + 16 >> 2], 128058);
  HEAP32[$3 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 16 >> 2], 120220);
  if (HEAP32[$3 + 8 >> 2]) {
   jsvSetArrayItem(HEAP32[$3 + 8 >> 2], jsvGetInteger(HEAP32[$3 + 24 >> 2]), HEAP32[$3 + 20 >> 2]);
   HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] - 1;
   jsvObjectSetChildAndUnLock(HEAP32[$3 + 16 >> 2], 128058, jsvNewFromInteger(HEAP32[$3 + 12 >> 2]));
   if (!HEAP32[$3 + 12 >> 2]) {
    _jswrap_prombox_queueresolve(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 8 >> 2]);
   }
   jsvUnLock(HEAP32[$3 + 8 >> 2]);
  }
  jsvUnLock(HEAP32[$3 + 16 >> 2]);
 }
 __stack_pointer = $3 + 32 | 0;
}

function jsvArrayBufferIteratorGetValue($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP8[$2 + 23 | 0] = $1;
 label$1: {
  if (!HEAPU8[HEAP32[$2 + 24 >> 2] + 36 | 0]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  jsvArrayBufferIteratorGetValueData(HEAP32[$2 + 24 >> 2], $2 + 12 | 0);
  if (HEAP8[$2 + 23 | 0] & 1) {
   reverseBytes($2 + 12 | 0, HEAPU8[HEAP32[$2 + 24 >> 2] + 36 | 0] & 15);
  }
  if (HEAPU8[HEAP32[$2 + 24 >> 2] + 36 | 0] & 32) {
   HEAP32[$2 + 28 >> 2] = jsvNewFromFloat(jsvArrayBufferIteratorDataToFloat(HEAP32[$2 + 24 >> 2], $2 + 12 | 0));
   break label$1;
  }
  HEAP32[$2 + 8 >> 2] = jsvArrayBufferIteratorDataToInt(HEAP32[$2 + 24 >> 2], $2 + 12 | 0);
  if (HEAPU8[HEAP32[$2 + 24 >> 2] + 36 | 0] == 4) {
   HEAP32[$2 + 28 >> 2] = jsvNewFromLongInteger(HEAP32[$2 + 8 >> 2], 0);
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = jsvNewFromInteger(HEAP32[$2 + 8 >> 2]);
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLitePoolParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 std____2____compressed_pair_TfLitePoolParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_____compressed_pair_TfLitePoolParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28TfLitePoolParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, $3 + 8 | 0, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___unique_ptr_true_2c_20void__28TfLiteConvParams__2c_20std____2____dependent_type_std____2____unique_ptr_deleter_sfinae_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__2c_20true_____good_rval_ref_type_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_____compressed_pair_TfLiteConvParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28TfLiteConvParams___2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, $3 + 8 | 0, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function jswrap_spi_setup($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1: {
  if (!(jsvIsObject(HEAP32[$2 + 28 >> 2]) & 1)) {
   break label$1;
  }
  HEAP8[$2 + 23 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 28 >> 2]);
  if (!(jsspiPopulateSPIInfo($2 + 8 | 0, HEAP32[$2 + 24 >> 2]) & 1)) {
   break label$1;
  }
  label$2: {
   if (!(HEAPU8[$2 + 23 | 0] < 26 | HEAPU8[$2 + 23 | 0] > 26)) {
    jshSPISetup(HEAPU8[$2 + 23 | 0], $2 + 8 | 0);
    break label$2;
   }
   if (HEAPU8[$2 + 23 | 0]) {
    break label$1;
   }
   if (HEAPU8[$2 + 13 | 0] != 255) {
    jshPinSetState(HEAPU8[$2 + 13 | 0], 1);
   }
   if (HEAPU8[$2 + 14 | 0] != 255) {
    jshPinSetState(HEAPU8[$2 + 14 | 0], 4);
   }
   if (HEAPU8[$2 + 15 | 0] != 255) {
    jshPinSetState(HEAPU8[$2 + 15 | 0], 1);
   }
  }
  jsvObjectSetOrRemoveChild(HEAP32[$2 + 28 >> 2], 120075, HEAP32[$2 + 24 >> 2]);
 }
 __stack_pointer = $2 + 32 | 0;
}

function jsvStringIteratorUpdatePtr($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (jsvIsFlatString(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 1) {
   $0 = jsvGetFlatStringPointer(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
   HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = $0;
   break label$1;
  }
  label$3: {
   if (jsvIsNativeString(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 1) {
    $0 = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
    HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
    break label$3;
   }
   if (!(jsvIsFlashString(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) & 1)) {
    label$6: {
     if (HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) {
      HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2];
      break label$6;
     }
     HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = 0;
    }
   }
  }
 }
 __stack_pointer = $1 + 16 | 0;
}

function jsi2cPopulateI2CInfo($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP32[$2 + 52 >> 2] = $1;
 jshI2CInitInfo(HEAP32[$2 + 56 >> 2]);
 HEAP32[$2 + 16 >> 2] = 128996;
 HEAP16[$2 + 20 >> 1] = 13;
 HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 56 >> 2] + 4;
 HEAP32[$2 + 28 >> 2] = 135853;
 HEAP16[$2 + 32 >> 1] = 13;
 HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 56 >> 2] + 5;
 HEAP32[$2 + 40 >> 2] = 132018;
 HEAP16[$2 + 44 >> 1] = 10;
 HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 56 >> 2];
 label$1: {
  if (jsvReadConfigObject(HEAP32[$2 + 52 >> 2], $2 + 16 | 0, 3) & 1) {
   HEAP8[$2 + 15 | 0] = 1;
   $0 = HEAP32[$2 + 56 >> 2];
   if ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) < 100) {
    jsExceptionHere(1, 132006, 0);
    HEAP8[$2 + 15 | 0] = 0;
   }
   HEAP8[$2 + 63 | 0] = HEAP8[$2 + 15 | 0] & 1;
   break label$1;
  }
  HEAP8[$2 + 63 | 0] = 0;
 }
 __stack_pointer = $2 - -64 | 0;
 return HEAP8[$2 + 63 | 0] & 1;
}

function jswrap_spi_send_cb($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = $3 - (HEAP32[$3 + 8 >> 2] + 15 & -16) | 0;
 __stack_pointer = $0;
 HEAP32[$3 >> 2] = $0;
 FUNCTION_TABLE[HEAP32[HEAP32[$3 + 4 >> 2] >> 2]](HEAP32[$3 + 12 >> 2], HEAP32[$3 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2] + 4 | 0);
 $0 = HEAP32[$3 + 4 >> 2];
 HEAP32[$0 + 24 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$0 + 24 >> 2];
 $0 = HEAP32[$3 + 4 >> 2];
 HEAP32[$0 + 20 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$0 + 20 >> 2];
 while (1) {
  $0 = HEAP32[$3 + 8 >> 2];
  HEAP32[$3 + 8 >> 2] = $0 - 1;
  if ($0) {
   $1 = HEAP32[$3 + 4 >> 2];
   $0 = HEAP32[$3 >> 2];
   HEAP32[$3 >> 2] = $0 + 1;
   jsvArrayBufferIteratorSetByteValue($1 + 28 | 0, HEAP8[$0 | 0]);
   jsvArrayBufferIteratorNext(HEAP32[$3 + 4 >> 2] + 28 | 0);
   continue;
  }
  break;
 }
 __stack_pointer = $3 + 16 | 0;
}

function jsfNameFromVar($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $1;
 $2 = $3;
 HEAP32[$2 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP8[$2 + 21 | 0] = 0;
 HEAP8[$2 + 22 | 0] = 0;
 HEAP8[$2 + 23 | 0] = 0;
 HEAP8[$2 + 24 | 0] = 0;
 HEAP8[$2 + 25 | 0] = 0;
 HEAP8[$2 + 26 | 0] = 0;
 HEAP8[$2 + 27 | 0] = 0;
 HEAP8[$2 + 28 | 0] = 0;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = 0;
 jsvGetString(HEAP32[$2 + 44 >> 2], $2, 29);
 $1 = HEAP32[$2 >> 2];
 $2 = HEAP32[$2 + 4 >> 2];
 $4 = $1;
 $1 = $0;
 HEAP32[$1 >> 2] = $4;
 HEAP32[$1 + 4 >> 2] = $2;
 HEAP32[$1 + 24 >> 2] = HEAP32[$3 + 24 >> 2];
 $1 = HEAP32[$3 + 20 >> 2];
 $2 = HEAP32[$3 + 16 >> 2];
 $4 = $2;
 $2 = $0;
 HEAP32[$2 + 16 >> 2] = $4;
 HEAP32[$2 + 20 >> 2] = $1;
 $2 = HEAP32[$3 + 12 >> 2];
 $1 = HEAP32[$3 + 8 >> 2];
 $4 = $1;
 $1 = $0;
 HEAP32[$1 + 8 >> 2] = $4;
 HEAP32[$1 + 12 >> 2] = $2;
 __stack_pointer = $3 + 48 | 0;
}

function jswrap_espruino_getErrorFlagArray($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 11 | 0] = $0;
 HEAP32[$1 + 4 >> 2] = jsvNewEmptyArray();
 label$1: {
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  if (HEAP8[$1 + 11 | 0] & 1) {
   jsvArrayPushString(HEAP32[$1 + 4 >> 2], 137328);
  }
  if (HEAPU8[$1 + 11 | 0] & 2) {
   jsvArrayPushString(HEAP32[$1 + 4 >> 2], 137316);
  }
  if (HEAPU8[$1 + 11 | 0] & 4) {
   jsvArrayPushString(HEAP32[$1 + 4 >> 2], 137449);
  }
  if (HEAPU8[$1 + 11 | 0] & 8) {
   jsvArrayPushString(HEAP32[$1 + 4 >> 2], 136325);
  }
  if (HEAPU8[$1 + 11 | 0] & 16) {
   jsvArrayPushString(HEAP32[$1 + 4 >> 2], 136329);
  }
  if (HEAPU8[$1 + 11 | 0] & 32) {
   jsvArrayPushString(HEAP32[$1 + 4 >> 2], 136313);
  }
  if (HEAPU8[$1 + 11 | 0] & 64) {
   jsvArrayPushString(HEAP32[$1 + 4 >> 2], 136506);
  }
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_waveform_kill() {
 var $0 = 0;
 $0 = __stack_pointer - 32 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 28 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 131709);
 if (HEAP32[$0 + 28 >> 2]) {
  jsvObjectIteratorNew($0 + 24 | 0, HEAP32[$0 + 28 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_18($0 + 24 | 0) & 1) {
    HEAP32[$0 + 20 >> 2] = jsvObjectIteratorGetValue_17($0 + 24 | 0);
    HEAP8[$0 + 19 | 0] = jsvObjectGetBoolChild(HEAP32[$0 + 20 >> 2], 129992) & 1;
    if (HEAP8[$0 + 19 | 0] & 1) {
     HEAP32[$0 + 12 >> 2] = jswrap_waveform_getBuffer(HEAP32[$0 + 20 >> 2], 0, 0);
     if (!(jstStopBufferTimerTask(HEAP32[$0 + 12 >> 2]) & 1)) {
      jsExceptionHere(1, 133800, 0);
     }
     jsvUnLock(HEAP32[$0 + 12 >> 2]);
    }
    jsvUnLock(HEAP32[$0 + 20 >> 2]);
    jsvObjectIteratorRemoveAndGotoNext($0 + 24 | 0, HEAP32[$0 + 28 >> 2]);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_18($0 + 24 | 0);
  jsvUnLock(HEAP32[$0 + 28 >> 2]);
 }
 __stack_pointer = $0 + 32 | 0;
}

function jswrap_i2c_setup($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1: {
  if (!(jsvIsObject(HEAP32[$2 + 28 >> 2]) & 1)) {
   break label$1;
  }
  HEAP8[$2 + 23 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 28 >> 2]);
  if (!(jsi2cPopulateI2CInfo($2 + 8 | 0, HEAP32[$2 + 24 >> 2]) & 1)) {
   break label$1;
  }
  label$2: {
   if (!(HEAPU8[$2 + 23 | 0] < 27 | HEAPU8[$2 + 23 | 0] > 27)) {
    jshI2CSetup(HEAPU8[$2 + 23 | 0], $2 + 8 | 0);
    break label$2;
   }
   if (!HEAPU8[$2 + 23 | 0]) {
    if (HEAPU8[$2 + 12 | 0] != 255) {
     jshPinSetValue(HEAPU8[$2 + 12 | 0], 1);
     jshPinSetState(HEAPU8[$2 + 12 | 0], 3);
    }
    if (HEAPU8[$2 + 13 | 0] != 255) {
     jshPinSetValue(HEAPU8[$2 + 13 | 0], 1);
     jshPinSetState(HEAPU8[$2 + 13 | 0], 3);
    }
   }
  }
  jsvObjectSetOrRemoveChild(HEAP32[$2 + 28 >> 2], 120075, HEAP32[$2 + 24 >> 2]);
 }
 __stack_pointer = $2 + 32 | 0;
}

function jsfNameFromString($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $1;
 $2 = $3;
 HEAP32[$2 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP8[$2 + 21 | 0] = 0;
 HEAP8[$2 + 22 | 0] = 0;
 HEAP8[$2 + 23 | 0] = 0;
 HEAP8[$2 + 24 | 0] = 0;
 HEAP8[$2 + 25 | 0] = 0;
 HEAP8[$2 + 26 | 0] = 0;
 HEAP8[$2 + 27 | 0] = 0;
 HEAP8[$2 + 28 | 0] = 0;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = 0;
 strcpy($2, HEAP32[$2 + 44 >> 2]);
 $1 = HEAP32[$2 >> 2];
 $2 = HEAP32[$2 + 4 >> 2];
 $4 = $1;
 $1 = $0;
 HEAP32[$1 >> 2] = $4;
 HEAP32[$1 + 4 >> 2] = $2;
 HEAP32[$1 + 24 >> 2] = HEAP32[$3 + 24 >> 2];
 $1 = HEAP32[$3 + 20 >> 2];
 $2 = HEAP32[$3 + 16 >> 2];
 $4 = $2;
 $2 = $0;
 HEAP32[$2 + 16 >> 2] = $4;
 HEAP32[$2 + 20 >> 2] = $1;
 $2 = HEAP32[$3 + 12 >> 2];
 $1 = HEAP32[$3 + 8 >> 2];
 $4 = $1;
 $1 = $0;
 HEAP32[$1 + 8 >> 2] = $4;
 HEAP32[$1 + 12 >> 2] = $2;
 __stack_pointer = $3 + 48 | 0;
}

function jswrap_modules_addCached($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1: {
  label$2: {
   if (jsvIsString(HEAP32[$2 + 28 >> 2]) & 1) {
    if (jsvIsString(HEAP32[$2 + 24 >> 2]) & 1) {
     break label$2;
    }
    if (jsvIsFunction(HEAP32[$2 + 24 >> 2]) & 1) {
     break label$2;
    }
   }
   jsExceptionHere(1, 142950, 0);
   break label$1;
  }
  HEAP32[$2 + 20 >> 2] = jswrap_modules_getModuleList();
  if (!HEAP32[$2 + 20 >> 2]) {
   break label$1;
  }
  HEAP32[$2 + 16 >> 2] = jspEvaluateModule(HEAP32[$2 + 24 >> 2]);
  label$4: {
   if (!HEAP32[$2 + 16 >> 2]) {
    HEAP32[$2 >> 2] = HEAP32[$2 + 28 >> 2];
    jsExceptionHere(1, 121603, $2);
    break label$4;
   }
   jsvObjectSetChildVar(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 16 >> 2]);
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
  }
  jsvUnLock(HEAP32[$2 + 20 >> 2]);
 }
 __stack_pointer = $2 + 32 | 0;
}

function jsvCreateEmptyVarList() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 32 | 0;
 __stack_pointer = $0;
 HEAP8[196322] = 1;
 HEAP16[98162] = 0;
 jsvSetNextSibling($0 + 16 | 0, 0);
 HEAP32[$0 + 12 >> 2] = $0 + 16;
 HEAP16[$0 + 10 >> 1] = 1;
 while (1) {
  if (HEAPU16[$0 + 10 >> 1] <= 12e3) {
   HEAP32[$0 + 4 >> 2] = jsvGetAddressOf(HEAPU16[$0 + 10 >> 1]);
   $1 = HEAP32[$0 + 4 >> 2];
   label$3: {
    if (!((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63)) {
     jsvSetNextSibling(HEAP32[$0 + 12 >> 2], HEAPU16[$0 + 10 >> 1]);
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2];
     break label$3;
    }
    if (jsvIsFlatString(HEAP32[$0 + 4 >> 2]) & 1) {
     HEAP16[$0 + 10 >> 1] = HEAPU16[$0 + 10 >> 1] + jsvGetFlatStringBlocks(HEAP32[$0 + 4 >> 2]);
    }
   }
   HEAP16[$0 + 10 >> 1] = HEAPU16[$0 + 10 >> 1] + 1;
   continue;
  }
  break;
 }
 jsvSetNextSibling(HEAP32[$0 + 12 >> 2], 0);
 HEAP16[98162] = jsvGetNextSibling($0 + 16 | 0);
 HEAP8[196322] = 0;
 __stack_pointer = $0 + 32 | 0;
}

function i2c_stop($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 i2c_pin_wr0(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]);
 dly(HEAP32[$1 + 12 >> 2]);
 i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2]]);
 HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
 while (1) {
  $0 = 0;
  if (!(jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2]]) & 1)) {
   $0 = HEAP32[$1 + 8 >> 2] != 0;
  }
  if ($0) {
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] - 1;
   continue;
  }
  break;
 }
 if (!(HEAP32[$1 + 8 >> 2] | !HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2])) {
  err(142916);
 }
 dly(HEAP32[$1 + 12 >> 2]);
 i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]);
 dly(HEAP32[$1 + 12 >> 2]);
 label$5: {
  if (!HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2]) {
   break label$5;
  }
  if (jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]) & 1) {
   break label$5;
  }
  err(142931);
 }
 dly(HEAP32[$1 + 12 >> 2]);
 HEAP8[HEAP32[$1 + 12 >> 2] + 2 | 0] = 0;
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_storage_readJSON($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 72 >> 2] = $0;
 HEAP8[$2 + 71 | 0] = $1;
 jsfNameFromVar($2 + 32 | 0, HEAP32[$2 + 72 >> 2]);
 HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 56 >> 2];
 $1 = HEAP32[$2 + 52 >> 2];
 $0 = HEAP32[$2 + 48 >> 2];
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 $0 = HEAP32[$2 + 44 >> 2];
 $1 = HEAP32[$2 + 40 >> 2];
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 12 >> 2] = $0;
 $1 = HEAP32[$2 + 36 >> 2];
 $0 = HEAP32[$2 + 32 >> 2];
 HEAP32[$2 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 + 64 >> 2] = jsfReadFile($2, 0, 0);
 label$1: {
  if (!HEAP32[$2 + 64 >> 2]) {
   HEAP32[$2 + 76 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = jswrap_json_parse_liberal(HEAP32[$2 + 64 >> 2], HEAP8[$2 + 71 | 0] & 1);
  jsvUnLock(HEAP32[$2 + 64 >> 2]);
  HEAP32[$2 + 76 >> 2] = HEAP32[$2 + 28 >> 2];
 }
 __stack_pointer = $2 + 80 | 0;
 return HEAP32[$2 + 76 >> 2];
}

function tflite__MicroInterpreter__Init_28tflite__Profiler__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = tflite__Model__subgraphs_28_29_20const(HEAP32[$0 + 4 >> 2]);
 label$1: {
  if ((flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph____size_28_29_20const(HEAP32[$2 + 4 >> 2]) | 0) != 1) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 12 >> 2], 147828, 0);
   HEAP32[$0 + 112 >> 2] = 1;
   break label$1;
  }
  HEAP32[$0 + 116 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph____operator_5b_5d_28unsigned_20int_29_20const(HEAP32[$2 + 4 >> 2], 0);
  HEAP32[$0 + 28 >> 2] = $0 + 124;
  HEAP32[$0 + 36 >> 2] = 675;
  HEAP32[$0 + 96 >> 2] = 676;
  HEAP32[$0 + 100 >> 2] = 677;
  HEAP32[$0 + 52 >> 2] = 1;
  HEAP32[$0 + 68 >> 2] = HEAP32[$2 + 8 >> 2];
  HEAP32[$0 + 112 >> 2] = 0;
 }
 __stack_pointer = $2 + 16 | 0;
}

function st_d_yield_literal($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (HEAPU32[HEAP32[HEAP32[$2 + 20 >> 2] + 8 >> 2] >> 2] < HEAPU32[HEAP32[$2 + 20 >> 2] + 4 >> 2]) {
   HEAP16[$2 + 18 >> 1] = get_bits(HEAP32[$2 + 24 >> 2], 8);
   if (HEAPU16[$2 + 18 >> 1] == 65535) {
    HEAP32[$2 + 28 >> 2] = 1;
    break label$1;
   }
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 24 >> 2] + 45;
   HEAP16[$2 + 10 >> 1] = 255;
   HEAP8[$2 + 9 | 0] = HEAPU16[$2 + 18 >> 1];
   $3 = HEAPU8[$2 + 9 | 0];
   $4 = HEAP32[$2 + 12 >> 2];
   $0 = HEAP32[$2 + 24 >> 2];
   $1 = HEAPU16[$0 + 8 >> 1];
   HEAP16[$0 + 8 >> 1] = $1 + 1;
   HEAP8[(HEAPU16[$2 + 10 >> 1] & $1) + $4 | 0] = $3;
   push_byte(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2], HEAPU8[$2 + 9 | 0]);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = 1;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jswrap_graphics_blendColor($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 112 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 104 >> 2] = $0;
 HEAP32[$4 + 100 >> 2] = $1;
 HEAP32[$4 + 96 >> 2] = $2;
 HEAP32[$4 + 92 >> 2] = $3;
 label$1: {
  if (!(graphicsGetFromVar($4 + 16 | 0, HEAP32[$4 + 104 >> 2]) & 1)) {
   HEAP32[$4 + 108 >> 2] = 0;
   break label$1;
  }
  HEAP32[$4 + 12 >> 2] = jswrap_graphics_toColor(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2], 0, 0);
  HEAP32[$4 + 8 >> 2] = jswrap_graphics_toColor(HEAP32[$4 + 104 >> 2], HEAP32[$4 + 96 >> 2], 0, 0);
  $1 = $4 + 16 | 0;
  $2 = HEAP32[$4 + 8 >> 2];
  $3 = HEAP32[$4 + 12 >> 2];
  $5 = jsvGetFloat(HEAP32[$4 + 92 >> 2]) * 256;
  label$3: {
   if (Math_abs($5) < 2147483648) {
    $0 = ~~$5;
    break label$3;
   }
   $0 = -2147483648;
  }
  HEAP32[$4 + 108 >> 2] = graphicsBlendColor($1, $2, $3, $0);
 }
 __stack_pointer = $4 + 112 | 0;
 return HEAP32[$4 + 108 >> 2];
}

function tflite__GreedyMemoryPlanner__GetOffsetForBuffer_28tflite__ErrorReporter__2c_20int_2c_20int__29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 $0 = HEAP32[$4 + 24 >> 2];
 tflite__GreedyMemoryPlanner__CalculateOffsetsIfNeeded_28_29($0);
 label$1: {
  if (!(HEAP32[$4 + 16 >> 2] < HEAP32[$0 + 8 >> 2] & HEAP32[$4 + 16 >> 2] >= 0)) {
   $1 = HEAP32[$4 + 20 >> 2];
   $2 = HEAP32[$4 + 16 >> 2];
   HEAP32[$4 + 4 >> 2] = HEAP32[$0 + 8 >> 2];
   HEAP32[$4 >> 2] = $2;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($1, 134867, $4);
   HEAP32[$4 + 28 >> 2] = 1;
   break label$1;
  }
  HEAP32[HEAP32[$4 + 12 >> 2] >> 2] = HEAP32[HEAP32[$0 + 36 >> 2] + (HEAP32[$4 + 16 >> 2] << 2) >> 2];
  HEAP32[$4 + 28 >> 2] = 0;
 }
 __stack_pointer = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}

function jswrap_array_concat($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = jsvNewEmptyArray();
 jsvObjectIteratorNew($2 + 16 | 0, HEAP32[$2 + 24 >> 2]);
 HEAP32[$2 + 12 >> 2] = jsvLockAgain(HEAP32[$2 + 28 >> 2]);
 while (1) {
  label$2: {
   if (jsvIsArray(HEAP32[$2 + 12 >> 2]) & 1) {
    jsvArrayPushAll(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 12 >> 2], 0);
    break label$2;
   }
   jsvArrayPush(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 12 >> 2]);
  }
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  label$4: {
   if (jsvObjectIteratorHasValue_6($2 + 16 | 0) & 1) {
    $0 = jsvObjectIteratorGetValue_6($2 + 16 | 0);
    break label$4;
   }
   $0 = 0;
  }
  HEAP32[$2 + 12 >> 2] = $0;
  jsvObjectIteratorNext($2 + 16 | 0);
  if (HEAP32[$2 + 12 >> 2]) {
   continue;
  }
  break;
 }
 jsvObjectIteratorFree_6($2 + 16 | 0);
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 20 >> 2];
}

function jswrap_pipe_drain_listener($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 label$1: {
  if (!(jsvIsObject(HEAP32[$1 + 28 >> 2]) & 1)) {
   break label$1;
  }
  HEAP32[$1 + 24 >> 2] = pipeGetArray(0);
  if (!HEAP32[$1 + 24 >> 2]) {
   break label$1;
  }
  jsvObjectIteratorNew($1 + 16 | 0, HEAP32[$1 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_16($1 + 16 | 0) & 1) {
    HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetValue_15($1 + 16 | 0);
    HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 12 >> 2], 128459);
    if (HEAP32[$1 + 8 >> 2] == HEAP32[$1 + 28 >> 2]) {
     jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 117690, jsvNewFromBool(0));
    }
    jsvUnLock2(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
    jsvObjectIteratorNext($1 + 16 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_16($1 + 16 | 0);
  jsvUnLock(HEAP32[$1 + 24 >> 2]);
 }
 __stack_pointer = $1 + 32 | 0;
}

function jswrap_espruino_variance($0, $1) {
 $0 = $0 | 0;
 $1 = +$1;
 var $2 = 0;
 $2 = __stack_pointer - 112 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 100 >> 2] = $0;
 HEAPF64[$2 + 88 >> 3] = $1;
 label$1: {
  if (!(jsvIsIterable(HEAP32[$2 + 100 >> 2]) & 1)) {
   HEAP32[$2 >> 2] = HEAP32[$2 + 100 >> 2];
   jsExceptionHere(1, 118163, $2);
   HEAPF64[$2 + 104 >> 3] = nan;
   break label$1;
  }
  HEAPF64[$2 + 80 >> 3] = 0;
  jsvIteratorNew($2 + 16 | 0, HEAP32[$2 + 100 >> 2], 1);
  while (1) {
   if (jsvIteratorHasElement($2 + 16 | 0) & 1) {
    HEAPF64[$2 + 8 >> 3] = jsvIteratorGetFloatValue($2 + 16 | 0);
    HEAPF64[$2 + 8 >> 3] = HEAPF64[$2 + 8 >> 3] - HEAPF64[$2 + 88 >> 3];
    HEAPF64[$2 + 80 >> 3] = HEAPF64[$2 + 8 >> 3] * HEAPF64[$2 + 8 >> 3] + HEAPF64[$2 + 80 >> 3];
    jsvIteratorNext($2 + 16 | 0);
    continue;
   }
   break;
  }
  jsvIteratorFree($2 + 16 | 0);
  HEAPF64[$2 + 104 >> 3] = HEAPF64[$2 + 80 >> 3];
 }
 __stack_pointer = $2 + 112 | 0;
 return +HEAPF64[$2 + 104 >> 3];
}

function jspeFunctionDefinition($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 27 | 0] = $0;
 HEAP32[$1 + 20 >> 2] = 0;
 HEAP8[$1 + 19 | 0] = (HEAP32[91094] & 63) == 1;
 if (HEAP8[$1 + 19 | 0] & 1) {
  HEAP32[$1 + 20 >> 2] = jsvNewWithFlags(7);
 }
 HEAP32[$1 + 12 >> 2] = 0;
 if (!(!(HEAP8[$1 + 27 | 0] & 1) | HEAP16[HEAP32[49079] + 2 >> 1] != 128)) {
  if (HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 12 >> 2] = jslGetTokenValueAsVar();
  }
  jslGetNextToken();
 }
 label$4: {
  if (!(jspeFunctionArguments(HEAP32[$1 + 20 >> 2]) & 1)) {
   jsvUnLock2(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 20 >> 2]);
   HEAP32[$1 + 28 >> 2] = 0;
   break label$4;
  }
  jspeFunctionDefinitionInternal(HEAP32[$1 + 20 >> 2], 0);
  if (!(!HEAP32[$1 + 20 >> 2] | !HEAP32[$1 + 12 >> 2])) {
   jsvObjectSetChildAndUnLock(HEAP32[$1 + 20 >> 2], 128707, HEAP32[$1 + 12 >> 2]);
  }
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function jswrap_espruino_sum($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 96 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 84 >> 2] = $0;
 label$1: {
  label$2: {
   if (jsvIsString(HEAP32[$1 + 84 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsArray(HEAP32[$1 + 84 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsArrayBuffer(HEAP32[$1 + 84 >> 2]) & 1) {
    break label$2;
   }
   HEAP32[$1 >> 2] = HEAP32[$1 + 84 >> 2];
   jsExceptionHere(1, 117955, $1);
   HEAPF64[$1 + 88 >> 3] = nan;
   break label$1;
  }
  HEAPF64[$1 + 72 >> 3] = 0;
  jsvIteratorNew($1 + 8 | 0, HEAP32[$1 + 84 >> 2], 0);
  while (1) {
   if (jsvIteratorHasElement($1 + 8 | 0) & 1) {
    $2 = jsvIteratorGetFloatValue($1 + 8 | 0);
    HEAPF64[$1 + 72 >> 3] = HEAPF64[$1 + 72 >> 3] + $2;
    jsvIteratorNext($1 + 8 | 0);
    continue;
   }
   break;
  }
  jsvIteratorFree($1 + 8 | 0);
  HEAPF64[$1 + 88 >> 3] = HEAPF64[$1 + 72 >> 3];
 }
 __stack_pointer = $1 + 96 | 0;
 return +HEAPF64[$1 + 88 >> 3];
}

function jsiTabComplete_findCommon($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 label$1: {
  if (jsvGetStringLength(HEAP32[$2 + 8 >> 2]) >>> 0 <= HEAPU32[HEAP32[$2 + 4 >> 2] >> 2]) {
   break label$1;
  }
  if (jsvCompareString(HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2], HEAP32[$2 + 8 >> 2], 0, 0, 1)) {
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
  HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
  label$2: {
   if (HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2]) {
    HEAP32[$2 >> 2] = jsvGetCommonCharacters(HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2], HEAP32[$2 + 8 >> 2]);
    jsvUnLock(HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2]);
    HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2] = HEAP32[$2 >> 2];
    break label$2;
   }
   $0 = jsvLockAgain(HEAP32[$2 + 8 >> 2]);
   HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2] = $0;
  }
 }
 __stack_pointer = $2 + 16 | 0;
}

function int_20gemmlowp__ShiftLeft_int__28int_2c_20int_29($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 32 | 0;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 $0 = HEAP32[$2 + 28 >> 2];
 $1 = $0 >> 31;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 $1 = HEAP32[$2 + 16 >> 2];
 $4 = $1;
 $0 = HEAP32[$2 + 20 >> 2];
 $3 = $0;
 $1 = 1 << HEAP32[$2 + 24 >> 2];
 $0 = $1 >> 31;
 $5 = $0;
 $0 = $3;
 $3 = $1;
 $1 = $5;
 $1 = __wasm_i64_mul($4, $0, $3, $1);
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = i64toi32_i32$HIGH_BITS;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = -2147483648;
 HEAP32[$2 >> 2] = 2147483647;
 $0 = HEAP32[$2 + 8 >> 2];
 $1 = HEAP32[$2 + 12 >> 2];
 if (($1 | 0) < 0 & $0 >>> 0 < 2147483648 | ($1 | 0) < -1) {
  $0 = -2147483648;
 } else {
  $0 = HEAP32[$2 + 8 >> 2];
  $1 = HEAP32[$2 + 12 >> 2];
  if ($0 >>> 0 > 2147483647 & ($1 | 0) >= 0 | ($1 | 0) > 0) {
   $0 = 2147483647;
  } else {
   $0 = HEAP32[$2 + 8 >> 2];
  }
 }
 return $0;
}

function jsvIteratorNext($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  label$2: {
   switch (HEAP32[HEAP32[$1 + 12 >> 2] >> 2] - 1 | 0) {
   case 3:
    $0 = HEAP32[$1 + 12 >> 2];
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    label$6: {
     if (!(jsvIsIntegerish(HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) & 1)) {
      break label$6;
     }
     if ((jsvGetInteger(HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) | 0) >= HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]) {
      break label$6;
     }
     jsvObjectIteratorNext(HEAP32[$1 + 12 >> 2] + 4 | 0);
    }
    break label$1;

   case 1:
    jsvObjectIteratorNext(HEAP32[$1 + 12 >> 2] + 4 | 0);
    break label$1;

   case 0:
    jsvStringIteratorNext(HEAP32[$1 + 12 >> 2] + 4 | 0);
    break label$1;

   case 2:
    break label$2;

   default:
    break label$1;
   }
  }
  jsvArrayBufferIteratorNext(HEAP32[$1 + 12 >> 2] + 4 | 0);
 }
 __stack_pointer = $1 + 16 | 0;
}

function jsvArrayPopFirst($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535) {
   HEAP32[$1 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535);
   if ((jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535) == (jsvGetLastChild(HEAP32[$1 + 8 >> 2]) & 65535)) {
    jsvSetLastChild(HEAP32[$1 + 8 >> 2], 0);
   }
   jsvSetFirstChild(HEAP32[$1 + 8 >> 2], jsvGetNextSibling(HEAP32[$1 + 4 >> 2]) & 65535);
   jsvUnRef(HEAP32[$1 + 4 >> 2]);
   if (jsvGetNextSibling(HEAP32[$1 + 4 >> 2]) & 65535) {
    HEAP32[$1 >> 2] = jsvLock(jsvGetNextSibling(HEAP32[$1 + 4 >> 2]) & 65535);
    jsvSetPrevSibling(HEAP32[$1 >> 2], 0);
    jsvUnLock(HEAP32[$1 >> 2]);
   }
   jsvSetNextSibling(HEAP32[$1 + 4 >> 2], 0);
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function i2c_wr_bit($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 label$1: {
  if (HEAP8[$2 + 11 | 0] & 1) {
   i2c_pin_wr1(HEAPU8[HEAP32[$2 + 12 >> 2] + 1 | 0]);
   break label$1;
  }
  i2c_pin_wr0(HEAPU8[HEAP32[$2 + 12 >> 2] + 1 | 0]);
 }
 dly(HEAP32[$2 + 12 >> 2]);
 i2c_pin_wr1(HEAPU8[HEAP32[$2 + 12 >> 2]]);
 dly(HEAP32[$2 + 12 >> 2]);
 dly(HEAP32[$2 + 12 >> 2]);
 HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2];
 while (1) {
  $0 = 0;
  if (!(jshPinGetValue(HEAPU8[HEAP32[$2 + 12 >> 2]]) & 1)) {
   $0 = HEAP32[$2 + 4 >> 2] != 0;
  }
  if ($0) {
   HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] - 1;
   continue;
  }
  break;
 }
 if (!(HEAP32[$2 + 4 >> 2] | !HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2])) {
  err(142903);
 }
 i2c_pin_wr0(HEAPU8[HEAP32[$2 + 12 >> 2]]);
 i2c_pin_wr1(HEAPU8[HEAP32[$2 + 12 >> 2] + 1 | 0]);
 dly(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_storage_readArrayBuffer($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 80 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 72 >> 2] = $0;
 jsfNameFromVar($1 + 40 | 0, HEAP32[$1 + 72 >> 2]);
 HEAP32[$1 + 32 >> 2] = HEAP32[$1 + 64 >> 2];
 $2 = HEAP32[$1 + 60 >> 2];
 $0 = HEAP32[$1 + 56 >> 2];
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 28 >> 2] = $2;
 $0 = HEAP32[$1 + 52 >> 2];
 $2 = HEAP32[$1 + 48 >> 2];
 HEAP32[$1 + 16 >> 2] = $2;
 HEAP32[$1 + 20 >> 2] = $0;
 $2 = HEAP32[$1 + 44 >> 2];
 $0 = HEAP32[$1 + 40 >> 2];
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 12 >> 2] = $2;
 HEAP32[$1 + 68 >> 2] = jsfReadFile($1 + 8 | 0, 0, 0);
 label$1: {
  if (!HEAP32[$1 + 68 >> 2]) {
   HEAP32[$1 + 76 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 36 >> 2] = jsvNewArrayBufferFromString(HEAP32[$1 + 68 >> 2], 0);
  jsvUnLock(HEAP32[$1 + 68 >> 2]);
  HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 36 >> 2];
 }
 __stack_pointer = $1 + 80 | 0;
 return HEAP32[$1 + 76 >> 2];
}

function jswrap_array_push($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (!(jsvIsArray(HEAP32[$2 + 24 >> 2]) & 1)) {
   HEAP32[$2 + 28 >> 2] = -1;
   break label$1;
  }
  HEAP32[$2 + 16 >> 2] = -1;
  jsvObjectIteratorNew($2 + 8 | 0, HEAP32[$2 + 20 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_6($2 + 8 | 0) & 1) {
    HEAP32[$2 + 4 >> 2] = jsvObjectIteratorGetValue_6($2 + 8 | 0);
    HEAP32[$2 + 16 >> 2] = jsvArrayPush(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 4 >> 2]);
    jsvUnLock(HEAP32[$2 + 4 >> 2]);
    jsvObjectIteratorNext($2 + 8 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_6($2 + 8 | 0);
  if (HEAP32[$2 + 16 >> 2] < 0) {
   HEAP32[$2 + 16 >> 2] = jsvGetArrayLength(HEAP32[$2 + 24 >> 2]);
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jshPinWatch($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP8[$3 + 14 | 0] = $0;
 HEAP8[$3 + 13 | 0] = $1;
 HEAP32[$3 + 8 >> 2] = $2;
 label$1: {
  if (HEAP8[$3 + 13 | 0] & 1) {
   HEAP32[$3 + 4 >> 2] = 0;
   while (1) {
    if (HEAP32[$3 + 4 >> 2] < 16) {
     if (HEAPU8[HEAP32[$3 + 4 >> 2] + 390976 | 0] == 255) {
      HEAP8[HEAP32[$3 + 4 >> 2] + 390976 | 0] = HEAPU8[$3 + 14 | 0];
      HEAP8[$3 + 15 | 0] = HEAP32[$3 + 4 >> 2] + 1;
      break label$1;
     } else {
      HEAP32[$3 >> 2] = 0;
      while (1) {
       if (HEAP32[$3 >> 2] < 16) {
        if (HEAPU8[HEAP32[$3 >> 2] + 390976 | 0] == HEAPU8[$3 + 14 | 0]) {
         HEAP8[HEAP32[$3 >> 2] + 390976 | 0] = 255;
        }
        HEAP32[$3 >> 2] = HEAP32[$3 >> 2] + 1;
        continue;
       }
       break;
      }
      HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 1;
      continue;
     }
    }
    break;
   }
  }
  HEAP8[$3 + 15 | 0] = 0;
 }
 return HEAPU8[$3 + 15 | 0];
}

function _jswrap_drawImageLayerNextXRepeat($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP8[HEAP32[$1 + 12 >> 2] + 33 | 0] & 1) {
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 180 >> 2] < 0) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 180 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 156 >> 2] + HEAP32[$0 + 180 >> 2];
  }
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 180 >> 2] >= HEAP32[HEAP32[$1 + 12 >> 2] + 156 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 180 >> 2] = HEAP32[$0 + 180 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 156 >> 2];
  }
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 184 >> 2] < 0) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 184 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2] + HEAP32[$0 + 184 >> 2];
  }
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 184 >> 2] >= HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2]) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 184 >> 2] = HEAP32[$0 + 184 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 160 >> 2];
  }
 }
}

function jswrap_object_toString($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 96 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP32[$2 + 84 >> 2] = $1;
 label$1: {
  label$2: {
   if (!(jsvIsInt(HEAP32[$2 + 84 >> 2]) & 1)) {
    break label$2;
   }
   if (!(jsvIsNumeric(HEAP32[$2 + 88 >> 2]) & 1)) {
    break label$2;
   }
   HEAP32[$2 + 80 >> 2] = jsvGetInteger(HEAP32[$2 + 84 >> 2]);
   if (!(HEAP32[$2 + 80 >> 2] < 2 | HEAP32[$2 + 80 >> 2] > 36)) {
    label$4: {
     if (jsvIsInt(HEAP32[$2 + 88 >> 2]) & 1) {
      itostr_3(jsvGetInteger(HEAP32[$2 + 88 >> 2]), $2, HEAP32[$2 + 80 >> 2]);
      break label$4;
     }
     ftoa_bounded_extra(jsvGetFloat(HEAP32[$2 + 88 >> 2]), $2, 70, HEAP32[$2 + 80 >> 2], -1);
    }
    HEAP32[$2 + 92 >> 2] = jsvNewFromString($2);
    break label$1;
   }
  }
  HEAP32[$2 + 92 >> 2] = jsvAsString(HEAP32[$2 + 88 >> 2]);
 }
 __stack_pointer = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}

function lcdSetPixel_JS($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 $0 = HEAP32[$4 + 28 >> 2];
 HEAP32[$4 + 12 >> 2] = jsvObjectGetChildIfExists(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 128800);
 if (HEAP32[$4 + 12 >> 2]) {
  HEAP32[$4 >> 2] = jsvNewFromInteger(HEAP32[$4 + 24 >> 2]);
  HEAP32[$4 + 4 >> 2] = jsvNewFromInteger(HEAP32[$4 + 20 >> 2]);
  HEAP32[$4 + 8 >> 2] = jsvNewFromInteger(HEAP32[$4 + 16 >> 2]);
  $0 = HEAP32[$4 + 28 >> 2];
  jsvUnLock(jspExecuteFunction(HEAP32[$4 + 12 >> 2], HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 3, $4));
  jsvUnLockMany(3, $4);
  jsvUnLock(HEAP32[$4 + 12 >> 2]);
 }
 __stack_pointer = $4 + 32 | 0;
}

function jswrap_arraybuffer_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (HEAP32[$1 + 8 >> 2] < 0) {
   jsExceptionHere(1, 121233, 0);
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$1 + 8 >> 2] > 16777215) {
   jsExceptionHere(1, 129704, 0);
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = 0;
  if (HEAP32[$1 + 8 >> 2] > 19) {
   HEAP32[$1 + 4 >> 2] = jsvNewFlatStringOfLength(HEAP32[$1 + 8 >> 2]);
  }
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 4 >> 2] = jsvNewStringOfLength(HEAP32[$1 + 8 >> 2], 0);
  }
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 >> 2] = jsvNewArrayBufferFromString(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2]);
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_graphics_getFonts_callback($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 label$1: {
  if (jsvGetStringLength(HEAP32[$2 + 8 >> 2]) >>> 0 <= 7) {
   break label$1;
  }
  if (!(jsvIsStringEqualOrStartsWith(HEAP32[$2 + 8 >> 2], 117454, 1) & 1)) {
   break label$1;
  }
  if (jsvIsStringEqual(HEAP32[$2 + 8 >> 2], 121849) & 1) {
   break label$1;
  }
  if (jsvIsStringEqual(HEAP32[$2 + 8 >> 2], 128520) & 1) {
   break label$1;
  }
  if (jsvIsStringEqual(HEAP32[$2 + 8 >> 2], 137678) & 1) {
   break label$1;
  }
  if (jsvIsStringEqual(HEAP32[$2 + 8 >> 2], 128672) & 1) {
   break label$1;
  }
  HEAP32[$2 >> 2] = jsvNewFromStringVar(HEAP32[$2 + 8 >> 2], 7, 2147483647);
  jsvArrayPush(HEAP32[$2 + 4 >> 2], HEAP32[$2 >> 2]);
  jsvUnLock(HEAP32[$2 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function jsvIsIntegerish($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $0 = 1;
  label$3: {
   if (HEAP8[$1 + 7 | 0] == 10) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 13) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 15) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 16) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 17) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 13) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 12) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 17) {
    break label$3;
   }
   $0 = HEAP8[$1 + 7 | 0] == 2;
  }
  HEAP8[$1 + 15 | 0] = $0;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function __jspePostfixExpression($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 while (1) {
  $0 = 1;
  $0 = HEAP16[HEAP32[49079] + 2 >> 1] != 152 ? HEAP16[HEAP32[49079] + 2 >> 1] == 153 : $0;
  if ($0) {
   HEAP32[$1 + 24 >> 2] = HEAP16[HEAP32[49079] + 2 >> 1];
   jslGetNextToken();
   if ((HEAP32[91094] & 63) == 1) {
    HEAP32[$1 + 20 >> 2] = jsvNewFromInteger(1);
    HEAP32[$1 + 16 >> 2] = jsvAsNumberAndUnLock(jsvSkipName(HEAP32[$1 + 28 >> 2]));
    HEAP32[$1 + 12 >> 2] = jsvMathsOpSkipNames(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 + 24 >> 2] == 152 ? 43 : 45);
    jsvUnLock(HEAP32[$1 + 20 >> 2]);
    jsvReplaceWith(HEAP32[$1 + 28 >> 2], HEAP32[$1 + 12 >> 2]);
    jsvUnLock(HEAP32[$1 + 12 >> 2]);
    jsvUnLock(HEAP32[$1 + 28 >> 2]);
    HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 16 >> 2];
   }
   continue;
  }
  break;
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function jspeiFindInScopes($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1: {
  if (HEAP32[91088]) {
   HEAP32[$1 + 20 >> 2] = jsvLockSafe(jsvGetLastChild(HEAP32[91088]) & 65535);
   while (1) {
    if (HEAP32[$1 + 20 >> 2]) {
     HEAP32[$1 + 16 >> 2] = jsvSkipName(HEAP32[$1 + 20 >> 2]);
     HEAP16[$1 + 14 >> 1] = jsvGetPrevSibling(HEAP32[$1 + 20 >> 2]);
     HEAP32[$1 + 8 >> 2] = jsvFindChildFromString(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 24 >> 2]);
     jsvUnLock2(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2]);
     if (HEAP32[$1 + 8 >> 2]) {
      HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 8 >> 2];
      break label$1;
     } else {
      HEAP32[$1 + 20 >> 2] = jsvLockSafe(HEAPU16[$1 + 14 >> 1]);
      continue;
     }
    }
    break;
   }
  }
  HEAP32[$1 + 28 >> 2] = jsvFindChildFromString(HEAP32[91086], HEAP32[$1 + 24 >> 2]);
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function jsiMoveCursor($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 while (1) {
  if (HEAPU32[$4 + 12 >> 2] < HEAPU32[$4 + 4 >> 2]) {
   jsiConsolePrintString(138117);
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 while (1) {
  if (HEAPU32[$4 + 12 >> 2] > HEAPU32[$4 + 4 >> 2]) {
   jsiConsolePrintString(137919);
   HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] - 1;
   continue;
  }
  break;
 }
 while (1) {
  if (HEAPU32[$4 + 8 >> 2] < HEAPU32[$4 >> 2]) {
   jsiConsolePrintString(138153);
   HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 while (1) {
  if (HEAPU32[$4 + 8 >> 2] > HEAPU32[$4 >> 2]) {
   jsiConsolePrintString(138211);
   HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] - 1;
   continue;
  }
  break;
 }
 __stack_pointer = $4 + 16 | 0;
}

function __strchrnul($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  $3 = $1 & 255;
  if ($3) {
   if ($0 & 3) {
    while (1) {
     $2 = HEAPU8[$0 | 0];
     if (!$2 | ($1 & 255) == ($2 | 0)) {
      break label$1;
     }
     $0 = $0 + 1 | 0;
     if ($0 & 3) {
      continue;
     }
     break;
    }
   }
   $2 = HEAP32[$0 >> 2];
   label$5: {
    if (($2 ^ -1) & $2 - 16843009 & -2139062144) {
     break label$5;
    }
    $3 = Math_imul($3, 16843009);
    while (1) {
     $2 = $2 ^ $3;
     if (($2 ^ -1) & $2 - 16843009 & -2139062144) {
      break label$5;
     }
     $2 = HEAP32[$0 + 4 >> 2];
     $0 = $0 + 4 | 0;
     if (!($2 - 16843009 & ($2 ^ -1) & -2139062144)) {
      continue;
     }
     break;
    }
   }
   while (1) {
    $2 = $0;
    $3 = HEAPU8[$2 | 0];
    if ($3) {
     $0 = $2 + 1 | 0;
     if (($1 & 255) != ($3 | 0)) {
      continue;
     }
    }
    break;
   }
   return $2;
  }
  return strlen($0) + $0 | 0;
 }
 return $0;
}

function jsvGetStringChars($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 56 >> 2] = $0;
 HEAP32[$4 + 52 >> 2] = $1;
 HEAP32[$4 + 48 >> 2] = $2;
 HEAP32[$4 + 44 >> 2] = $3;
 HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 44 >> 2];
 jsvStringIteratorNew($4, HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2]);
 label$1: {
  while (1) {
   if (jsvStringIteratorHasChar_1($4) & 1) {
    $0 = HEAP32[$4 + 40 >> 2];
    HEAP32[$4 + 40 >> 2] = $0 - 1;
    if ($0) {
     $1 = jsvStringIteratorGetCharAndNext($4);
     $0 = HEAP32[$4 + 48 >> 2];
     HEAP32[$4 + 48 >> 2] = $0 + 1;
     HEAP8[$0 | 0] = $1;
     continue;
    } else {
     jsvStringIteratorFree_1($4);
     HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 44 >> 2];
     break label$1;
    }
   }
   break;
  }
  jsvStringIteratorFree_1($4);
  HEAP32[$4 + 60 >> 2] = HEAP32[$4 + 44 >> 2] - HEAP32[$4 + 40 >> 2];
 }
 __stack_pointer = $4 - -64 | 0;
 return HEAP32[$4 + 60 >> 2];
}

function tflite__GetQuantizedConvolutionMultipler_28TfLiteContext__2c_20TfLiteTensor_20const__2c_20TfLiteTensor_20const__2c_20TfLiteTensor__2c_20double__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 40 >> 2] = $0;
 HEAP32[$5 + 36 >> 2] = $1;
 HEAP32[$5 + 32 >> 2] = $2;
 HEAP32[$5 + 28 >> 2] = $3;
 HEAP32[$5 + 24 >> 2] = $4;
 HEAPF64[$5 + 16 >> 3] = Math_fround(HEAPF32[HEAP32[$5 + 36 >> 2] + 8 >> 2] * HEAPF32[HEAP32[$5 + 32 >> 2] + 8 >> 2]);
 label$1: {
  if (!(HEAPF64[$5 + 16 >> 3] >= 0)) {
   $0 = HEAP32[HEAP32[$5 + 40 >> 2] + 20 >> 2];
   $1 = HEAP32[$5 + 40 >> 2];
   HEAP32[$5 >> 2] = 140063;
   FUNCTION_TABLE[$0 | 0]($1, 140586, $5);
   HEAP32[$5 + 44 >> 2] = 1;
   break label$1;
  }
  HEAPF64[HEAP32[$5 + 24 >> 2] >> 3] = HEAPF64[$5 + 16 >> 3] / +HEAPF32[HEAP32[$5 + 28 >> 2] + 8 >> 2];
  HEAP32[$5 + 44 >> 2] = 0;
 }
 __stack_pointer = $5 + 48 | 0;
 return HEAP32[$5 + 44 >> 2];
}

function jsvGetArrayItems($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 jsvObjectIteratorNew($3 + 16 | 0, HEAP32[$3 + 28 >> 2]);
 HEAP32[$3 + 12 >> 2] = 0;
 while (1) {
  if (jsvObjectIteratorHasValue($3 + 16 | 0) & 1) {
   if (HEAPU32[$3 + 12 >> 2] < HEAPU32[$3 + 24 >> 2]) {
    $1 = jsvObjectIteratorGetValue($3 + 16 | 0);
    $2 = HEAP32[$3 + 20 >> 2];
    $0 = HEAP32[$3 + 12 >> 2];
    HEAP32[$3 + 12 >> 2] = $0 + 1;
    HEAP32[($0 << 2) + $2 >> 2] = $1;
   }
   jsvObjectIteratorNext($3 + 16 | 0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree($3 + 16 | 0);
 while (1) {
  if (HEAPU32[$3 + 12 >> 2] < HEAPU32[$3 + 24 >> 2]) {
   $1 = HEAP32[$3 + 20 >> 2];
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 + 12 >> 2] = $0 + 1;
   HEAP32[($0 << 2) + $1 >> 2] = 0;
   continue;
  }
  break;
 }
 __stack_pointer = $3 + 32 | 0;
}

function jswrap_arraybufferview_sort($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (!(jsvIsArrayBuffer(HEAP32[$2 + 24 >> 2]) & 1)) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP8[$2 + 19 | 0] = (HEAPU8[HEAP32[$2 + 24 >> 2] + 5 | 0] & 32) != 0;
  if (HEAP32[$2 + 20 >> 2]) {
   HEAP32[$2 + 28 >> 2] = jswrap_array_sort(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
   break label$1;
  }
  label$4: {
   if (HEAP8[$2 + 19 | 0] & 1) {
    $0 = jsvNewNativeFunction(621, 511);
    break label$4;
   }
   $0 = jsvNewNativeFunction(622, 292);
  }
  HEAP32[$2 + 20 >> 2] = $0;
  HEAP32[$2 + 12 >> 2] = jswrap_array_sort(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
  jsvUnLock(HEAP32[$2 + 20 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jsfIsEqual($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 160 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 152 >> 2] = $0;
 HEAP32[$3 + 148 >> 2] = $1;
 HEAP32[$3 + 144 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = 0;
 label$1: {
  while (1) {
   if (HEAP32[$3 + 144 >> 2]) {
    HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 144 >> 2];
    if (HEAPU32[$3 + 8 >> 2] > 128) {
     HEAP32[$3 + 8 >> 2] = 128;
    }
    jshFlashRead($3 + 16 | 0, HEAP32[$3 + 152 >> 2] + HEAP32[$3 + 12 >> 2] | 0, HEAP32[$3 + 8 >> 2]);
    if (memcmp($3 + 16 | 0, HEAP32[$3 + 148 >> 2] + HEAP32[$3 + 12 >> 2] | 0, HEAP32[$3 + 8 >> 2])) {
     HEAP8[$3 + 159 | 0] = 0;
     break label$1;
    } else {
     HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$3 + 12 >> 2];
     HEAP32[$3 + 144 >> 2] = HEAP32[$3 + 144 >> 2] - HEAP32[$3 + 8 >> 2];
     continue;
    }
   }
   break;
  }
  HEAP8[$3 + 159 | 0] = 1;
 }
 __stack_pointer = $3 + 160 | 0;
 return HEAP8[$3 + 159 | 0] & 1;
}

function lcdMemLCD_setPixel($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 16 >> 2] = lcdMemLCD_convert16toLCD(HEAP32[$4 + 16 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2]);
 lcdMemLCD_waitForSendComplete();
 HEAP32[$4 + 12 >> 2] = (Math_imul(HEAP32[$4 + 24 >> 2], 3) + 16 | 0) + (Math_imul(HEAP32[$4 + 20 >> 2], 68) << 3);
 HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 12 >> 2] & 7;
 $0 = HEAP32[$4 + 12 >> 2] >> 3;
 HEAP16[$4 + 6 >> 1] = HEAPU8[$0 + 378848 | 0] | HEAPU8[$0 + 378849 | 0] << 8;
 $0 = HEAP32[$4 + 12 >> 2] >> 3;
 $1 = HEAPU16[$4 + 6 >> 1] & (7 << HEAP32[$4 + 8 >> 2] ^ -1) | HEAP32[$4 + 16 >> 2] << HEAP32[$4 + 8 >> 2];
 HEAP8[$0 + 378848 | 0] = $1;
 HEAP8[$0 + 378849 | 0] = $1 >>> 8;
 __stack_pointer = $4 + 32 | 0;
}

function _jswrap_banglejs_setLocked($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 31 | 0] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 if ((HEAP32[97749] & 262144) != (HEAP8[$2 + 31 | 0] & 1)) {
  HEAP32[$2 + 20 >> 2] = jsvObjectGetChildIfExists(HEAP32[91086], 132487);
  if (HEAP32[$2 + 20 >> 2]) {
   HEAP32[$2 + 12 >> 2] = jsvNewFromBool(HEAP8[$2 + 31 | 0] & 1);
   $1 = $2 + 12 | 0;
   label$3: {
    if (HEAP32[$2 + 24 >> 2]) {
     $0 = jsvNewFromString(HEAP32[$2 + 24 >> 2]);
     break label$3;
    }
    $0 = 0;
   }
   HEAP32[$1 + 4 >> 2] = $0;
   jsiQueueObjectCallbacks(HEAP32[$2 + 20 >> 2], 129113, $2 + 12 | 0, 2);
   jsvUnLockMany(2, $2 + 12 | 0);
  }
  jsvUnLock(HEAP32[$2 + 20 >> 2]);
 }
 label$5: {
  if (HEAP8[$2 + 31 | 0] & 1) {
   HEAP32[97749] = HEAP32[97749] | 262144;
   break label$5;
  }
  HEAP16[195510] = 0;
  HEAP32[97749] = HEAP32[97749] & -262145;
 }
 __stack_pointer = $2 + 32 | 0;
}

function jsiExecuteEventCallback($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 HEAP32[$4 + 8 >> 2] = jsvSkipName(HEAP32[$4 + 20 >> 2]);
 label$1: {
  if (!HEAP32[$4 + 8 >> 2]) {
   HEAP8[$4 + 31 | 0] = 0;
   break label$1;
  }
  HEAP16[182206] = HEAPU16[182206] | 8192;
  HEAP8[$4 + 7 | 0] = jsiExecuteEventCallbackInner(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 16 >> 2], HEAP32[$4 + 12 >> 2]) & 1;
  jsvUnLock(HEAP32[$4 + 8 >> 2]);
  HEAP16[182206] = HEAPU16[182206] & -24577;
  label$3: {
   if (HEAP8[$4 + 7 | 0] & 1) {
    if (!(jspIsInterrupted() & 1)) {
     break label$3;
    }
   }
   HEAP16[182206] = HEAPU16[182206] | 32768;
   HEAP8[$4 + 31 | 0] = 0;
   break label$1;
  }
  HEAP8[$4 + 31 | 0] = 1;
 }
 __stack_pointer = $4 + 32 | 0;
 return HEAP8[$4 + 31 | 0] & 1;
}

function jsvFindChildFromVar($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP8[$3 + 19 | 0] = $2;
 HEAP16[$3 + 10 >> 1] = jsvGetFirstChild(HEAP32[$3 + 24 >> 2]);
 label$1: {
  while (1) {
   if (HEAPU16[$3 + 10 >> 1]) {
    HEAP32[$3 + 12 >> 2] = jsvLock(HEAPU16[$3 + 10 >> 1]);
    if (jsvIsBasicVarEqual(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 20 >> 2]) & 1) {
     break label$1;
    }
    HEAP16[$3 + 10 >> 1] = jsvGetNextSibling(HEAP32[$3 + 12 >> 2]);
    jsvUnLock(HEAP32[$3 + 12 >> 2]);
    continue;
   }
   break;
  }
  HEAP32[$3 + 12 >> 2] = 0;
  if (!(!(HEAP8[$3 + 19 | 0] & 1) | !HEAP32[$3 + 20 >> 2])) {
   HEAP32[$3 + 12 >> 2] = jsvAsName(HEAP32[$3 + 20 >> 2]);
   jsvAddName(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 12 >> 2]);
  }
 }
 HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function graphicsGetPixelDevice($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 8 >> 2] = $0;
 HEAP32[$3 + 4 >> 2] = $1;
 HEAP32[$3 >> 2] = $2;
 label$1: {
  label$2: {
   label$3: {
    if ((HEAP32[$3 + 4 >> 2] | HEAP32[$3 >> 2]) < 0) {
     break label$3;
    }
    $0 = HEAP32[$3 + 8 >> 2];
    if (HEAP32[$3 + 4 >> 2] >= (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8)) {
     break label$3;
    }
    $0 = HEAP32[$3 + 8 >> 2];
    if (HEAP32[$3 >> 2] < (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8)) {
     break label$2;
    }
   }
   HEAP32[$3 + 12 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$3 + 8 >> 2];
  HEAP32[$3 + 12 >> 2] = FUNCTION_TABLE[HEAPU8[$0 + 60 | 0] | HEAPU8[$0 + 61 | 0] << 8 | (HEAPU8[$0 + 62 | 0] << 16 | HEAPU8[$0 + 63 | 0] << 24)](HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$3 >> 2]);
 }
 __stack_pointer = $3 + 16 | 0;
 return HEAP32[$3 + 12 >> 2];
}

function jslPreserveSpaceBetweenTokens($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (!(!(HEAP32[$2 + 8 >> 2] == 128 | HEAP32[$2 + 8 >> 2] == 130) & HEAP32[$2 + 8 >> 2] != 129 | !(HEAP32[$2 + 4 >> 2] == 128 | HEAP32[$2 + 4 >> 2] == 130) & HEAP32[$2 + 4 >> 2] != 129)) {
   HEAP8[$2 + 15 | 0] = 1;
   break label$1;
  }
  label$5: {
   label$6: {
    if (HEAP32[$2 + 8 >> 2] == 47 & HEAP32[$2 + 4 >> 2] == 135 | (HEAP32[$2 + 8 >> 2] == 45 & HEAP32[$2 + 4 >> 2] == 45 | HEAP32[$2 + 8 >> 2] == 43 & HEAP32[$2 + 4 >> 2] == 43)) {
     break label$6;
    }
    if (HEAP32[$2 + 8 >> 2] != 135) {
     break label$5;
    }
    if (HEAP32[$2 + 4 >> 2] == 47) {
     break label$6;
    }
    if (HEAP32[$2 + 4 >> 2] != 128) {
     break label$5;
    }
   }
   HEAP8[$2 + 15 | 0] = 1;
   break label$1;
  }
  HEAP8[$2 + 15 | 0] = 0;
 }
 return HEAP8[$2 + 15 | 0] & 1;
}

function jswrap_espruino_lookupNoCase($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 96 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP8[$3 + 83 | 0] = $2;
 label$1: {
  if (!(jsvHasChildren(HEAP32[$3 + 88 >> 2]) & 1)) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  if ((jsvGetString(HEAP32[$3 + 84 >> 2], $3 + 16 | 0, 64) | 0) == 64) {
   HEAP32[$3 >> 2] = 64;
   jsExceptionHere(1, 142773, $3);
  }
  if (HEAP8[$3 + 83 | 0] & 1) {
   HEAP32[$3 + 12 >> 2] = jsvFindChildFromStringI(HEAP32[$3 + 88 >> 2], $3 + 16 | 0);
   if (HEAP32[$3 + 12 >> 2]) {
    HEAP32[$3 + 92 >> 2] = jsvAsStringAndUnLock(HEAP32[$3 + 12 >> 2]);
    break label$1;
   }
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 92 >> 2] = jsvObjectGetChildI(HEAP32[$3 + 88 >> 2], $3 + 16 | 0);
 }
 __stack_pointer = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}

function tflite__internal__GetFlatbufferTensorBuffer_28tflite__Tensor_20const__2c_20flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer___20const__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer____operator_5b_5d_28unsigned_20int_29_20const(HEAP32[$2 + 24 >> 2], tflite__Tensor__buffer_28_29_20const(HEAP32[$2 + 28 >> 2]));
 if (HEAP32[$2 + 16 >> 2]) {
  HEAP32[$2 + 12 >> 2] = tflite__Buffer__data_28_29_20const(HEAP32[$2 + 16 >> 2]);
  if (HEAP32[$2 + 12 >> 2]) {
   if (flatbuffers__Vector_unsigned_20char___size_28_29_20const(HEAP32[$2 + 12 >> 2])) {
    HEAP32[$2 + 20 >> 2] = flatbuffers__Vector_unsigned_20char___data_28_29_20const(HEAP32[$2 + 12 >> 2]);
   }
  }
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 20 >> 2];
}

function jswrap_object_create($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  label$2: {
   if (jsvIsObject(HEAP32[$2 + 24 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsNull(HEAP32[$2 + 24 >> 2]) & 1) {
    break label$2;
   }
   HEAP32[$2 >> 2] = HEAP32[$2 + 24 >> 2];
   jsExceptionHere(3, 119528, $2);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  if (jsvIsObject(HEAP32[$2 + 20 >> 2]) & 1) {
   jsExceptionHere(1, 117787, 0);
  }
  HEAP32[$2 + 16 >> 2] = jsvNewObject();
  if (!HEAP32[$2 + 16 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  if (jsvIsObject(HEAP32[$2 + 24 >> 2]) & 1) {
   jsvObjectSetChild(HEAP32[$2 + 16 >> 2], 135865, HEAP32[$2 + 24 >> 2]);
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jswrap_string_startsWith($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1: {
  if (!(jsvIsString(HEAP32[$3 + 24 >> 2]) & 1)) {
   HEAP8[$3 + 31 | 0] = 0;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvAsString(HEAP32[$3 + 20 >> 2]);
  HEAP8[$3 + 11 | 0] = 0;
  label$3: {
   if (HEAP32[$3 + 16 >> 2] < 0) {
    break label$3;
   }
   if ((jsvGetStringLength(HEAP32[$3 + 12 >> 2]) + HEAP32[$3 + 16 >> 2] | 0) > (jsvGetStringLength(HEAP32[$3 + 24 >> 2]) | 0)) {
    break label$3;
   }
   HEAP8[$3 + 11 | 0] = !jsvCompareString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2], 0, 1);
  }
  jsvUnLock(HEAP32[$3 + 12 >> 2]);
  HEAP8[$3 + 31 | 0] = HEAP8[$3 + 11 | 0] & 1;
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP8[$3 + 31 | 0] & 1;
}

function jsvGetFunctionArgumentLength($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = jsvNewEmptyArray();
 label$1: {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  jsvObjectIteratorNew($1 + 16 | 0, HEAP32[$1 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue($1 + 16 | 0) & 1) {
    HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetKey($1 + 16 | 0);
    if (jsvIsFunctionParameter(HEAP32[$1 + 12 >> 2]) & 1) {
     HEAP32[$1 + 8 >> 2] = jsvSkipOneName(HEAP32[$1 + 12 >> 2]);
     jsvArrayPushAndUnLock(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 8 >> 2]);
    }
    jsvUnLock(HEAP32[$1 + 12 >> 2]);
    jsvObjectIteratorNext($1 + 16 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree($1 + 16 | 0);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function jsiHandleMoveUpDown($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 16 >> 2] = jsvGetLinesInString(HEAP32[91104]);
 jsvGetLineAndCol(HEAP32[91104], HEAP32[91106], $1 + 20 | 0, $1 + 24 | 0);
 HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 24 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 20 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + HEAP32[$1 + 28 >> 2];
 if (!HEAP32[$1 + 8 >> 2]) {
  HEAP32[$1 + 8 >> 2] = 1;
 }
 if (HEAPU32[$1 + 8 >> 2] > HEAPU32[$1 + 16 >> 2]) {
  HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 16 >> 2];
 }
 HEAP32[91106] = jsvGetIndexFromLineAndCol(HEAP32[91104], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
 jsvGetLineAndCol(HEAP32[91104], HEAP32[91106], $1 + 8 | 0, $1 + 12 | 0);
 if (jsiShowInputLine() & 1) {
  jsiMoveCursor(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2]);
 }
 __stack_pointer = $1 + 32 | 0;
}

function jswrap_espruino_enableWatchdog($0, $1) {
 $0 = +$0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAPF64[$2 + 24 >> 3] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  label$2: {
   if (HEAPF64[$2 + 24 >> 3] < 0) {
    break label$2;
   }
   $3 = __DOUBLE_BITS_7(HEAPF64[$2 + 24 >> 3]);
   $1 = $3;
   $4 = i64toi32_i32$HIGH_BITS;
   $3 = $4 & 2147483647;
   $4 = $1;
   if (($3 | 0) == 2146435072 & ($4 | 0) != 0 | $3 >>> 0 > 2146435072) {
    break label$2;
   }
   break label$1;
  }
  HEAPF64[$2 + 24 >> 3] = 1;
 }
 label$3: {
  label$4: {
   if (!(jsvIsUndefined(HEAP32[$2 + 20 >> 2]) & 1)) {
    if (!(jsvGetBool(HEAP32[$2 + 20 >> 2]) & 1)) {
     break label$4;
    }
   }
   HEAP16[182206] = HEAPU16[182206] | 512;
   break label$3;
  }
  HEAP16[182206] = HEAPU16[182206] & -513;
 }
 jshEnableWatchDog(HEAPF64[$2 + 24 >> 3]);
 __stack_pointer = $2 + 32 | 0;
}

function jsvIsIterable($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $0 = 1;
  label$3: {
   if (HEAP8[$1 + 7 | 0] == 3) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 5) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 1) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 7) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 9) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 8) {
    break label$3;
   }
   if (HEAP8[$1 + 7 | 0] >= 18) {
    $0 = 1;
    if (HEAP8[$1 + 7 | 0] <= 40) {
     break label$3;
    }
   }
   $0 = HEAP8[$1 + 7 | 0] == 4;
  }
  HEAP8[$1 + 15 | 0] = $0;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function jsvGetArrayBufferBackingString($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (!HEAP32[$2 + 8 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  jsvLockAgain(HEAP32[$2 + 8 >> 2]);
  if (HEAP32[$2 + 4 >> 2]) {
   HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = 0;
  }
  while (1) {
   if (jsvIsArrayBuffer(HEAP32[$2 + 8 >> 2]) & 1) {
    if (HEAP32[$2 + 4 >> 2]) {
     $0 = HEAP32[$2 + 4 >> 2];
     $1 = HEAP32[$2 + 8 >> 2];
     HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + (HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8);
    }
    HEAP32[$2 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$2 + 8 >> 2]) & 65535);
    jsvUnLock(HEAP32[$2 + 8 >> 2]);
    HEAP32[$2 + 8 >> 2] = HEAP32[$2 >> 2];
    continue;
   }
   break;
  }
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 8 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function graphicsGetSetPixelUnclippedFn($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 32 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 24 >> 2] = $0;
 HEAP32[$6 + 20 >> 2] = $1;
 HEAP32[$6 + 16 >> 2] = $2;
 HEAP32[$6 + 12 >> 2] = $3;
 HEAP32[$6 + 8 >> 2] = $4;
 HEAP8[$6 + 7 | 0] = $5;
 label$1: {
  label$2: {
   $0 = HEAP32[$6 + 24 >> 2];
   if (!((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 112)) {
    if (!(graphicsSetModifiedAndClip(HEAP32[$6 + 24 >> 2], $6 + 20 | 0, $6 + 16 | 0, $6 + 12 | 0, $6 + 8 | 0, HEAP8[$6 + 7 | 0] & 1) & 1)) {
     break label$2;
    }
   }
   HEAP32[$6 + 28 >> 2] = 581;
   break label$1;
  }
  $0 = HEAP32[$6 + 24 >> 2];
  HEAP32[$6 + 28 >> 2] = HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24);
 }
 __stack_pointer = $6 + 32 | 0;
 return HEAP32[$6 + 28 >> 2];
}

function jshFlashErasePages($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 24 >> 2] + HEAP32[$2 + 20 >> 2];
 label$1: {
  if (!(jshFlashGetPage(HEAP32[$2 + 24 >> 2], $2 + 12 | 0, $2 + 8 | 0) & 1)) {
   HEAP8[$2 + 31 | 0] = 0;
   break label$1;
  }
  while (1) {
   $0 = 0;
   if (HEAPU32[$2 + 12 >> 2] < HEAPU32[$2 + 16 >> 2]) {
    $0 = jspIsInterrupted() ^ -1;
   }
   if ($0 & 1) {
    jshFlashErasePage(HEAP32[$2 + 12 >> 2]);
    if (!(jshFlashGetPage(HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 8 >> 2] | 0, $2 + 12 | 0, $2 + 8 | 0) & 1)) {
     HEAP8[$2 + 31 | 0] = 1;
     break label$1;
    }
    jshKickWatchDog();
    jshKickSoftWatchDog();
    continue;
   }
   break;
  }
  HEAP8[$2 + 31 | 0] = (jspIsInterrupted() ^ -1) & 1;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP8[$2 + 31 | 0] & 1;
}

function __stpcpy($0, $1) {
 var $2 = 0;
 label$1: {
  label$2: {
   if (($0 ^ $1) & 3) {
    $2 = HEAPU8[$1 | 0];
    break label$2;
   }
   if ($1 & 3) {
    while (1) {
     $2 = HEAPU8[$1 | 0];
     HEAP8[$0 | 0] = $2;
     if (!$2) {
      break label$1;
     }
     $0 = $0 + 1 | 0;
     $1 = $1 + 1 | 0;
     if ($1 & 3) {
      continue;
     }
     break;
    }
   }
   $2 = HEAP32[$1 >> 2];
   if (($2 ^ -1) & $2 - 16843009 & -2139062144) {
    break label$2;
   }
   while (1) {
    HEAP32[$0 >> 2] = $2;
    $2 = HEAP32[$1 + 4 >> 2];
    $0 = $0 + 4 | 0;
    $1 = $1 + 4 | 0;
    if (!($2 - 16843009 & ($2 ^ -1) & -2139062144)) {
     continue;
    }
    break;
   }
  }
  HEAP8[$0 | 0] = $2;
  if (!($2 & 255)) {
   break label$1;
  }
  while (1) {
   $2 = HEAPU8[$1 + 1 | 0];
   HEAP8[$0 + 1 | 0] = $2;
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
 return $0;
}

function jswrap_banglejs_powerusage($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (jswrap_banglejs_isBacklightOn()) {
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 117731, jsvNewFromInteger(14e3));
 }
 if (!jswrap_banglejs_isLocked()) {
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 129515, jsvNewFromInteger(1600));
 }
 if (jswrap_banglejs_isHRMOn()) {
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 137237, jsvNewFromInteger(700));
 }
 if (jswrap_banglejs_isGPSOn()) {
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 136781, jsvNewFromInteger(2e4));
 }
 if (jswrap_banglejs_isCompassOn()) {
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 119874, jsvNewFromInteger(600));
 }
 if (jswrap_banglejs_isBarometerOn()) {
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 128042, jsvNewFromInteger(200));
 }
 __stack_pointer = $1 + 16 | 0;
}

function tflite__MicroMutableOpResolver_9u___FindOp_28char_20const__29_20const($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 $0 = HEAP32[$2 + 24 >> 2];
 HEAP32[$2 + 16 >> 2] = 0;
 label$1: {
  while (1) {
   if (HEAPU32[$2 + 16 >> 2] < HEAPU32[$0 + 292 >> 2]) {
    HEAP32[$2 + 12 >> 2] = ($0 + 4 | 0) + (HEAP32[$2 + 16 >> 2] << 5);
    label$4: {
     if (HEAP32[HEAP32[$2 + 12 >> 2] + 20 >> 2] != 32) {
      break label$4;
     }
     if (strcmp(HEAP32[HEAP32[$2 + 12 >> 2] + 24 >> 2], HEAP32[$2 + 20 >> 2])) {
      break label$4;
     }
     HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
     break label$1;
    }
    HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function tflite__CalculateInputRadius_28int_2c_20int_2c_20int_29($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 32 | 0;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 $0 = $3;
 $1 = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 28 >> 2] | 0;
 $2 = $1 & 31;
 $4 = +((1 << HEAP32[$3 + 28 >> 2]) - 1 | 0) * 1;
 if (($1 & 63) >>> 0 >= 32) {
  $1 = 1 << $2;
  $2 = 0;
 } else {
  $1 = (1 << $2) - 1 & 1 >>> 32 - $2;
  $2 = 1 << $2;
 }
 $4 = $4 * (+($2 >>> 0) + +($1 | 0) * 4294967296);
 $1 = HEAP32[$3 + 24 >> 2];
 $2 = $1 & 31;
 if (($1 & 63) >>> 0 >= 32) {
  $1 = 1 << $2;
  $2 = 0;
 } else {
  $1 = (1 << $2) - 1 & 1 >>> 32 - $2;
  $2 = 1 << $2;
 }
 HEAPF64[$0 + 8 >> 3] = $4 / (+($2 >>> 0) + +($1 | 0) * 4294967296);
 $4 = Math_floor(HEAPF64[$3 + 8 >> 3]);
 label$1: {
  if (Math_abs($4) < 2147483648) {
   $0 = ~~$4;
   break label$1;
  }
  $0 = -2147483648;
 }
 return $0;
}

function jshGetDeviceFor($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP16[$3 + 12 >> 1] = $0;
 HEAP16[$3 + 10 >> 1] = $1;
 HEAP8[$3 + 9 | 0] = $2;
 label$1: {
  if (!(jshIsPinValid(HEAPU8[$3 + 9 | 0]) & 1)) {
   HEAP16[$3 + 14 >> 1] = 0;
   break label$1;
  }
  HEAP32[$3 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$3 + 4 >> 2] < 0) {
    $0 = (Math_imul(HEAPU8[$3 + 9 | 0], 3) + 180755 | 0) + (HEAP32[$3 + 4 >> 2] << 1) | 0;
    HEAP16[$3 + 2 >> 1] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8;
    if (!(HEAPU16[$3 + 10 >> 1] < (HEAPU16[$3 + 2 >> 1] & 4080) | HEAPU16[$3 + 12 >> 1] > (HEAPU16[$3 + 2 >> 1] & 4080))) {
     HEAP16[$3 + 14 >> 1] = HEAPU16[$3 + 2 >> 1];
     break label$1;
    }
    HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP16[$3 + 14 >> 1] = 0;
 }
 __stack_pointer = $3 + 16 | 0;
 return HEAPU16[$3 + 14 >> 1];
}

function jsvArrayPushAll($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP8[$3 + 23 | 0] = $2;
 jsvObjectIteratorNew($3 + 16 | 0, HEAP32[$3 + 24 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue($3 + 16 | 0) & 1) {
   HEAP32[$3 + 12 >> 2] = jsvObjectIteratorGetValue($3 + 16 | 0);
   HEAP8[$3 + 11 | 0] = 1;
   if (HEAP8[$3 + 23 | 0] & 1) {
    HEAP32[$3 + 4 >> 2] = jsvGetIndexOf(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 12 >> 2], 0);
    if (HEAP32[$3 + 4 >> 2]) {
     HEAP8[$3 + 11 | 0] = 0;
     jsvUnLock(HEAP32[$3 + 4 >> 2]);
    }
   }
   if (HEAP8[$3 + 11 | 0] & 1) {
    jsvArrayPush(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 12 >> 2]);
   }
   jsvUnLock(HEAP32[$3 + 12 >> 2]);
   jsvObjectIteratorNext($3 + 16 | 0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree($3 + 16 | 0);
 __stack_pointer = $3 + 32 | 0;
}

function jsfResetStorage_progress($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = 0;
 while (1) {
  if (HEAP32[$3 + 20 >> 2]) {
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 20 >> 2];
   if (HEAPU32[$3 + 16 >> 2] > 8192) {
    HEAP32[$3 + 16 >> 2] = 8192;
   }
   jshFlashWrite(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 16 >> 2]);
   HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 28 >> 2];
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2] + HEAP32[$3 + 24 >> 2];
   HEAP32[$3 + 20 >> 2] = HEAP32[$3 + 20 >> 2] - HEAP32[$3 + 16 >> 2];
   HEAP32[$3 >> 2] = HEAP8[(HEAP32[$3 + 12 >> 2] & 3) + 116066 | 0];
   jsiConsolePrintf(135685, $3);
   HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $3 + 32 | 0;
}

function jswrap_graphics_lineTo($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 96 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP32[$3 + 80 >> 2] = $2;
 label$1: {
  if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  graphicsDrawLine($3 + 8 | 0, (HEAPU8[$3 + 35 | 0] | HEAPU8[$3 + 36 | 0] << 8) << 16 >> 16, (HEAPU8[$3 + 37 | 0] | HEAPU8[$3 + 38 | 0] << 8) << 16 >> 16, HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2]);
  $0 = HEAP32[$3 + 84 >> 2];
  HEAP8[$3 + 35 | 0] = $0;
  HEAP8[$3 + 36 | 0] = $0 >>> 8;
  $0 = HEAP32[$3 + 80 >> 2];
  HEAP8[$3 + 37 | 0] = $0;
  HEAP8[$3 + 38 | 0] = $0 >>> 8;
  graphicsSetVar($3 + 8 | 0);
  HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
 }
 __stack_pointer = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}

function jswrap_date_setHours($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 44 >> 2] = $0;
 HEAP32[$5 + 40 >> 2] = $1;
 HEAP32[$5 + 36 >> 2] = $2;
 HEAP32[$5 + 32 >> 2] = $3;
 HEAP32[$5 + 28 >> 2] = $4;
 getTimeFromDateVar($5, HEAP32[$5 + 44 >> 2], 0);
 HEAP32[$5 + 16 >> 2] = HEAP32[$5 + 40 >> 2];
 if (jsvIsNumeric(HEAP32[$5 + 36 >> 2]) & 1) {
  HEAP32[$5 + 12 >> 2] = jsvGetInteger(HEAP32[$5 + 36 >> 2]);
 }
 if (jsvIsNumeric(HEAP32[$5 + 32 >> 2]) & 1) {
  HEAP32[$5 + 8 >> 2] = jsvGetInteger(HEAP32[$5 + 32 >> 2]);
 }
 if (jsvIsNumeric(HEAP32[$5 + 28 >> 2]) & 1) {
  HEAP32[$5 + 4 >> 2] = jsvGetInteger(HEAP32[$5 + 28 >> 2]);
 }
 setCorrectTimeZone($5);
 $6 = jswrap_date_setTime(HEAP32[$5 + 44 >> 2], fromTimeInDay($5));
 __stack_pointer = $5 + 48 | 0;
 return +$6;
}

function jsvStringIteratorNew($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jsvLockAgain(HEAP32[$3 + 8 >> 2]);
 HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2] = $0;
 HEAP32[HEAP32[$3 + 12 >> 2] + 8 >> 2] = 0;
 $0 = jsvGetCharactersInVar(HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2]);
 HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] = $0;
 label$1: {
  if (jsvIsFlashString(HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2]) & 1) {
   HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] = 0;
   HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[$3 + 4 >> 2];
   jsvStringIteratorLoadFlashString_1(HEAP32[$3 + 12 >> 2]);
   break label$1;
  }
  jsvStringIteratorUpdatePtr(HEAP32[$3 + 12 >> 2]);
  HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[$3 + 4 >> 2];
  jsvStringIteratorCatchUp(HEAP32[$3 + 12 >> 2]);
 }
 __stack_pointer = $3 + 16 | 0;
}

function _jswrap_graphics_floodFill_inside($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 label$1: {
  label$2: {
   label$3: {
    if ((HEAP32[$4 + 20 >> 2] | HEAP32[$4 + 16 >> 2]) < 0) {
     break label$3;
    }
    $0 = HEAP32[$4 + 24 >> 2];
    if (HEAP32[$4 + 20 >> 2] >= (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8)) {
     break label$3;
    }
    $0 = HEAP32[$4 + 24 >> 2];
    if (HEAP32[$4 + 16 >> 2] < (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8)) {
     break label$2;
    }
   }
   HEAP8[$4 + 31 | 0] = 0;
   break label$1;
  }
  HEAP8[$4 + 31 | 0] = (graphicsGetPixel(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]) | 0) == HEAP32[$4 + 12 >> 2];
 }
 __stack_pointer = $4 + 32 | 0;
 return HEAP8[$4 + 31 | 0] & 1;
}

function jswrap_banglejs_getHealthStatus($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  label$2: {
   if (!(jsvIsUndefined(HEAP32[$1 + 8 >> 2]) & 1)) {
    if (!(jsvIsStringEqual(HEAP32[$1 + 8 >> 2], 128492) & 1)) {
     break label$2;
    }
   }
   HEAP32[$1 + 12 >> 2] = _jswrap_banglejs_getHealthStatusObject(391088);
   break label$1;
  }
  if (jsvIsStringEqual(HEAP32[$1 + 8 >> 2], 117343) & 1) {
   HEAP32[$1 + 12 >> 2] = _jswrap_banglejs_getHealthStatusObject(391104);
   break label$1;
  }
  if (jsvIsStringEqual(HEAP32[$1 + 8 >> 2], 116395) & 1) {
   HEAP32[$1 + 12 >> 2] = _jswrap_banglejs_getHealthStatusObject(391120);
   break label$1;
  }
  HEAP32[$1 >> 2] = HEAP32[$1 + 8 >> 2];
  jsExceptionHere(1, 121581, $1);
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function sin($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 wasm2js_scratch_store_f64(+$0);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 wasm2js_scratch_load_i32(0) | 0;
 $2 = $2 & 2147483647;
 label$1: {
  if ($2 >>> 0 <= 1072243195) {
   if ($2 >>> 0 < 1045430272) {
    break label$1;
   }
   $0 = __sin($0, 0, 0);
   break label$1;
  }
  if ($2 >>> 0 >= 2146435072) {
   $0 = $0 - $0;
   break label$1;
  }
  label$4: {
   switch (__rem_pio2($0, $1) & 3) {
   case 0:
    $0 = __sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
    break label$1;

   case 1:
    $0 = __cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
    break label$1;

   case 2:
    $0 = -__sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
    break label$1;

   default:
    break label$4;
   }
  }
  $0 = -__cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
 }
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_banglejs_setLCDPowerBacklight($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 if ((HEAP8[$1 + 15 | 0] & 1) != ((HEAP32[97749] & 131072) != 0 | 0)) {
  HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[91086], 132487);
  if (HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 4 >> 2] = jsvNewFromBool(HEAP8[$1 + 15 | 0] & 1);
   jsiQueueObjectCallbacks(HEAP32[$1 + 8 >> 2], 117718, $1 + 4 | 0, 1);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
  }
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
 }
 label$3: {
  if (HEAP8[$1 + 15 | 0] & 1) {
   if (HEAP32[97753] > 0) {
    HEAP16[195510] = 0;
   }
   HEAP32[97749] = HEAP32[97749] | 131072;
   break label$3;
  }
  if (!(HEAP32[97754] <= 0 | HEAP32[97754] > HEAP32[97753])) {
   _jswrap_banglejs_setLocked(1, 117735);
  }
  HEAP32[97749] = HEAP32[97749] & -131073;
 }
 __stack_pointer = $1 + 16 | 0;
}

function jsvAddGetterOrSetter($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP8[$4 + 23 | 0] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = jsvFindChildFromVar(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], 1);
 if (jsvIsName(HEAP32[$4 + 12 >> 2]) & 1) {
  HEAP32[$4 + 8 >> 2] = jsvGetValueOfName(HEAP32[$4 + 12 >> 2]);
  if (!(jsvIsGetterOrSetter(HEAP32[$4 + 8 >> 2]) & 1)) {
   jsvUnLock(HEAP32[$4 + 8 >> 2]);
   HEAP32[$4 + 8 >> 2] = jsvNewWithFlags(6);
   jsvSetValueOfName(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2]);
  }
  if (jsvIsGetterOrSetter(HEAP32[$4 + 8 >> 2]) & 1) {
   jsvObjectSetChild(HEAP32[$4 + 8 >> 2], HEAP8[$4 + 23 | 0] & 1 ? 117892 : 117878, HEAP32[$4 + 16 >> 2]);
  }
  jsvUnLock(HEAP32[$4 + 8 >> 2]);
 }
 jsvUnLock(HEAP32[$4 + 12 >> 2]);
 __stack_pointer = $4 + 32 | 0;
}

function graphicsFallbackFillRect($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = __stack_pointer - 32 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $5;
 HEAP32[$6 >> 2] = HEAP32[$6 + 20 >> 2];
 while (1) {
  if (HEAP32[$6 >> 2] <= HEAP32[$6 + 12 >> 2]) {
   HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 24 >> 2];
   while (1) {
    if (HEAP32[$6 + 4 >> 2] <= HEAP32[$6 + 16 >> 2]) {
     graphicsSetPixelDevice(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 4 >> 2], HEAP32[$6 >> 2], HEAP32[$6 + 8 >> 2]);
     HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$6 >> 2] = HEAP32[$6 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $6 + 32 | 0;
}

function _jswrap_promise_add_reaction($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP8[$4 + 19 | 0] = $3;
 HEAP32[$4 + 12 >> 2] = _jswrap_promise_new_reaction(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2]);
 if (HEAP32[$4 + 12 >> 2]) {
  HEAP32[$4 + 8 >> 2] = HEAP8[$4 + 19 | 0] & 1 ? 128515 : 117947;
  HEAP32[$4 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 8 >> 2]);
  label$2: {
   if (jsvIsArray(HEAP32[$4 + 4 >> 2]) & 1) {
    jsvArrayPush(HEAP32[$4 + 4 >> 2], HEAP32[$4 + 12 >> 2]);
    break label$2;
   }
   jsvUnLock(HEAP32[$4 + 4 >> 2]);
   jsvObjectSetChildAndUnLock(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 8 >> 2], jsvNewArray($4 + 12 | 0, 1));
  }
  jsvUnLock2(HEAP32[$4 + 4 >> 2], HEAP32[$4 + 12 >> 2]);
 }
 __stack_pointer = $4 + 32 | 0;
}

function jsvGetLongInteger($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 4 >> 2] = $0;
 label$1: {
  if (jsvIsInt(HEAP32[$1 + 4 >> 2]) & 1) {
   $0 = jsvGetInteger(HEAP32[$1 + 4 >> 2]);
   $3 = $0 >> 31;
   HEAP32[$1 + 8 >> 2] = $0;
   HEAP32[$1 + 12 >> 2] = $3;
   break label$1;
  }
  $0 = $1;
  $2 = jsvGetFloat(HEAP32[$1 + 4 >> 2]);
  label$3: {
   if (Math_abs($2) < 0x8000000000000000) {
    $3 = Math_abs($2) >= 1 ? ~~($2 > 0 ? Math_min(Math_floor($2 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($2 - +(~~$2 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
    $4 = ~~$2 >>> 0;
    break label$3;
   }
   $3 = -2147483648;
  }
  HEAP32[$0 + 8 >> 2] = $4;
  HEAP32[$0 + 12 >> 2] = $3;
 }
 __stack_pointer = $1 + 16 | 0;
 $0 = HEAP32[$1 + 12 >> 2];
 i64toi32_i32$HIGH_BITS = $0;
 $3 = HEAP32[$1 + 8 >> 2];
 return $3;
}

function lcdSetPixel_ArrayBuffer_flat1($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 $0 = HEAP32[$4 + 28 >> 2];
 HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 24 >> 2] + Math_imul(HEAP32[$4 + 20 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
 $0 = HEAP32[$4 + 28 >> 2];
 HEAP32[$4 + 8 >> 2] = (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$4 + 12 >> 2] >> 3);
 label$1: {
  if (HEAP32[$4 + 16 >> 2]) {
   $0 = HEAP32[$4 + 8 >> 2];
   HEAP8[$0 | 0] = HEAPU8[$0 | 0] | 128 >> (HEAP32[$4 + 12 >> 2] & 7) & 255;
   break label$1;
  }
  $0 = HEAP32[$4 + 8 >> 2];
  HEAP8[$0 | 0] = HEAPU8[$0 | 0] & (65407 >> (HEAP32[$4 + 12 >> 2] & 7) & 255);
 }
}

function jswrap_error_toString($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 24 >> 2], 132338);
 if (!HEAP32[$1 + 20 >> 2]) {
  HEAP32[$1 + 20 >> 2] = jsvNewFromString(120973);
 }
 label$2: {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$2;
  }
  HEAP32[$1 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 24 >> 2], 132672);
  if (HEAP32[$1 + 16 >> 2]) {
   $0 = HEAP32[$1 + 20 >> 2];
   HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 16 >> 2];
   HEAP32[$1 >> 2] = $0;
   HEAP32[$1 + 12 >> 2] = jsvVarPrintf(116867, $1);
   jsvUnLock2(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
   HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 12 >> 2];
  }
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function jsiDumpDeviceInitialisation($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[91086], HEAP32[$3 + 20 >> 2]);
 if (HEAP32[$3 + 16 >> 2]) {
  HEAP32[$3 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 16 >> 2], 120075);
  if (HEAP32[$3 + 12 >> 2]) {
   $0 = HEAP32[$3 + 28 >> 2];
   $1 = HEAP32[$3 + 24 >> 2];
   HEAP32[$3 >> 2] = HEAP32[$3 + 20 >> 2];
   cbprintf($0, $1, 145195, $3);
   if (jsvIsObject(HEAP32[$3 + 12 >> 2]) & 1) {
    jsfGetJSONWithCallback(HEAP32[$3 + 12 >> 2], 0, 32, 0, HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2]);
   }
   FUNCTION_TABLE[HEAP32[$3 + 28 >> 2]](147434, HEAP32[$3 + 24 >> 2]);
  }
  jsvUnLock2(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2]);
 }
 __stack_pointer = $3 + 32 | 0;
}

function jsvSetFirstChild($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP16[$3 + 10 >> 1] = $1;
 $4 = HEAP32[$3 + 12 >> 2];
 $2 = $4;
 $0 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
 $1 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
 $2 = $0;
 $5 = $2 & 268435455;
 $0 = $1 & -1024;
 $6 = $0;
 $1 = $3;
 $0 = HEAPU16[$1 + 10 >> 1];
 $2 = $0 & 16383;
 $1 = $2 >>> 4 | 0;
 $3 = $1;
 $0 = $5;
 $1 = $2 << 28 | $0;
 $0 = $4;
 HEAP8[$0 + 4 | 0] = $1;
 HEAP8[$0 + 5 | 0] = $1 >>> 8;
 HEAP8[$0 + 6 | 0] = $1 >>> 16;
 HEAP8[$0 + 7 | 0] = $1 >>> 24;
 $1 = $6;
 $2 = $3;
 $2 = $1 | $2;
 HEAP8[$0 + 8 | 0] = $2;
 HEAP8[$0 + 9 | 0] = $2 >>> 8;
 HEAP8[$0 + 10 | 0] = $2 >>> 16;
 HEAP8[$0 + 11 | 0] = $2 >>> 24;
}

function jspGetNamedVariable($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if ((HEAP32[91094] & 63) == 1) {
   $0 = jspeiFindInScopes(HEAP32[$1 + 12 >> 2]);
   break label$1;
  }
  $0 = 0;
 }
 HEAP32[$1 + 8 >> 2] = $0;
 if (!(HEAP32[$1 + 8 >> 2] | (HEAP32[91094] & 63) != 1)) {
  HEAP32[$1 + 8 >> 2] = jswFindBuiltInFunction(0, HEAP32[$1 + 12 >> 2]);
  label$4: {
   if (HEAP32[$1 + 8 >> 2]) {
    if (jswIsBuiltInObject(HEAP32[$1 + 12 >> 2]) & 1) {
     HEAP32[$1 + 4 >> 2] = jsvAddNamedChild(HEAP32[91086], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
     jsvUnLock(HEAP32[$1 + 8 >> 2]);
     HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 4 >> 2];
    }
    break label$4;
   }
   HEAP32[$1 + 8 >> 2] = jsvNewNameFromString(HEAP32[$1 + 12 >> 2]);
  }
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jswrap_string_substring($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 if (jsvIsUndefined(HEAP32[$3 + 20 >> 2]) & 1) {
  $0 = 2147483647;
 } else {
  $0 = jsvGetInteger(HEAP32[$3 + 20 >> 2]);
 }
 HEAP32[$3 + 16 >> 2] = $0;
 if (HEAP32[$3 + 24 >> 2] < 0) {
  HEAP32[$3 + 24 >> 2] = 0;
 }
 if (HEAP32[$3 + 16 >> 2] < 0) {
  HEAP32[$3 + 16 >> 2] = 0;
 }
 if (HEAP32[$3 + 16 >> 2] < HEAP32[$3 + 24 >> 2]) {
  HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 24 >> 2];
  HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 16 >> 2];
  HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 $0 = jsvNewFromStringVar(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 16 >> 2] - HEAP32[$3 + 24 >> 2] | 0);
 __stack_pointer = $3 + 32 | 0;
 return $0 | 0;
}

function jswrap_date_setFullYear($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 80 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 76 >> 2] = $0;
 HEAP32[$4 + 72 >> 2] = $1;
 HEAP32[$4 + 68 >> 2] = $2;
 HEAP32[$4 + 64 >> 2] = $3;
 getTimeFromDateVar($4 + 32 | 0, HEAP32[$4 + 76 >> 2], 0);
 getCalendarDate($4 + 8 | 0, HEAP32[$4 + 32 >> 2]);
 HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 72 >> 2];
 if (jsvIsNumeric(HEAP32[$4 + 68 >> 2]) & 1) {
  HEAP32[$4 + 16 >> 2] = jsvGetInteger(HEAP32[$4 + 68 >> 2]);
 }
 if (jsvIsNumeric(HEAP32[$4 + 64 >> 2]) & 1) {
  HEAP32[$4 + 12 >> 2] = jsvGetInteger(HEAP32[$4 + 64 >> 2]);
 }
 HEAP32[$4 + 32 >> 2] = fromCalendarDate($4 + 8 | 0);
 setCorrectTimeZone($4 + 32 | 0);
 $5 = jswrap_date_setTime(HEAP32[$4 + 76 >> 2], fromTimeInDay($4 + 32 | 0));
 __stack_pointer = $4 + 80 | 0;
 return +$5;
}

function jsvSetPrevSibling($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP16[$3 + 10 >> 1] = $1;
 $4 = HEAP32[$3 + 12 >> 2];
 $2 = $4;
 $0 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
 $1 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
 $2 = $0;
 $5 = $2 & -268419073;
 $0 = $1;
 $6 = $0;
 $1 = $3;
 $0 = HEAPU16[$1 + 10 >> 1];
 $2 = $0 & 16383;
 $1 = $2 >>> 18 | 0;
 $3 = $1;
 $0 = $5;
 $1 = $2 << 14 | $0;
 $0 = $4;
 HEAP8[$0 + 4 | 0] = $1;
 HEAP8[$0 + 5 | 0] = $1 >>> 8;
 HEAP8[$0 + 6 | 0] = $1 >>> 16;
 HEAP8[$0 + 7 | 0] = $1 >>> 24;
 $1 = $6;
 $2 = $3;
 $2 = $1 | $2;
 HEAP8[$0 + 8 | 0] = $2;
 HEAP8[$0 + 9 | 0] = $2 >>> 8;
 HEAP8[$0 + 10 | 0] = $2 >>> 16;
 HEAP8[$0 + 11 | 0] = $2 >>> 24;
}

function jsvArrayAddToEnd($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 16 >> 2];
 if (jsvGetLastChild(HEAP32[$3 + 24 >> 2]) & 65535) {
  HEAP32[$3 + 8 >> 2] = jsvLock(jsvGetLastChild(HEAP32[$3 + 24 >> 2]) & 65535);
  HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 8 >> 2]) + 1;
  jsvUnLock(HEAP32[$3 + 8 >> 2]);
 }
 HEAP32[$3 + 4 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(HEAP32[$3 + 12 >> 2]), HEAP32[$3 + 20 >> 2]);
 label$2: {
  if (!HEAP32[$3 + 4 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$2;
  }
  jsvAddName(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 4 >> 2]);
  jsvUnLock(HEAP32[$3 + 4 >> 2]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jsvHasChildren($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $0 = 1;
  label$3: {
   if (HEAP8[$1 + 7 | 0] == 7) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 9) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 8) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 5) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 1) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 3) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 1) {
    break label$3;
   }
   $0 = HEAP8[$1 + 7 | 0] == 6;
  }
  HEAP8[$1 + 15 | 0] = $0;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function tflite__GetReciprocal_28int_2c_20int_2c_20int__29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = int_20tflite__CountLeadingZeros_unsigned_20int__28unsigned_20int_29(HEAP32[$3 + 28 >> 2]);
 HEAP32[HEAP32[$3 + 20 >> 2] >> 2] = HEAP32[$3 + 24 >> 2] - HEAP32[$3 + 16 >> 2];
 HEAP32[$3 + 12 >> 2] = (HEAP32[$3 + 28 >> 2] << HEAP32[$3 + 16 >> 2]) - -2147483648;
 HEAP32[$3 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromRaw_28int_29(HEAP32[$3 + 12 >> 2]);
 HEAP32[$3 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_200__20gemmlowp__one_over_one_plus_x_for_x_in_0_1_int__28gemmlowp__FixedPoint_int_2c_200__29(HEAP32[$3 >> 2]);
 $0 = gemmlowp__FixedPoint_int_2c_200___raw_28_29($3 + 8 | 0);
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$0 >> 2];
}

function jswrap_i2c_readReg($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 label$1: {
  if (!(jsvIsObject(HEAP32[$4 + 24 >> 2]) & 1)) {
   HEAP32[$4 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP8[$4 + 11 | 0] = jsiGetDeviceFromClass(HEAP32[$4 + 24 >> 2]);
  HEAP8[$4 + 10 | 0] = 0;
  HEAP8[$4 + 9 | 0] = HEAP32[$4 + 16 >> 2];
  _jswrap_i2c_writeTo(HEAP32[$4 + 24 >> 2], HEAPU8[$4 + 11 | 0], HEAP32[$4 + 20 >> 2], HEAP8[$4 + 10 | 0] & 1, 1, $4 + 9 | 0);
  HEAP32[$4 + 28 >> 2] = _jswrap_i2c_readFrom(HEAP32[$4 + 24 >> 2], HEAPU8[$4 + 11 | 0], HEAP32[$4 + 20 >> 2], HEAP8[$4 + 10 | 0] & 1, HEAP32[$4 + 12 >> 2]);
 }
 __stack_pointer = $4 + 32 | 0;
 return HEAP32[$4 + 28 >> 2];
}

function jsvGetCharsOnLine($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 60 >> 2] = $0;
 HEAP32[$2 + 56 >> 2] = $1;
 HEAP32[$2 + 52 >> 2] = 1;
 HEAP32[$2 + 48 >> 2] = 0;
 jsvStringIteratorNew($2 + 8 | 0, HEAP32[$2 + 60 >> 2], 0);
 while (1) {
  label$2: {
   if (!(jsvStringIteratorHasChar_1($2 + 8 | 0) & 1)) {
    break label$2;
   }
   label$3: {
    if ((jsvStringIteratorGetCharAndNext($2 + 8 | 0) & 255) == 10) {
     HEAP32[$2 + 52 >> 2] = HEAP32[$2 + 52 >> 2] + 1;
     if (HEAPU32[$2 + 52 >> 2] > HEAPU32[$2 + 56 >> 2]) {
      break label$2;
     }
     break label$3;
    }
    if (HEAP32[$2 + 52 >> 2] == HEAP32[$2 + 56 >> 2]) {
     HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 48 >> 2] + 1;
    }
   }
   continue;
  }
  break;
 }
 jsvStringIteratorFree_1($2 + 8 | 0);
 __stack_pointer = $2 - -64 | 0;
 return HEAP32[$2 + 48 >> 2];
}

function jsfEraseFileInternal($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP8[$3 + 39 | 0] = $2;
 HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 44 >> 2] - 32;
 HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 44 >> 2] + ((HEAP32[$3 + 40 >> 2] + 4 | 0) - HEAP32[$3 + 40 >> 2] | 0);
 HEAP32[HEAP32[$3 + 40 >> 2] + 4 >> 2] = 0;
 jshFlashWrite(HEAP32[$3 + 40 >> 2] + 4 | 0, HEAP32[$3 + 44 >> 2], 4);
 if (!(!(HEAP8[$3 + 39 | 0] & 1) | HEAPU32[$3 + 44 >> 2] < 134217728 | HEAPU32[$3 + 44 >> 2] >= 142606336)) {
  HEAP32[$3 + 32 >> 2] = 0;
  if (HEAP32[91095]) {
   HEAP32[$3 + 32 >> 2] = HEAP32[91095] + HEAP32[91096];
  }
  jsfGetStorageStats($3, HEAP32[$3 + 32 >> 2], 1);
  if (HEAP32[$3 + 12 >> 2] + HEAP32[$3 + 4 >> 2] >>> 0 > 200) {
   jsfBankCreateFileTable(134217728);
  }
 }
 __stack_pointer = $3 + 48 | 0;
}

function i2c_rd_bit($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]);
 dly(HEAP32[$1 + 12 >> 2]);
 i2c_pin_wr1(HEAPU8[HEAP32[$1 + 12 >> 2]]);
 dly(HEAP32[$1 + 12 >> 2]);
 HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
 while (1) {
  $0 = 0;
  if (!(jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2]]) & 1)) {
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP32[$1 + 8 >> 2] = $0 - 1;
   $0 = ($0 | 0) != 0;
  }
  if ($0) {
   continue;
  }
  break;
 }
 if (!(HEAP32[$1 + 8 >> 2] | !HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2])) {
  err(143119);
 }
 dly(HEAP32[$1 + 12 >> 2]);
 HEAP8[$1 + 7 | 0] = jshPinGetValue(HEAPU8[HEAP32[$1 + 12 >> 2] + 1 | 0]) & 1;
 i2c_pin_wr0(HEAPU8[HEAP32[$1 + 12 >> 2]]);
 dly(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 7 | 0] & 1;
}

function tflite__SimpleMemoryAllocator__Create_28tflite__ErrorReporter__2c_20unsigned_20char__2c_20unsigned_20long_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 label$1: {
  if (!HEAP32[$3 + 44 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (!HEAP32[$3 + 40 >> 2]) {
   break label$2;
  }
 }
 FUNCTION_TABLE[667]($3 + 8 | 0, HEAP32[$3 + 44 >> 2], HEAP32[$3 + 40 >> 2], HEAP32[$3 + 36 >> 2]) | 0;
 HEAP32[$3 + 4 >> 2] = tflite__SimpleMemoryAllocator__AllocateFromTail_28unsigned_20long_2c_20unsigned_20long_29($3 + 8 | 0, 28, 4);
 $0 = HEAP32[$3 + 4 >> 2];
 tflite__SimpleMemoryAllocator__SimpleMemoryAllocator_28tflite__SimpleMemoryAllocator_20const__29($0, $3 + 8 | 0);
 FUNCTION_TABLE[668]($3 + 8 | 0) | 0;
 __stack_pointer = $3 + 48 | 0;
 return $0;
}

function jsvIteratorGetKey($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  label$2: {
   switch (HEAP32[HEAP32[$1 + 8 >> 2] >> 2] - 1 | 0) {
   case 3:
    HEAP32[$1 + 12 >> 2] = jsvNewFromInteger(HEAP32[HEAP32[$1 + 8 >> 2] + 12 >> 2]);
    break label$1;

   case 1:
    HEAP32[$1 + 12 >> 2] = jsvObjectIteratorGetKey_1(HEAP32[$1 + 8 >> 2] + 4 | 0);
    break label$1;

   case 0:
    HEAP32[$1 + 12 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(jsvStringIteratorGetIndex_2(HEAP32[$1 + 8 >> 2] + 4 | 0)), 0);
    break label$1;

   case 2:
    HEAP32[$1 + 12 >> 2] = jsvMakeIntoVariableName(jsvArrayBufferIteratorGetIndex(HEAP32[$1 + 8 >> 2] + 4 | 0), 0);
    break label$1;

   default:
    break label$2;
   }
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jshPushIOCharEventAppend($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 14 | 0] = $0;
 HEAP8[$2 + 13 | 0] = $1;
 HEAP8[$2 + 12 | 0] = HEAPU8[364486] + 255;
 label$1: {
  if (!(HEAPU8[364486] == HEAPU8[364487] | HEAPU8[$2 + 12 | 0] == HEAPU8[364487]) & HEAPU8[$2 + 14 | 0] == (HEAPU8[Math_imul(HEAPU8[$2 + 12 | 0], 5) + 365072 | 0] & 31)) {
   HEAP8[$2 + 11 | 0] = ((HEAPU8[Math_imul(HEAPU8[$2 + 12 | 0], 5) + 365072 | 0] & 96) >>> 5 | 0) + 1;
   if (HEAPU8[$2 + 11 | 0] < 4) {
    HEAP8[HEAPU8[$2 + 11 | 0] + (Math_imul(HEAPU8[$2 + 12 | 0], 5) + 365073 | 0) | 0] = HEAPU8[$2 + 13 | 0];
    HEAP8[Math_imul(HEAPU8[$2 + 12 | 0], 5) + 365072 | 0] = HEAPU8[Math_imul(HEAPU8[$2 + 12 | 0], 5) + 365072 | 0] & 159 | HEAPU8[$2 + 11 | 0] << 5;
    HEAP8[$2 + 15 | 0] = 1;
    break label$1;
   }
  }
  HEAP8[$2 + 15 | 0] = 0;
 }
 return HEAP8[$2 + 15 | 0] & 1;
}

function _jswrap_graphics_parseImage_palette($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[HEAP32[$2 + 12 >> 2] + 28 >> 2] = 0;
 if (!(!(jsvIsArrayBuffer(HEAP32[$2 + 8 >> 2]) & 1) | HEAPU8[HEAP32[$2 + 8 >> 2] + 5 | 0] != 2)) {
  HEAP32[$2 + 4 >> 2] = 0;
  $0 = jsvGetDataPointer(HEAP32[$2 + 8 >> 2], $2 + 4 | 0);
  HEAP32[HEAP32[$2 + 12 >> 2] + 28 >> 2] = $0;
  label$2: {
   if (!(HEAP32[$2 + 4 >> 2] == 2 | HEAP32[$2 + 4 >> 2] == 4 | (HEAP32[$2 + 4 >> 2] == 8 | HEAP32[$2 + 4 >> 2] == 16))) {
    if (HEAP32[$2 + 4 >> 2] != 256) {
     break label$2;
    }
   }
   HEAP32[HEAP32[$2 + 12 >> 2] + 32 >> 2] = HEAP32[$2 + 4 >> 2] - 1;
  }
 }
 if (!HEAP32[HEAP32[$2 + 12 >> 2] + 28 >> 2]) {
  jsExceptionHere(1, 119747, 0);
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 8 >> 2];
}

function jsvFindChildFromStringI($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP16[$2 + 18 >> 1] = jsvGetFirstChild(HEAP32[$2 + 24 >> 2]);
 label$1: {
  while (1) {
   if (HEAPU16[$2 + 18 >> 1]) {
    HEAP32[$2 + 12 >> 2] = jsvGetAddressOf(HEAPU16[$2 + 18 >> 1]);
    label$4: {
     if (!(jsvHasCharacterData(HEAP32[$2 + 12 >> 2]) & 1)) {
      break label$4;
     }
     if (!(jsvIsStringEqualOrStartsWithOffset(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 20 >> 2], 0, 0, 1) & 1)) {
      break label$4;
     }
     HEAP32[$2 + 28 >> 2] = jsvLockAgain(HEAP32[$2 + 12 >> 2]);
     break label$1;
    }
    HEAP16[$2 + 18 >> 1] = jsvGetNextSibling(HEAP32[$2 + 12 >> 2]);
    continue;
   }
   break;
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jsvGetLength($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = jsvGetArrayLength(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  if (jsvIsArrayBuffer(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = jsvGetArrayBufferLength(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  if (jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = jsvGetStringLength(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  label$5: {
   if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
    if (!(jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1)) {
     break label$5;
    }
   }
   HEAP32[$1 + 12 >> 2] = jsvGetChildren(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 1;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_interactive_setTime($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 24 >> 3] = $0;
 jshInterruptOff();
 $2 = jshGetTimeFromMilliseconds(HEAPF64[$1 + 24 >> 3] * 1e3);
 HEAP32[$1 + 16 >> 2] = $2;
 HEAP32[$1 + 20 >> 2] = i64toi32_i32$HIGH_BITS;
 $2 = HEAP32[$1 + 20 >> 2];
 HEAP32[91118] = HEAP32[$1 + 16 >> 2];
 HEAP32[91119] = $2;
 $2 = jshGetSystemTime();
 HEAP32[$1 + 8 >> 2] = $2;
 HEAP32[$1 + 12 >> 2] = i64toi32_i32$HIGH_BITS;
 $2 = HEAP32[$1 + 20 >> 2];
 jshSetSystemTime(HEAP32[$1 + 16 >> 2], $2);
 $2 = HEAP32[$1 + 16 >> 2];
 $4 = $2;
 $2 = HEAP32[$1 + 12 >> 2];
 $5 = HEAP32[$1 + 8 >> 2];
 $3 = $2 + ($5 >>> 0 > $4 >>> 0) | 0;
 $2 = HEAP32[$1 + 20 >> 2];
 $3 = $2 - $3 | 0;
 jstSystemTimeChanged($4 - $5 | 0, $3);
 jshInterruptOn();
 __stack_pointer = $1 + 32 | 0;
}

function jshGetDeviceString($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 11 | 0] = $0;
 label$1: {
  label$2: {
   switch (HEAPU8[$1 + 11 | 0]) {
   case 0:
    HEAP32[$1 + 12 >> 2] = 128729;
    break label$1;

   case 17:
    HEAP32[$1 + 12 >> 2] = 138201;
    break label$1;

   case 18:
    HEAP32[$1 + 12 >> 2] = 138143;
    break label$1;

   case 19:
    HEAP32[$1 + 12 >> 2] = 128052;
    break label$1;

   case 21:
    HEAP32[$1 + 12 >> 2] = 138161;
    break label$1;

   case 20:
    HEAP32[$1 + 12 >> 2] = 129058;
    break label$1;

   case 22:
    HEAP32[$1 + 12 >> 2] = 139865;
    break label$1;

   case 26:
    HEAP32[$1 + 12 >> 2] = 139913;
    break label$1;

   case 27:
    HEAP32[$1 + 12 >> 2] = 139927;
    break label$1;

   default:
    break label$2;
   }
  }
  HEAP32[$1 + 12 >> 2] = 148267;
 }
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_interface_getSerial() {
 var $0 = 0;
 $0 = __stack_pointer + -64 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = jshGetSerialNumber($0 + 16 | 0, 32);
 HEAP32[$0 + 4 >> 2] = jsvNewFromEmptyString_10();
 label$1: {
  if (!HEAP32[$0 + 4 >> 2]) {
   HEAP32[$0 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$0 + 12 >> 2] < HEAP32[$0 + 8 >> 2]) {
    if (!(!HEAP32[$0 + 12 >> 2] | HEAP32[$0 + 12 >> 2] & 3)) {
     jsvAppendString(HEAP32[$0 + 4 >> 2], 141263);
    }
    itostr_4(HEAPU8[HEAP32[$0 + 12 >> 2] + ($0 + 16 | 0) | 0] | 256, $0 + 52 | 0, 16);
    jsvAppendString(HEAP32[$0 + 4 >> 2], $0 + 53 | 0);
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$0 + 60 >> 2] = HEAP32[$0 + 4 >> 2];
 }
 __stack_pointer = $0 - -64 | 0;
 return HEAP32[$0 + 60 >> 2];
}

function jswrap_graphics_drawRect($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = __stack_pointer - 112 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 104 >> 2] = $0;
 HEAP32[$5 + 100 >> 2] = $1;
 HEAP32[$5 + 96 >> 2] = $2;
 HEAP32[$5 + 92 >> 2] = $3;
 HEAP32[$5 + 88 >> 2] = $4;
 _jswrap_graphics_getRect(HEAP32[$5 + 100 >> 2], $5 + 84 | 0, $5 + 96 | 0, $5 + 92 | 0, $5 + 88 | 0, $5 + 80 | 0);
 label$1: {
  if (!(graphicsGetFromVar($5 + 8 | 0, HEAP32[$5 + 104 >> 2]) & 1)) {
   HEAP32[$5 + 108 >> 2] = 0;
   break label$1;
  }
  graphicsDrawRect($5 + 8 | 0, HEAP32[$5 + 84 >> 2], HEAP32[$5 + 96 >> 2], HEAP32[$5 + 92 >> 2], HEAP32[$5 + 88 >> 2]);
  graphicsSetVar($5 + 8 | 0);
  HEAP32[$5 + 108 >> 2] = jsvLockAgain(HEAP32[$5 + 104 >> 2]);
 }
 __stack_pointer = $5 + 112 | 0;
 return HEAP32[$5 + 108 >> 2];
}

function jstPinTaskChecker($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (HEAPU8[HEAP32[$2 + 24 >> 2] + 24 | 0] != 2) {
   HEAP8[$2 + 31 | 0] = 0;
   break label$1;
  }
  HEAP8[$2 + 19 | 0] = HEAPU8[HEAP32[$2 + 20 >> 2]];
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 12 >> 2] < 8) {
    if (HEAPU8[HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 24 >> 2] + 8 | 0) | 0] == HEAPU8[$2 + 19 | 0]) {
     HEAP8[$2 + 31 | 0] = 1;
     break label$1;
    }
    if (HEAPU8[HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 24 >> 2] + 8 | 0) | 0] == 255) {
     HEAP8[$2 + 31 | 0] = 0;
     break label$1;
    } else {
     HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
     continue;
    }
   }
   break;
  }
  HEAP8[$2 + 31 | 0] = 0;
 }
 return HEAP8[$2 + 31 | 0] & 1;
}

function jsvAppendStringVar($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 112 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 108 >> 2] = $0;
 HEAP32[$4 + 104 >> 2] = $1;
 HEAP32[$4 + 100 >> 2] = $2;
 HEAP32[$4 + 96 >> 2] = $3;
 jsvStringIteratorNew($4 + 56 | 0, HEAP32[$4 + 108 >> 2], 0);
 jsvStringIteratorGotoEnd($4 + 56 | 0);
 jsvStringIteratorNew($4 + 16 | 0, HEAP32[$4 + 104 >> 2], HEAP32[$4 + 100 >> 2]);
 while (1) {
  $0 = 0;
  if (jsvStringIteratorHasChar_1($4 + 16 | 0) & 1) {
   $0 = HEAP32[$4 + 96 >> 2];
   HEAP32[$4 + 96 >> 2] = $0 - 1;
   $0 = ($0 | 0) != 0;
  }
  if ($0) {
   HEAP8[$4 + 15 | 0] = jsvStringIteratorGetCharAndNext($4 + 16 | 0);
   jsvStringIteratorAppend($4 + 56 | 0, HEAP8[$4 + 15 | 0]);
   continue;
  }
  break;
 }
 jsvStringIteratorFree_1($4 + 16 | 0);
 jsvStringIteratorFree_1($4 + 56 | 0);
 __stack_pointer = $4 + 112 | 0;
}

function jswrap_io_poke($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 80 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 76 >> 2] = $0;
 HEAP32[$3 + 72 >> 2] = $1;
 HEAP32[$3 + 68 >> 2] = $2;
 label$1: {
  if (jsvIsNumeric(HEAP32[$3 + 72 >> 2]) & 1) {
   _jswrap_io_poke(HEAP32[$3 + 76 >> 2], jsvGetInteger(HEAP32[$3 + 72 >> 2]), HEAP32[$3 + 68 >> 2]);
   break label$1;
  }
  if (jsvIsIterable(HEAP32[$3 + 72 >> 2]) & 1) {
   jsvIteratorNew($3 + 8 | 0, HEAP32[$3 + 72 >> 2], 1);
   while (1) {
    if (jsvIteratorHasElement($3 + 8 | 0) & 1) {
     _jswrap_io_poke(HEAP32[$3 + 76 >> 2], jsvIteratorGetIntegerValue($3 + 8 | 0), HEAP32[$3 + 68 >> 2]);
     HEAP32[$3 + 76 >> 2] = HEAP32[$3 + 68 >> 2] + HEAP32[$3 + 76 >> 2];
     jsvIteratorNext($3 + 8 | 0);
     continue;
    }
    break;
   }
   jsvIteratorFree($3 + 8 | 0);
  }
 }
 __stack_pointer = $3 + 80 | 0;
}

function jsvIteratorHasElement($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  label$2: {
   switch (HEAP32[HEAP32[$1 + 8 >> 2] >> 2] - 1 | 0) {
   case 3:
    HEAP8[$1 + 15 | 0] = HEAP32[HEAP32[$1 + 8 >> 2] + 12 >> 2] < (jsvGetArrayLength(HEAP32[HEAP32[$1 + 8 >> 2] + 8 >> 2]) | 0);
    break label$1;

   case 1:
    HEAP8[$1 + 15 | 0] = jsvObjectIteratorHasValue_1(HEAP32[$1 + 8 >> 2] + 4 | 0) & 1;
    break label$1;

   case 0:
    HEAP8[$1 + 15 | 0] = jsvStringIteratorHasChar_2(HEAP32[$1 + 8 >> 2] + 4 | 0) & 1;
    break label$1;

   case 2:
    HEAP8[$1 + 15 | 0] = jsvArrayBufferIteratorHasElement(HEAP32[$1 + 8 >> 2] + 4 | 0) & 1;
    break label$1;

   default:
    break label$2;
   }
  }
  HEAP8[$1 + 15 | 0] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}

function jshSetFlowControlEnabled($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP8[$3 + 15 | 0] = $0;
 HEAP8[$3 + 14 | 0] = $1;
 HEAP8[$3 + 13 | 0] = $2;
 if (!(HEAPU8[$3 + 15 | 0] < 21 | HEAPU8[$3 + 15 | 0] > 22)) {
  HEAP32[$3 + 8 >> 2] = HEAPU8[$3 + 15 | 0] - 21;
  HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 8 >> 2] + 364488;
  label$2: {
   if (HEAP8[$3 + 14 | 0] & 1) {
    $0 = HEAP32[$3 + 4 >> 2];
    HEAP8[$0 | 0] = HEAPU8[$0 | 0] | 8;
    break label$2;
   }
   $0 = HEAP32[$3 + 4 >> 2];
   HEAP8[$0 | 0] = HEAPU8[$0 | 0] & -9;
  }
  HEAP8[HEAP32[$3 + 8 >> 2] + 364490 | 0] = 255;
  if (jshIsPinValid(HEAPU8[$3 + 13 | 0]) & 1) {
   jshPinSetState(HEAPU8[$3 + 13 | 0], 1);
   jshPinSetValue(HEAPU8[$3 + 13 | 0], 0);
   HEAP8[HEAP32[$3 + 8 >> 2] + 364490 | 0] = HEAPU8[$3 + 13 | 0];
  }
 }
 __stack_pointer = $3 + 16 | 0;
}

function tflite__NumElements_28TfLiteIntArray_20const__29($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = __stack_pointer - 32 | 0;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 16 >> 2] = 1;
 HEAP32[$1 + 20 >> 2] = 0;
 HEAP32[$1 + 12 >> 2] = 0;
 while (1) {
  if (HEAP32[$1 + 12 >> 2] < HEAP32[HEAP32[$1 + 28 >> 2] >> 2]) {
   $2 = HEAP32[(HEAP32[$1 + 28 >> 2] + 4 | 0) + (HEAP32[$1 + 12 >> 2] << 2) >> 2];
   $0 = $2 >> 31;
   $3 = $2;
   $2 = HEAP32[$1 + 20 >> 2];
   $4 = $2;
   $2 = $0;
   $0 = HEAP32[$1 + 16 >> 2];
   $5 = $0;
   $0 = $4;
   $0 = __wasm_i64_mul($3, $2, $5, $0);
   HEAP32[$1 + 16 >> 2] = $0;
   $2 = i64toi32_i32$HIGH_BITS;
   HEAP32[$1 + 20 >> 2] = $2;
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 $0 = HEAP32[$1 + 20 >> 2];
 i64toi32_i32$HIGH_BITS = $0;
 $2 = HEAP32[$1 + 16 >> 2];
 return $2;
}

function jsvFreePtrStringExt($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP16[$1 + 10 >> 1] = jsvGetLastChild(HEAP32[$1 + 12 >> 2]);
 if (HEAPU16[$1 + 10 >> 1]) {
  HEAP32[$1 + 4 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 10 >> 1]);
  while (1) {
   $0 = HEAP32[$1 + 4 >> 2];
   HEAP8[$0 + 12 | 0] = 0;
   HEAP8[$0 + 13 | 0] = 0;
   HEAP16[$1 + 10 >> 1] = jsvGetLastChild(HEAP32[$1 + 4 >> 2]);
   if (HEAPU16[$1 + 10 >> 1]) {
    jsvSetNextSibling(HEAP32[$1 + 4 >> 2], HEAPU16[$1 + 10 >> 1]);
    HEAP32[$1 + 4 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 10 >> 1]);
    continue;
   }
   break;
  }
  jshInterruptOff();
  jsvSetNextSibling(HEAP32[$1 + 4 >> 2], HEAPU16[98162]);
  HEAP16[98162] = jsvGetLastChild(HEAP32[$1 + 12 >> 2]);
  HEAP8[196321] = 1;
  jshInterruptOn();
 }
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_waveform_getBuffer($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2] ? 139553 : 121187);
 label$1: {
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$3 + 16 >> 2]) {
   HEAP8[HEAP32[$3 + 16 >> 2]] = 0;
   if (!(!(jsvIsArrayBuffer(HEAP32[$3 + 12 >> 2]) & 1) | (HEAPU8[HEAP32[$3 + 12 >> 2] + 5 | 0] & 15) != 2)) {
    HEAP8[HEAP32[$3 + 16 >> 2]] = 1;
   }
  }
  HEAP32[$3 + 8 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$3 + 12 >> 2], 0);
  jsvUnLock(HEAP32[$3 + 12 >> 2]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 8 >> 2];
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jswrap_espruino_CRC32($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 80 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 76 >> 2] = $0;
 jsvIteratorNew($1 + 16 | 0, HEAP32[$1 + 76 >> 2], 1);
 HEAP32[$1 + 12 >> 2] = -1;
 while (1) {
  if (jsvIteratorHasElement($1 + 16 | 0) & 1) {
   HEAP32[$1 + 12 >> 2] = jsvIteratorGetIntegerValue($1 + 16 | 0) & 255 ^ HEAP32[$1 + 12 >> 2];
   HEAP32[$1 + 8 >> 2] = 0;
   while (1) {
    if (HEAP32[$1 + 8 >> 2] < 8) {
     HEAP32[$1 + 12 >> 2] = 0 - (HEAP32[$1 + 12 >> 2] & 1) & -306674912 ^ HEAP32[$1 + 12 >> 2] >>> 1;
     HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
     continue;
    }
    break;
   }
   jsvIteratorNext($1 + 16 | 0);
   continue;
  }
  break;
 }
 jsvIteratorFree($1 + 16 | 0);
 $0 = jsvNewFromLongInteger(HEAP32[$1 + 12 >> 2] ^ -1, 0);
 __stack_pointer = $1 + 80 | 0;
 return $0 | 0;
}

function jsvObjectGetIntegerChild($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (!HEAP32[$2 + 24 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 16 >> 2] = jsvFindChildFromString(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
  label$3: {
   if (!(jsvIsNameInt(HEAP32[$2 + 16 >> 2]) & 1)) {
    if (!(jsvIsNameIntBool(HEAP32[$2 + 16 >> 2]) & 1)) {
     break label$3;
    }
   }
   HEAP32[$2 + 12 >> 2] = jsvGetFirstChildSigned(HEAP32[$2 + 16 >> 2]) << 16 >> 16;
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(HEAP32[$2 + 16 >> 2]));
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jspePostfixExpression() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 label$1: {
  if (!(HEAP16[HEAP32[49079] + 2 >> 1] != 152 & HEAP16[HEAP32[49079] + 2 >> 1] != 153)) {
   HEAP32[$0 + 8 >> 2] = HEAP16[HEAP32[49079] + 2 >> 1];
   jslGetNextToken();
   HEAP32[$0 + 12 >> 2] = jspePostfixExpression();
   if ((HEAP32[91094] & 63) == 1) {
    HEAP32[$0 + 4 >> 2] = jsvNewFromInteger(1);
    HEAP32[$0 >> 2] = jsvMathsOpSkipNames(HEAP32[$0 + 12 >> 2], HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2] == 152 ? 43 : 45);
    jsvUnLock(HEAP32[$0 + 4 >> 2]);
    jsvReplaceWith(HEAP32[$0 + 12 >> 2], HEAP32[$0 >> 2]);
    jsvUnLock(HEAP32[$0 >> 2]);
   }
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = jspeFactorFunctionCall();
 }
 $1 = __jspePostfixExpression(HEAP32[$0 + 12 >> 2]);
 __stack_pointer = $0 + 16 | 0;
 return $1;
}

function graphicsGetFromVar($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 $0 = HEAP32[$2 + 8 >> 2];
 $1 = HEAP32[$2 + 4 >> 2];
 HEAP8[$0 | 0] = $1;
 HEAP8[$0 + 1 | 0] = $1 >>> 8;
 HEAP8[$0 + 2 | 0] = $1 >>> 16;
 HEAP8[$0 + 3 | 0] = $1 >>> 24;
 HEAP32[$2 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 4 >> 2], 116422);
 label$1: {
  if (!HEAP32[$2 >> 2]) {
   __memcpy(HEAP32[$2 + 8 >> 2], 366800, 72);
   HEAP8[$2 + 15 | 0] = 1;
   break label$1;
  }
  if (HEAP32[$2 >> 2]) {
   jsvGetStringChars(HEAP32[$2 >> 2], 0, HEAP32[$2 + 8 >> 2] + 4 | 0, 44);
   jsvUnLock(HEAP32[$2 >> 2]);
   HEAP8[$2 + 15 | 0] = graphicsSetCallbacks(HEAP32[$2 + 8 >> 2]) & 1;
   break label$1;
  }
  HEAP8[$2 + 15 | 0] = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP8[$2 + 15 | 0] & 1;
}

function jsserialEventCallbackKill($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 28 >> 2], 129312);
 if (HEAP32[$2 + 20 >> 2]) {
  HEAP8[$2 + 19 | 0] = jsvGetIntegerAndUnLock(HEAP32[$2 + 20 >> 2]);
  jshPinWatch(HEAPU8[$2 + 19 | 0], 0, 0);
  HEAP32[$2 + 12 >> 2] = jsserialGetSerialList(0);
  if (HEAP32[$2 + 12 >> 2]) {
   HEAP32[$2 + 8 >> 2] = jsvGetArrayIndex(HEAP32[$2 + 12 >> 2], HEAPU8[$2 + 19 | 0]);
   if (HEAP32[$2 + 8 >> 2]) {
    jsvRemoveChild(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
   }
   if (!jsvGetChildren(HEAP32[$2 + 12 >> 2])) {
    jsvObjectRemoveChild(HEAP32[91087], 129067);
   }
   jsvUnLock2(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2]);
  }
 }
 __stack_pointer = $2 + 32 | 0;
}

function tflite__ComputeOutSize_28TfLitePadding_2c_20int_2c_20int_2c_20int_2c_20int_29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 32 | 0;
 HEAP32[$5 + 24 >> 2] = $0;
 HEAP32[$5 + 20 >> 2] = $1;
 HEAP32[$5 + 16 >> 2] = $2;
 HEAP32[$5 + 12 >> 2] = $3;
 HEAP32[$5 + 8 >> 2] = $4;
 HEAP32[$5 + 4 >> 2] = Math_imul(HEAP32[$5 + 8 >> 2], HEAP32[$5 + 16 >> 2] - 1 | 0) + 1;
 label$1: {
  label$2: {
   switch (HEAP32[$5 + 24 >> 2] - 1 | 0) {
   case 0:
    HEAP32[$5 + 28 >> 2] = ((HEAP32[$5 + 20 >> 2] + HEAP32[$5 + 12 >> 2] | 0) - 1 | 0) / HEAP32[$5 + 12 >> 2];
    break label$1;

   case 1:
    HEAP32[$5 + 28 >> 2] = ((HEAP32[$5 + 20 >> 2] + HEAP32[$5 + 12 >> 2] | 0) - HEAP32[$5 + 4 >> 2] | 0) / HEAP32[$5 + 12 >> 2];
    break label$1;

   default:
    break label$2;
   }
  }
  HEAP32[$5 + 28 >> 2] = 0;
 }
 return HEAP32[$5 + 28 >> 2];
}

function tflite__GetOptionalInputTensor_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 $4 = HEAP32[$3 + 16 >> 2] < HEAP32[HEAP32[HEAP32[$3 + 20 >> 2] >> 2] >> 2] ? HEAP32[(HEAP32[HEAP32[$3 + 20 >> 2] >> 2] + 4 | 0) + (HEAP32[$3 + 16 >> 2] << 2) >> 2] != -1 : $4;
 HEAP8[$3 + 15 | 0] = $4;
 label$2: {
  if (HEAP8[$3 + 15 | 0] & 1) {
   HEAP32[$3 + 28 >> 2] = tflite___28anonymous_20namespace_29__GetMutableInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2]);
   break label$2;
  }
  HEAP32[$3 + 28 >> 2] = 0;
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jswrap_io_analogWrite($0, $1, $2) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP8[$3 + 47 | 0] = $0;
 HEAPF64[$3 + 32 >> 3] = $1;
 HEAP32[$3 + 28 >> 2] = $2;
 HEAPF64[$3 + 16 >> 3] = 0;
 HEAP32[$3 + 12 >> 2] = 0;
 if (jsvIsObject(HEAP32[$3 + 28 >> 2]) & 1) {
  HEAPF64[$3 + 16 >> 3] = jsvObjectGetFloatChild(HEAP32[$3 + 28 >> 2], 121475);
  label$2: {
   if (jsvObjectGetBoolChild(HEAP32[$3 + 28 >> 2], 117772) & 1) {
    HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] | 2;
    break label$2;
   }
   if (jsvObjectGetBoolChild(HEAP32[$3 + 28 >> 2], 117767) & 1) {
    HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] | 1;
   }
  }
 }
 jshPinAnalogOutput(HEAPU8[$3 + 47 | 0], HEAPF64[$3 + 32 >> 3], HEAPF64[$3 + 16 >> 3], HEAP32[$3 + 12 >> 2]);
 __stack_pointer = $3 + 48 | 0;
}

function tflite__Offset_28tflite__RuntimeShape_20const__2c_20int_2c_20int_2c_20int_2c_20int_29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 28 >> 2] = $0;
 HEAP32[$5 + 24 >> 2] = $1;
 HEAP32[$5 + 20 >> 2] = $2;
 HEAP32[$5 + 16 >> 2] = $3;
 HEAP32[$5 + 12 >> 2] = $4;
 label$1: {
  if ((tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$5 + 28 >> 2]) | 0) != 4) {
   break label$1;
  }
 }
 HEAP32[$5 + 8 >> 2] = tflite__RuntimeShape__DimsDataUpTo5D_28_29_20const(HEAP32[$5 + 28 >> 2]);
 __stack_pointer = $5 + 32 | 0;
 return HEAP32[$5 + 12 >> 2] + Math_imul(HEAP32[HEAP32[$5 + 8 >> 2] + 12 >> 2], HEAP32[$5 + 16 >> 2] + Math_imul(HEAP32[HEAP32[$5 + 8 >> 2] + 8 >> 2], HEAP32[$5 + 20 >> 2] + Math_imul(HEAP32[$5 + 24 >> 2], HEAP32[HEAP32[$5 + 8 >> 2] + 4 >> 2]) | 0) | 0) | 0;
}

function jswrap_print($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsiConsoleRemoveInputLine();
 jsvObjectIteratorNew($1 + 8 | 0, HEAP32[$1 + 12 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue_7($1 + 8 | 0) & 1) {
   HEAP32[$1 + 4 >> 2] = jsvObjectIteratorGetValue_7($1 + 8 | 0);
   label$3: {
    if (jsvIsString(HEAP32[$1 + 4 >> 2]) & 1) {
     jsiConsolePrintStringVar(HEAP32[$1 + 4 >> 2]);
     break label$3;
    }
    jsfPrintJSON(HEAP32[$1 + 4 >> 2], 261);
   }
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   jsvObjectIteratorNext($1 + 8 | 0);
   if (jsvObjectIteratorHasValue_7($1 + 8 | 0) & 1) {
    jsiConsolePrintString(146437);
   }
   continue;
  }
  break;
 }
 jsvObjectIteratorFree_7($1 + 8 | 0);
 jsiConsolePrintString(148266);
 __stack_pointer = $1 + 16 | 0;
}

function jshResetDevices() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 jshResetPinStateIsManual();
 HEAP32[$0 + 12 >> 2] = 0;
 while (1) {
  label$2: {
   if (!HEAP32[$0 + 12 >> 2] | HEAP32[$0 + 12 >> 2] >= 2) {
    break label$2;
   }
   if (HEAP32[$0 + 12 >> 2] == ((jsiGetConsoleDevice() & 255) - 21 | 0)) {
    break label$2;
   }
   HEAP8[HEAP32[$0 + 12 >> 2] + 364488 | 0] = 0;
   HEAP8[HEAP32[$0 + 12 >> 2] + 364490 | 0] = 255;
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[$0 + 8 >> 2] = 1;
 while (1) {
  if (HEAP32[$0 + 8 >> 2] <= 16) {
   HEAP32[(HEAP32[$0 + 8 >> 2] << 2) + 364492 >> 2] = 0;
   HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 jshSetPinStateIsManual(17, 1);
 jshPinSetState(17, 6);
 __stack_pointer = $0 + 16 | 0;
}

function jswrap_object_setPrototypeOf($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 label$1: {
  label$2: {
   if (!(jsvIsFunction(HEAP32[$2 + 12 >> 2]) & 1)) {
    if (!(jsvIsObject(HEAP32[$2 + 12 >> 2]) & 1)) {
     break label$2;
    }
   }
   $0 = jsvFindOrAddChildFromString(HEAP32[$2 + 12 >> 2], 135865);
   break label$1;
  }
  $0 = 0;
 }
 HEAP32[$2 + 4 >> 2] = $0;
 label$4: {
  if (!(jsvIsName(HEAP32[$2 + 4 >> 2]) & 1)) {
   HEAP32[$2 >> 2] = HEAP32[$2 + 4 >> 2];
   jsExceptionHere(3, 119344, $2);
   break label$4;
  }
  jsvSetValueOfName(HEAP32[$2 + 4 >> 2], HEAP32[$2 + 8 >> 2]);
 }
 jsvUnLock(HEAP32[$2 + 4 >> 2]);
 $0 = jsvLockAgainSafe(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function tflite__MicroMutableOpResolver_9u___FindOp_28tflite__BuiltinOperator_29_20const($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 $0 = HEAP32[$2 + 24 >> 2];
 label$1: {
  if (HEAP32[$2 + 20 >> 2] == 32) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 16 >> 2] = 0;
  while (1) {
   if (HEAPU32[$2 + 16 >> 2] < HEAPU32[$0 + 292 >> 2]) {
    HEAP32[$2 + 12 >> 2] = ($0 + 4 | 0) + (HEAP32[$2 + 16 >> 2] << 5);
    if (HEAP32[HEAP32[$2 + 12 >> 2] + 20 >> 2] == HEAP32[$2 + 20 >> 2]) {
     HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
     break label$1;
    } else {
     HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] + 1;
     continue;
    }
   }
   break;
  }
  HEAP32[$2 + 28 >> 2] = 0;
 }
 return HEAP32[$2 + 28 >> 2];
}

function tflite__GreedyMemoryPlanner__AddBuffer_28tflite__ErrorReporter__2c_20int_2c_20int_2c_20int_2c_20int_29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 32 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 24 >> 2] = $0;
 HEAP32[$6 + 20 >> 2] = $1;
 HEAP32[$6 + 16 >> 2] = $2;
 HEAP32[$6 + 12 >> 2] = $3;
 HEAP32[$6 + 8 >> 2] = $4;
 HEAP32[$6 + 4 >> 2] = $5;
 $0 = HEAP32[$6 + 24 >> 2];
 HEAP32[$6 >> 2] = HEAP32[$0 + 12 >> 2] + (HEAP32[$0 + 8 >> 2] << 4);
 label$1: {
  if (FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 8 >> 2]]($0, HEAP32[$6 + 20 >> 2], HEAP32[$6 + 16 >> 2], HEAP32[$6 + 12 >> 2], HEAP32[$6 + 8 >> 2]) | 0) {
   HEAP32[$6 + 28 >> 2] = 1;
   break label$1;
  }
  HEAP32[HEAP32[$6 >> 2] + 4 >> 2] = HEAP32[$6 + 4 >> 2];
  HEAP32[$6 + 28 >> 2] = 0;
 }
 __stack_pointer = $6 + 32 | 0;
 return HEAP32[$6 + 28 >> 2];
}

function jsvArrayBufferIteratorGetValueData($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 label$1: {
  if (!HEAPU8[HEAP32[$2 + 12 >> 2] + 36 | 0]) {
   break label$1;
  }
  HEAP32[$2 >> 2] = HEAPU8[HEAP32[$2 + 12 >> 2] + 36 | 0] & 15;
  HEAP32[$2 + 4 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 4 >> 2] < HEAP32[$2 >> 2]) {
    $0 = jsvStringIteratorGetChar_2(HEAP32[$2 + 12 >> 2]);
    HEAP8[HEAP32[$2 + 8 >> 2] + HEAP32[$2 + 4 >> 2] | 0] = $0;
    if (HEAP32[$2 >> 2] != 1) {
     jsvStringIteratorNext(HEAP32[$2 + 12 >> 2]);
    }
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
    continue;
   }
   break;
  }
  if (HEAP32[$2 >> 2] == 1) {
   break label$1;
  }
  HEAP8[HEAP32[$2 + 12 >> 2] + 52 | 0] = 1;
 }
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_date_toUTCString($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $1 = __stack_pointer - 96 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 92 >> 2] = $0;
 getTimeFromDateVar($1 - -64 | 0, HEAP32[$1 + 92 >> 2], 1);
 getCalendarDate($1 + 40 | 0, HEAP32[$1 + 64 >> 2]);
 $0 = HEAP32[48928];
 $2 = HEAP32[$1 + 56 >> 2] << 2;
 $3 = HEAP32[$1 + 44 >> 2];
 $4 = HEAP32[48927];
 $5 = HEAP32[$1 + 48 >> 2] << 2;
 $6 = HEAP32[$1 + 52 >> 2];
 $7 = HEAP32[$1 + 80 >> 2];
 $8 = HEAP32[$1 + 76 >> 2];
 HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 72 >> 2];
 HEAP32[$1 + 20 >> 2] = $8;
 HEAP32[$1 + 16 >> 2] = $7;
 HEAP32[$1 + 12 >> 2] = $6;
 HEAP32[$1 + 8 >> 2] = $4 + $5;
 HEAP32[$1 + 4 >> 2] = $3;
 HEAP32[$1 >> 2] = $0 + $2;
 $0 = jsvVarPrintf(136669, $1);
 __stack_pointer = $1 + 96 | 0;
 return $0 | 0;
}

function tflite__FlatSizeSkipDim_28tflite__RuntimeShape_20const__2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = tflite__RuntimeShape__DimensionsCount_28_29_20const(HEAP32[$2 + 28 >> 2]);
 HEAP32[$2 + 16 >> 2] = tflite__RuntimeShape__DimsData_28_29_20const(HEAP32[$2 + 28 >> 2]);
 HEAP32[$2 + 12 >> 2] = 1;
 HEAP32[$2 + 8 >> 2] = 0;
 while (1) {
  if (HEAP32[$2 + 8 >> 2] < HEAP32[$2 + 20 >> 2]) {
   HEAP32[$2 + 12 >> 2] = Math_imul(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2] == HEAP32[$2 + 24 >> 2] ? 1 : HEAP32[HEAP32[$2 + 16 >> 2] + (HEAP32[$2 + 8 >> 2] << 2) >> 2]);
   HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function push_outgoing_bits($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP8[$2 + 7 | 0] = 0;
 HEAP8[$2 + 6 | 0] = 0;
 label$1: {
  if (HEAPU8[HEAP32[$2 + 12 >> 2] + 10 | 0] > 8) {
   HEAP8[$2 + 7 | 0] = 8;
   HEAP8[$2 + 6 | 0] = HEAPU16[HEAP32[$2 + 12 >> 2] + 8 >> 1] >> HEAPU8[HEAP32[$2 + 12 >> 2] + 10 | 0] - 8;
   break label$1;
  }
  HEAP8[$2 + 7 | 0] = HEAPU8[HEAP32[$2 + 12 >> 2] + 10 | 0];
  HEAP8[$2 + 6 | 0] = HEAPU16[HEAP32[$2 + 12 >> 2] + 8 >> 1];
 }
 if (HEAPU8[$2 + 7 | 0]) {
  push_bits(HEAP32[$2 + 12 >> 2], HEAPU8[$2 + 7 | 0], HEAPU8[$2 + 6 | 0], HEAP32[$2 + 8 >> 2]);
  $0 = HEAP32[$2 + 12 >> 2];
  HEAP8[$0 + 10 | 0] = HEAPU8[$0 + 10 | 0] - HEAPU8[$2 + 7 | 0];
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAPU8[$2 + 7 | 0];
}

function jsvGetMemoryUsage() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 1;
 while (1) {
  if (HEAPU32[$0 + 8 >> 2] <= 12e3) {
   HEAP32[$0 + 4 >> 2] = jsvGetAddressOf(HEAP32[$0 + 8 >> 2] & 65535);
   $1 = HEAP32[$0 + 4 >> 2];
   if ((HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) & 63) {
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    if (jsvIsFlatString(HEAP32[$0 + 4 >> 2]) & 1) {
     HEAP32[$0 >> 2] = jsvGetFlatStringBlocks(HEAP32[$0 + 4 >> 2]);
     HEAP32[$0 + 8 >> 2] = HEAP32[$0 >> 2] + HEAP32[$0 + 8 >> 2];
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 >> 2] + HEAP32[$0 + 12 >> 2];
    }
   }
   HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function jslNewTokenisedStringFromLexer($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 192 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 188 >> 2] = $0;
 HEAP32[$2 + 184 >> 2] = $1;
 HEAP32[$2 + 180 >> 2] = HEAP32[49079];
 HEAP32[49079] = $2 + 56;
 jslInit(HEAP32[HEAP32[$2 + 180 >> 2] + 84 >> 2]);
 HEAP32[$2 + 52 >> 2] = _jslNewTokenisedStringFromLexer(0, 0, HEAP32[$2 + 188 >> 2], HEAP32[$2 + 184 >> 2]);
 HEAP32[$2 + 48 >> 2] = jsvNewStringOfLength(HEAP32[$2 + 52 >> 2], 0);
 if (HEAP32[$2 + 48 >> 2]) {
  jsvStringIteratorNew($2 + 8 | 0, HEAP32[$2 + 48 >> 2], 0);
  _jslNewTokenisedStringFromLexer($2 + 8 | 0, HEAP32[$2 + 48 >> 2], HEAP32[$2 + 188 >> 2], HEAP32[$2 + 184 >> 2]);
  jsvStringIteratorFree($2 + 8 | 0);
 }
 jslKill();
 HEAP32[49079] = HEAP32[$2 + 180 >> 2];
 __stack_pointer = $2 + 192 | 0;
 return HEAP32[$2 + 48 >> 2];
}

function jsvSetLastChild($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP16[$4 + 10 >> 1] = $1;
 $5 = HEAP32[$4 + 12 >> 2];
 $2 = $5;
 $0 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
 $1 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
 $2 = $0;
 $3 = $2;
 $0 = $1 & 262143;
 $6 = $0;
 $1 = $4;
 $0 = HEAPU16[$1 + 10 >> 1];
 $2 = $0 & 16383;
 $1 = $2 << 18;
 $2 = $1;
 $0 = $5;
 HEAP8[$0 + 4 | 0] = $3;
 HEAP8[$0 + 5 | 0] = $3 >>> 8;
 HEAP8[$0 + 6 | 0] = $3 >>> 16;
 HEAP8[$0 + 7 | 0] = $3 >>> 24;
 $1 = $6;
 $2 = $1 | $2;
 HEAP8[$0 + 8 | 0] = $2;
 HEAP8[$0 + 9 | 0] = $2 >>> 8;
 HEAP8[$0 + 10 | 0] = $2 >>> 16;
 HEAP8[$0 + 11 | 0] = $2 >>> 24;
}

function jsvNewArrayBufferWithPtr($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = jsvNewFlatStringOfLength(HEAP32[$2 + 24 >> 2]);
 label$1: {
  if (!HEAP32[$2 + 16 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvNewArrayBufferFromString(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 24 >> 2]);
  if (!HEAP32[$2 + 12 >> 2]) {
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  $0 = jsvGetFlatStringPointer(HEAP32[$2 + 16 >> 2]);
  HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = $0;
  jsvUnLock(HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function _ZN17compiler_builtins3int4sdiv3Div3div17he78fc483e41d7ec7E($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $4 = $1 >> 31;
 $8 = $4;
 $5 = $1;
 $5 = $4 ^ $5;
 $7 = $1 >> 31;
 $4 = $0 ^ $7;
 $9 = $4 - $7 | 0;
 $0 = $8;
 $6 = $0 + ($4 >>> 0 < $7 >>> 0) | 0;
 $6 = $5 - $6 | 0;
 $10 = $6;
 $6 = $3;
 $4 = $6 >> 31;
 $8 = $4;
 $5 = $6;
 $5 = $4 ^ $5;
 $7 = $6 >> 31;
 $6 = $7;
 $4 = $6 ^ $2;
 $0 = $4 - $6 | 0;
 $6 = $8;
 $4 = $5 - ($6 + ($4 >>> 0 < $7 >>> 0) | 0) | 0;
 $4 = __wasm_i64_udiv($9, $10, $0, $4);
 $6 = $4;
 $4 = $1;
 $4 = $3 ^ $4;
 $0 = $4 >> 31;
 $5 = $4 >> 31;
 $1 = $5;
 $5 = i64toi32_i32$HIGH_BITS;
 $2 = $1 ^ $5;
 $4 = $6;
 $5 = $0 ^ $4;
 $6 = $5 - $0 | 0;
 $4 = $1;
 $0 = $4 + ($0 >>> 0 > $5 >>> 0) | 0;
 $0 = $2 - $0 | 0;
 $5 = $6;
 i64toi32_i32$HIGH_BITS = $0;
 return $5;
}

function jsvGetNativeFunctionPtr($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = jsvFindChildFromString(HEAP32[$1 + 8 >> 2], 133204);
 label$1: {
  if (HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 4 >> 2] = jsvSkipNameAndUnLock(HEAP32[$1 + 4 >> 2]);
   $0 = HEAP32[$1 + 8 >> 2];
   HEAP32[$1 >> 2] = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) + jsvGetFlatStringPointer(HEAP32[$1 + 4 >> 2]);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP32[$1 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function fromCalendarDate($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 while (1) {
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] < 0) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] - 1;
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 12;
   continue;
  }
  break;
 }
 while (1) {
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] > 11) {
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] - 12;
   continue;
  }
  break;
 }
 $0 = getDayNumberFromDate(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2], HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2], HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function _jswrap_drawImageLayerSetStart($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = (HEAP32[$3 + 24 >> 2] << 8) - HEAP32[HEAP32[$3 + 28 >> 2] >> 2];
 HEAP32[$3 + 12 >> 2] = (HEAP32[$3 + 20 >> 2] << 8) - HEAP32[HEAP32[$3 + 28 >> 2] + 4 >> 2];
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$0 + 172 >> 2] = HEAP32[$0 + 172 >> 2] + (Math_imul(HEAP32[HEAP32[$3 + 28 >> 2] + 164 >> 2], HEAP32[$3 + 16 >> 2]) + Math_imul(HEAP32[HEAP32[$3 + 28 >> 2] + 168 >> 2], HEAP32[$3 + 12 >> 2]) >> 8);
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$0 + 176 >> 2] = HEAP32[$0 + 176 >> 2] + (Math_imul(HEAP32[HEAP32[$3 + 28 >> 2] + 164 >> 2], HEAP32[$3 + 12 >> 2]) - Math_imul(HEAP32[HEAP32[$3 + 28 >> 2] + 168 >> 2], HEAP32[$3 + 16 >> 2]) >> 8);
}

function jsfGetFileHeader($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP8[$3 + 19 | 0] = $2;
 label$1: {
  if (!HEAP32[$3 + 24 >> 2]) {
   HEAP8[$3 + 31 | 0] = 0;
   break label$1;
  }
  jshFlashRead(HEAP32[$3 + 20 >> 2], HEAP32[$3 + 24 >> 2], HEAP8[$3 + 19 | 0] & 1 ? 32 : 8);
  HEAP32[$3 + 12 >> 2] = (HEAP32[$3 + 24 >> 2] + 32 | 0) + jsfGetFileSize(HEAP32[$3 + 20 >> 2]);
  $0 = 0;
  label$3: {
   if (HEAP32[HEAP32[$3 + 20 >> 2] >> 2] == -1) {
    break label$3;
   }
   $0 = 0;
   if (!HEAP32[HEAP32[$3 + 20 >> 2] >> 2]) {
    break label$3;
   }
   $0 = HEAPU32[$3 + 12 >> 2] <= jsfGetBankEndAddress(HEAP32[$3 + 24 >> 2]) >>> 0;
  }
  HEAP8[$3 + 31 | 0] = $0;
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP8[$3 + 31 | 0] & 1;
}

function jshFlashRead($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 label$1: {
  if (HEAPU32[$3 + 24 >> 2] < 134217728) {
   break label$1;
  }
  HEAP32[$3 + 16 >> 2] = 0;
  while (1) {
   if (HEAPU32[$3 + 16 >> 2] >= HEAPU32[$3 + 20 >> 2]) {
    break label$1;
   }
   HEAP32[$3 + 12 >> 2] = 196215;
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP8[$3 + 10 | 0] = 105;
   HEAP8[$3 + 11 | 0] = 0;
   HEAP32[$3 >> 2] = (HEAP32[$3 + 24 >> 2] + HEAP32[$3 + 16 >> 2] | 0) + -134217728;
   $0 = emscripten_asm_const_int($0 | 0, $3 + 10 | 0, $3 | 0) | 0;
   HEAP8[HEAP32[$3 + 28 >> 2] + HEAP32[$3 + 16 >> 2] | 0] = $0;
   HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 16 >> 2] + 1;
   continue;
  }
 }
 __stack_pointer = $3 + 32 | 0;
}

function jsvSetRefs($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP16[$4 + 10 >> 1] = $1;
 $5 = HEAP32[$4 + 12 >> 2];
 $2 = $5;
 $0 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
 $1 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
 $2 = $0;
 $3 = $2;
 $0 = $1 & -261121;
 $6 = $0;
 $1 = $4;
 $0 = HEAPU16[$1 + 10 >> 1];
 $2 = $0 & 255;
 $1 = $2 << 10;
 $2 = $1;
 $0 = $5;
 HEAP8[$0 + 4 | 0] = $3;
 HEAP8[$0 + 5 | 0] = $3 >>> 8;
 HEAP8[$0 + 6 | 0] = $3 >>> 16;
 HEAP8[$0 + 7 | 0] = $3 >>> 24;
 $1 = $6;
 $2 = $1 | $2;
 HEAP8[$0 + 8 | 0] = $2;
 HEAP8[$0 + 9 | 0] = $2 >>> 8;
 HEAP8[$0 + 10 | 0] = $2 >>> 16;
 HEAP8[$0 + 11 | 0] = $2 >>> 24;
}

function jsvIsInstanceOf($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP8[$2 + 19 | 0] = 0;
 label$1: {
  if (!(jsvHasChildren(HEAP32[$2 + 24 >> 2]) & 1)) {
   HEAP8[$2 + 31 | 0] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 24 >> 2], 135865);
  if (jsvIsObject(HEAP32[$2 + 12 >> 2]) & 1) {
   HEAP32[$2 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 12 >> 2], 120855);
   if (HEAP32[$2 + 8 >> 2]) {
    HEAP8[$2 + 19 | 0] = jspIsConstructor(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 20 >> 2]) & 1;
   }
   jsvUnLock(HEAP32[$2 + 8 >> 2]);
  }
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  HEAP8[$2 + 31 | 0] = HEAP8[$2 + 19 | 0] & 1;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP8[$2 + 31 | 0] & 1;
}

function jsiQueueEvents($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = jsvNewObject();
 if (HEAP32[$4 + 12 >> 2]) {
  jsvUnLock(jsvAddNamedChild(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 24 >> 2], 135671));
  if (HEAP32[$4 + 16 >> 2]) {
   HEAP32[$4 + 8 >> 2] = jsvNewArray(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
   if (HEAP32[$4 + 8 >> 2]) {
    jsvAddNamedChildAndUnLock(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], 120162);
   }
  }
  if (HEAP32[$4 + 28 >> 2]) {
   jsvUnLock(jsvAddNamedChild(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 28 >> 2], 120152));
  }
  jsvArrayPushAndUnLock(HEAP32[91101], HEAP32[$4 + 12 >> 2]);
 }
 __stack_pointer = $4 + 32 | 0;
}

function jswrap_storage_read($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 80 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 76 >> 2] = $0;
 HEAP32[$3 + 72 >> 2] = $1;
 HEAP32[$3 + 68 >> 2] = $2;
 jsfNameFromVar($3 + 40 | 0, HEAP32[$3 + 76 >> 2]);
 $2 = HEAP32[$3 + 72 >> 2];
 $4 = HEAP32[$3 + 68 >> 2];
 HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 64 >> 2];
 $1 = HEAP32[$3 + 60 >> 2];
 $0 = HEAP32[$3 + 56 >> 2];
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 28 >> 2] = $1;
 $0 = HEAP32[$3 + 52 >> 2];
 $1 = HEAP32[$3 + 48 >> 2];
 HEAP32[$3 + 16 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $0;
 $1 = HEAP32[$3 + 44 >> 2];
 $0 = HEAP32[$3 + 40 >> 2];
 HEAP32[$3 + 8 >> 2] = $0;
 HEAP32[$3 + 12 >> 2] = $1;
 $0 = jsfReadFile($3 + 8 | 0, $2, $4);
 __stack_pointer = $3 + 80 | 0;
 return $0 | 0;
}

function jsvNewFromFloat($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 16 >> 3] = $0;
 HEAP32[$1 + 12 >> 2] = jsvNewWithFlags(11);
 label$1: {
  if (!HEAP32[$1 + 12 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  $2 = HEAP32[$1 + 12 >> 2];
  wasm2js_scratch_store_f64(+HEAPF64[$1 + 16 >> 3]);
  $3 = wasm2js_scratch_load_i32(1) | 0;
  $4 = wasm2js_scratch_load_i32(0) | 0;
  HEAP8[$2 | 0] = $4;
  HEAP8[$2 + 1 | 0] = $4 >>> 8;
  HEAP8[$2 + 2 | 0] = $4 >>> 16;
  HEAP8[$2 + 3 | 0] = $4 >>> 24;
  HEAP8[$2 + 4 | 0] = $3;
  HEAP8[$2 + 5 | 0] = $3 >>> 8;
  HEAP8[$2 + 6 | 0] = $3 >>> 16;
  HEAP8[$2 + 7 | 0] = $3 >>> 24;
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 12 >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function lcdSetPixel_ArrayBuffer_flat4($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 $0 = HEAP32[$4 + 28 >> 2];
 HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 24 >> 2] + Math_imul(HEAP32[$4 + 20 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
 HEAP32[$4 + 8 >> 2] = (HEAP32[$4 + 12 >> 2] & 1) << 2;
 $0 = HEAP32[$4 + 28 >> 2];
 HEAP32[$4 + 4 >> 2] = (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$4 + 12 >> 2] >> 1);
 HEAP8[HEAP32[$4 + 4 >> 2]] = HEAPU8[HEAP32[$4 + 4 >> 2]] & 65295 >> HEAP32[$4 + 8 >> 2] | (HEAP32[$4 + 16 >> 2] & 15) << 4 - HEAP32[$4 + 8 >> 2];
}

function jswrap_atob_decode($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] & 255;
 label$1: {
  if (!(HEAP32[$1 + 8 >> 2] < 65 | HEAP32[$1 + 8 >> 2] > 90)) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] - 65;
   break label$1;
  }
  if (!(HEAP32[$1 + 8 >> 2] < 97 | HEAP32[$1 + 8 >> 2] > 122)) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] - 71;
   break label$1;
  }
  if (!(HEAP32[$1 + 8 >> 2] < 48 | HEAP32[$1 + 8 >> 2] > 57)) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] + 4;
   break label$1;
  }
  if (HEAP32[$1 + 8 >> 2] == 43) {
   HEAP32[$1 + 12 >> 2] = 62;
   break label$1;
  }
  if (HEAP32[$1 + 8 >> 2] == 47) {
   HEAP32[$1 + 12 >> 2] = 63;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = -1;
 }
 return HEAP32[$1 + 12 >> 2];
}

function lcdSetPixel_ArrayBuffer_flat2($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 $0 = HEAP32[$4 + 28 >> 2];
 HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 24 >> 2] + Math_imul(HEAP32[$4 + 20 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
 HEAP32[$4 + 8 >> 2] = (HEAP32[$4 + 12 >> 2] & 3) << 1;
 $0 = HEAP32[$4 + 28 >> 2];
 HEAP32[$4 + 4 >> 2] = (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$4 + 12 >> 2] >> 2);
 HEAP8[HEAP32[$4 + 4 >> 2]] = HEAPU8[HEAP32[$4 + 4 >> 2]] & 65343 >> HEAP32[$4 + 8 >> 2] | (HEAP32[$4 + 16 >> 2] & 3) << 6 - HEAP32[$4 + 8 >> 2];
}

function vfGetCharPtr($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 HEAP8[$2 + 27 | 0] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP8[$2 + 19 | 0] = HEAPU8[$2 + 27 | 0];
 label$1: {
  if (!(HEAPU8[$2 + 19 | 0] <= 255 & HEAPU8[$2 + 19 | 0] >= 33)) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP8[$2 + 19 | 0] = HEAPU8[$2 + 19 | 0] - 33;
  HEAP32[$2 + 12 >> 2] = 170016;
  HEAP8[$2 + 11 | 0] = 0;
  while (1) {
   if (HEAPU8[$2 + 11 | 0] < HEAPU8[$2 + 19 | 0]) {
    HEAP32[$2 + 12 >> 2] = HEAPU8[HEAPU8[$2 + 11 | 0] + 170368 | 0] + HEAP32[$2 + 12 >> 2];
    HEAP8[$2 + 11 | 0] = HEAPU8[$2 + 11 | 0] + 1;
    continue;
   }
   break;
  }
  HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = HEAPU8[HEAPU8[$2 + 19 | 0] + 170368 | 0];
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 return HEAP32[$2 + 28 >> 2];
}

function jspGetBuiltinPrototype($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 4 >> 2] = jspFindPrototypeFor(116389);
   if (HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
    break label$1;
   }
  }
  label$4: {
   if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
    if (!(jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1)) {
     break label$4;
    }
   }
   HEAP32[$1 >> 2] = jspFindPrototypeFor(117903);
   if (HEAP32[$1 >> 2] == HEAP32[$1 + 8 >> 2]) {
    jsvUnLock(HEAP32[$1 >> 2]);
    HEAP32[$1 >> 2] = 0;
   }
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvHasStringExt($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  label$3: {
   if (!(HEAP8[$1 + 7 | 0] <= 40 & HEAP8[$1 + 7 | 0] >= 18)) {
    $0 = 0;
    if (HEAP8[$1 + 7 | 0] < 41) {
     break label$3;
    }
    $0 = 0;
    if (HEAP8[$1 + 7 | 0] > 51) {
     break label$3;
    }
   }
   $0 = 1;
   label$6: {
    if (HEAP8[$1 + 7 | 0] == 38) {
     break label$6;
    }
    $0 = 1;
    if (HEAP8[$1 + 7 | 0] == 39) {
     break label$6;
    }
    $0 = HEAP8[$1 + 7 | 0] == 40;
   }
   $0 = $0 ^ -1;
  }
  HEAP8[$1 + 15 | 0] = $0 & 1;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function tflite__MicroAllocator__GetSubGraphFromModel_28tflite__Model_20const__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 $0 = HEAP32[$2 + 8 >> 2];
 HEAP32[$2 >> 2] = tflite__Model__subgraphs_28_29_20const(HEAP32[$2 + 4 >> 2]);
 label$1: {
  if ((flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph____size_28_29_20const(HEAP32[$2 >> 2]) | 0) != 1) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$0 + 8 >> 2], 147828, 0);
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph____operator_5b_5d_28unsigned_20int_29_20const(HEAP32[$2 >> 2], 0);
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function terminalScroll() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 80 | 0;
 __stack_pointer = $0;
 HEAP8[195720] = HEAPU8[195720] - 1;
 if (terminalGetGFX($0 + 8 | 0) & 1) {
  HEAP32[$0 + 4 >> 2] = HEAPU8[$0 + 29 | 0] | HEAPU8[$0 + 30 | 0] << 8 | (HEAPU8[$0 + 31 | 0] << 16 | HEAPU8[$0 + 32 | 0] << 24);
  $1 = HEAPU8[366787] | HEAPU8[366788] << 8;
  HEAP8[$0 + 29 | 0] = $1;
  HEAP8[$0 + 30 | 0] = $1 >>> 8;
  HEAP8[$0 + 31 | 0] = $1 >>> 16;
  HEAP8[$0 + 32 | 0] = $1 >>> 24;
  graphicsScroll($0 + 8 | 0, 0, -8);
  $1 = HEAP32[$0 + 4 >> 2];
  HEAP8[$0 + 29 | 0] = $1;
  HEAP8[$0 + 30 | 0] = $1 >>> 8;
  HEAP8[$0 + 31 | 0] = $1 >>> 16;
  HEAP8[$0 + 32 | 0] = $1 >>> 24;
  terminalSetGFX($0 + 8 | 0);
  if (!(jshIsInInterrupt() & 1)) {
   jswrap_terminal_idle();
  }
 }
 __stack_pointer = $0 + 80 | 0;
}

function jswrap_string_fromCharCode($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = jsvNewFromEmptyString_8();
 label$1: {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  jsvObjectIteratorNew($1 + 16 | 0, HEAP32[$1 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_10($1 + 16 | 0) & 1) {
    HEAP8[$1 + 15 | 0] = jsvGetIntegerAndUnLock(jsvObjectIteratorGetValue_10($1 + 16 | 0));
    jsvAppendStringBuf(HEAP32[$1 + 20 >> 2], $1 + 15 | 0, 1);
    jsvObjectIteratorNext($1 + 16 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_10($1 + 16 | 0);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 20 >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function jswrap_banglejs_getAccel() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = jsvNewObject();
 if (HEAP32[$0 + 12 >> 2]) {
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 116522, jsvNewFromFloat(+HEAP16[195536] * .0001220703125));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 116397, jsvNewFromFloat(+HEAP16[195537] * .0001220703125));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 116106, jsvNewFromFloat(+HEAP16[195538] * .0001220703125));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 130069, jsvNewFromFloat(Math_sqrt(+HEAP32[97770]) * .0001220703125));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 12 >> 2], 130140, jsvNewFromFloat(+HEAPU32[97771] * .0001220703125));
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Allocate_28_29($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 HEAP32[$1 + 4 >> 2] = Math_imul(tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Size_28_29_20const($0), 24);
 $2 = HEAP32[$0 + 4 >> 2];
 HEAP32[$0 + 16 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$2 >> 2] + 12 >> 2]]($2, HEAP32[$1 + 4 >> 2], 4);
 label$1: {
  if (!HEAP32[$0 + 16 >> 2]) {
   $0 = HEAP32[$0 >> 2];
   HEAP32[$1 >> 2] = HEAP32[$1 + 4 >> 2];
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, 133735, $1);
   HEAP32[$1 + 12 >> 2] = 1;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_array_join($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (!(jsvIsIterable(HEAP32[$2 + 8 >> 2]) & 1)) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  label$3: {
   if (jsvIsUndefined(HEAP32[$2 + 4 >> 2]) & 1) {
    HEAP32[$2 + 4 >> 2] = jsvNewFromString(141344);
    break label$3;
   }
   HEAP32[$2 + 4 >> 2] = jsvAsString(HEAP32[$2 + 4 >> 2]);
  }
  if (!HEAP32[$2 + 4 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 >> 2] = jsvArrayJoin(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2], 1);
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function OneWireRead($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jshPinSetState(HEAPU8[$2 + 15 | 0], 3);
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP32[$2 >> 2] = 1;
 while (1) {
  $0 = HEAP32[$2 + 8 >> 2];
  HEAP32[$2 + 8 >> 2] = $0 - 1;
  if (($0 | 0) > 0) {
   jshInterruptOff();
   jshPinSetValue(HEAPU8[$2 + 15 | 0], 0);
   jshDelayMicroseconds(3);
   jshPinSetValue(HEAPU8[$2 + 15 | 0], 1);
   jshDelayMicroseconds(10);
   if (jshPinGetValue(HEAPU8[$2 + 15 | 0]) & 1) {
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | HEAP32[$2 >> 2];
   }
   jshInterruptOn();
   jshDelayMicroseconds(53);
   HEAP32[$2 >> 2] = HEAP32[$2 >> 2] << 1;
   continue;
  }
  break;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 4 >> 2];
}

function jsvGetMaxCharactersInVar($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (jsvIsStringExt(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 10;
   break label$1;
  }
  if (jsvIsName(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 4;
   break label$1;
  }
  label$4: {
   label$5: {
    if (jsvIsFlatString(HEAP32[$1 + 8 >> 2]) & 1) {
     break label$5;
    }
    if (jsvIsFlashString(HEAP32[$1 + 8 >> 2]) & 1) {
     break label$5;
    }
    if (!(jsvIsNativeString(HEAP32[$1 + 8 >> 2]) & 1)) {
     break label$4;
    }
   }
   HEAP32[$1 + 12 >> 2] = jsvGetCharactersInVar(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 9;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function mbedtls_cipher_info_from_values($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = 180640;
 label$1: {
  while (1) {
   if (HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2]) {
    if (!(HEAP32[HEAP32[HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] + 28 >> 2] >> 2] != HEAP32[$3 + 24 >> 2] | HEAP32[HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] + 8 >> 2] != HEAP32[$3 + 20 >> 2] | HEAP32[HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] + 4 >> 2] != HEAP32[$3 + 16 >> 2])) {
     HEAP32[$3 + 28 >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2];
     break label$1;
    }
    HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 8;
    continue;
   }
   break;
  }
  HEAP32[$3 + 28 >> 2] = 0;
 }
 return HEAP32[$3 + 28 >> 2];
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode___20const___28unsigned_20short_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 8 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 HEAP32[$2 + 4 >> 2] = HEAPU16[$2 + 8 >> 1] + $0;
 label$1: {
  if (HEAPU16[$2 + 8 >> 1]) {
   $0 = HEAP32[$2 + 4 >> 2] + unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 4 >> 2]) | 0;
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jsvGetStringIndexOf($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP8[$2 + 55 | 0] = $1;
 jsvStringIteratorNew($2 + 16 | 0, HEAP32[$2 + 56 >> 2], 0);
 label$1: {
  while (1) {
   if (jsvStringIteratorHasChar_1($2 + 16 | 0) & 1) {
    if ((jsvStringIteratorGetChar_1($2 + 16 | 0) & 255) == HEAPU8[$2 + 55 | 0]) {
     HEAP32[$2 + 12 >> 2] = jsvStringIteratorGetIndex_1($2 + 16 | 0);
     jsvStringIteratorFree_1($2 + 16 | 0);
     HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 12 >> 2];
     break label$1;
    } else {
     jsvStringIteratorNext($2 + 16 | 0);
     continue;
    }
   }
   break;
  }
  jsvStringIteratorFree_1($2 + 16 | 0);
  HEAP32[$2 + 60 >> 2] = -1;
 }
 __stack_pointer = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}

function jsspiSend4bit($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP8[$4 + 15 | 0] = $0;
 HEAP8[$4 + 14 | 0] = $1;
 HEAP32[$4 + 8 >> 2] = $2;
 HEAP32[$4 + 4 >> 2] = $3;
 HEAP8[$4 | 0] = HEAP32[$4 + 8 >> 2] | HEAP32[$4 + 8 >> 2] << 4;
 HEAP8[$4 + 1 | 0] = HEAP32[$4 + 4 >> 2] | HEAP32[$4 + 8 >> 2] << 4;
 HEAP8[$4 + 2 | 0] = HEAP32[$4 + 8 >> 2] | HEAP32[$4 + 4 >> 2] << 4;
 HEAP8[$4 + 3 | 0] = HEAP32[$4 + 4 >> 2] | HEAP32[$4 + 4 >> 2] << 4;
 jshSPISend16(HEAPU8[$4 + 15 | 0], HEAPU8[(HEAPU8[$4 + 14 | 0] >>> 4 & 3) + $4 | 0] | HEAPU8[(HEAPU8[$4 + 14 | 0] >>> 6 | 0) + $4 | 0] << 8);
 jshSPISend16(HEAPU8[$4 + 15 | 0], HEAPU8[(HEAPU8[$4 + 14 | 0] & 3) + $4 | 0] | HEAPU8[(HEAPU8[$4 + 14 | 0] >>> 2 & 3) + $4 | 0] << 8);
 __stack_pointer = $4 + 16 | 0;
}

function jswrap_banglejs_lcdWr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 $2 = $3;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP32[$2 >> 2] = jsvGetDataPointer(HEAP32[$2 + 8 >> 2], $2 + 4 | 0);
 if (!(HEAP32[$2 >> 2] | !HEAP32[$2 + 8 >> 2])) {
  HEAP32[$2 + 4 >> 2] = jsvIterateCallbackCount(HEAP32[$2 + 8 >> 2]);
  label$2: {
   if (HEAP32[$2 + 4 >> 2] + 256 >>> 0 > jsuGetFreeStack() >>> 0) {
    jsExceptionHere(1, 135807, 0);
    break label$2;
   }
   $3 = $3 - (HEAP32[$2 + 4 >> 2] + 15 & -16) | 0;
   __stack_pointer = $3;
   HEAP32[$2 >> 2] = $3;
   jsvIterateCallbackToBytes(HEAP32[$2 + 8 >> 2], HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
  }
 }
 __stack_pointer = $2 + 16 | 0;
}

function jsiDumpJSON($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = jsvGetIndexOf(HEAP32[91086], HEAP32[$4 + 20 >> 2], 1);
 label$1: {
  label$2: {
   if (!HEAP32[$4 + 12 >> 2]) {
    break label$2;
   }
   if (!(jsvIsString(HEAP32[$4 + 12 >> 2]) & 1) | HEAP32[$4 + 12 >> 2] == HEAP32[$4 + 16 >> 2]) {
    break label$2;
   }
   $0 = HEAP32[$4 + 28 >> 2];
   $1 = HEAP32[$4 + 24 >> 2];
   HEAP32[$4 >> 2] = HEAP32[$4 + 12 >> 2];
   cbprintf($0, $1, 116903, $4);
   break label$1;
  }
  jsfGetJSONWithCallback(HEAP32[$4 + 20 >> 2], 0, 37, 0, HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2]);
 }
 __stack_pointer = $4 + 32 | 0;
}

function tflite__PreprocessSoftmaxScaling_28double_2c_20double_2c_20int_2c_20int__2c_20int__29($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer + -64 | 0;
 __stack_pointer = $5;
 HEAPF64[$5 + 56 >> 3] = $0;
 HEAPF64[$5 + 48 >> 3] = $1;
 HEAP32[$5 + 44 >> 2] = $2;
 HEAP32[$5 + 40 >> 2] = $3;
 HEAP32[$5 + 36 >> 2] = $4;
 HEAPF64[$5 + 16 >> 3] = HEAPF64[$5 + 56 >> 3] * HEAPF64[$5 + 48 >> 3] * +(1 << 31 - HEAP32[$5 + 44 >> 2]);
 HEAPF64[$5 + 8 >> 3] = 2147483647;
 HEAPF64[$5 + 24 >> 3] = HEAPF64[double_20const__20std____2__min_double__28double_20const__2c_20double_20const__29($5 + 16 | 0, $5 + 8 | 0) >> 3];
 tflite__QuantizeMultiplierGreaterThanOne_28double_2c_20int__2c_20int__29(HEAPF64[$5 + 24 >> 3], HEAP32[$5 + 40 >> 2], HEAP32[$5 + 36 >> 2]);
 __stack_pointer = $5 - -64 | 0;
}

function jswrap_banglejs_setLCDTimeout($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 24 >> 3] = $0;
 __DOUBLE_BITS_2(HEAPF64[$1 + 24 >> 3]);
 $2 = i64toi32_i32$HIGH_BITS & 2147483647;
 label$1: {
  if (($2 | 0) == 2146435072 | $2 >>> 0 > 2146435072) {
   HEAPF64[$1 + 24 >> 3] = 0;
   break label$1;
  }
  if (HEAPF64[$1 + 24 >> 3] < 0) {
   HEAPF64[$1 + 24 >> 3] = 0;
  }
 }
 $0 = HEAPF64[$1 + 24 >> 3] * 1e3;
 label$4: {
  if (Math_abs($0) < 2147483648) {
   $2 = ~~$0;
   break label$4;
  }
  $2 = -2147483648;
 }
 HEAP32[97753] = $2;
 $0 = HEAPF64[$1 + 24 >> 3] * 1e3;
 label$6: {
  if (Math_abs($0) < 2147483648) {
   $2 = ~~$0;
   break label$6;
  }
  $2 = -2147483648;
 }
 HEAP32[97754] = $2;
 __stack_pointer = $1 + 32 | 0;
}

function jsvSetNextSibling($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = $2;
 $3 = HEAPU16[$0 + 10 >> 1];
 $0 = $3;
 $4 = $0 & 16383;
 $2 = HEAP32[$2 + 12 >> 2];
 $1 = $2;
 $3 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
 $0 = HEAPU8[$1 + 8 | 0] | HEAPU8[$1 + 9 | 0] << 8 | (HEAPU8[$1 + 10 | 0] << 16 | HEAPU8[$1 + 11 | 0] << 24);
 $1 = $3;
 $3 = $0;
 $0 = $4;
 $1 = $1 & -16384 | $0;
 $0 = $2;
 HEAP8[$0 + 4 | 0] = $1;
 HEAP8[$0 + 5 | 0] = $1 >>> 8;
 HEAP8[$0 + 6 | 0] = $1 >>> 16;
 HEAP8[$0 + 7 | 0] = $1 >>> 24;
 $1 = $3;
 HEAP8[$0 + 8 | 0] = $1;
 HEAP8[$0 + 9 | 0] = $1 >>> 8;
 HEAP8[$0 + 10 | 0] = $1 >>> 16;
 HEAP8[$0 + 11 | 0] = $1 >>> 24;
}

function jspeSkipBlock() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = 1;
 HEAP32[$0 + 8 >> 2] = HEAP32[91094];
 HEAP32[91094] = HEAP32[91094] & -64;
 while (1) {
  $1 = 0;
  label$3: {
   $1 = HEAP16[HEAP32[49079] + 2 >> 1] ? HEAP32[$0 + 12 >> 2] != 0 : $1;
   if (!$1) {
    break label$3;
   }
   label$4: {
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 123) {
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
     break label$4;
    }
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 125) {
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] - 1;
     if (!HEAP32[$0 + 12 >> 2]) {
      break label$3;
     }
    }
   }
   jslGetNextToken();
   continue;
  }
  break;
 }
 HEAP32[91094] = HEAP32[$0 + 8 >> 2];
 __stack_pointer = $0 + 16 | 0;
}

function jslCheckToken($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP16[$2 + 6 >> 1] = $1;
 HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] - 1;
 HEAP32[$2 >> 2] = 1;
 label$1: {
  while (1) {
   if (HEAP32[$2 >> 2] < HEAPU8[HEAP32[49079] + 80 | 0]) {
    if (HEAP8[HEAP32[$2 >> 2] + (HEAP32[49079] + 12 | 0) | 0] != HEAP8[HEAP32[$2 + 8 >> 2] + HEAP32[$2 >> 2] | 0]) {
     HEAP8[$2 + 15 | 0] = 0;
     break label$1;
    } else {
     HEAP32[$2 >> 2] = HEAP32[$2 >> 2] + 1;
     continue;
    }
   }
   break;
  }
  if (!HEAP8[HEAP32[$2 + 8 >> 2] + HEAPU8[HEAP32[49079] + 80 | 0] | 0]) {
   HEAP16[HEAP32[49079] + 2 >> 1] = HEAPU16[$2 + 6 >> 1];
   HEAP8[$2 + 15 | 0] = 1;
   break label$1;
  }
  HEAP8[$2 + 15 | 0] = 0;
 }
 return HEAP8[$2 + 15 | 0] & 1;
}

function graphicsGetVectorChar($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 $7 = __stack_pointer - 48 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 40 >> 2] = $0;
 HEAP32[$7 + 36 >> 2] = $1;
 HEAP32[$7 + 32 >> 2] = $2;
 HEAP32[$7 + 28 >> 2] = $3;
 HEAP32[$7 + 24 >> 2] = $4;
 HEAP32[$7 + 20 >> 2] = $5;
 HEAP8[$7 + 19 | 0] = $6;
 HEAP32[$7 + 8 >> 2] = vfGetCharPtr(HEAP8[$7 + 19 | 0], $7 + 12 | 0);
 label$1: {
  if (!HEAP32[$7 + 8 >> 2]) {
   HEAP32[$7 + 44 >> 2] = HEAP32[$7 + 24 >> 2] / 2;
   break label$1;
  }
  HEAP32[$7 + 44 >> 2] = vfGetCharFromPtr(HEAP32[$7 + 40 >> 2], HEAP32[$7 + 36 >> 2], HEAP32[$7 + 32 >> 2], HEAP32[$7 + 28 >> 2], HEAP32[$7 + 24 >> 2], HEAP32[$7 + 20 >> 2], HEAP32[$7 + 8 >> 2], HEAP32[$7 + 12 >> 2]);
 }
 __stack_pointer = $7 + 48 | 0;
 return HEAP32[$7 + 44 >> 2];
}

function jsfGetSpaceLeftInPage($0) {
 var $1 = 0;
 $1 = __stack_pointer + -64 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 56 >> 2] = $0;
 label$1: {
  if (!(jshFlashGetPage(HEAP32[$1 + 56 >> 2], $1 + 52 | 0, $1 + 48 | 0) & 1)) {
   HEAP32[$1 + 60 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 44 >> 2] = jsfGetBankEndAddress(HEAP32[$1 + 56 >> 2]);
  HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 52 >> 2] + HEAP32[$1 + 48 >> 2];
  label$3: {
   if (HEAPU32[$1 + 40 >> 2] >= HEAPU32[$1 + 44 >> 2]) {
    break label$3;
   }
   if (jsfGetFileHeader(HEAP32[$1 + 40 >> 2], $1 + 8 | 0, 0) & 1) {
    break label$3;
   }
   HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 44 >> 2];
  }
  HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 40 >> 2] - HEAP32[$1 + 56 >> 2];
 }
 __stack_pointer = $1 - -64 | 0;
 return HEAP32[$1 + 60 >> 2];
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph___20const___28unsigned_20short_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 8 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 HEAP32[$2 + 4 >> 2] = HEAPU16[$2 + 8 >> 1] + $0;
 label$1: {
  if (HEAPU16[$2 + 8 >> 1]) {
   $0 = HEAP32[$2 + 4 >> 2] + unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 4 >> 2]) | 0;
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Operator___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Operator___20const___28unsigned_20short_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 8 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 HEAP32[$2 + 4 >> 2] = HEAPU16[$2 + 8 >> 1] + $0;
 label$1: {
  if (HEAPU16[$2 + 8 >> 1]) {
   $0 = HEAP32[$2 + 4 >> 2] + unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 4 >> 2]) | 0;
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Metadata___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Metadata___20const___28unsigned_20short_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 8 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 HEAP32[$2 + 4 >> 2] = HEAPU16[$2 + 8 >> 1] + $0;
 label$1: {
  if (HEAPU16[$2 + 8 >> 1]) {
   $0 = HEAP32[$2 + 4 >> 2] + unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 4 >> 2]) | 0;
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jspGetException() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = jsvFindChildFromString(HEAP32[91087], 117353);
 label$1: {
  if (HEAP32[$0 + 8 >> 2]) {
   HEAP32[$0 + 4 >> 2] = jsvSkipName(HEAP32[$0 + 8 >> 2]);
   jsvRemoveChildAndUnLock(HEAP32[91087], HEAP32[$0 + 8 >> 2]);
   HEAP32[$0 >> 2] = jspGetStackTrace();
   label$3: {
    if (!HEAP32[$0 >> 2]) {
     break label$3;
    }
    if (!(jsvHasChildren(HEAP32[$0 + 4 >> 2]) & 1)) {
     break label$3;
    }
    jsvObjectSetChild(HEAP32[$0 + 4 >> 2], 129121, HEAP32[$0 >> 2]);
   }
   jsvUnLock(HEAP32[$0 >> 2]);
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2];
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = 0;
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor___20const___28unsigned_20short_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 8 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 HEAP32[$2 + 4 >> 2] = HEAPU16[$2 + 8 >> 1] + $0;
 label$1: {
  if (HEAPU16[$2 + 8 >> 1]) {
   $0 = HEAP32[$2 + 4 >> 2] + unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 4 >> 2]) | 0;
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer___20const___28unsigned_20short_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 8 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 HEAP32[$2 + 4 >> 2] = HEAPU16[$2 + 8 >> 1] + $0;
 label$1: {
  if (HEAPU16[$2 + 8 >> 1]) {
   $0 = HEAP32[$2 + 4 >> 2] + unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 4 >> 2]) | 0;
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function lcdFillRect_ArrayBuffer_flat($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = __stack_pointer - 32 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $5;
 HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 20 >> 2];
 while (1) {
  if (HEAP32[$6 + 4 >> 2] <= HEAP32[$6 + 12 >> 2]) {
   lcdSetPixels_ArrayBuffer_flat(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 4 >> 2], (HEAP32[$6 + 16 >> 2] + 1 | 0) - HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 8 >> 2]);
   HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $6 + 32 | 0;
}

function jswrap_serial_isConnected($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP8[$1 + 7 | 0] = jsiGetDeviceFromClass(HEAP32[$1 + 8 >> 2]);
 label$1: {
  if (!(HEAPU8[$1 + 7 | 0] != 17 & HEAPU8[$1 + 7 | 0] != 18)) {
   HEAP8[$1 + 15 | 0] = 1;
   break label$1;
  }
  if (HEAPU8[$1 + 7 | 0] == 20) {
   HEAP8[$1 + 15 | 0] = 1;
   break label$1;
  }
  if (HEAPU8[$1 + 7 | 0] == 21) {
   HEAP8[$1 + 15 | 0] = jshIsUSBSERIALConnected() & 1;
   break label$1;
  }
  if (!(HEAPU8[$1 + 7 | 0] < 22 | HEAPU8[$1 + 7 | 0] > 22)) {
   HEAP8[$1 + 15 | 0] = jshIsDeviceInitialised(HEAPU8[$1 + 7 | 0]) & 1;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}

function jslGetTokenString($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1: {
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 128) {
   $0 = HEAP32[$2 + 28 >> 2];
   $1 = HEAP32[$2 + 24 >> 2];
   HEAP32[$2 >> 2] = jslGetTokenValueAsString();
   espruino_snprintf($0, $1, 120506, $2);
   break label$1;
  }
  label$3: {
   if (HEAP16[HEAP32[49079] + 2 >> 1] == 131) {
    $0 = HEAP32[$2 + 28 >> 2];
    $1 = HEAP32[$2 + 24 >> 2];
    HEAP32[$2 + 16 >> 2] = jslGetTokenValueAsString();
    espruino_snprintf($0, $1, 145283, $2 + 16 | 0);
    break label$3;
   }
   jslTokenAsString(HEAP16[HEAP32[49079] + 2 >> 1], HEAP32[$2 + 28 >> 2], HEAP32[$2 + 24 >> 2]);
  }
 }
 __stack_pointer = $2 + 32 | 0;
}

function tflite__MicroMutableOpResolver_9u___GetOpDataParser_28tflite__BuiltinOperator_29_20const($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 $0 = HEAP32[$2 + 8 >> 2];
 label$1: {
  if (HEAPU32[$0 + 368 >> 2] > 9) {
   break label$1;
  }
 }
 HEAP32[$2 >> 2] = 0;
 label$2: {
  while (1) {
   if (HEAPU32[$2 >> 2] < HEAPU32[$0 + 368 >> 2]) {
    if (HEAP32[($0 + 296 | 0) + (HEAP32[$2 >> 2] << 2) >> 2] == HEAP32[$2 + 4 >> 2]) {
     HEAP32[$2 + 12 >> 2] = HEAP32[($0 + 332 | 0) + (HEAP32[$2 >> 2] << 2) >> 2];
     break label$2;
    } else {
     HEAP32[$2 >> 2] = HEAP32[$2 >> 2] + 1;
     continue;
    }
   }
   break;
  }
  HEAP32[$2 + 12 >> 2] = 0;
 }
 return HEAP32[$2 + 12 >> 2];
}

function st_backref_index_lsb($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP8[$1 + 7 | 0] = 8;
 $2 = HEAP32[$1 + 8 >> 2];
 if (HEAPU8[$1 + 7 | 0] < 8) {
  $0 = HEAPU8[$1 + 7 | 0];
 } else {
  $0 = 8;
 }
 HEAP16[$1 + 4 >> 1] = get_bits($2, $0);
 label$3: {
  if (HEAPU16[$1 + 4 >> 1] == 65535) {
   HEAP32[$1 + 12 >> 2] = 3;
   break label$3;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP16[$0 + 6 >> 1] = HEAPU16[$1 + 4 >> 1] | HEAPU16[$0 + 6 >> 1];
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP16[$0 + 6 >> 1] = HEAPU16[$0 + 6 >> 1] + 1;
  HEAP8[$1 + 3 | 0] = 6;
  HEAP16[HEAP32[$1 + 8 >> 2] + 4 >> 1] = 0;
  HEAP32[$1 + 12 >> 2] = HEAPU8[$1 + 3 | 0] > 8 ? 4 : 5;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jshGetDeviceObjectFor($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP16[$3 + 42 >> 1] = $0;
 HEAP16[$3 + 40 >> 1] = $1;
 HEAP8[$3 + 39 | 0] = $2;
 HEAP16[$3 + 36 >> 1] = jshGetDeviceFor(HEAPU16[$3 + 42 >> 1], HEAPU16[$3 + 40 >> 1], HEAPU8[$3 + 39 | 0]);
 label$1: {
  if (!HEAPU16[$3 + 36 >> 1]) {
   HEAP32[$3 + 44 >> 2] = 0;
   break label$1;
  }
  jshPinFunctionToString(HEAPU16[$3 + 36 >> 1], 19, $3 + 16 | 0, 16);
  HEAP32[$3 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[91086], $3 + 16 | 0);
  if (HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 44 >> 2] = HEAP32[$3 + 12 >> 2];
   break label$1;
  }
  HEAP32[$3 + 44 >> 2] = jswFindBuiltInFunction(0, $3 + 16 | 0);
 }
 __stack_pointer = $3 + 48 | 0;
 return HEAP32[$3 + 44 >> 2];
}

function specialcase($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 if (!(0 | $3 & -2147483648)) {
  wasm2js_scratch_store_i32(0, $1 | 0);
  $1 = $2;
  wasm2js_scratch_store_i32(1, $1 - 1058013184 | 0);
  $5 = +wasm2js_scratch_load_f64();
  return ($5 * $0 + $5) * 5486124068793689e288;
 }
 $3 = __stack_pointer - 16 | 0;
 wasm2js_scratch_store_i32(0, $1 | 0);
 wasm2js_scratch_store_i32(1, $2 + 1071644672 | 0);
 $5 = +wasm2js_scratch_load_f64();
 $6 = $5 * $0;
 $0 = $6 + $5;
 if ($0 < 1) {
  $1 = $3;
  HEAP32[$1 + 8 >> 2] = 0;
  HEAP32[$1 + 12 >> 2] = 1048576;
  HEAPF64[$1 + 8 >> 3] = HEAPF64[$1 + 8 >> 3] * 22250738585072014e-324;
  $7 = $0 + 1;
  $0 = $7 + ($6 + ($5 - $0) + ($0 + (1 - $7))) + -1;
  $0 = $0 == 0 ? 0 : $0;
 }
 return $0 * 22250738585072014e-324;
}

function lcdFillRect_ArrayBuffer($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = __stack_pointer - 32 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $5;
 HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 20 >> 2];
 while (1) {
  if (HEAP32[$6 + 4 >> 2] <= HEAP32[$6 + 12 >> 2]) {
   lcdSetPixels_ArrayBuffer(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 4 >> 2], (HEAP32[$6 + 16 >> 2] + 1 | 0) - HEAP32[$6 + 24 >> 2] | 0, HEAP32[$6 + 8 >> 2]);
   HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $6 + 32 | 0;
}

function tflite___28anonymous_20namespace_29__GetMutableInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 8 >> 2] = $0;
 HEAP32[$3 + 4 >> 2] = $1;
 HEAP32[$3 >> 2] = $2;
 label$1: {
  if (HEAP32[HEAP32[$3 + 8 >> 2] + 8 >> 2]) {
   HEAP32[$3 + 12 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 8 >> 2] + Math_imul(HEAP32[(HEAP32[HEAP32[$3 + 4 >> 2] >> 2] + 4 | 0) + (HEAP32[$3 >> 2] << 2) >> 2], 40);
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 8 >> 2] + 80 >> 2]](HEAP32[$3 + 8 >> 2], HEAP32[(HEAP32[HEAP32[$3 + 4 >> 2] >> 2] + 4 | 0) + (HEAP32[$3 >> 2] << 2) >> 2]);
 }
 __stack_pointer = $3 + 16 | 0;
 return HEAP32[$3 + 12 >> 2];
}

function jswrap_crypto_error_to_str($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      $0 = HEAP32[$1 + 8 >> 2];
      if (($0 | 0) != -20864) {
       if (($0 | 0) == -20736) {
        break label$4;
       }
       if (($0 | 0) == -20608) {
        break label$5;
       }
       if (($0 | 0) == -15) {
        break label$3;
       }
       break label$2;
      }
      HEAP32[$1 + 12 >> 2] = 116136;
      break label$1;
     }
     HEAP32[$1 + 12 >> 2] = 132578;
     break label$1;
    }
    HEAP32[$1 + 12 >> 2] = 135751;
    break label$1;
   }
   HEAP32[$1 + 12 >> 2] = 134005;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 return HEAP32[$1 + 12 >> 2];
}

function _jswrap_promise_queue_reaction($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 44 >> 2] = $0;
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 36 >> 2] = $2;
 HEAP8[$4 + 35 | 0] = $3;
 HEAP32[$4 + 28 >> 2] = jsvNewNativeFunction(656, 33352);
 if (HEAP32[$4 + 28 >> 2]) {
  jsvObjectSetChild(HEAP32[$4 + 28 >> 2], 120157, HEAP32[$4 + 44 >> 2]);
  HEAP32[$4 + 24 >> 2] = jsvNewFromBool(HEAP8[$4 + 35 | 0] & 1);
  HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 40 >> 2];
  HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 36 >> 2];
  HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 24 >> 2];
  jsiQueueEvents(HEAP32[$4 + 44 >> 2], HEAP32[$4 + 28 >> 2], $4 + 12 | 0, 3);
  jsvUnLock2(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2]);
 }
 __stack_pointer = $4 + 48 | 0;
}

function jsvNewArrayBufferFromString($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 >> 2] = jsvNewWithFlags(4);
 label$1: {
  if (!HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  jsvSetFirstChild(HEAP32[$2 >> 2], jsvGetRef(jsvRef(HEAP32[$2 + 8 >> 2])) & 65535);
  HEAP8[HEAP32[$2 >> 2] + 5 | 0] = 129;
  if (!HEAP32[$2 + 4 >> 2]) {
   HEAP32[$2 + 4 >> 2] = jsvGetStringLength(HEAP32[$2 + 8 >> 2]);
  }
  $0 = HEAP32[$2 >> 2];
  $1 = HEAP32[$2 + 4 >> 2];
  HEAP8[$0 + 2 | 0] = $1;
  HEAP8[$0 + 3 | 0] = $1 >>> 8;
  HEAP8[$0 + 4 | 0] = $1 >>> 16;
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jstBufferTaskChecker($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (!(HEAPU8[HEAP32[$2 + 8 >> 2] + 24 | 0] == 4 | HEAPU8[HEAP32[$2 + 8 >> 2] + 24 | 0] == 5 | (HEAPU8[HEAP32[$2 + 8 >> 2] + 24 | 0] == 6 | HEAPU8[HEAP32[$2 + 8 >> 2] + 24 | 0] == 7))) {
   HEAP8[$2 + 15 | 0] = 0;
   break label$1;
  }
  HEAP16[$2 + 2 >> 1] = HEAPU16[HEAP32[$2 + 4 >> 2] >> 1];
  $0 = 1;
  $1 = HEAP32[$2 + 8 >> 2];
  if (HEAPU16[$2 + 2 >> 1] != (HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8)) {
   $0 = HEAP32[$2 + 8 >> 2];
   $0 = HEAPU16[$2 + 2 >> 1] == (HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8);
  }
  HEAP8[$2 + 15 | 0] = $0;
 }
 return HEAP8[$2 + 15 | 0] & 1;
}

function jshPushEvent($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jshInterruptOff();
 HEAP8[$1 + 11 | 0] = HEAPU8[364486] + 1;
 label$1: {
  if (HEAPU8[364487] == HEAPU8[$1 + 11 | 0]) {
   jshInterruptOn();
   jshIOEventOverflowed();
   break label$1;
  }
  $0 = Math_imul(HEAPU8[364486], 5) + 365072 | 0;
  $2 = HEAP32[$1 + 12 >> 2];
  $3 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
  HEAP8[$0 | 0] = $3;
  HEAP8[$0 + 1 | 0] = $3 >>> 8;
  HEAP8[$0 + 2 | 0] = $3 >>> 16;
  HEAP8[$0 + 3 | 0] = $3 >>> 24;
  HEAP8[$0 + 4 | 0] = HEAPU8[$2 + 4 | 0];
  HEAP8[364486] = HEAPU8[$1 + 11 | 0];
  jshInterruptOn();
 }
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_pipe_idle() {
 var $0 = 0;
 $0 = __stack_pointer - 32 | 0;
 __stack_pointer = $0;
 HEAP8[$0 + 31 | 0] = 0;
 HEAP32[$0 + 24 >> 2] = pipeGetArray(0);
 if (HEAP32[$0 + 24 >> 2]) {
  jsvObjectIteratorNew($0 + 16 | 0, HEAP32[$0 + 24 >> 2]);
  while (1) {
   if (jsvObjectIteratorHasValue_16($0 + 16 | 0) & 1) {
    HEAP32[$0 + 12 >> 2] = jsvObjectIteratorGetValue_15($0 + 16 | 0);
    HEAP8[$0 + 31 | 0] = handlePipe(HEAP32[$0 + 24 >> 2], $0 + 16 | 0, HEAP32[$0 + 12 >> 2]) & 1 | HEAP8[$0 + 31 | 0] & 1;
    jsvUnLock(HEAP32[$0 + 12 >> 2]);
    jsvObjectIteratorNext($0 + 16 | 0);
    continue;
   }
   break;
  }
  jsvObjectIteratorFree_16($0 + 16 | 0);
  jsvUnLock(HEAP32[$0 + 24 >> 2]);
 }
 __stack_pointer = $0 + 32 | 0;
 return HEAP8[$0 + 31 | 0] & 1;
}

function jsvArrayBufferIteratorGetIntegerValue($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAPU8[HEAP32[$1 + 8 >> 2] + 36 | 0]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  jsvArrayBufferIteratorGetValueData(HEAP32[$1 + 8 >> 2], $1);
  if (HEAPU8[HEAP32[$1 + 8 >> 2] + 36 | 0] & 32) {
   $2 = jsvArrayBufferIteratorDataToFloat(HEAP32[$1 + 8 >> 2], $1);
   label$4: {
    if (Math_abs($2) < 2147483648) {
     $0 = ~~$2;
     break label$4;
    }
    $0 = -2147483648;
   }
   HEAP32[$1 + 12 >> 2] = $0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvArrayBufferIteratorDataToInt(HEAP32[$1 + 8 >> 2], $1);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function tflite__MicroAllocator__GetScratchBuffer_28int_29_20const($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 $0 = HEAP32[$2 + 24 >> 2];
 label$1: {
  if (HEAPU32[$2 + 20 >> 2] >= HEAPU32[$0 + 20 >> 2]) {
   $1 = HEAP32[$0 + 8 >> 2];
   $3 = HEAP32[$2 + 20 >> 2];
   HEAP32[$2 + 4 >> 2] = HEAP32[$0 + 20 >> 2];
   HEAP32[$2 >> 2] = $3;
   tflite__ErrorReporter__Report_28char_20const__2c_20____29($1, 140603, $2);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[HEAP32[$0 + 16 >> 2] + Math_imul((HEAP32[$0 + 20 >> 2] - HEAP32[$2 + 20 >> 2] | 0) - 1 | 0, 12) >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jshGetSerialNumber($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 32 | 0;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = -559030611;
 HEAP32[$2 + 12 >> 2] = -559030611;
 $1 = HEAP32[$2 + 28 >> 2];
 $0 = HEAP32[$2 + 20 >> 2];
 HEAP8[$1 | 0] = $0;
 HEAP8[$1 + 1 | 0] = $0 >>> 8;
 HEAP8[$1 + 2 | 0] = $0 >>> 16;
 HEAP8[$1 + 3 | 0] = $0 >>> 24;
 $1 = HEAP32[$2 + 12 >> 2];
 $3 = HEAP32[$2 + 8 >> 2];
 $0 = $3;
 $3 = HEAP32[$2 + 28 >> 2];
 HEAP8[$3 + 4 | 0] = $0;
 HEAP8[$3 + 5 | 0] = $0 >>> 8;
 HEAP8[$3 + 6 | 0] = $0 >>> 16;
 HEAP8[$3 + 7 | 0] = $0 >>> 24;
 HEAP8[$3 + 8 | 0] = $1;
 HEAP8[$3 + 9 | 0] = $1 >>> 8;
 HEAP8[$3 + 10 | 0] = $1 >>> 16;
 HEAP8[$3 + 11 | 0] = $1 >>> 24;
 return 12;
}

function _jswrap_serial_print($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP8[$4 + 23 | 0] = $2;
 HEAP8[$4 + 22 | 0] = $3;
 label$1: {
  if (!(jsserialGetSendFunction(HEAP32[$4 + 28 >> 2], $4 + 16 | 0, $4) & 1)) {
   break label$1;
  }
  if (HEAP8[$4 + 23 | 0] & 1) {
   HEAP32[$4 + 24 >> 2] = jsvAsString(HEAP32[$4 + 24 >> 2]);
  }
  jsvIterateCallback(HEAP32[$4 + 24 >> 2], HEAP32[$4 + 16 >> 2], $4);
  if (HEAP8[$4 + 23 | 0] & 1) {
   jsvUnLock(HEAP32[$4 + 24 >> 2]);
  }
  if (!(HEAP8[$4 + 22 | 0] & 1)) {
   break label$1;
  }
  FUNCTION_TABLE[HEAP32[$4 + 16 >> 2]](13, $4);
  FUNCTION_TABLE[HEAP32[$4 + 16 >> 2]](10, $4);
 }
 __stack_pointer = $4 + 32 | 0;
}

function jsvObjectAppendAll($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 jsvObjectIteratorNew($2 + 16 | 0, HEAP32[$2 + 24 >> 2]);
 while (1) {
  if (jsvObjectIteratorHasValue($2 + 16 | 0) & 1) {
   HEAP32[$2 + 12 >> 2] = jsvObjectIteratorGetKey($2 + 16 | 0);
   HEAP32[$2 + 8 >> 2] = jsvSkipName(HEAP32[$2 + 12 >> 2]);
   if (!(jsvIsInternalObjectKey(HEAP32[$2 + 12 >> 2]) & 1)) {
    jsvObjectSetChildVar(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
   }
   jsvUnLock2(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
   jsvObjectIteratorNext($2 + 16 | 0);
   continue;
  }
  break;
 }
 jsvObjectIteratorFree($2 + 16 | 0);
 __stack_pointer = $2 + 32 | 0;
}

function jsvCreateNewChild($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = jsvAsName(HEAP32[$3 + 20 >> 2]);
 label$1: {
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$3 + 16 >> 2]) {
   jsvSetValueOfName(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2]);
  }
  HEAP16[$3 + 10 >> 1] = jsvGetRef(jsvRef(jsvRef(HEAP32[$3 + 24 >> 2])));
  jsvSetNextSibling(HEAP32[$3 + 12 >> 2], HEAPU16[$3 + 10 >> 1]);
  jsvSetPrevSibling(HEAP32[$3 + 12 >> 2], HEAPU16[$3 + 10 >> 1]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jspEvaluate($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP8[$2 + 23 | 0] = $1;
 label$1: {
  if (HEAP8[$2 + 23 | 0] & 1) {
   HEAP32[$2 + 16 >> 2] = jsvNewNativeString(HEAP32[$2 + 24 >> 2], strlen(HEAP32[$2 + 24 >> 2]));
   break label$1;
  }
  HEAP32[$2 + 16 >> 2] = jsvNewFromString(HEAP32[$2 + 24 >> 2]);
 }
 label$3: {
  if (!HEAP32[$2 + 16 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$3;
  }
  HEAP32[$2 + 12 >> 2] = 0;
  if (!(jsvIsMemoryFull() & 1)) {
   HEAP32[$2 + 12 >> 2] = jspEvaluateVar(HEAP32[$2 + 16 >> 2], 0, 0);
  }
  jsvUnLock(HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jslNeedSpaceBetween($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 label$1: {
  if (HEAPU8[$2 + 15 | 0] < 163) {
   $0 = 0;
   if (HEAPU8[$2 + 14 | 0] < 163) {
    break label$1;
   }
  }
  label$3: {
   if (HEAPU8[$2 + 15 | 0] >= 163) {
    break label$3;
   }
   if (isAlpha(HEAP8[$2 + 15 | 0]) & 1) {
    break label$3;
   }
   $0 = 0;
   if (!(isNumeric(HEAP8[$2 + 15 | 0]) & 1)) {
    break label$1;
   }
  }
  $0 = 1;
  label$4: {
   if (HEAPU8[$2 + 14 | 0] >= 163) {
    break label$4;
   }
   $0 = 1;
   if (isAlpha(HEAP8[$2 + 14 | 0]) & 1) {
    break label$4;
   }
   $0 = isNumeric(HEAP8[$2 + 14 | 0]);
  }
 }
 __stack_pointer = $2 + 16 | 0;
 return $0 & 1;
}

function jswrap_modules_removeCached($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (!(jsvIsString(HEAP32[$1 + 12 >> 2]) & 1)) {
   jsExceptionHere(1, 129842, 0);
   break label$1;
  }
  HEAP32[$1 + 8 >> 2] = jswrap_modules_getModuleList();
  if (!HEAP32[$1 + 8 >> 2]) {
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = jsvFindChildFromVar(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2], 0);
  label$3: {
   if (!HEAP32[$1 + 4 >> 2]) {
    HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
    jsExceptionHere(1, 133209, $1);
    break label$3;
   }
   jsvRemoveChildAndUnLock(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2]);
  }
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_date_toISOString($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $1 = __stack_pointer - 96 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 92 >> 2] = $0;
 getTimeFromDateVar($1 - -64 | 0, HEAP32[$1 + 92 >> 2], 1);
 getCalendarDate($1 + 40 | 0, HEAP32[$1 + 64 >> 2]);
 $0 = HEAP32[$1 + 52 >> 2];
 $2 = HEAP32[$1 + 48 >> 2];
 $3 = HEAP32[$1 + 44 >> 2];
 $4 = HEAP32[$1 + 80 >> 2];
 $5 = HEAP32[$1 + 76 >> 2];
 $6 = HEAP32[$1 + 72 >> 2];
 HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 68 >> 2];
 HEAP32[$1 + 20 >> 2] = $6;
 HEAP32[$1 + 16 >> 2] = $5;
 HEAP32[$1 + 12 >> 2] = $4;
 HEAP32[$1 + 8 >> 2] = $3;
 HEAP32[$1 + 4 >> 2] = $2 + 1;
 HEAP32[$1 >> 2] = $0;
 $0 = jsvVarPrintf(136269, $1);
 __stack_pointer = $1 + 96 | 0;
 return $0 | 0;
}

function jsvCountJsVarsUsed($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (!(!HEAP32[91086] | HEAP32[$1 + 12 >> 2] == HEAP32[91086])) {
  $0 = HEAP32[91086];
  $2 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8 | 512;
  HEAP8[$0 + 12 | 0] = $2;
  HEAP8[$0 + 13 | 0] = $2 >>> 8;
 }
 HEAP32[$1 + 8 >> 2] = _jsvCountJsVarsUsedRecursive(HEAP32[$1 + 12 >> 2], 0);
 _jsvCountJsVarsUsedRecursive(HEAP32[$1 + 12 >> 2], 1);
 if (!(!HEAP32[91086] | HEAP32[$1 + 12 >> 2] == HEAP32[91086])) {
  $0 = HEAP32[91086];
  $2 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & -513;
  HEAP8[$0 + 12 | 0] = $2;
  HEAP8[$0 + 13 | 0] = $2 >>> 8;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jswrap_string_substr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 if (jsvIsUndefined(HEAP32[$3 + 4 >> 2]) & 1) {
  $0 = 2147483647;
 } else {
  $0 = jsvGetInteger(HEAP32[$3 + 4 >> 2]);
 }
 HEAP32[$3 >> 2] = $0;
 if (HEAP32[$3 >> 2] < 0) {
  HEAP32[$3 >> 2] = 0;
 }
 if (HEAP32[$3 + 8 >> 2] < 0) {
  HEAP32[$3 + 8 >> 2] = jsvGetStringLength(HEAP32[$3 + 12 >> 2]) + HEAP32[$3 + 8 >> 2];
 }
 if (HEAP32[$3 + 8 >> 2] < 0) {
  HEAP32[$3 + 8 >> 2] = 0;
 }
 $0 = jsvNewFromStringVar(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function jsvGetValueOf($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
   HEAP32[$1 + 12 >> 2] = jsvLockAgainSafe(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = jspGetNamedField(HEAP32[$1 + 8 >> 2], 130171, 0);
  if (!(jsvIsFunction(HEAP32[$1 + 4 >> 2]) & 1)) {
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 8 >> 2] = jspeFunctionCall(HEAP32[$1 + 4 >> 2], 0, HEAP32[$1 + 8 >> 2], 0, 0, 0);
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2];
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_storage_list($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = 0;
 if (jsvIsObject(HEAP32[$2 + 24 >> 2]) & 1) {
  HEAP32[$2 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 24 >> 2], 130091);
  if (HEAP32[$2 + 12 >> 2]) {
   label$3: {
    if (jsvGetBoolAndUnLock(HEAP32[$2 + 12 >> 2]) & 1) {
     HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] | 64;
     break label$3;
    }
    HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] | 64;
   }
  }
 }
 $0 = jsfListFiles(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
 __stack_pointer = $2 + 32 | 0;
 return $0 | 0;
}

function jsiConsolePrintStringVarWithNewLineChar($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 HEAP8[$3 + 55 | 0] = $2;
 jsvStringIteratorNew($3 + 16 | 0, HEAP32[$3 + 60 >> 2], HEAP32[$3 + 56 >> 2]);
 while (1) {
  if (jsvStringIteratorHasChar_5($3 + 16 | 0) & 1) {
   HEAP8[$3 + 15 | 0] = jsvStringIteratorGetCharAndNext($3 + 16 | 0);
   if (HEAP8[$3 + 15 | 0] == 10) {
    jsiConsolePrintChar(13);
   }
   jsiConsolePrintChar(HEAP8[$3 + 15 | 0]);
   if (!(!HEAP8[$3 + 55 | 0] | HEAP8[$3 + 15 | 0] != 10)) {
    jsiConsolePrintChar(HEAP8[$3 + 55 | 0]);
   }
   continue;
  }
  break;
 }
 jsvStringIteratorFree_5($3 + 16 | 0);
 __stack_pointer = $3 - -64 | 0;
}

function jsfGetFlags() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = jsvNewWithFlags(5);
 label$1: {
  if (!HEAP32[$0 + 8 >> 2]) {
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 4 >> 2] = HEAP32[48913];
  HEAP8[$0 + 3 | 0] = 1;
  while (1) {
   if (HEAPU8[HEAP32[$0 + 4 >> 2]]) {
    jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2], jsvNewFromInteger(jsfGetFlag(HEAPU8[$0 + 3 | 0]) & 1));
    HEAP32[$0 + 4 >> 2] = (strlen(HEAP32[$0 + 4 >> 2]) + 1 | 0) + HEAP32[$0 + 4 >> 2];
    HEAP8[$0 + 3 | 0] = HEAPU8[$0 + 3 | 0] << 1;
    continue;
   }
   break;
  }
  HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function jsvIsChild($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP16[$2 + 18 >> 1] = jsvGetRef(HEAP32[$2 + 20 >> 2]);
 HEAP16[$2 + 16 >> 1] = jsvGetFirstChild(HEAP32[$2 + 24 >> 2]);
 label$1: {
  while (1) {
   if (HEAPU16[$2 + 16 >> 1]) {
    if (HEAPU16[$2 + 16 >> 1] == HEAPU16[$2 + 18 >> 1]) {
     HEAP8[$2 + 31 | 0] = 1;
     break label$1;
    } else {
     HEAP32[$2 + 12 >> 2] = jsvLock(HEAPU16[$2 + 16 >> 1]);
     HEAP16[$2 + 16 >> 1] = jsvGetNextSibling(HEAP32[$2 + 12 >> 2]);
     jsvUnLock(HEAP32[$2 + 12 >> 2]);
     continue;
    }
   }
   break;
  }
  HEAP8[$2 + 31 | 0] = 0;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP8[$2 + 31 | 0] & 1;
}

function jsvArrayBufferIteratorNext($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 48 >> 2] + 1;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] + (HEAPU8[HEAP32[$1 + 12 >> 2] + 36 | 0] & 15);
 label$1: {
  if (!(HEAP8[HEAP32[$1 + 12 >> 2] + 52 | 0] & 1)) {
   HEAP32[$1 + 8 >> 2] = HEAPU8[HEAP32[$1 + 12 >> 2] + 36 | 0] & 15;
   while (1) {
    $0 = HEAP32[$1 + 8 >> 2];
    HEAP32[$1 + 8 >> 2] = $0 - 1;
    if ($0) {
     jsvStringIteratorNext(HEAP32[$1 + 12 >> 2]);
     continue;
    }
    break;
   }
   break label$1;
  }
  HEAP8[HEAP32[$1 + 12 >> 2] + 52 | 0] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_date_setMinutes($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 44 >> 2] = $0;
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 36 >> 2] = $2;
 HEAP32[$4 + 32 >> 2] = $3;
 getTimeFromDateVar($4, HEAP32[$4 + 44 >> 2], 0);
 HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 40 >> 2];
 if (jsvIsNumeric(HEAP32[$4 + 36 >> 2]) & 1) {
  HEAP32[$4 + 8 >> 2] = jsvGetInteger(HEAP32[$4 + 36 >> 2]);
 }
 if (jsvIsNumeric(HEAP32[$4 + 32 >> 2]) & 1) {
  HEAP32[$4 + 4 >> 2] = jsvGetInteger(HEAP32[$4 + 32 >> 2]);
 }
 setCorrectTimeZone($4);
 $5 = jswrap_date_setTime(HEAP32[$4 + 44 >> 2], fromTimeInDay($4));
 __stack_pointer = $4 + 48 | 0;
 return +$5;
}

function jsfSetFlags($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (!(jsvIsObject(HEAP32[$1 + 12 >> 2]) & 1)) {
   break label$1;
  }
  HEAP32[$1 + 8 >> 2] = HEAP32[48913];
  HEAP8[$1 + 7 | 0] = 1;
  while (1) {
   if (!HEAPU8[HEAP32[$1 + 8 >> 2]]) {
    break label$1;
   }
   HEAP32[$1 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2]);
   if (HEAP32[$1 >> 2]) {
    jsfSetFlag(HEAPU8[$1 + 7 | 0], jsvGetBoolAndUnLock(HEAP32[$1 >> 2]) & 1);
   }
   HEAP32[$1 + 8 >> 2] = (strlen(HEAP32[$1 + 8 >> 2]) + 1 | 0) + HEAP32[$1 + 8 >> 2];
   HEAP8[$1 + 7 | 0] = HEAPU8[$1 + 7 | 0] << 1;
   continue;
  }
 }
 __stack_pointer = $1 + 16 | 0;
}

function jsvArrayBufferIteratorDataToInt($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = HEAPU8[HEAP32[$2 + 28 >> 2] + 36 | 0] & 15;
 HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 20 >> 2] << 3;
 $0 = HEAP32[$2 + 16 >> 2];
 $1 = $0 & 31;
 $0 = ($0 & 63) >>> 0 >= 32 ? 0 : 1 << $1;
 $1 = $0 - 1 | 0;
 HEAP32[$2 + 12 >> 2] = $1;
 HEAP32[$2 + 8 >> 2] = HEAP32[HEAP32[$2 + 24 >> 2] >> 2];
 HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] & HEAP32[$2 + 12 >> 2];
 if (!(!(HEAPU8[HEAP32[$2 + 28 >> 2] + 36 | 0] & 16) | !(HEAP32[$2 + 8 >> 2] & 1 << HEAP32[$2 + 16 >> 2] - 1))) {
  HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] | HEAP32[$2 + 12 >> 2] ^ -1;
 }
 return HEAP32[$2 + 8 >> 2];
}

function tflite__ComputePaddingWithOffset_28int_2c_20int_2c_20int_2c_20int_2c_20int_2c_20int__29($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 32 | 0;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $5;
 HEAP32[$6 + 4 >> 2] = Math_imul(HEAP32[$6 + 24 >> 2], HEAP32[$6 + 16 >> 2] - 1 | 0) + 1;
 HEAP32[$6 >> 2] = (HEAP32[$6 + 4 >> 2] + Math_imul(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 12 >> 2] - 1 | 0) | 0) - HEAP32[$6 + 20 >> 2];
 if (HEAP32[$6 >> 2] > 0) {
  $0 = HEAP32[$6 >> 2];
 } else {
  $0 = 0;
 }
 HEAP32[$6 >> 2] = $0;
 HEAP32[HEAP32[$6 + 8 >> 2] >> 2] = HEAP32[$6 >> 2] % 2;
 return HEAP32[$6 >> 2] / 2 | 0;
}

function flatbuffers__Vector_unsigned_20char__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_unsigned_20char__20const___28unsigned_20short_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 8 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 HEAP32[$2 + 4 >> 2] = HEAPU16[$2 + 8 >> 1] + $0;
 label$1: {
  if (HEAPU16[$2 + 8 >> 1]) {
   $0 = HEAP32[$2 + 4 >> 2] + unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 4 >> 2]) | 0;
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jswrap_regexp_hasFlag($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 60 >> 2] = $0;
 HEAP8[$2 + 59 | 0] = $1;
 HEAP32[$2 + 52 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 60 >> 2], 120167);
 HEAP8[$2 + 51 | 0] = 0;
 if (jsvIsString(HEAP32[$2 + 52 >> 2]) & 1) {
  jsvStringIteratorNew($2 + 8 | 0, HEAP32[$2 + 52 >> 2], 0);
  while (1) {
   if (jsvStringIteratorHasChar_7($2 + 8 | 0) & 1) {
    HEAP8[$2 + 51 | 0] = (jsvStringIteratorGetCharAndNext($2 + 8 | 0) & 255) == HEAPU8[$2 + 59 | 0] | HEAP8[$2 + 51 | 0] & 1;
    continue;
   }
   break;
  }
  jsvStringIteratorFree_9($2 + 8 | 0);
 }
 jsvUnLock(HEAP32[$2 + 52 >> 2]);
 __stack_pointer = $2 - -64 | 0;
 return HEAP8[$2 + 51 | 0] & 1;
}

function jsvNewNativeString($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 >> 2] = jsvNewWithFlags(39);
 label$2: {
  if (!HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$2;
  }
  $0 = HEAP32[$2 >> 2];
  $1 = HEAP32[$2 + 8 >> 2];
  HEAP8[$0 | 0] = $1;
  HEAP8[$0 + 1 | 0] = $1 >>> 8;
  HEAP8[$0 + 2 | 0] = $1 >>> 16;
  HEAP8[$0 + 3 | 0] = $1 >>> 24;
  $0 = HEAP32[$2 >> 2];
  $1 = HEAP32[$2 + 4 >> 2];
  HEAP8[$0 + 4 | 0] = $1;
  HEAP8[$0 + 5 | 0] = $1 >>> 8;
  HEAP8[$0 + 6 | 0] = $1 >>> 16;
  HEAP8[$0 + 7 | 0] = $1 >>> 24;
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jsvExecuteGetter($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (!(jsvIsGetterOrSetter(HEAP32[$2 + 20 >> 2]) & 1)) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 20 >> 2], 117892);
  if (!(jsvIsFunction(HEAP32[$2 + 16 >> 2]) & 1)) {
   jsvUnLock(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jspExecuteFunction(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 24 >> 2], 0, 0);
  jsvUnLock(HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jsvSkipToLastName($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
 while (1) {
  label$2: {
   if (!(jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535)) {
    break label$2;
   }
   HEAP32[$1 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$1 + 8 >> 2]) & 65535);
   label$4: {
    if (jsvIsName(HEAP32[$1 + 4 >> 2]) & 1) {
     jsvUnLock(HEAP32[$1 + 8 >> 2]);
     HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 4 >> 2];
     break label$4;
    }
    jsvUnLock(HEAP32[$1 + 4 >> 2]);
    break label$2;
   }
   continue;
  }
  break;
 }
 HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2];
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvNewFlashString($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 >> 2] = jsvNewWithFlags(40);
 label$2: {
  if (!HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$2;
  }
  $0 = HEAP32[$2 >> 2];
  $1 = HEAP32[$2 + 8 >> 2];
  HEAP8[$0 | 0] = $1;
  HEAP8[$0 + 1 | 0] = $1 >>> 8;
  HEAP8[$0 + 2 | 0] = $1 >>> 16;
  HEAP8[$0 + 3 | 0] = $1 >>> 24;
  $0 = HEAP32[$2 >> 2];
  $1 = HEAP32[$2 + 4 >> 2];
  HEAP8[$0 + 4 | 0] = $1;
  HEAP8[$0 + 5 | 0] = $1 >>> 8;
  HEAP8[$0 + 6 | 0] = $1 >>> 16;
  HEAP8[$0 + 7 | 0] = $1 >>> 24;
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jswrap_i2c_readFrom($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1: {
  if (!(jsvIsObject(HEAP32[$3 + 24 >> 2]) & 1)) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP8[$3 + 15 | 0] = jsiGetDeviceFromClass(HEAP32[$3 + 24 >> 2]);
  HEAP8[$3 + 14 | 0] = 1;
  HEAP32[$3 + 8 >> 2] = i2c_get_address(HEAP32[$3 + 20 >> 2], $3 + 14 | 0);
  HEAP32[$3 + 28 >> 2] = _jswrap_i2c_readFrom(HEAP32[$3 + 24 >> 2], HEAPU8[$3 + 15 | 0], HEAP32[$3 + 8 >> 2], HEAP8[$3 + 14 | 0] & 1, HEAP32[$3 + 16 >> 2]);
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jspromise_create_prombox($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = jspromise_create();
 label$1: {
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 >> 2] = jsvNewObject();
  if (!HEAP32[$1 >> 2]) {
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 4 >> 2], 131993, jsvNewFromInteger(0));
  jsvObjectSetChildAndUnLock(HEAP32[$1 >> 2], 128686, HEAP32[$1 + 4 >> 2]);
  HEAP32[HEAP32[$1 + 8 >> 2] >> 2] = HEAP32[$1 + 4 >> 2];
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function tflite__EnumNameBuiltinOperator_28tflite__BuiltinOperator_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = 0;
 HEAP32[$1 + 16 >> 2] = 126;
 label$1: {
  if (bool_20flatbuffers__IsOutRange_tflite__BuiltinOperator__28tflite__BuiltinOperator_20const__2c_20tflite__BuiltinOperator_20const__2c_20tflite__BuiltinOperator_20const__29($1 + 24 | 0, $1 + 20 | 0, $1 + 16 | 0) & 1) {
   HEAP32[$1 + 28 >> 2] = 148267;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 24 >> 2];
  HEAP32[$1 + 28 >> 2] = HEAP32[tflite__EnumNamesBuiltinOperator_28_29() + (HEAP32[$1 + 12 >> 2] << 2) >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function reverseBytes($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 24 >> 2] >> 1;
 HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 24 >> 2] - 1;
 HEAP32[$2 + 12 >> 2] = 0;
 while (1) {
  if (HEAP32[$2 + 12 >> 2] < HEAP32[$2 + 20 >> 2]) {
   HEAP8[$2 + 11 | 0] = HEAPU8[HEAP32[$2 + 28 >> 2] + HEAP32[$2 + 12 >> 2] | 0];
   HEAP8[HEAP32[$2 + 28 >> 2] + HEAP32[$2 + 12 >> 2] | 0] = HEAPU8[HEAP32[$2 + 28 >> 2] + HEAP32[$2 + 16 >> 2] | 0];
   HEAP8[HEAP32[$2 + 28 >> 2] + HEAP32[$2 + 16 >> 2] | 0] = HEAPU8[$2 + 11 | 0];
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
   HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 16 >> 2] - 1;
   continue;
  }
  break;
 }
}

function tflite__GetOutput_28TfLiteContext__2c_20TfLiteNode_20const__2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 8 >> 2] = $0;
 HEAP32[$3 + 4 >> 2] = $1;
 HEAP32[$3 >> 2] = $2;
 label$1: {
  if (HEAP32[HEAP32[$3 + 8 >> 2] + 8 >> 2]) {
   HEAP32[$3 + 12 >> 2] = HEAP32[HEAP32[$3 + 8 >> 2] + 8 >> 2] + Math_imul(HEAP32[(HEAP32[HEAP32[$3 + 4 >> 2] + 4 >> 2] + 4 | 0) + (HEAP32[$3 >> 2] << 2) >> 2], 40);
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 8 >> 2] + 80 >> 2]](HEAP32[$3 + 8 >> 2], HEAP32[(HEAP32[HEAP32[$3 + 4 >> 2] + 4 >> 2] + 4 | 0) + (HEAP32[$3 >> 2] << 2) >> 2]);
 }
 __stack_pointer = $3 + 16 | 0;
 return HEAP32[$3 + 12 >> 2];
}

function mbedtls_ccm_encrypt_and_tag($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
 var $10 = 0;
 $10 = __stack_pointer - 48 | 0;
 __stack_pointer = $10;
 HEAP32[$10 + 44 >> 2] = $0;
 HEAP32[$10 + 40 >> 2] = $1;
 HEAP32[$10 + 36 >> 2] = $2;
 HEAP32[$10 + 32 >> 2] = $3;
 HEAP32[$10 + 28 >> 2] = $4;
 HEAP32[$10 + 24 >> 2] = $5;
 HEAP32[$10 + 20 >> 2] = $6;
 HEAP32[$10 + 16 >> 2] = $7;
 HEAP32[$10 + 12 >> 2] = $8;
 HEAP32[$10 + 8 >> 2] = $9;
 $0 = ccm_auth_crypt(HEAP32[$10 + 44 >> 2], 0, HEAP32[$10 + 40 >> 2], HEAP32[$10 + 36 >> 2], HEAP32[$10 + 32 >> 2], HEAP32[$10 + 28 >> 2], HEAP32[$10 + 24 >> 2], HEAP32[$10 + 20 >> 2], HEAP32[$10 + 16 >> 2], HEAP32[$10 + 12 >> 2], HEAP32[$10 + 8 >> 2]);
 __stack_pointer = $10 + 48 | 0;
 return $0;
}

function jsiHistoryAddLine($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 12 >> 2]) {
   break label$1;
  }
  HEAP32[$1 + 8 >> 2] = jsvGetStringLength(HEAP32[$1 + 12 >> 2]);
  if (!HEAP32[$1 + 8 >> 2] | HEAPU32[$1 + 8 >> 2] > 500) {
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = jsiGetHistory();
  if (!HEAP32[$1 + 4 >> 2]) {
   break label$1;
  }
  HEAP32[$1 >> 2] = jsvGetIndexOf(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 12 >> 2], 0);
  if (HEAP32[$1 >> 2]) {
   jsvRemoveChildAndUnLock(HEAP32[$1 + 4 >> 2], HEAP32[$1 >> 2]);
  }
  jsvArrayPush(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
}

function graphicsSetPixelDeviceBlended($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = graphicsGetPixelDevice(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2]);
 $0 = HEAP32[$4 + 28 >> 2];
 HEAP32[$4 + 8 >> 2] = graphicsBlendColor(HEAP32[$4 + 28 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24), HEAP32[$4 + 12 >> 2], HEAP32[$4 + 16 >> 2]);
 graphicsSetPixelDevice(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 8 >> 2]);
 __stack_pointer = $4 + 32 | 0;
}

function flatbuffers__Vector_long_20long__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_long_20long__20const___28unsigned_20short_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 8 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 HEAP32[$2 + 4 >> 2] = HEAPU16[$2 + 8 >> 1] + $0;
 label$1: {
  if (HEAPU16[$2 + 8 >> 1]) {
   $0 = HEAP32[$2 + 4 >> 2] + unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 4 >> 2]) | 0;
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function tflite__GreedyMemoryPlanner__DoesEntryOverlapInTime_28tflite__GreedyMemoryPlanner__ListEntry_20const__2c_20int_2c_20int_29_20const($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 HEAP32[$4 + 24 >> 2] = $0;
 HEAP32[$4 + 20 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 HEAP32[$4 + 8 >> 2] = HEAP32[HEAP32[$4 + 24 >> 2] + 12 >> 2] + (HEAP32[HEAP32[$4 + 20 >> 2] + 4 >> 2] << 4);
 label$1: {
  if (HEAP32[HEAP32[$4 + 8 >> 2] + 8 >> 2] > HEAP32[$4 + 12 >> 2]) {
   HEAP8[$4 + 31 | 0] = 0;
   break label$1;
  }
  if (HEAP32[$4 + 16 >> 2] > HEAP32[HEAP32[$4 + 8 >> 2] + 12 >> 2]) {
   HEAP8[$4 + 31 | 0] = 0;
   break label$1;
  }
  HEAP8[$4 + 31 | 0] = 1;
 }
 return HEAP8[$4 + 31 | 0] & 1;
}

function tf_get($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $1;
 HEAP8[$3 + 11 | 0] = $2;
 HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 12 >> 2];
 HEAP32[$0 >> 2] = 0;
 label$1: {
  if (HEAP8[$3 + 11 | 0] & 1) {
   $1 = tflite__MicroInterpreter__input_28unsigned_20long_29(HEAP32[$3 + 4 >> 2] + 400 | 0, 0);
   break label$1;
  }
  $1 = tflite__MicroInterpreter__output_28unsigned_20long_29(HEAP32[$3 + 4 >> 2] + 400 | 0, 0);
 }
 HEAP32[$3 >> 2] = $1;
 if (HEAP32[$3 >> 2]) {
  HEAP32[$0 + 4 >> 2] = HEAP32[HEAP32[$3 >> 2] + 28 >> 2];
  HEAP32[$0 >> 2] = HEAP32[HEAP32[$3 >> 2] + 16 >> 2];
  HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$3 >> 2] + 24 >> 2];
 }
 __stack_pointer = $3 + 16 | 0;
}

function tflite__QuantizationParameters_20const__20flatbuffers__Table__GetPointer_tflite__QuantizationParameters_20const___28unsigned_20short_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 8 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 HEAP32[$2 + 4 >> 2] = HEAPU16[$2 + 8 >> 1] + $0;
 label$1: {
  if (HEAPU16[$2 + 8 >> 1]) {
   $0 = HEAP32[$2 + 4 >> 2] + unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 4 >> 2]) | 0;
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jswrap_string_repeat($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (HEAP32[$2 + 4 >> 2] < 0) {
   jsExceptionHere(1, 131774, 0);
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 >> 2] = jsvNewFromEmptyString_8();
  while (1) {
   $0 = HEAP32[$2 + 4 >> 2];
   HEAP32[$2 + 4 >> 2] = $0 - 1;
   $1 = 0;
   if ($0) {
    $1 = jspIsInterrupted() ^ -1;
   }
   if ($1 & 1) {
    jsvAppendStringVarComplete(HEAP32[$2 >> 2], HEAP32[$2 + 8 >> 2]);
    continue;
   }
   break;
  }
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jswrap_parseFloat($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 112 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 100 >> 2] = $0;
 jsvGetString(HEAP32[$1 + 100 >> 2], $1 + 16 | 0, 70);
 label$1: {
  if (!strcmp($1 + 16 | 0, 116119)) {
   HEAPF64[$1 + 104 >> 3] = infinity;
   break label$1;
  }
  if (!strcmp($1 + 16 | 0, 116118)) {
   HEAPF64[$1 + 104 >> 3] = -infinity;
   break label$1;
  }
  HEAPF64[$1 >> 3] = stringToFloatWithRadix($1 + 16 | 0, 0, $1 + 12 | 0);
  if (HEAP32[$1 + 12 >> 2] == ($1 + 85 | 0)) {
   jsExceptionHere(1, 121368, 0);
   HEAPF64[$1 + 104 >> 3] = nan;
   break label$1;
  }
  HEAPF64[$1 + 104 >> 3] = HEAPF64[$1 >> 3];
 }
 __stack_pointer = $1 + 112 | 0;
 return +HEAPF64[$1 + 104 >> 3];
}

function jswrap_graphics_asURL($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = jswrap_graphics_asBMP_X(HEAP32[$1 + 24 >> 2], 0);
 label$1: {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 16 >> 2] = jswrap_btoa(HEAP32[$1 + 20 >> 2]);
  jsvUnLock(HEAP32[$1 + 20 >> 2]);
  if (!HEAP32[$1 + 16 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 >> 2] = HEAP32[$1 + 16 >> 2];
  HEAP32[$1 + 12 >> 2] = jsvVarPrintf(116813, $1);
  jsvUnLock(HEAP32[$1 + 16 >> 2]);
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 12 >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function jsiDumpEvent($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 28 >> 2] = $0;
 HEAP32[$5 + 24 >> 2] = $1;
 HEAP32[$5 + 20 >> 2] = $2;
 HEAP32[$5 + 16 >> 2] = $3;
 HEAP32[$5 + 12 >> 2] = $4;
 HEAP32[$5 + 8 >> 2] = jsvNewFromStringVar(HEAP32[$5 + 16 >> 2], 3, 2147483647);
 $0 = HEAP32[$5 + 28 >> 2];
 $1 = HEAP32[$5 + 24 >> 2];
 $2 = HEAP32[$5 + 20 >> 2];
 HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 8 >> 2];
 HEAP32[$5 >> 2] = $2;
 cbprintf($0, $1, 146367, $5);
 jsvUnLock(HEAP32[$5 + 8 >> 2]);
 jsiDumpJSON(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 12 >> 2], 0);
 FUNCTION_TABLE[HEAP32[$5 + 28 >> 2]](147434, HEAP32[$5 + 24 >> 2]);
 __stack_pointer = $5 + 32 | 0;
}

function save_backlog($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = get_input_buffer_size(HEAP32[$1 + 12 >> 2]) & 65535;
 HEAP16[$1 + 6 >> 1] = HEAPU16[HEAP32[$1 + 12 >> 2] + 2 >> 1];
 HEAP16[$1 + 4 >> 1] = HEAP32[$1 + 8 >> 2] - HEAPU16[$1 + 6 >> 1];
 HEAP16[$1 + 2 >> 1] = HEAP32[$1 + 8 >> 2] + HEAPU16[$1 + 4 >> 1];
 memmove(HEAP32[$1 + 12 >> 2] + 15 | 0, HEAP32[$1 + 12 >> 2] + 15 + (HEAP32[$1 + 8 >> 2] - HEAPU16[$1 + 4 >> 1]) | 0, HEAPU16[$1 + 2 >> 1]);
 HEAP16[HEAP32[$1 + 12 >> 2] + 2 >> 1] = 0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP16[$0 >> 1] = HEAPU16[$0 >> 1] - (HEAP32[$1 + 8 >> 2] - HEAPU16[$1 + 4 >> 1] | 0);
 __stack_pointer = $1 + 16 | 0;
}

function std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[std____2____compressed_pair_TfLiteFullyConnectedParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2];
 HEAP32[std____2____compressed_pair_TfLiteFullyConnectedParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2] = 0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jsvCompareInteger($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  label$2: {
   if (!(jsvIsInt(HEAP32[$2 + 8 >> 2]) & 1)) {
    break label$2;
   }
   if (!(jsvIsInt(HEAP32[$2 + 4 >> 2]) & 1)) {
    break label$2;
   }
   HEAP32[$2 + 12 >> 2] = jsvGetInteger(HEAP32[$2 + 8 >> 2]) - jsvGetInteger(HEAP32[$2 + 4 >> 2]);
   break label$1;
  }
  if (jsvIsInt(HEAP32[$2 + 8 >> 2]) & 1) {
   HEAP32[$2 + 12 >> 2] = -1;
   break label$1;
  }
  if (jsvIsInt(HEAP32[$2 + 4 >> 2]) & 1) {
   HEAP32[$2 + 12 >> 2] = 1;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function lcdInit_ArrayBuffer($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 label$1: {
  if (HEAP32[$2 + 8 >> 2]) {
   $0 = HEAP32[$2 + 12 >> 2];
   jsvAddNamedChild(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), HEAP32[$2 + 8 >> 2], 121187);
   break label$1;
  }
  HEAP32[$2 + 4 >> 2] = jswrap_arraybuffer_constructor(graphicsGetMemoryRequired(HEAP32[$2 + 12 >> 2]));
  $0 = HEAP32[$2 + 12 >> 2];
  jsvAddNamedChildAndUnLock(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), HEAP32[$2 + 4 >> 2], 121187);
 }
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_espruino_setDST($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (jsvIsUndefined(HEAP32[$1 + 12 >> 2]) & 1) {
   jsvObjectRemoveChild(HEAP32[91087], 117339);
   break label$1;
  }
  label$3: {
   if (jsvIsArray(HEAP32[$1 + 12 >> 2]) & 1) {
    if ((jsvGetLength(HEAP32[$1 + 12 >> 2]) | 0) == 12) {
     break label$3;
    }
   }
   jsExceptionHere(1, 119687, 0);
   break label$1;
  }
  jsvObjectRemoveChild(HEAP32[91087], 116073);
  HEAP32[$1 + 8 >> 2] = jswrap_typedarray_constructor(18, HEAP32[$1 + 12 >> 2], 0, 0);
  jsvObjectSetChildAndUnLock(HEAP32[91087], 117339, HEAP32[$1 + 8 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
}

function tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 if (HEAP32[$3 + 20 >> 2] > 0) {
  $0 = HEAP32[$3 + 20 >> 2];
 } else {
  $0 = 0;
 }
 HEAP32[$3 + 16 >> 2] = $0;
 HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 20 >> 2] > 0 ? 0 : 0 - HEAP32[$3 + 20 >> 2] | 0;
 $0 = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(int_20gemmlowp__SaturatingRoundingDoublingHighMul_int__28int_2c_20int_29(Math_imul(HEAP32[$3 + 28 >> 2], 1 << HEAP32[$3 + 16 >> 2]), HEAP32[$3 + 24 >> 2]), HEAP32[$3 + 12 >> 2]);
 __stack_pointer = $3 + 32 | 0;
 return $0;
}

function std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[std____2____compressed_pair_TfLiteDepthwiseConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2];
 HEAP32[std____2____compressed_pair_TfLiteDepthwiseConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2] = 0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jswrap_flash_getPage($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1: {
  if (!(jshFlashGetPage(HEAP32[$1 + 24 >> 2], $1 + 20 | 0, $1 + 16 | 0) & 1)) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvNewObject();
  if (!HEAP32[$1 + 12 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 121453, jsvNewFromInteger(HEAP32[$1 + 20 >> 2]));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 12 >> 2], 129363, jsvNewFromInteger(HEAP32[$1 + 16 >> 2]));
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 12 >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function jswGetBuiltInLibrary($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!strcmp(HEAP32[$1 + 8 >> 2], 129475)) {
   HEAP32[$1 + 12 >> 2] = 40;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 132680)) {
   HEAP32[$1 + 12 >> 2] = 43;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 129094)) {
   HEAP32[$1 + 12 >> 2] = 44;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 128030)) {
   HEAP32[$1 + 12 >> 2] = 45;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 116529)) {
   HEAP32[$1 + 12 >> 2] = 47;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function flatbuffers__Vector_float__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_float__20const___28unsigned_20short_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 8 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 HEAP32[$2 + 4 >> 2] = HEAPU16[$2 + 8 >> 1] + $0;
 label$1: {
  if (HEAPU16[$2 + 8 >> 1]) {
   $0 = HEAP32[$2 + 4 >> 2] + unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 4 >> 2]) | 0;
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jswrap_graphics_fillEllipse($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = __stack_pointer - 96 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 88 >> 2] = $0;
 HEAP32[$5 + 84 >> 2] = $1;
 HEAP32[$5 + 80 >> 2] = $2;
 HEAP32[$5 + 76 >> 2] = $3;
 HEAP32[$5 + 72 >> 2] = $4;
 label$1: {
  if (!(graphicsGetFromVar($5, HEAP32[$5 + 88 >> 2]) & 1)) {
   HEAP32[$5 + 92 >> 2] = 0;
   break label$1;
  }
  graphicsFillEllipse($5, HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2], HEAP32[$5 + 72 >> 2]);
  graphicsSetVar($5);
  HEAP32[$5 + 92 >> 2] = jsvLockAgain(HEAP32[$5 + 88 >> 2]);
 }
 __stack_pointer = $5 + 96 | 0;
 return HEAP32[$5 + 92 >> 2];
}

function jswrap_graphics_drawEllipse($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = __stack_pointer - 96 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 88 >> 2] = $0;
 HEAP32[$5 + 84 >> 2] = $1;
 HEAP32[$5 + 80 >> 2] = $2;
 HEAP32[$5 + 76 >> 2] = $3;
 HEAP32[$5 + 72 >> 2] = $4;
 label$1: {
  if (!(graphicsGetFromVar($5, HEAP32[$5 + 88 >> 2]) & 1)) {
   HEAP32[$5 + 92 >> 2] = 0;
   break label$1;
  }
  graphicsDrawEllipse($5, HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2], HEAP32[$5 + 72 >> 2]);
  graphicsSetVar($5);
  HEAP32[$5 + 92 >> 2] = jsvLockAgain(HEAP32[$5 + 88 >> 2]);
 }
 __stack_pointer = $5 + 96 | 0;
 return HEAP32[$5 + 92 >> 2];
}

function _jswrap_object_entries_cb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 28 >> 2];
 HEAP32[$2 + 16 >> 2] = jsvNewEmptyArray();
 if (HEAP32[$2 + 16 >> 2]) {
  jsvArrayPush(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 24 >> 2]);
  HEAP32[$2 + 12 >> 2] = jsvAsArrayIndex(HEAP32[$2 + 24 >> 2]);
  jsvArrayPushAndUnLock(HEAP32[$2 + 16 >> 2], jspGetVarNamedField(HEAP32[HEAP32[$2 + 20 >> 2] + 4 >> 2], HEAP32[$2 + 12 >> 2], 0));
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  jsvArrayPushAndUnLock(HEAP32[HEAP32[$2 + 20 >> 2] >> 2], HEAP32[$2 + 16 >> 2]);
 }
 __stack_pointer = $2 + 32 | 0;
}

function jspeParseFunctionCallBrackets() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 label$1: {
  if (!(jslMatch(40) & 1)) {
   break label$1;
  }
  while (1) {
   $1 = 0;
   $1 = HEAP32[91094] & 80 ? $1 : HEAP16[HEAP32[49079] + 2 >> 1] != 41;
   if ($1) {
    jsvUnLock(jspeAssignmentExpression());
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 162) {
     jsvUnLock(jspeArrowFunction(0, 0));
    }
    if (HEAP16[HEAP32[49079] + 2 >> 1] != 41) {
     if (!(jslMatch(44) & 1)) {
      break label$1;
     }
    }
    continue;
   }
   break;
  }
  if (!(HEAP32[91094] & 80)) {
   jslMatch(41);
  }
 }
 HEAP8[$0 + 15 | 0] = 0;
 __stack_pointer = $0 + 16 | 0;
 return HEAP8[$0 + 15 | 0] & 1;
}

function flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 8 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 HEAP32[$2 + 4 >> 2] = HEAPU16[$2 + 8 >> 1] + $0;
 label$1: {
  if (HEAPU16[$2 + 8 >> 1]) {
   $0 = HEAP32[$2 + 4 >> 2] + unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 4 >> 2]) | 0;
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 HEAP32[$2 + 4 >> 2] = flatbuffers__Table__GetVTable_28_29_20const(HEAP32[$2 + 12 >> 2]);
 HEAP16[$2 + 2 >> 1] = unsigned_20short_20flatbuffers__ReadScalar_unsigned_20short__28void_20const__29(HEAP32[$2 + 4 >> 2]);
 label$1: {
  if (HEAPU16[$2 + 10 >> 1] < HEAPU16[$2 + 2 >> 1]) {
   $0 = unsigned_20short_20flatbuffers__ReadScalar_unsigned_20short__28void_20const__29(HEAP32[$2 + 4 >> 2] + HEAPU16[$2 + 10 >> 1] | 0) & 65535;
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jswrap_graphics_getFonts($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 96 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 88 >> 2] = $0;
 label$1: {
  if (!(graphicsGetFromVar($1 + 16 | 0, HEAP32[$1 + 88 >> 2]) & 1)) {
   HEAP32[$1 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvNewEmptyArray();
  if (!HEAP32[$1 + 12 >> 2]) {
   HEAP32[$1 + 92 >> 2] = 0;
   break label$1;
  }
  jsvArrayPushString(HEAP32[$1 + 12 >> 2], 139174);
  jsvArrayPushString(HEAP32[$1 + 12 >> 2], 139037);
  jswrap_object_keys_or_property_names_cb(HEAP32[$1 + 88 >> 2], 3, 662, HEAP32[$1 + 12 >> 2]);
  HEAP32[$1 + 92 >> 2] = HEAP32[$1 + 12 >> 2];
 }
 __stack_pointer = $1 + 96 | 0;
 return HEAP32[$1 + 92 >> 2];
}

function jswrap_banglejs_dbg() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = jsvNewObject();
 label$1: {
  if (!HEAP32[$0 + 8 >> 2]) {
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 116455, jsvNewFromInteger(HEAPU8[391166]));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 117398, jsvNewFromInteger(HEAPU8[391320]));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 117424, jsvNewFromInteger(HEAPU8[391321]));
  jsvObjectSetChildAndUnLock(HEAP32[$0 + 8 >> 2], 129022, jsvNewFromInteger(HEAPU16[195511]));
  HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function jswrap_graphics_drawLine($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = __stack_pointer - 96 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 88 >> 2] = $0;
 HEAP32[$5 + 84 >> 2] = $1;
 HEAP32[$5 + 80 >> 2] = $2;
 HEAP32[$5 + 76 >> 2] = $3;
 HEAP32[$5 + 72 >> 2] = $4;
 label$1: {
  if (!(graphicsGetFromVar($5, HEAP32[$5 + 88 >> 2]) & 1)) {
   HEAP32[$5 + 92 >> 2] = 0;
   break label$1;
  }
  graphicsDrawLine($5, HEAP32[$5 + 84 >> 2], HEAP32[$5 + 80 >> 2], HEAP32[$5 + 76 >> 2], HEAP32[$5 + 72 >> 2]);
  graphicsSetVar($5);
  HEAP32[$5 + 92 >> 2] = jsvLockAgain(HEAP32[$5 + 88 >> 2]);
 }
 __stack_pointer = $5 + 96 | 0;
 return HEAP32[$5 + 92 >> 2];
}

function st_yield_tag_bit($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (can_take_byte(HEAP32[$2 + 4 >> 2])) {
   if (!HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1]) {
    add_tag_bit(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2], 1);
    HEAP32[$2 + 12 >> 2] = 4;
    break label$1;
   }
   add_tag_bit(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2], 0);
   HEAP16[HEAP32[$2 + 8 >> 2] + 8 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 6 >> 1] - 1;
   HEAP8[HEAP32[$2 + 8 >> 2] + 10 | 0] = 8;
   HEAP32[$2 + 12 >> 2] = 5;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 3;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jspeStatementReturn() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 jslGetNextToken();
 if (!(HEAP16[HEAP32[49079] + 2 >> 1] == 59 | HEAP16[HEAP32[49079] + 2 >> 1] == 125)) {
  HEAP32[$0 + 12 >> 2] = jsvSkipNameAndUnLock(jspeExpression());
 }
 if ((HEAP32[91094] & 63) == 1) {
  HEAP32[$0 + 8 >> 2] = jspeiFindInScopes(128076);
  label$3: {
   if (HEAP32[$0 + 8 >> 2]) {
    jsvReplaceWith(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 12 >> 2]);
    jsvUnLock(HEAP32[$0 + 8 >> 2]);
    HEAP32[91094] = HEAP32[91094] | 8;
    break label$3;
   }
   jsExceptionHere(2, 140545, 0);
  }
 }
 jsvUnLock(HEAP32[$0 + 12 >> 2]);
 __stack_pointer = $0 + 16 | 0;
 return 0;
}

function flatbuffers__String_20const__20flatbuffers__Table__GetPointer_flatbuffers__String_20const___28unsigned_20short_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 8 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 HEAP32[$2 + 4 >> 2] = HEAPU16[$2 + 8 >> 1] + $0;
 label$1: {
  if (HEAPU16[$2 + 8 >> 1]) {
   $0 = HEAP32[$2 + 4 >> 2] + unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 4 >> 2]) | 0;
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function unsigned_20char_20const__20std____2__min_unsigned_20char_2c_20std____2____less_unsigned_20char_2c_20unsigned_20char___28unsigned_20char_20const__2c_20unsigned_20char_20const__2c_20std____2____less_unsigned_20char_2c_20unsigned_20char__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1: {
  if (std____2____less_unsigned_20char_2c_20unsigned_20char___operator_28_29_28unsigned_20char_20const__2c_20unsigned_20char_20const__29_20const($2 + 8 | 0, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function unsigned_20char_20const__20std____2__max_unsigned_20char_2c_20std____2____less_unsigned_20char_2c_20unsigned_20char___28unsigned_20char_20const__2c_20unsigned_20char_20const__2c_20std____2____less_unsigned_20char_2c_20unsigned_20char__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1: {
  if (std____2____less_unsigned_20char_2c_20unsigned_20char___operator_28_29_28unsigned_20char_20const__2c_20unsigned_20char_20const__29_20const($2 + 8 | 0, HEAP32[$2 + 4 >> 2], HEAP32[$2 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function getMonth($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = 0;
 label$1: {
  while (1) {
   if (HEAP32[$1 + 4 >> 2] < 12) {
    if (!(HEAP8[HEAP32[$1 + 8 >> 2]] != HEAP8[HEAP32[48927] + (HEAP32[$1 + 4 >> 2] << 2) | 0] | HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] != HEAP8[HEAP32[48927] + ((HEAP32[$1 + 4 >> 2] << 2) + 1 | 0) | 0] | HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] != HEAP8[HEAP32[48927] + ((HEAP32[$1 + 4 >> 2] << 2) + 2 | 0) | 0])) {
     HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
     break label$1;
    }
    HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$1 + 12 >> 2] = -1;
 }
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_date_setMonth($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 HEAP32[$3 + 52 >> 2] = $2;
 getTimeFromDateVar($3 + 24 | 0, HEAP32[$3 + 60 >> 2], 0);
 getCalendarDate($3, HEAP32[$3 + 24 >> 2]);
 HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 56 >> 2];
 if (jsvIsNumeric(HEAP32[$3 + 52 >> 2]) & 1) {
  HEAP32[$3 + 4 >> 2] = jsvGetInteger(HEAP32[$3 + 52 >> 2]);
 }
 HEAP32[$3 + 24 >> 2] = fromCalendarDate($3);
 setCorrectTimeZone($3 + 24 | 0);
 $4 = jswrap_date_setTime(HEAP32[$3 + 60 >> 2], fromTimeInDay($3 + 24 | 0));
 __stack_pointer = $3 - -64 | 0;
 return +$4;
}

function std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[std____2____compressed_pair_TfLiteSoftmaxParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2];
 HEAP32[std____2____compressed_pair_TfLiteSoftmaxParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2] = 0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[std____2____compressed_pair_TfLiteReshapeParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2];
 HEAP32[std____2____compressed_pair_TfLiteReshapeParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2] = 0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jswrap_graphics_moveTo($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 96 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP32[$3 + 80 >> 2] = $2;
 label$1: {
  if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$3 + 84 >> 2];
  HEAP8[$3 + 35 | 0] = $0;
  HEAP8[$3 + 36 | 0] = $0 >>> 8;
  $0 = HEAP32[$3 + 80 >> 2];
  HEAP8[$3 + 37 | 0] = $0;
  HEAP8[$3 + 38 | 0] = $0 >>> 8;
  graphicsSetVar($3 + 8 | 0);
  HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
 }
 __stack_pointer = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}

function jswrap_banglejs_setPollInterval($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 24 >> 3] = $0;
 __DOUBLE_BITS_2(HEAPF64[$1 + 24 >> 3]);
 $2 = i64toi32_i32$HIGH_BITS & 2147483647;
 label$1: {
  if (HEAPF64[$1 + 24 >> 3] > 4e3 ? 1 : ($2 | 0) == 2146435072 | $2 >>> 0 > 2146435072 | HEAPF64[$1 + 24 >> 3] < 10) {
   jsExceptionHere(1, 129005, 0);
   break label$1;
  }
  HEAP32[97749] = HEAP32[97749] & -2049;
  $0 = HEAPF64[$1 + 24 >> 3];
  label$5: {
   if ($0 < 4294967296 & $0 >= 0) {
    $2 = ~~$0 >>> 0;
    break label$5;
   }
   $2 = 0;
  }
  jswrap_banglejs_setPollInterval_internal($2 & 65535);
 }
 __stack_pointer = $1 + 32 | 0;
}

function jsvGetConstString($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (jsvIsUndefined(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 133948;
   break label$1;
  }
  if (jsvIsNull(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 128729;
   break label$1;
  }
  label$4: {
   if (!(jsvIsBoolean(HEAP32[$1 + 8 >> 2]) & 1)) {
    break label$4;
   }
   if (jsvIsNameIntBool(HEAP32[$1 + 8 >> 2]) & 1) {
    break label$4;
   }
   HEAP32[$1 + 12 >> 2] = jsvGetBool(HEAP32[$1 + 8 >> 2]) & 1 ? 131761 : 132085;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function tflite___28anonymous_20namespace_29__ConvertActivation_28tflite__ActivationFunctionType_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  label$2: {
   switch (HEAP32[$1 + 8 >> 2]) {
   case 0:
    HEAP32[$1 + 12 >> 2] = 0;
    break label$1;

   case 1:
    HEAP32[$1 + 12 >> 2] = 1;
    break label$1;

   case 2:
    HEAP32[$1 + 12 >> 2] = 2;
    break label$1;

   case 3:
    HEAP32[$1 + 12 >> 2] = 3;
    break label$1;

   case 4:
    HEAP32[$1 + 12 >> 2] = 4;
    break label$1;

   case 5:
    HEAP32[$1 + 12 >> 2] = 5;
    break label$1;

   default:
    break label$2;
   }
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 return HEAP32[$1 + 12 >> 2];
}

function unsigned_20char_20flatbuffers__Table__GetField_unsigned_20char__28unsigned_20short_2c_20unsigned_20char_29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP16[$3 + 10 >> 1] = $1;
 HEAP8[$3 + 9 | 0] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP16[$3 + 6 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$3 + 10 >> 1]);
 label$1: {
  if (HEAPU16[$3 + 6 >> 1]) {
   $0 = unsigned_20char_20flatbuffers__ReadScalar_unsigned_20char__28void_20const__29(HEAPU16[$3 + 6 >> 1] + $0 | 0);
   break label$1;
  }
  $0 = HEAPU8[$3 + 9 | 0];
 }
 __stack_pointer = $3 + 16 | 0;
 return $0 & 255;
}

function jswrap_graphics_getColorX($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 96 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP8[$2 + 87 | 0] = $1;
 label$1: {
  if (!(graphicsGetFromVar($2 + 8 | 0, HEAP32[$2 + 88 >> 2]) & 1)) {
   HEAP32[$2 + 92 >> 2] = 0;
   break label$1;
  }
  if (HEAP8[$2 + 87 | 0] & 1) {
   $0 = HEAPU8[$2 + 25 | 0] | HEAPU8[$2 + 26 | 0] << 8 | (HEAPU8[$2 + 27 | 0] << 16 | HEAPU8[$2 + 28 | 0] << 24);
  } else {
   $0 = HEAPU8[$2 + 29 | 0] | HEAPU8[$2 + 30 | 0] << 8 | (HEAPU8[$2 + 31 | 0] << 16 | HEAPU8[$2 + 32 | 0] << 24);
  }
  HEAP32[$2 + 92 >> 2] = $0 & (1 << HEAPU8[$2 + 24 | 0]) - 1;
 }
 __stack_pointer = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}

function jsvStringIteratorAppendString($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 60 >> 2] = $0;
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP32[$4 + 48 >> 2] = $3;
 jsvStringIteratorNew($4 + 8 | 0, HEAP32[$4 + 56 >> 2], HEAP32[$4 + 52 >> 2]);
 while (1) {
  $0 = 0;
  if (jsvStringIteratorHasChar_2($4 + 8 | 0) & 1) {
   $0 = HEAP32[$4 + 48 >> 2] > 0;
  }
  if ($0) {
   jsvStringIteratorAppend(HEAP32[$4 + 60 >> 2], jsvStringIteratorGetCharAndNext($4 + 8 | 0) << 24 >> 24);
   HEAP32[$4 + 48 >> 2] = HEAP32[$4 + 48 >> 2] - 1;
   continue;
  }
  break;
 }
 jsvStringIteratorFree_2($4 + 8 | 0);
 __stack_pointer = $4 - -64 | 0;
}

function jsvObjectSetChild($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1: {
  if (!(jsvHasChildren(HEAP32[$3 + 24 >> 2]) & 1)) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvFindOrAddChildFromString(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2]);
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  jsvSetValueOfName(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2]);
  jsvUnLock(HEAP32[$3 + 12 >> 2]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 16 >> 2];
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jspSetException($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvFindOrAddChildFromString(HEAP32[91087], 117353);
 if (HEAP32[$1 + 8 >> 2]) {
  jsvSetValueOfName(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
 }
 HEAP32[91094] = HEAP32[91094] | 32;
 if (HEAP32[49079]) {
  HEAP32[$1 + 4 >> 2] = jsvObjectGetChild(HEAP32[91087], 132883, 28);
  if (HEAP32[$1 + 4 >> 2]) {
   jsvAppendPrintf(HEAP32[$1 + 4 >> 2], 146079, 0);
   jspAppendStackTrace(HEAP32[$1 + 4 >> 2]);
   jsvUnLock(HEAP32[$1 + 4 >> 2]);
   HEAP32[91094] = HEAP32[91094] | 128;
  }
 }
 __stack_pointer = $1 + 16 | 0;
}

function std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[std____2____compressed_pair_TfLitePoolParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2];
 HEAP32[std____2____compressed_pair_TfLitePoolParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2] = 0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___release_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2];
 HEAP32[std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) >> 2] = 0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jsvObjectSetChildVar($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 label$1: {
  if (!(jsvHasChildren(HEAP32[$3 + 24 >> 2]) & 1)) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = jsvFindChildFromVar(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], 1);
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  jsvSetValueOfName(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2]);
  jsvUnLock(HEAP32[$3 + 12 >> 2]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 16 >> 2];
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function bool_20std____2__operator___TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator_20bool_28_29_20const(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 & 1;
}

function tflite__SimpleMemoryAllocator__SimpleMemoryAllocator_28tflite__SimpleMemoryAllocator_20const__29($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $1 = HEAP32[$2 + 12 >> 2];
 HEAP32[$1 >> 2] = 189224;
 $3 = HEAP32[$2 + 8 >> 2];
 $0 = HEAP32[$3 + 4 >> 2];
 $2 = HEAP32[$3 + 8 >> 2];
 $4 = $0;
 $0 = $1;
 HEAP32[$0 + 4 >> 2] = $4;
 HEAP32[$0 + 8 >> 2] = $2;
 $0 = HEAP32[$3 + 24 >> 2];
 $2 = HEAP32[$3 + 20 >> 2];
 HEAP32[$1 + 20 >> 2] = $2;
 HEAP32[$1 + 24 >> 2] = $0;
 $2 = HEAP32[$3 + 16 >> 2];
 $0 = HEAP32[$3 + 12 >> 2];
 $4 = $0;
 $0 = $1;
 HEAP32[$0 + 12 >> 2] = $4;
 HEAP32[$0 + 16 >> 2] = $2;
 return $0;
}

function jsvIteratorFree($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  label$2: {
   switch (HEAP32[HEAP32[$1 + 12 >> 2] >> 2] - 1 | 0) {
   case 3:
    jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2]);
    jsvObjectIteratorFree_1(HEAP32[$1 + 12 >> 2] + 4 | 0);
    break label$1;

   case 1:
    jsvObjectIteratorFree_1(HEAP32[$1 + 12 >> 2] + 4 | 0);
    break label$1;

   case 0:
    jsvStringIteratorFree_2(HEAP32[$1 + 12 >> 2] + 4 | 0);
    break label$1;

   case 2:
    break label$2;

   default:
    break label$1;
   }
  }
  jsvArrayBufferIteratorFree(HEAP32[$1 + 12 >> 2] + 4 | 0);
 }
 __stack_pointer = $1 + 16 | 0;
}

function tflite___28anonymous_20namespace_29__CalculateActivationRangeQuantizedImpl_28TfLiteFusedActivation_2c_20int_2c_20int_2c_20TfLiteTensor__2c_20int__2c_20int__29__$_0__operator_28_29_28float_29_20const($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAPF32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 $3 = HEAP32[$0 + 4 >> 2];
 $1 = float_20tflite__TfLiteRound_float__28float_29(Math_fround(HEAPF32[$2 + 8 >> 2] / HEAPF32[$0 >> 2]));
 label$1: {
  if (Math_fround(Math_abs($1)) < Math_fround(2147483648)) {
   $0 = ~~$1;
   break label$1;
  }
  $0 = -2147483648;
 }
 __stack_pointer = $2 + 16 | 0;
 return $3 + $0 | 0;
}

function st_flush_bit_buffer($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (HEAPU8[HEAP32[$2 + 8 >> 2] + 14 | 0] == 128) {
   HEAP32[$2 + 12 >> 2] = 9;
   break label$1;
  }
  if (can_take_byte(HEAP32[$2 + 4 >> 2])) {
   $3 = HEAPU8[HEAP32[$2 + 8 >> 2] + 13 | 0];
   $4 = HEAP32[HEAP32[$2 + 4 >> 2] >> 2];
   $0 = HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2];
   $1 = HEAP32[$0 >> 2];
   HEAP32[$0 >> 2] = $1 + 1;
   HEAP8[$1 + $4 | 0] = $3;
   HEAP32[$2 + 12 >> 2] = 9;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 8;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP16[$3 + 10 >> 1] = $1;
 HEAP8[$3 + 9 | 0] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP16[$3 + 6 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$3 + 10 >> 1]);
 label$1: {
  if (HEAPU16[$3 + 6 >> 1]) {
   $0 = signed_20char_20flatbuffers__ReadScalar_signed_20char__28void_20const__29(HEAPU16[$3 + 6 >> 1] + $0 | 0);
   break label$1;
  }
  $0 = HEAPU8[$3 + 9 | 0];
 }
 __stack_pointer = $3 + 16 | 0;
 return $0 << 24 >> 24;
}

function jsvMathsOpSkipNames($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = jsvSkipName(HEAP32[$3 + 28 >> 2]);
 HEAP32[$3 + 12 >> 2] = jsvSkipName(HEAP32[$3 + 24 >> 2]);
 HEAP32[$3 + 8 >> 2] = jsvGetValueOf(HEAP32[$3 + 16 >> 2]);
 HEAP32[$3 + 4 >> 2] = jsvGetValueOf(HEAP32[$3 + 12 >> 2]);
 jsvUnLock2(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2]);
 HEAP32[$3 >> 2] = jsvMathsOp(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$3 + 20 >> 2]);
 jsvUnLock2(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 >> 2];
}

function lcdGetPixel_ArrayBuffer_flat4($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 24 >> 2] + Math_imul(HEAP32[$3 + 20 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
 HEAP32[$3 + 12 >> 2] = (HEAP32[$3 + 16 >> 2] & 1) << 2;
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$3 + 8 >> 2] = (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$3 + 16 >> 2] >> 1);
 return HEAPU8[HEAP32[$3 + 8 >> 2]] >> 4 - HEAP32[$3 + 12 >> 2] & 15;
}

function jsvNewFromLongInteger($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  label$2: {
   $0 = HEAP32[$2 + 4 >> 2];
   if (($0 | 0) < 0 & HEAPU32[$2 >> 2] < 2147483648 | ($0 | 0) < -1) {
    break label$2;
   }
   $0 = HEAP32[$2 + 4 >> 2];
   if (HEAPU32[$2 >> 2] > 2147483647 & ($0 | 0) >= 0 | ($0 | 0) > 0) {
    break label$2;
   }
   HEAP32[$2 + 12 >> 2] = jsvNewFromInteger(HEAP32[$2 >> 2]);
   break label$1;
  }
  $0 = HEAP32[$2 >> 2];
  HEAP32[$2 + 12 >> 2] = jsvNewFromFloat(+($0 >>> 0) + +HEAP32[$2 + 4 >> 2] * 4294967296);
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SelectUsingMask_int_2c_200__28int_2c_20gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 16 >> 2] = $1;
 HEAP32[$3 + 8 >> 2] = $2;
 HEAP32[$3 + 4 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromRaw_28int_29(int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29(HEAP32[$3 + 4 >> 2], HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($3 + 16 | 0) >> 2], HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($3 + 8 | 0) >> 2]));
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 24 >> 2];
}

function bool_20std____2__operator___TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator_20bool_28_29_20const(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 & 1;
}

function lcdGetPixel_ArrayBuffer_flat2($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 24 >> 2] + Math_imul(HEAP32[$3 + 20 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
 HEAP32[$3 + 12 >> 2] = (HEAP32[$3 + 16 >> 2] & 3) << 1;
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$3 + 8 >> 2] = (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$3 + 16 >> 2] >> 2);
 return HEAPU8[HEAP32[$3 + 8 >> 2]] >> 6 - HEAP32[$3 + 12 >> 2] & 3;
}

function isIDString($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(isAlpha(HEAP8[HEAP32[$1 + 8 >> 2]]) & 1)) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  while (1) {
   if (HEAPU8[HEAP32[$1 + 8 >> 2]]) {
    label$5: {
     if (isAlpha(HEAP8[HEAP32[$1 + 8 >> 2]]) & 1) {
      break label$5;
     }
     if (isNumeric(HEAP8[HEAP32[$1 + 8 >> 2]]) & 1) {
      break label$5;
     }
     HEAP8[$1 + 15 | 0] = 0;
     break label$1;
    }
    HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP8[$1 + 15 | 0] = 1;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}

function unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP16[$3 + 10 >> 1] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP16[$3 + 2 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$3 + 10 >> 1]);
 label$1: {
  if (HEAPU16[$3 + 2 >> 1]) {
   $0 = unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAPU16[$3 + 2 >> 1] + $0 | 0);
   break label$1;
  }
  $0 = HEAP32[$3 + 4 >> 2];
 }
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function jsvNewArray($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = jsvNewEmptyArray();
 label$1: {
  if (!HEAP32[$2 + 16 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$2 + 12 >> 2] < HEAP32[$2 + 20 >> 2]) {
    jsvArrayPush(HEAP32[$2 + 16 >> 2], HEAP32[HEAP32[$2 + 24 >> 2] + (HEAP32[$2 + 12 >> 2] << 2) >> 2]);
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function graphicsSetVarInitial($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = jsvFindOrAddChildFromString(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 116422);
 HEAP32[$1 + 4 >> 2] = jsvSkipName(HEAP32[$1 + 8 >> 2]);
 if (!HEAP32[$1 + 4 >> 2]) {
  HEAP32[$1 + 4 >> 2] = jsvNewStringOfLength(44, 0);
  jsvSetValueOfName(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 4 >> 2]);
 }
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 jsvSetString(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 12 >> 2] + 4 | 0, 44);
 jsvUnLock(HEAP32[$1 + 4 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_onewire_write($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 HEAP8[$3 + 6 | 0] = onewire_getpin(HEAP32[$3 + 12 >> 2]);
 label$1: {
  if (!(jshIsPinValid(HEAPU8[$3 + 6 | 0]) & 1)) {
   break label$1;
  }
  jsvIterateCallback(HEAP32[$3 + 8 >> 2], 649, $3 + 6 | 0);
  if (HEAP8[$3 + 7 | 0] & 1) {
   jshPinSetValue(HEAPU8[$3 + 6 | 0], 1);
   jshPinSetState(HEAPU8[$3 + 6 | 0], 1);
   break label$1;
  }
  jshPinSetState(HEAPU8[$3 + 6 | 0], 4);
  jshPinSetValue(HEAPU8[$3 + 6 | 0], 1);
 }
 __stack_pointer = $3 + 16 | 0;
}

function vfGetPolyPtr($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 HEAP8[$2 + 27 | 0] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (HEAPU8[$2 + 27 | 0] >= 201) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[HEAP32[$2 + 20 >> 2] >> 2] = HEAPU8[HEAPU8[$2 + 27 | 0] + 167904 | 0];
  HEAP32[$2 + 16 >> 2] = 168112;
  HEAP8[$2 + 15 | 0] = 0;
  while (1) {
   if (HEAPU8[$2 + 15 | 0] < HEAPU8[$2 + 27 | 0]) {
    HEAP32[$2 + 16 >> 2] = HEAPU8[HEAPU8[$2 + 15 | 0] + 167904 | 0] + HEAP32[$2 + 16 >> 2];
    HEAP8[$2 + 15 | 0] = HEAPU8[$2 + 15 | 0] + 1;
    continue;
   }
   break;
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
 }
 return HEAP32[$2 + 28 >> 2];
}

function heatshrink_decoder_finish($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 12 >> 2] = -1;
   break label$1;
  }
  label$3: {
   switch (HEAPU8[HEAP32[$1 + 8 >> 2] + 10 | 0]) {
   case 0:
    HEAP32[$1 + 12 >> 2] = !!HEAPU16[HEAP32[$1 + 8 >> 2] >> 1];
    break label$1;

   case 2:
   case 3:
   case 4:
   case 5:
    HEAP32[$1 + 12 >> 2] = !!HEAPU16[HEAP32[$1 + 8 >> 2] >> 1];
    break label$1;

   case 1:
    HEAP32[$1 + 12 >> 2] = !!HEAPU16[HEAP32[$1 + 8 >> 2] >> 1];
    break label$1;

   default:
    break label$3;
   }
  }
  HEAP32[$1 + 12 >> 2] = 1;
 }
 return HEAP32[$1 + 12 >> 2];
}

function lcdMemLCD_getPixel($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 16 >> 2] = (Math_imul(HEAP32[$3 + 24 >> 2], 3) + 16 | 0) + (Math_imul(HEAP32[$3 + 20 >> 2], 68) << 3);
 HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 16 >> 2] & 7;
 $0 = HEAP32[$3 + 16 >> 2] >> 3;
 HEAP16[$3 + 10 >> 1] = HEAPU8[$0 + 378848 | 0] | HEAPU8[$0 + 378849 | 0] << 8;
 HEAP32[$3 + 4 >> 2] = HEAPU16[$3 + 10 >> 1] >> HEAP32[$3 + 12 >> 2] & 7;
 return (HEAP32[$3 + 4 >> 2] & 1 ? 63488 : 0) | (HEAP32[$3 + 4 >> 2] & 2 ? 2016 : 0) | (HEAP32[$3 + 4 >> 2] & 4 ? 31 : 0);
}

function jsiChangeToHistory($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 HEAP32[$1 + 8 >> 2] = jsiGetHistoryLine(HEAP8[$1 + 15 | 0] & 1);
 label$1: {
  if (HEAP32[$1 + 8 >> 2]) {
   jsiReplaceInputLine(HEAP32[$1 + 8 >> 2]);
   jsvUnLock(HEAP32[$1 + 8 >> 2]);
   HEAP8[364429] = 1;
   break label$1;
  }
  if (!(HEAP8[$1 + 15 | 0] & 1)) {
   if (jsiShowInputLine() & 1) {
    jsiMoveCursorChar(HEAP32[91104], HEAP32[91106], 0);
    jsiConsoleEraseAfterCursor();
   }
   jsiInputLineCursorMoved();
   jsvUnLock(HEAP32[91104]);
   HEAP32[91104] = jsvNewFromEmptyString_5();
   HEAP32[91106] = 0;
  }
 }
 __stack_pointer = $1 + 16 | 0;
}

function tflite__micro__GetTensorShape_28TfLiteEvalTensor_20const__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 label$1: {
  if (!(HEAP32[HEAP32[$2 + 24 >> 2] + 4 >> 2] ? HEAP32[$2 + 24 >> 2] : 0)) {
   tflite__RuntimeShape__RuntimeShape_28_29($0);
   break label$1;
  }
  HEAP32[$2 + 20 >> 2] = HEAP32[HEAP32[$2 + 24 >> 2] + 4 >> 2];
  HEAP32[$2 + 16 >> 2] = HEAP32[HEAP32[$2 + 20 >> 2] >> 2];
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 20 >> 2] + 4;
  tflite__RuntimeShape__RuntimeShape_28int_2c_20int_20const__29($0, HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2]);
 }
 __stack_pointer = $2 + 32 | 0;
}

function signed_20char_20const__20std____2__min_signed_20char_2c_20std____2____less_signed_20char_2c_20signed_20char___28signed_20char_20const__2c_20signed_20char_20const__2c_20std____2____less_signed_20char_2c_20signed_20char__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1: {
  if (std____2____less_signed_20char_2c_20signed_20char___operator_28_29_28signed_20char_20const__2c_20signed_20char_20const__29_20const($2 + 8 | 0, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function signed_20char_20const__20std____2__max_signed_20char_2c_20std____2____less_signed_20char_2c_20signed_20char___28signed_20char_20const__2c_20signed_20char_20const__2c_20std____2____less_signed_20char_2c_20signed_20char__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1: {
  if (std____2____less_signed_20char_2c_20signed_20char___operator_28_29_28signed_20char_20const__2c_20signed_20char_20const__29_20const($2 + 8 | 0, HEAP32[$2 + 4 >> 2], HEAP32[$2 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function void_20const__20flatbuffers__Table__GetPointer_void_20const___28unsigned_20short_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP16[$2 + 8 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$2 + 10 >> 1]);
 HEAP32[$2 + 4 >> 2] = HEAPU16[$2 + 8 >> 1] + $0;
 label$1: {
  if (HEAPU16[$2 + 8 >> 1]) {
   $0 = HEAP32[$2 + 4 >> 2] + unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 4 >> 2]) | 0;
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function st_backref_count_lsb($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP8[$1 + 7 | 0] = 6;
 $2 = HEAP32[$1 + 8 >> 2];
 if (HEAPU8[$1 + 7 | 0] < 8) {
  $0 = HEAPU8[$1 + 7 | 0];
 } else {
  $0 = 8;
 }
 HEAP16[$1 + 4 >> 1] = get_bits($2, $0);
 label$3: {
  if (HEAPU16[$1 + 4 >> 1] == 65535) {
   HEAP32[$1 + 12 >> 2] = 5;
   break label$3;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP16[$0 + 4 >> 1] = HEAPU16[$1 + 4 >> 1] | HEAPU16[$0 + 4 >> 1];
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP16[$0 + 4 >> 1] = HEAPU16[$0 + 4 >> 1] + 1;
  HEAP32[$1 + 12 >> 2] = 6;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function wakeUpBangle($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = 0;
 if (!(!HEAP32[97751] | HEAP32[97749] & 65536)) {
  HEAP8[$1 + 11 | 0] = 1;
  HEAP32[97752] = HEAP32[97752] | 2;
 }
 if (!(!HEAP32[97753] | HEAP32[97749] & 131072)) {
  HEAP8[$1 + 11 | 0] = 1;
  HEAP32[97752] = HEAP32[97752] | 8;
 }
 if (!(!HEAP32[97754] | !(HEAP32[97749] & 262144))) {
  HEAP8[$1 + 11 | 0] = 1;
  HEAP32[97750] = HEAP32[$1 + 12 >> 2];
  HEAP32[97752] = HEAP32[97752] | 64;
 }
 if (HEAP8[$1 + 11 | 0] & 1) {
  HEAP16[195510] = 0;
  jshHadEvent();
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 11 | 0] & 1;
}

function jsvNewNativeFunction($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP16[$2 + 6 >> 1] = $1;
 HEAP32[$2 >> 2] = jsvNewWithFlags(8);
 label$1: {
  if (!HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$2 >> 2];
  $1 = HEAP32[$2 + 8 >> 2];
  HEAP8[$0 | 0] = $1;
  HEAP8[$0 + 1 | 0] = $1 >>> 8;
  HEAP8[$0 + 2 | 0] = $1 >>> 16;
  HEAP8[$0 + 3 | 0] = $1 >>> 24;
  $0 = HEAP32[$2 >> 2];
  $1 = HEAPU16[$2 + 6 >> 1];
  HEAP8[$0 + 4 | 0] = $1;
  HEAP8[$0 + 5 | 0] = $1 >>> 8;
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jsiExecuteEventCallbackName($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP8[$4 + 15 | 0] = 0;
 if (jsvHasChildren(HEAP32[$4 + 28 >> 2]) & 1) {
  HEAP32[$4 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2]);
  if (HEAP32[$4 + 8 >> 2]) {
   jsiExecuteEventCallback(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
   HEAP8[$4 + 15 | 0] = 1;
  }
  jsvUnLock(HEAP32[$4 + 8 >> 2]);
 }
 __stack_pointer = $4 + 32 | 0;
 return HEAP8[$4 + 15 | 0] & 1;
}

function jsvIsInt($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $0 = 1;
  label$3: {
   if (HEAP8[$1 + 7 | 0] == 10) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 13) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 15) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 16) {
    break label$3;
   }
   $0 = HEAP8[$1 + 7 | 0] == 17;
  }
  HEAP8[$1 + 15 | 0] = $0;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function bool_20std____2__operator___TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator_20bool_28_29_20const(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 & 1;
}

function bool_20std____2__operator___TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator_20bool_28_29_20const(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 & 1;
}

function espruino_snprintf_va($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 >> 2] = HEAP32[$4 + 28 >> 2];
 HEAP32[$4 + 4 >> 2] = 0;
 HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 24 >> 2];
 vcbprintf(8, $4, HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
 label$1: {
  if (HEAPU32[$4 + 4 >> 2] < HEAPU32[$4 + 8 >> 2]) {
   HEAP8[HEAP32[$4 >> 2] + HEAP32[$4 + 4 >> 2] | 0] = 0;
   break label$1;
  }
  HEAP8[HEAP32[$4 >> 2] + (HEAP32[$4 + 8 >> 2] - 1 | 0) | 0] = 0;
 }
 __stack_pointer = $4 + 32 | 0;
 return HEAP32[$4 + 4 >> 2];
}

function tflite__MatchingDim_28tflite__RuntimeShape_20const__2c_20int_2c_20tflite__RuntimeShape_20const__2c_20int_29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 label$1: {
  if ((tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2]) | 0) != (tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]) | 0)) {
   break label$1;
  }
 }
 $0 = tflite__RuntimeShape__Dims_28int_29_20const(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2]);
 __stack_pointer = $4 + 16 | 0;
 return $0;
}

function jshFlashErasePage($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 4144 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 4140 >> 2] = $0;
 if (jshFlashGetPage(HEAP32[$1 + 4140 >> 2], $1 + 4136 | 0, $1 + 4132 | 0) & 1) {
  memset($1 + 32 | 0, 255, 4096);
  HEAP32[$1 + 28 >> 2] = 196184;
  $0 = HEAP32[$1 + 28 >> 2];
  HEAP8[$1 + 24 | 0] = 105;
  HEAP8[$1 + 25 | 0] = 105;
  HEAP8[$1 + 26 | 0] = 105;
  HEAP8[$1 + 27 | 0] = 0;
  $2 = HEAP32[$1 + 4136 >> 2];
  HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 4132 >> 2];
  HEAP32[$1 + 4 >> 2] = $1 + 32;
  HEAP32[$1 >> 2] = $2 + -134217728;
  emscripten_asm_const_int($0 | 0, $1 + 24 | 0, $1 | 0) | 0;
 }
 __stack_pointer = $1 + 4144 | 0;
}

function jslReservedWordAsString($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 12 >> 2] - 138;
 while (1) {
  $0 = 0;
  $0 = HEAP32[$1 + 4 >> 2] > 0 ? HEAPU32[$1 + 8 >> 2] < 312 : $0;
  if ($0) {
   while (1) {
    $0 = 0;
    $0 = HEAP8[HEAP32[$1 + 8 >> 2] + 148272 | 0] ? HEAPU32[$1 + 8 >> 2] < 312 : $0;
    if ($0) {
     HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
     continue;
    }
    break;
   }
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
   HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] - 1;
   continue;
  }
  break;
 }
 return HEAP32[$1 + 8 >> 2] + 148272 | 0;
}

function tflite__SimpleMemoryAllocator__SimpleMemoryAllocator_28tflite__ErrorReporter__2c_20unsigned_20char__2c_20unsigned_20long_29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = HEAP32[$4 + 12 >> 2];
 tflite__SimpleMemoryAllocator__SimpleMemoryAllocator_28tflite__ErrorReporter__2c_20unsigned_20char__2c_20unsigned_20char__29($0, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 + 4 >> 2] + HEAP32[$4 >> 2] | 0);
 __stack_pointer = $4 + 16 | 0;
 return $0 | 0;
}

function i2c_get_address($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP8[HEAP32[$2 + 4 >> 2]] = 1;
 label$1: {
  if (jsvIsObject(HEAP32[$2 + 8 >> 2]) & 1) {
   HEAP32[$2 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 8 >> 2], 121718);
   if (HEAP32[$2 >> 2]) {
    $0 = jsvGetBoolAndUnLock(HEAP32[$2 >> 2]);
    HEAP8[HEAP32[$2 + 4 >> 2]] = $0 & 1;
   }
   HEAP32[$2 + 12 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 8 >> 2], 119858);
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvGetInteger(HEAP32[$2 + 8 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}
function jslGetTokenValueAsVar() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 label$1: {
  if (HEAP32[HEAP32[49079] + 76 >> 2]) {
   HEAP32[$0 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[49079] + 76 >> 2]);
   break label$1;
  }
  if (!(HEAP16[HEAP32[49079] + 2 >> 1] < 163 | HEAP16[HEAP32[49079] + 2 >> 1] > 198)) {
   HEAP32[$0 + 12 >> 2] = jsvNewFromString(jslReservedWordAsString(HEAP16[HEAP32[49079] + 2 >> 1]));
   break label$1;
  }
  HEAP8[HEAPU8[HEAP32[49079] + 80 | 0] + (HEAP32[49079] + 12 | 0) | 0] = 0;
  HEAP32[$0 + 12 >> 2] = jsvNewFromString(HEAP32[49079] + 12 | 0);
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function jswrap_string_concat($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 label$1: {
  if (!(jsvIsString(HEAP32[$2 + 24 >> 2]) & 1)) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 16 >> 2] = jsvNewFromStringVarComplete(HEAP32[$2 + 24 >> 2]);
  HEAP32[$2 + 12 >> 2] = jsvArrayJoin(HEAP32[$2 + 20 >> 2], 0, 0);
  jsvAppendStringVarComplete(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 12 >> 2]);
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 16 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jswrap_pin_writeAtTime($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = +$2;
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP8[$3 + 27 | 0] = $1;
 HEAPF64[$3 + 16 >> 3] = $2;
 HEAP8[$3 + 15 | 0] = jshGetPinFromVar(HEAP32[$3 + 28 >> 2]);
 $0 = jshGetTimeFromMilliseconds(HEAPF64[$3 + 16 >> 3] * 1e3);
 $4 = i64toi32_i32$HIGH_BITS;
 $1 = jshGetSystemTime();
 HEAP32[$3 >> 2] = $0 - $1;
 HEAP32[$3 + 4 >> 2] = $4 - (i64toi32_i32$HIGH_BITS + ($0 >>> 0 < $1 >>> 0) | 0);
 jstPinOutputAtTime(HEAP32[$3 >> 2], HEAP32[$3 + 4 >> 2], 0, $3 + 15 | 0, 1, HEAP8[$3 + 27 | 0] & 1);
 __stack_pointer = $3 + 32 | 0;
}

function jsvMoreFreeVariablesThan($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  HEAP16[$1 + 6 >> 1] = HEAPU16[98162];
  while (1) {
   if (HEAPU16[$1 + 6 >> 1]) {
    $0 = HEAP32[$1 + 8 >> 2];
    HEAP32[$1 + 8 >> 2] = $0 - 1;
    if ($0) {
     HEAP16[$1 + 6 >> 1] = jsvGetNextSibling(jsvGetAddressOf(HEAPU16[$1 + 6 >> 1]));
     continue;
    } else {
     HEAP8[$1 + 15 | 0] = 1;
     break label$1;
    }
   }
   break;
  }
  HEAP8[$1 + 15 | 0] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}

function jshFlashWrite($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 if (HEAPU32[$3 + 24 >> 2] >= 134217728) {
  HEAP32[$3 + 16 >> 2] = 196242;
  $0 = HEAP32[$3 + 16 >> 2];
  HEAP8[$3 + 12 | 0] = 105;
  HEAP8[$3 + 13 | 0] = 105;
  HEAP8[$3 + 14 | 0] = 105;
  HEAP8[$3 + 15 | 0] = 0;
  $1 = HEAP32[$3 + 24 >> 2];
  $2 = HEAP32[$3 + 28 >> 2];
  HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 20 >> 2];
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[$3 >> 2] = $1 + -134217728;
  emscripten_asm_const_int($0 | 0, $3 + 12 | 0, $3 | 0) | 0;
 }
 __stack_pointer = $3 + 32 | 0;
}

function bool_20std____2__operator___TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator_20bool_28_29_20const(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 & 1;
}

function bool_20std____2__operator___TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__28std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__20const__2c_20std__nullptr_t_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator_20bool_28_29_20const(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 & 1;
}

function jsvArrayBufferIteratorGetFloatValue($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 20 >> 2] = $0;
 label$1: {
  if (!HEAPU8[HEAP32[$1 + 20 >> 2] + 36 | 0]) {
   HEAPF64[$1 + 24 >> 3] = 0;
   break label$1;
  }
  jsvArrayBufferIteratorGetValueData(HEAP32[$1 + 20 >> 2], $1 + 12 | 0);
  if (HEAPU8[HEAP32[$1 + 20 >> 2] + 36 | 0] & 32) {
   HEAPF64[$1 + 24 >> 3] = jsvArrayBufferIteratorDataToFloat(HEAP32[$1 + 20 >> 2], $1 + 12 | 0);
   break label$1;
  }
  HEAPF64[$1 + 24 >> 3] = jsvArrayBufferIteratorDataToInt(HEAP32[$1 + 20 >> 2], $1 + 12 | 0) | 0;
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAPF64[$1 + 24 >> 3];
}

function int_sqrt32($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP16[$1 + 26 >> 1] = 0;
 HEAP16[$1 + 24 >> 1] = 32768;
 HEAP32[$1 + 20 >> 2] = 0;
 while (1) {
  if (HEAP32[$1 + 20 >> 2] < 16) {
   HEAP16[$1 + 18 >> 1] = HEAPU16[$1 + 26 >> 1] | HEAPU16[$1 + 24 >> 1];
   HEAP32[$1 + 12 >> 2] = Math_imul(HEAPU16[$1 + 18 >> 1], HEAPU16[$1 + 18 >> 1]);
   if (HEAPU32[$1 + 28 >> 2] >= HEAPU32[$1 + 12 >> 2]) {
    HEAP16[$1 + 26 >> 1] = HEAPU16[$1 + 18 >> 1];
   }
   HEAP16[$1 + 24 >> 1] = HEAPU16[$1 + 24 >> 1] >>> 1;
   HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 20 >> 2] + 1;
   continue;
  }
  break;
 }
 return HEAPU16[$1 + 26 >> 1];
}

function jsvHasSingleChild($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $0 = 1;
  if (HEAP8[$1 + 7 | 0] != 4) {
   $0 = 0;
   label$4: {
    if (HEAP8[$1 + 7 | 0] < 14) {
     break label$4;
    }
    $0 = 0;
    if (HEAP8[$1 + 7 | 0] > 27) {
     break label$4;
    }
    $2 = HEAP8[$1 + 7 | 0] >= 16 ? HEAP8[$1 + 7 | 0] <= 22 : $2;
    $0 = $2 ^ -1;
   }
  }
  HEAP8[$1 + 15 | 0] = $0 & 1;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function tflite__MicroAllocator__Create_28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 label$1: {
  if (!HEAP32[$2 + 12 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (!HEAP32[$2 + 8 >> 2]) {
   break label$2;
  }
 }
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 12 >> 2]]($0, 24, 4);
 $0 = HEAP32[$2 + 4 >> 2];
 FUNCTION_TABLE[682]($0, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]) | 0;
 HEAP32[$2 >> 2] = $0;
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 >> 2];
}

function jsserialCheckForCharacter($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAPU8[HEAP32[$1 + 12 >> 2] + 88 | 0] >= HEAPU8[HEAP32[$1 + 12 >> 2] + 89 | 0]) {
  HEAP32[$1 + 8 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 84 >> 2] >>> 1 & 255;
  if (HEAPU8[HEAP32[$1 + 12 >> 2] + 64 | 0] < 64) {
   $3 = HEAP32[$1 + 8 >> 2];
   $0 = HEAP32[$1 + 12 >> 2];
   $2 = HEAPU8[$0 + 64 | 0];
   HEAP8[$0 + 64 | 0] = $2 + 1;
   HEAP8[$0 + $2 | 0] = $3;
   jshHasEvents();
  }
  HEAP8[HEAP32[$1 + 12 >> 2] + 88 | 0] = 0;
  HEAP32[HEAP32[$1 + 12 >> 2] + 84 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
}

function jshPopIOEvent($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (HEAPU8[364486] == HEAPU8[364487]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  $2 = Math_imul(HEAPU8[364487], 5) + 365072 | 0;
  $3 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
  HEAP8[$0 | 0] = $3;
  HEAP8[$0 + 1 | 0] = $3 >>> 8;
  HEAP8[$0 + 2 | 0] = $3 >>> 16;
  HEAP8[$0 + 3 | 0] = $3 >>> 24;
  HEAP8[$0 + 4 | 0] = HEAPU8[$2 + 4 | 0];
  HEAP8[364487] = HEAPU8[364487] + 1;
  HEAP8[$1 + 15 | 0] = 1;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function jswrap_graphics_setFont12x20($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 if (HEAP32[$2 + 24 >> 2] <= 0) {
  HEAP32[$2 + 24 >> 2] = 1;
 }
 HEAP32[$2 + 20 >> 2] = jsvNewNativeString(183456, 4723);
 HEAP32[$2 + 16 >> 2] = jsvNewNativeString(188192, 224);
 HEAP32[$2 + 12 >> 2] = jswrap_graphics_setFontCustom(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], 32, HEAP32[$2 + 16 >> 2], (HEAP32[$2 + 24 >> 2] << 8) + 20 | 0);
 jsvUnLock2(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jswrap_graphics_setFont6x15($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 if (HEAP32[$2 + 24 >> 2] <= 0) {
  HEAP32[$2 + 24 >> 2] = 1;
 }
 HEAP32[$2 + 20 >> 2] = jsvNewNativeString(181376, 1842);
 HEAP32[$2 + 16 >> 2] = jsvNewNativeString(183232, 224);
 HEAP32[$2 + 12 >> 2] = jswrap_graphics_setFontCustom(HEAP32[$2 + 28 >> 2], HEAP32[$2 + 20 >> 2], 32, HEAP32[$2 + 16 >> 2], (HEAP32[$2 + 24 >> 2] << 8) + 15 | 0);
 jsvUnLock2(HEAP32[$2 + 20 >> 2], HEAP32[$2 + 16 >> 2]);
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jsvAsName($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  if (!(jsvGetRefs(HEAP32[$1 + 8 >> 2]) & 65535)) {
   if (!(jsvIsName(HEAP32[$1 + 8 >> 2]) & 1)) {
    HEAP32[$1 + 12 >> 2] = jsvMakeIntoVariableName(jsvLockAgain(HEAP32[$1 + 8 >> 2]), 0);
    break label$1;
   }
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvMakeIntoVariableName(jsvCopy(HEAP32[$1 + 8 >> 2], 0), 0);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function gemmlowp__FixedPoint_int_2c_202_20__202__20gemmlowp__operator__int_2c_202_2c_202__28gemmlowp__FixedPoint_int_2c_202__2c_20gemmlowp__FixedPoint_int_2c_202__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = int_20gemmlowp__SaturatingRoundingDoublingHighMul_int__28int_2c_20int_29(HEAP32[gemmlowp__FixedPoint_int_2c_202___raw_28_29($2 + 16 | 0) >> 2], HEAP32[gemmlowp__FixedPoint_int_2c_202___raw_28_29($2 + 8 | 0) >> 2]);
 HEAP32[gemmlowp__FixedPoint_int_2c_204___raw_28_29($2 + 24 | 0) >> 2] = $0;
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}

function gemmlowp__FixedPoint_int_2c_200_20__202__20gemmlowp__operator__int_2c_200_2c_202__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_202__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = int_20gemmlowp__SaturatingRoundingDoublingHighMul_int__28int_2c_20int_29(HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($2 + 16 | 0) >> 2], HEAP32[gemmlowp__FixedPoint_int_2c_202___raw_28_29($2 + 8 | 0) >> 2]);
 HEAP32[gemmlowp__FixedPoint_int_2c_202___raw_28_29($2 + 24 | 0) >> 2] = $0;
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}

function gemmlowp__FixedPoint_int_2c_200_20__200__20gemmlowp__operator__int_2c_200_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = int_20gemmlowp__SaturatingRoundingDoublingHighMul_int__28int_2c_20int_29(HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($2 + 16 | 0) >> 2], HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($2 + 8 | 0) >> 2]);
 HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($2 + 24 | 0) >> 2] = $0;
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}

function jswrap_graphics_drawCircleAA($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 96 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 88 >> 2] = $0;
 HEAP32[$4 + 84 >> 2] = $1;
 HEAP32[$4 + 80 >> 2] = $2;
 HEAP32[$4 + 76 >> 2] = $3;
 label$1: {
  if (!(graphicsGetFromVar($4, HEAP32[$4 + 88 >> 2]) & 1)) {
   HEAP32[$4 + 92 >> 2] = 0;
   break label$1;
  }
  graphicsDrawCircleAA($4, HEAP32[$4 + 84 >> 2], HEAP32[$4 + 80 >> 2], HEAP32[$4 + 76 >> 2]);
  graphicsSetVar($4);
  HEAP32[$4 + 92 >> 2] = jsvLockAgain(HEAP32[$4 + 88 >> 2]);
 }
 __stack_pointer = $4 + 96 | 0;
 return HEAP32[$4 + 92 >> 2];
}

function heatshrink_decoder_reset($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 256;
 HEAP32[$1 + 4 >> 2] = 32;
 memset(HEAP32[$1 + 12 >> 2] + 13 | 0, 0, HEAP32[$1 + 8 >> 2] + HEAP32[$1 + 4 >> 2] | 0);
 HEAP8[HEAP32[$1 + 12 >> 2] + 10 | 0] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] >> 1] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] + 2 >> 1] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 12 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 11 | 0] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] + 4 >> 1] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] + 6 >> 1] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] + 8 >> 1] = 0;
 __stack_pointer = $1 + 16 | 0;
}

function jsvMalloc($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvNewFlatStringOfLength(HEAP32[$1 + 12 >> 2]);
 if (!HEAP32[$1 + 8 >> 2]) {
  HEAP8[364342] = HEAPU8[364342] | 8;
  while (1) {
   if (jsiFreeMoreMemory() & 1) {
    continue;
   }
   break;
  }
  jsvGarbageCollect();
  HEAP32[$1 + 8 >> 2] = jsvNewFlatStringOfLength(HEAP32[$1 + 12 >> 2]);
 }
 HEAP32[$1 + 4 >> 2] = jsvGetFlatStringPointer(HEAP32[$1 + 8 >> 2]);
 if (HEAP32[$1 + 4 >> 2]) {
  memset(HEAP32[$1 + 4 >> 2], 0, HEAP32[$1 + 12 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 4 >> 2];
}

function wrapAround($0, $1) {
 $0 = +$0;
 $1 = +$1;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 32 | 0;
 HEAPF64[$2 + 16 >> 3] = $0;
 HEAPF64[$2 + 8 >> 3] = $1;
 label$1: {
  if (HEAPF64[$2 + 8 >> 3] < 0) {
   HEAPF64[$2 + 24 >> 3] = 0;
   break label$1;
  }
  HEAPF64[$2 + 16 >> 3] = HEAPF64[$2 + 16 >> 3] / HEAPF64[$2 + 8 >> 3];
  $0 = HEAPF64[$2 + 16 >> 3];
  $1 = HEAPF64[$2 + 16 >> 3];
  label$3: {
   if (Math_abs($1) < 2147483648) {
    $3 = ~~$1;
    break label$3;
   }
   $3 = -2147483648;
  }
  HEAPF64[$2 + 16 >> 3] = $0 - +($3 | 0);
  HEAPF64[$2 + 24 >> 3] = HEAPF64[$2 + 16 >> 3] * HEAPF64[$2 + 8 >> 3];
 }
 return +HEAPF64[$2 + 24 >> 3];
}

function jsiHandlePageUpDown($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 31 | 0] = $0;
 jsvGetLineAndCol(HEAP32[91104], HEAP32[91106], $1 + 20 | 0, $1 + 24 | 0);
 label$1: {
  if (!(HEAP8[$1 + 31 | 0] & 1)) {
   HEAP32[91106] = 0;
   break label$1;
  }
  HEAP32[91106] = jsvGetStringLength(HEAP32[91104]);
 }
 HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 24 >> 2];
 HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 20 >> 2];
 jsvGetLineAndCol(HEAP32[91104], HEAP32[91106], $1 + 12 | 0, $1 + 16 | 0);
 jsiMoveCursor(HEAP32[$1 + 24 >> 2], HEAP32[$1 + 20 >> 2], HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 32 | 0;
}

function st_yield_br_length($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (can_take_byte(HEAP32[$2 + 4 >> 2])) {
   if (push_outgoing_bits(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]) & 255) {
    HEAP32[$2 + 12 >> 2] = 6;
    break label$1;
   }
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP16[$0 + 2 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1] + HEAPU16[$0 + 2 >> 1];
   HEAP16[HEAP32[$2 + 8 >> 2] + 4 >> 1] = 0;
   HEAP32[$2 + 12 >> 2] = 2;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 6;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jshPushIOCharEvent($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 label$1: {
  if (jshPushIOCharEventHandler(HEAPU8[$2 + 15 | 0], HEAP8[$2 + 14 | 0]) & 1) {
   break label$1;
  }
  if (jshPushIOCharEventAppend(HEAPU8[$2 + 15 | 0], HEAP8[$2 + 14 | 0]) & 1) {
   break label$1;
  }
  HEAP8[$2 + 8 | 0] = HEAPU8[$2 + 15 | 0];
  HEAP8[$2 + 8 | 0] = HEAPU8[$2 + 8 | 0] & 159;
  HEAP8[$2 + 9 | 0] = HEAPU8[$2 + 14 | 0];
  jshPushEvent($2 + 8 | 0);
  jshPushIOCharEventFlowControl(HEAPU8[$2 + 15 | 0]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function jsvArrayPush($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = jsvGetArrayLength(HEAP32[$2 + 24 >> 2]);
 HEAP32[$2 + 12 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(HEAP32[$2 + 16 >> 2]), HEAP32[$2 + 20 >> 2]);
 label$1: {
  if (!HEAP32[$2 + 12 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  jsvAddName(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 12 >> 2]);
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  HEAP32[$2 + 28 >> 2] = jsvGetArrayLength(HEAP32[$2 + 24 >> 2]);
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jsvAddNamedChild($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = jsvNewNameFromString(HEAP32[$3 + 16 >> 2]);
 label$1: {
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$3 + 20 >> 2]) {
   jsvSetFirstChild(HEAP32[$3 + 12 >> 2], jsvGetRef(jsvRef(HEAP32[$3 + 20 >> 2])) & 65535);
  }
  jsvAddName(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 12 >> 2]);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jshTransmitFlushDevice($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jsiSetBusy(2, 1);
 HEAP8[$1 + 14 | 0] = 0;
 while (1) {
  HEAP8[$1 + 14 | 0] = 0;
  HEAP8[$1 + 13 | 0] = HEAPU8[364485];
  while (1) {
   if (HEAPU8[364484] != HEAPU8[$1 + 13 | 0]) {
    if (HEAPU8[$1 + 15 | 0] == (HEAPU8[(HEAPU8[$1 + 13 | 0] << 1) + 364560 | 0] & 31)) {
     HEAP8[$1 + 14 | 0] = 1;
    } else {
     HEAP8[$1 + 13 | 0] = HEAPU8[$1 + 13 | 0] + 1;
     continue;
    }
   }
   break;
  }
  if (HEAP8[$1 + 14 | 0] & 1) {
   continue;
  }
  break;
 }
 jsiSetBusy(2, 0);
 __stack_pointer = $1 + 16 | 0;
}

function float_20flatbuffers__Table__GetField_float__28unsigned_20short_2c_20float_29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP16[$3 + 10 >> 1] = $1;
 HEAPF32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP16[$3 + 2 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$3 + 10 >> 1]);
 label$1: {
  if (HEAPU16[$3 + 2 >> 1]) {
   $2 = float_20flatbuffers__ReadScalar_float__28void_20const__29(HEAPU16[$3 + 2 >> 1] + $0 | 0);
   break label$1;
  }
  $2 = HEAPF32[$3 + 4 >> 2];
 }
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function scalbn($0, $1) {
 label$1: {
  if (($1 | 0) >= 1024) {
   $0 = $0 * 898846567431158e293;
   if ($1 >>> 0 < 2047) {
    $1 = $1 - 1023 | 0;
    break label$1;
   }
   $0 = $0 * 898846567431158e293;
   $1 = (($1 | 0) < 3069 ? $1 : 3069) - 2046 | 0;
   break label$1;
  }
  if (($1 | 0) > -1023) {
   break label$1;
  }
  $0 = $0 * 2004168360008973e-307;
  if ($1 >>> 0 > 4294965304) {
   $1 = $1 + 969 | 0;
   break label$1;
  }
  $0 = $0 * 2004168360008973e-307;
  $1 = (($1 | 0) > -2960 ? $1 : -2960) + 1938 | 0;
 }
 wasm2js_scratch_store_i32(0, 0);
 wasm2js_scratch_store_i32(1, $1 + 1023 << 20);
 return $0 * +wasm2js_scratch_load_f64();
}

function heatshrink_encoder_reset($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 512;
 memset(HEAP32[$1 + 12 >> 2] + 15 | 0, 0, HEAP32[$1 + 8 >> 2]);
 HEAP16[HEAP32[$1 + 12 >> 2] >> 1] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 12 | 0] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] + 2 >> 1] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 11 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 14 | 0] = 128;
 HEAP8[HEAP32[$1 + 12 >> 2] + 13 | 0] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] + 4 >> 1] = 0;
 HEAP16[HEAP32[$1 + 12 >> 2] + 8 >> 1] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 10 | 0] = 0;
 __stack_pointer = $1 + 16 | 0;
}

function jstUtilTimerWaitEmpty() {
 var $0 = 0, $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = 2e6;
 while (1) {
  $0 = 0;
  label$2: {
   if (!(jstUtilTimerIsRunning() & 1)) {
    break label$2;
   }
   $0 = 0;
   if (jspIsInterrupted() & 1) {
    break label$2;
   }
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$1 + 12 >> 2] = $0 - 1;
   $0 = ($0 | 0) > 0;
  }
  if ($0) {
   continue;
  }
  break;
 }
 label$3: {
  if (jspIsInterrupted() & 1) {
   jsExceptionHere(4, 121089, 0);
   break label$3;
  }
  if (HEAP32[$1 + 12 >> 2] <= 0) {
   jsExceptionHere(4, 121064, 0);
  }
 }
 __stack_pointer = $1 + 16 | 0;
}

function lcdGetPixel_ArrayBuffer_flat1($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 24 >> 2] + Math_imul(HEAP32[$3 + 20 >> 2], HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8);
 $0 = HEAP32[$3 + 28 >> 2];
 HEAP8[$3 + 15 | 0] = HEAPU8[(HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) + (HEAP32[$3 + 16 >> 2] >> 3) | 0];
 return HEAPU8[$3 + 15 | 0] >> 7 - (HEAP32[$3 + 16 >> 2] & 7) & 1;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode___20const___28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode___20const___28unsigned_20short_29(HEAP32[$2 + 12 >> 2], HEAPU16[$2 + 10 >> 1]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jsvExecuteSetter($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (!(jsvIsGetterOrSetter(HEAP32[$3 + 8 >> 2]) & 1)) {
   break label$1;
  }
  HEAP32[$3 >> 2] = jsvObjectGetChildIfExists(HEAP32[$3 + 8 >> 2], 117878);
  if (!(jsvIsFunction(HEAP32[$3 >> 2]) & 1)) {
   jsvUnLock(HEAP32[$3 >> 2]);
   break label$1;
  }
  if (!HEAP32[$3 >> 2]) {
   break label$1;
  }
  jsvUnLock2(jspExecuteFunction(HEAP32[$3 >> 2], HEAP32[$3 + 12 >> 2], 1, $3 + 4 | 0), HEAP32[$3 >> 2]);
 }
 __stack_pointer = $3 + 16 | 0;
}

function jswrap_arguments() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = 0;
 if (HEAP32[91089]) {
  HEAP32[$0 + 8 >> 2] = jsvLockAgain(HEAP32[91089]);
 }
 label$2: {
  if (!(jsvIsFunction(HEAP32[$0 + 8 >> 2]) & 1)) {
   jsExceptionHere(1, 128238, 0);
   HEAP32[$0 + 12 >> 2] = 0;
   break label$2;
  }
  HEAP32[$0 + 4 >> 2] = jsvGetFunctionArgumentLength(HEAP32[$0 + 8 >> 2]);
  jsvObjectSetChild(HEAP32[$0 + 8 >> 2], 119698, HEAP32[$0 + 4 >> 2]);
  jsvUnLock(HEAP32[$0 + 8 >> 2]);
  HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2];
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function jsvSetArrayItem($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 >> 2] = jsvGetArrayIndex(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
 label$1: {
  if (HEAP32[$3 >> 2]) {
   jsvSetValueOfName(HEAP32[$3 >> 2], HEAP32[$3 + 4 >> 2]);
   break label$1;
  }
  HEAP32[$3 >> 2] = jsvMakeIntoVariableName(jsvNewFromInteger(HEAP32[$3 + 8 >> 2]), HEAP32[$3 + 4 >> 2]);
  if (HEAP32[$3 >> 2]) {
   jsvAddName(HEAP32[$3 + 12 >> 2], HEAP32[$3 >> 2]);
  }
 }
 jsvUnLock(HEAP32[$3 >> 2]);
 __stack_pointer = $3 + 16 | 0;
}

function jsvReplaceWithOrAddToRoot($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 label$1: {
  if (jsvGetRefs(HEAP32[$2 + 12 >> 2]) & 65535) {
   break label$1;
  }
  if (!(jsvIsName(HEAP32[$2 + 12 >> 2]) & 1)) {
   break label$1;
  }
  label$2: {
   if (jsvIsArrayBufferName(HEAP32[$2 + 12 >> 2]) & 1) {
    break label$2;
   }
   if (jsvIsNewChild(HEAP32[$2 + 12 >> 2]) & 1) {
    break label$2;
   }
   jsvAddName(HEAP32[91086], HEAP32[$2 + 12 >> 2]);
  }
 }
 jsvReplaceWith(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
}

function tflite__internal__ContextHelper__RequestScratchBufferInArena_28TfLiteContext__2c_20unsigned_20long_2c_20int__29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2];
 $0 = tflite__MicroAllocator__RequestScratchBufferInArena_28int_2c_20unsigned_20long_2c_20int__29(HEAP32[HEAP32[$3 >> 2] >> 2], HEAP32[HEAP32[$3 >> 2] + 16 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function jswrap_btoa_encode($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] & 63;
 label$1: {
  if (HEAP32[$1 + 8 >> 2] < 26) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] + 65;
   break label$1;
  }
  if (HEAP32[$1 + 8 >> 2] < 52) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] + 71;
   break label$1;
  }
  if (HEAP32[$1 + 8 >> 2] < 62) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] - 4;
   break label$1;
  }
  if (HEAP32[$1 + 8 >> 2] == 62) {
   HEAP32[$1 + 12 >> 2] = 43;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 47;
 }
 return HEAP32[$1 + 12 >> 2];
}

function jspeArrowFunction($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jslGetNextToken();
 if ((HEAP32[91094] & 63) == 1) {
  HEAP32[$2 + 12 >> 2] = jspeAddNamedFunctionParameter(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 }
 HEAP8[$2 + 7 | 0] = HEAP16[HEAP32[49079] + 2 >> 1] != 123;
 HEAP8[$2 + 6 | 0] = jspeFunctionDefinitionInternal(HEAP32[$2 + 12 >> 2], HEAP8[$2 + 7 | 0] & 1) & 1;
 if (HEAP8[$2 + 6 | 0] & 1) {
  jsvObjectSetChild(HEAP32[$2 + 12 >> 2], 120157, HEAP32[91092]);
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function _jswrap_prombox_all_reject($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 12 >> 2], 128686);
 if (HEAP32[$2 + 4 >> 2]) {
  HEAP32[$2 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 4 >> 2], 120220);
  if (HEAP32[$2 >> 2]) {
   jsvUnLock(HEAP32[$2 >> 2]);
   jsvObjectRemoveChild(HEAP32[$2 + 4 >> 2], 120220);
   _jswrap_prombox_queuereject(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
  }
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP16[$3 + 10 >> 1] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP16[$3 + 2 >> 1] = flatbuffers__Table__GetOptionalFieldOffset_28unsigned_20short_29_20const($0, HEAPU16[$3 + 10 >> 1]);
 label$1: {
  if (HEAPU16[$3 + 2 >> 1]) {
   $0 = int_20flatbuffers__ReadScalar_int__28void_20const__29(HEAPU16[$3 + 2 >> 1] + $0 | 0);
   break label$1;
  }
  $0 = HEAP32[$3 + 4 >> 2];
 }
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function _jswrap_error_constructor($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 >> 2] = jspNewObject(0, HEAP32[$2 + 4 >> 2]);
 label$1: {
  if (!HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$2 + 8 >> 2]) {
   jsvObjectSetChildAndUnLock(HEAP32[$2 >> 2], 132672, jsvAsString(HEAP32[$2 + 8 >> 2]));
  }
  jsvObjectSetChildAndUnLock(HEAP32[$2 >> 2], 132338, jsvNewFromString(HEAP32[$2 + 4 >> 2]));
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jsfGetAddressOfNextPage($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 label$1: {
  if (!(jshFlashGetPage(HEAP32[$1 + 24 >> 2], $1 + 20 | 0, $1 + 16 | 0) & 1)) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsfGetBankEndAddress(HEAP32[$1 + 24 >> 2]);
  HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 20 >> 2] + HEAP32[$1 + 16 >> 2];
  if (HEAPU32[$1 + 24 >> 2] >= HEAPU32[$1 + 12 >> 2]) {
   HEAP32[$1 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 24 >> 2];
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__AddSaturatingIf16Bit_int_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromRaw_28int_29(int_20gemmlowp__AddSaturatingIf16Bit_int__28int_2c_20int_29(HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($2 + 16 | 0) >> 2], HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($2 + 8 | 0) >> 2]));
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}

function espruino_snprintf_cb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 while (1) {
  if (HEAPU8[HEAP32[$2 + 12 >> 2]]) {
   if (HEAPU32[HEAP32[$2 + 4 >> 2] + 4 >> 2] < HEAPU32[HEAP32[$2 + 4 >> 2] + 8 >> 2]) {
    HEAP8[HEAP32[HEAP32[$2 + 4 >> 2] >> 2] + HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] | 0] = HEAPU8[HEAP32[$2 + 12 >> 2]];
   }
   $0 = HEAP32[$2 + 4 >> 2];
   HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
}

function jswrap_storage_erase($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer + -64 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 60 >> 2] = $0;
 jsfNameFromVar($1 + 32 | 0, HEAP32[$1 + 60 >> 2]);
 HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 56 >> 2];
 $2 = HEAP32[$1 + 52 >> 2];
 $0 = HEAP32[$1 + 48 >> 2];
 HEAP32[$1 + 16 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = $2;
 $0 = HEAP32[$1 + 44 >> 2];
 $2 = HEAP32[$1 + 40 >> 2];
 HEAP32[$1 + 8 >> 2] = $2;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = HEAP32[$1 + 36 >> 2];
 $0 = HEAP32[$1 + 32 >> 2];
 HEAP32[$1 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = $2;
 jsfEraseFile($1);
 __stack_pointer = $1 - -64 | 0;
}

function jsvVarPrintf($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP32[$2 + 52 >> 2] = jsvNewFromEmptyString_1();
 label$1: {
  if (!HEAP32[$2 + 52 >> 2]) {
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  jsvStringIteratorNew($2 + 16 | 0, HEAP32[$2 + 52 >> 2], 0);
  jsvStringIteratorGotoEnd($2 + 16 | 0);
  HEAP32[$2 + 12 >> 2] = $1;
  vcbprintf(2, $2 + 16 | 0, HEAP32[$2 + 56 >> 2], HEAP32[$2 + 12 >> 2]);
  jsvStringIteratorFree_1($2 + 16 | 0);
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 52 >> 2];
 }
 __stack_pointer = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}

function graphicsSetVar($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 116422));
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   __memcpy(366800, HEAP32[$1 + 12 >> 2], 72);
   break label$1;
  }
  if (!HEAP32[$1 + 8 >> 2]) {
   break label$1;
  }
  jsvSetString(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2] + 4 | 0, 44);
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
}

function graphicsFillRect($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = __stack_pointer - 32 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 28 >> 2] = $0;
 HEAP32[$6 + 24 >> 2] = $1;
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $5;
 graphicsToDeviceCoordinates(HEAP32[$6 + 28 >> 2], $6 + 24 | 0, $6 + 20 | 0);
 graphicsToDeviceCoordinates(HEAP32[$6 + 28 >> 2], $6 + 16 | 0, $6 + 12 | 0);
 graphicsFillRectDevice(HEAP32[$6 + 28 >> 2], HEAP32[$6 + 24 >> 2], HEAP32[$6 + 20 >> 2], HEAP32[$6 + 16 >> 2], HEAP32[$6 + 12 >> 2], HEAP32[$6 + 8 >> 2]);
 __stack_pointer = $6 + 32 | 0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph___20const___28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph___20const___28unsigned_20short_29(HEAP32[$2 + 12 >> 2], HEAPU16[$2 + 10 >> 1]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Operator___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Operator___20const___28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__Operator___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Operator___20const___28unsigned_20short_29(HEAP32[$2 + 12 >> 2], HEAPU16[$2 + 10 >> 1]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Metadata___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Metadata___20const___28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__Metadata___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Metadata___20const___28unsigned_20short_29(HEAP32[$2 + 12 >> 2], HEAPU16[$2 + 10 >> 1]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function tflite__SimpleMemoryAllocator__SimpleMemoryAllocator_28tflite__ErrorReporter__2c_20unsigned_20char__2c_20unsigned_20char__29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP32[$0 >> 2] = 189224;
 HEAP32[$0 + 4 >> 2] = HEAP32[$4 + 8 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[$4 + 4 >> 2];
 HEAP32[$0 + 12 >> 2] = HEAP32[$4 >> 2];
 HEAP32[$0 + 16 >> 2] = HEAP32[$4 + 4 >> 2];
 HEAP32[$0 + 20 >> 2] = HEAP32[$4 >> 2];
 HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 8 >> 2];
 return $0;
}

function jswrap_date_setTime($0, $1) {
 $0 = $0 | 0;
 $1 = +$1;
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 20 >> 2] = $0;
 HEAPF64[$2 + 8 >> 3] = $1;
 label$1: {
  if (HEAPF64[$2 + 8 >> 3] >= 393840543168e5 ? 1 : HEAPF64[$2 + 8 >> 3] < -395083256832e5) {
   jsExceptionHere(1, 120451, 0);
   HEAPF64[$2 + 24 >> 3] = 0;
   break label$1;
  }
  if (HEAP32[$2 + 20 >> 2]) {
   jsvObjectSetChildAndUnLock(HEAP32[$2 + 20 >> 2], 120133, jsvNewFromFloat(HEAPF64[$2 + 8 >> 3]));
  }
  HEAPF64[$2 + 24 >> 3] = HEAPF64[$2 + 8 >> 3];
 }
 __stack_pointer = $2 + 32 | 0;
 return +HEAPF64[$2 + 24 >> 3];
}

function jsvArrayBufferIteratorIntToData($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 if (HEAP32[$4 + 4 >> 2] & 64) {
  if (HEAP32[$4 >> 2] < 0) {
   HEAP32[$4 >> 2] = 0;
  }
  if (HEAP32[$4 >> 2] > 255) {
   HEAP32[$4 >> 2] = 255;
  }
 }
 label$4: {
  if (HEAP32[$4 + 8 >> 2] == 8) {
   $0 = HEAP32[$4 >> 2];
   $2 = $0 >> 31;
   $1 = $0;
   $0 = HEAP32[$4 + 12 >> 2];
   HEAP32[$0 >> 2] = $1;
   HEAP32[$0 + 4 >> 2] = $2;
   break label$4;
  }
  HEAP32[HEAP32[$4 + 12 >> 2] >> 2] = HEAP32[$4 >> 2];
 }
}

function lcdMemLCD_setCallbacks($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 + 52 | 0] = 92;
 HEAP8[$0 + 53 | 0] = 2;
 HEAP8[$0 + 54 | 0] = 0;
 HEAP8[$0 + 55 | 0] = 0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 + 56 | 0] = 93;
 HEAP8[$0 + 57 | 0] = 2;
 HEAP8[$0 + 58 | 0] = 0;
 HEAP8[$0 + 59 | 0] = 0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 + 60 | 0] = 94;
 HEAP8[$0 + 61 | 0] = 2;
 HEAP8[$0 + 62 | 0] = 0;
 HEAP8[$0 + 63 | 0] = 0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 + 68 | 0] = 95;
 HEAP8[$0 + 69 | 0] = 2;
 HEAP8[$0 + 70 | 0] = 0;
 HEAP8[$0 + 71 | 0] = 0;
}

function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__RoundingHalfSum_int_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromRaw_28int_29(int_20gemmlowp__RoundingHalfSum_int__28int_2c_20int_29(HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($2 + 16 | 0) >> 2], HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($2 + 8 | 0) >> 2]));
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}

function jspeFactorTypeOf() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 jslGetNextToken();
 HEAP32[$0 + 12 >> 2] = jspeUnaryExpression();
 HEAP32[$0 + 8 >> 2] = 0;
 if ((HEAP32[91094] & 63) == 1) {
  label$2: {
   if (!(jsvIsVariableDefined(HEAP32[$0 + 12 >> 2]) & 1)) {
    HEAP32[$0 + 8 >> 2] = jsvNewFromString(133948);
    break label$2;
   }
   HEAP32[$0 + 12 >> 2] = jsvSkipNameAndUnLock(HEAP32[$0 + 12 >> 2]);
   HEAP32[$0 + 8 >> 2] = jsvNewFromString(jsvGetTypeOf(HEAP32[$0 + 12 >> 2]));
  }
 }
 jsvUnLock(HEAP32[$0 + 12 >> 2]);
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 8 >> 2];
}

function jsvStringIteratorGoto($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (HEAPU32[$3 + 4 >> 2] >= HEAPU32[HEAP32[$3 + 12 >> 2] + 8 >> 2]) {
   HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[$3 + 4 >> 2] - HEAP32[HEAP32[$3 + 12 >> 2] + 8 >> 2];
   jsvStringIteratorCatchUp(HEAP32[$3 + 12 >> 2]);
   break label$1;
  }
  jsvStringIteratorFree_2(HEAP32[$3 + 12 >> 2]);
  jsvStringIteratorNew(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 }
 __stack_pointer = $3 + 16 | 0;
}

function jsvAddressToVar($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (!HEAP32[$2 + 4 >> 2]) {
   HEAP32[$2 + 12 >> 2] = jsvNewFromEmptyString_4();
   break label$1;
  }
  HEAP32[$2 >> 2] = jshFlashGetMemMapAddress(HEAP32[$2 + 8 >> 2]);
  if (!HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = jsvNewFlashString(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvNewNativeString(HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function tflite__micro__GetMutableEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (!HEAP32[$3 + 12 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (!HEAP32[$3 + 8 >> 2]) {
   break label$2;
  }
 }
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 12 >> 2] + 84 >> 2]](HEAP32[$3 + 12 >> 2], HEAP32[(HEAP32[HEAP32[$3 + 8 >> 2] >> 2] + 4 | 0) + (HEAP32[$3 + 4 >> 2] << 2) >> 2]) | 0;
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function i2c_initstruct($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP8[HEAP32[$2 + 12 >> 2] + 1 | 0] = HEAPU8[HEAP32[$2 + 8 >> 2] + 5 | 0];
 HEAP8[HEAP32[$2 + 12 >> 2]] = HEAPU8[HEAP32[$2 + 8 >> 2] + 4 | 0];
 HEAP8[HEAP32[$2 + 12 >> 2] + 2 | 0] = HEAP8[HEAP32[$2 + 8 >> 2] + 6 | 0] & 1;
 $0 = HEAP32[$2 + 8 >> 2];
 HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2] = 25e4 / (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24));
 HEAP32[HEAP32[$2 + 12 >> 2] + 8 >> 2] = HEAP8[HEAP32[$2 + 8 >> 2] + 7 | 0] & 1 ? 1e5 : 0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor___20const___28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor___20const___28unsigned_20short_29(HEAP32[$2 + 12 >> 2], HEAPU16[$2 + 10 >> 1]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer___20const___28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer___20const___28unsigned_20short_29(HEAP32[$2 + 12 >> 2], HEAPU16[$2 + 10 >> 1]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jswrap_array_indexOf($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = jsvGetIndexOfFull(HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], 0, 1, HEAP32[$3 + 16 >> 2]);
 label$1: {
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = jsvNewFromInteger(-1);
   break label$1;
  }
  HEAP32[$3 + 28 >> 2] = jsvNewFromInteger(jsvGetIntegerAndUnLock(HEAP32[$3 + 12 >> 2]));
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function tflite__micro__GetEvalOutput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (!HEAP32[$3 + 12 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (!HEAP32[$3 + 8 >> 2]) {
   break label$2;
  }
 }
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 12 >> 2] + 84 >> 2]](HEAP32[$3 + 12 >> 2], HEAP32[(HEAP32[HEAP32[$3 + 8 >> 2] + 4 >> 2] + 4 | 0) + (HEAP32[$3 + 4 >> 2] << 2) >> 2]) | 0;
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function jswrap_espruino_toUint8Array($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 80 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 72 >> 2] = $0;
 HEAP32[$1 + 68 >> 2] = jsvNewTypedArray(1, jsvIterateCallbackCount(HEAP32[$1 + 72 >> 2]));
 label$1: {
  if (!HEAP32[$1 + 68 >> 2]) {
   HEAP32[$1 + 76 >> 2] = 0;
   break label$1;
  }
  jsvArrayBufferIteratorNew($1 + 8 | 0, HEAP32[$1 + 68 >> 2], 0);
  jsvIterateCallback(HEAP32[$1 + 72 >> 2], 627, $1 + 8 | 0);
  jsvArrayBufferIteratorFree($1 + 8 | 0);
  HEAP32[$1 + 76 >> 2] = HEAP32[$1 + 68 >> 2];
 }
 __stack_pointer = $1 + 80 | 0;
 return HEAP32[$1 + 76 >> 2];
}

function jswrap_isFinite($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAPF64[$1 + 16 >> 3] = jsvGetFloat(HEAP32[$1 + 28 >> 2]);
 $2 = __DOUBLE_BITS_4(HEAPF64[$1 + 16 >> 3]);
 $0 = $2;
 $3 = i64toi32_i32$HIGH_BITS;
 $2 = $3 & 2147483647;
 $3 = $0;
 $0 = 0;
 label$1: {
  if (($2 | 0) == 2146435072 & ($3 | 0) != 0 | $2 >>> 0 > 2146435072) {
   break label$1;
  }
  $0 = 0;
  if (HEAPF64[$1 + 16 >> 3] == infinity) {
   break label$1;
  }
  $0 = HEAPF64[$1 + 16 >> 3] != -infinity;
 }
 __stack_pointer = $1 + 32 | 0;
 return $0 | 0;
}

function jsiAtEndOfInputLine() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = HEAP32[91106];
 HEAP32[$0 + 4 >> 2] = jsvGetStringLength(HEAP32[91104]);
 label$1: {
  while (1) {
   if (HEAPU32[$0 + 8 >> 2] < HEAPU32[$0 + 4 >> 2]) {
    if (isWhitespace(jsvGetCharInString(HEAP32[91104], HEAP32[$0 + 8 >> 2]) << 24 >> 24) & 1) {
     HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 1;
     continue;
    } else {
     HEAP8[$0 + 15 | 0] = 0;
     break label$1;
    }
   }
   break;
  }
  HEAP8[$0 + 15 | 0] = 1;
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP8[$0 + 15 | 0] & 1;
}

function frexp($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 wasm2js_scratch_store_f64(+$0);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 $3 = wasm2js_scratch_load_i32(0) | 0;
 $4 = $2;
 $2 = $2 >>> 20 & 2047;
 if (($2 | 0) != 2047) {
  if (!$2) {
   if ($0 == 0) {
    $2 = 0;
   } else {
    $0 = frexp($0 * 0x10000000000000000, $1);
    $2 = HEAP32[$1 >> 2] + -64 | 0;
   }
   HEAP32[$1 >> 2] = $2;
   return $0;
  }
  HEAP32[$1 >> 2] = $2 - 1022;
  $2 = $3;
  wasm2js_scratch_store_i32(0, $2 | 0);
  $2 = $4 & -2146435073 | 1071644672;
  wasm2js_scratch_store_i32(1, $2 | 0);
  $0 = +wasm2js_scratch_load_f64();
 }
 return $0;
}

function st_yield_br_index($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (can_take_byte(HEAP32[$2 + 4 >> 2])) {
   if (push_outgoing_bits(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]) & 255) {
    HEAP32[$2 + 12 >> 2] = 5;
    break label$1;
   }
   HEAP16[HEAP32[$2 + 8 >> 2] + 8 >> 1] = HEAPU16[HEAP32[$2 + 8 >> 2] + 4 >> 1] - 1;
   HEAP8[HEAP32[$2 + 8 >> 2] + 10 | 0] = 6;
   HEAP32[$2 + 12 >> 2] = 6;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 5;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jsvSetArrayLength($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 label$1: {
  if (!(HEAP8[$3 + 7 | 0] & 1)) {
   break label$1;
  }
  $0 = HEAP32[$3 + 12 >> 2];
  if (HEAP32[$3 + 8 >> 2] >= (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24))) {
   break label$1;
  }
 }
 $0 = HEAP32[$3 + 12 >> 2];
 $1 = HEAP32[$3 + 8 >> 2];
 HEAP8[$0 | 0] = $1;
 HEAP8[$0 + 1 | 0] = $1 >>> 8;
 HEAP8[$0 + 2 | 0] = $1 >>> 16;
 HEAP8[$0 + 3 | 0] = $1 >>> 24;
 return HEAP32[$3 + 8 >> 2];
}

function mbedtls_sha1_processR($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] & 15) << 2) >> 2] ^ (HEAP32[HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] - 14 & 15) << 2) >> 2] ^ (HEAP32[HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] - 3 & 15) << 2) >> 2] ^ HEAP32[HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] - 8 & 15) << 2) >> 2]));
 $0 = HEAP32[$2 + 4 >> 2] << 1 | HEAP32[$2 + 4 >> 2] >>> 31;
 HEAP32[HEAP32[$2 + 12 >> 2] + ((HEAP32[$2 + 8 >> 2] & 15) << 2) >> 2] = $0;
 return $0;
}

function jswrap_date_setSeconds($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 getTimeFromDateVar($3 + 8 | 0, HEAP32[$3 + 44 >> 2], 0);
 HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 40 >> 2];
 if (jsvIsNumeric(HEAP32[$3 + 36 >> 2]) & 1) {
  HEAP32[$3 + 12 >> 2] = jsvGetInteger(HEAP32[$3 + 36 >> 2]);
 }
 setCorrectTimeZone($3 + 8 | 0);
 $4 = jswrap_date_setTime(HEAP32[$3 + 44 >> 2], fromTimeInDay($3 + 8 | 0));
 __stack_pointer = $3 + 48 | 0;
 return +$4;
}

function jspeAddNamedFunctionParameter($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 96 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 92 >> 2] = $0;
 HEAP32[$2 + 88 >> 2] = $1;
 if (!HEAP32[$2 + 92 >> 2]) {
  HEAP32[$2 + 92 >> 2] = jsvNewWithFlags(7);
 }
 if (HEAP32[$2 + 88 >> 2]) {
  HEAP8[$2 + 16 | 0] = 255;
  jsvGetString(HEAP32[$2 + 88 >> 2], $2 + 17 | 0, 64);
  HEAP32[$2 + 12 >> 2] = jsvAddNamedChild(HEAP32[$2 + 92 >> 2], 0, $2 + 16 | 0);
  HEAP32[$2 + 12 >> 2] = jsvMakeFunctionParameter(HEAP32[$2 + 12 >> 2]);
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
 }
 __stack_pointer = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}

function jshUSARTInitInfo($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 | 0] = 128;
 HEAP8[$0 + 1 | 0] = 37;
 HEAP8[$0 + 2 | 0] = 0;
 HEAP8[$0 + 3 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 4 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 5 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 6 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 7 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 8 | 0] = 8;
 HEAP8[HEAP32[$1 + 12 >> 2] + 9 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 10 | 0] = 1;
 HEAP8[HEAP32[$1 + 12 >> 2] + 11 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 12 | 0] = 0;
}

function jswrap_stream_available($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 8 >> 2], 130086);
  HEAP32[$1 >> 2] = 0;
  if (jsvIsString(HEAP32[$1 + 4 >> 2]) & 1) {
   HEAP32[$1 >> 2] = jsvGetStringLength(HEAP32[$1 + 4 >> 2]);
  }
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__operator__int_2c_2012__28gemmlowp__FixedPoint_int_2c_2012__2c_20gemmlowp__FixedPoint_int_2c_2012__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromRaw_28int_29(int_20gemmlowp__Add_int__28int_2c_20int_29(HEAP32[gemmlowp__FixedPoint_int_2c_2012___raw_28_29($2 + 16 | 0) >> 2], HEAP32[gemmlowp__FixedPoint_int_2c_2012___raw_28_29($2 + 8 | 0) >> 2]));
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}

function jshSPIInitInfo($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 | 0] = 160;
 HEAP8[$0 + 1 | 0] = 134;
 HEAP8[$0 + 2 | 0] = 1;
 HEAP8[$0 + 3 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 4 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 5 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 6 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 7 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 8 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 9 | 0] = 1;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 + 10 | 0] = 8;
 HEAP8[$0 + 11 | 0] = 0;
 HEAP8[$0 + 12 | 0] = 0;
 HEAP8[$0 + 13 | 0] = 0;
}

function gemmlowp__FixedPoint_int_2c_205__20gemmlowp__operator__int_2c_205__28gemmlowp__FixedPoint_int_2c_205__2c_20gemmlowp__FixedPoint_int_2c_205__29_1($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[gemmlowp__FixedPoint_int_2c_205___raw_28_29($2 + 16 | 0) >> 2], HEAP32[gemmlowp__FixedPoint_int_2c_205___raw_28_29($2 + 8 | 0) >> 2]));
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}

function memcpy_circular($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 32 | 0;
 HEAP32[$5 + 28 >> 2] = $0;
 HEAP32[$5 + 24 >> 2] = $1;
 HEAP32[$5 + 20 >> 2] = $2;
 HEAP32[$5 + 16 >> 2] = $3;
 HEAP32[$5 + 12 >> 2] = $4;
 while (1) {
  $0 = HEAP32[$5 + 12 >> 2];
  HEAP32[$5 + 12 >> 2] = $0 - 1;
  if ($0) {
   $0 = HEAP32[$5 + 16 >> 2];
   HEAP32[$5 + 16 >> 2] = $0 + 1;
   HEAP8[HEAP32[$5 + 28 >> 2] + HEAP32[HEAP32[$5 + 24 >> 2] >> 2] | 0] = HEAPU8[$0 | 0];
   HEAP32[HEAP32[$5 + 24 >> 2] >> 2] = (HEAP32[HEAP32[$5 + 24 >> 2] >> 2] + 1 >>> 0) % HEAPU32[$5 + 20 >> 2];
   continue;
  }
  break;
 }
}

function jsvIsEqual($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  label$2: {
   if (!(jsvIsBasic(HEAP32[$2 + 8 >> 2]) & 1)) {
    break label$2;
   }
   if (!(jsvIsBasic(HEAP32[$2 + 4 >> 2]) & 1)) {
    break label$2;
   }
   HEAP8[$2 + 15 | 0] = jsvIsBasicVarEqual(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]) & 1;
   break label$1;
  }
  HEAP8[$2 + 15 | 0] = (jsvGetRef(HEAP32[$2 + 8 >> 2]) & 65535) == (jsvGetRef(HEAP32[$2 + 4 >> 2]) & 65535);
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP8[$2 + 15 | 0] & 1;
}

function jswrap_banglejs_setLCDBrightness($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = HEAPF64[$1 + 8 >> 3] * 256 + .5;
 label$1: {
  if (Math_abs($0) < 2147483648) {
   $2 = ~~$0;
   break label$1;
  }
  $2 = -2147483648;
 }
 HEAP32[$1 + 4 >> 2] = $2;
 if (HEAP32[$1 + 4 >> 2] < 0) {
  HEAP32[$1 + 4 >> 2] = 0;
 }
 if (HEAP32[$1 + 4 >> 2] > 255) {
  HEAP32[$1 + 4 >> 2] = 255;
 }
 HEAP8[391062] = HEAP32[$1 + 4 >> 2];
 if (HEAP32[97749] & 131072) {
  jswrap_banglejs_setLCDPowerBacklight(1);
 }
 __stack_pointer = $1 + 16 | 0;
}

function jsbangle_exec_pending($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP16[$1 + 10 >> 1] = HEAPU8[$0 + 2 | 0] << 8 | HEAPU8[$0 + 3 | 0];
 if (!HEAP8[HEAP32[$1 + 12 >> 2] + 1 | 0]) {
  HEAP32[$1 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[91086], 132487);
  if (HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 >> 2] = jsvNewFromInteger(HEAPU16[$1 + 10 >> 1]);
   jsiQueueObjectCallbacks(HEAP32[$1 + 4 >> 2], 116777, $1, 1);
   jsvUnLock(HEAP32[$1 >> 2]);
  }
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
}

function gemmlowp__FixedPoint_int_2c_202__20gemmlowp__operator__int_2c_202__28gemmlowp__FixedPoint_int_2c_202__2c_20gemmlowp__FixedPoint_int_2c_202__29_1($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_202___FromRaw_28int_29(int_20gemmlowp__Sub_int__28int_2c_20int_29(HEAP32[gemmlowp__FixedPoint_int_2c_202___raw_28_29($2 + 16 | 0) >> 2], HEAP32[gemmlowp__FixedPoint_int_2c_202___raw_28_29($2 + 8 | 0) >> 2]));
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}

function tflite___28anonymous_20namespace_29__CheckParsePointerParams_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 label$1: {
  if (!HEAP32[$4 + 12 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (!HEAP32[$4 + 8 >> 2]) {
   break label$2;
  }
 }
 label$3: {
  if (!HEAP32[$4 + 4 >> 2]) {
   break label$3;
  }
 }
 label$4: {
  if (!HEAP32[$4 >> 2]) {
   break label$4;
  }
 }
}

function tflite__RuntimeShape__FlatSize_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = 1;
 HEAP32[$1 + 4 >> 2] = tflite__RuntimeShape__DimsData_28_29_20const($0);
 HEAP32[$1 >> 2] = 0;
 while (1) {
  if (HEAP32[$1 >> 2] < HEAP32[$0 >> 2]) {
   HEAP32[$1 + 8 >> 2] = Math_imul(HEAP32[HEAP32[$1 + 4 >> 2] + (HEAP32[$1 >> 2] << 2) >> 2], HEAP32[$1 + 8 >> 2]);
   HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jshPinSetValue($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 31 | 0] = $0;
 HEAP8[$2 + 30 | 0] = $1;
 if (HEAPU8[Math_imul(HEAPU8[$2 + 31 | 0], 3) + 180752 | 0] & 16) {
  HEAP8[$2 + 30 | 0] = (HEAPU8[$2 + 30 | 0] ^ -1) & 1;
 }
 HEAP32[$2 + 24 >> 2] = 196107;
 $0 = HEAP32[$2 + 24 >> 2];
 HEAP8[$2 + 21 | 0] = 105;
 HEAP8[$2 + 22 | 0] = 105;
 HEAP8[$2 + 23 | 0] = 0;
 $1 = HEAPU8[$2 + 31 | 0];
 HEAP32[$2 + 4 >> 2] = HEAP8[$2 + 30 | 0] & 1;
 HEAP32[$2 >> 2] = $1;
 emscripten_asm_const_int($0 | 0, $2 + 21 | 0, $2 | 0) | 0;
 __stack_pointer = $2 + 32 | 0;
}

function gemmlowp__FixedPoint_int_2c_205__20gemmlowp__operator__int_2c_205__28gemmlowp__FixedPoint_int_2c_205__2c_20gemmlowp__FixedPoint_int_2c_205__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29(int_20gemmlowp__Sub_int__28int_2c_20int_29(HEAP32[gemmlowp__FixedPoint_int_2c_205___raw_28_29($2 + 16 | 0) >> 2], HEAP32[gemmlowp__FixedPoint_int_2c_205___raw_28_29($2 + 8 | 0) >> 2]));
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}

function gemmlowp__FixedPoint_int_2c_202__20gemmlowp__operator__int_2c_202__28gemmlowp__FixedPoint_int_2c_202__2c_20gemmlowp__FixedPoint_int_2c_202__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_202___FromRaw_28int_29(int_20gemmlowp__Add_int__28int_2c_20int_29(HEAP32[gemmlowp__FixedPoint_int_2c_202___raw_28_29($2 + 16 | 0) >> 2], HEAP32[gemmlowp__FixedPoint_int_2c_202___raw_28_29($2 + 8 | 0) >> 2]));
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}

function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__operator__int_2c_200__28gemmlowp__FixedPoint_int_2c_200__2c_20gemmlowp__FixedPoint_int_2c_200__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 16 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 24 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromRaw_28int_29(int_20gemmlowp__Add_int__28int_2c_20int_29(HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($2 + 16 | 0) >> 2], HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($2 + 8 | 0) >> 2]));
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 24 >> 2];
}

function jslSeekToP($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[HEAP32[49079] + 100 >> 2]) {
  jsvLockAgain(HEAP32[HEAP32[49079] + 100 >> 2]);
 }
 jsvStringIteratorFree(HEAP32[49079] + 88 | 0);
 jsvStringIteratorClone(HEAP32[49079] + 88 | 0, HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[HEAP32[49079] + 100 >> 2]);
 HEAP8[HEAP32[49079]] = HEAPU8[HEAP32[$1 + 12 >> 2] + 36 | 0];
 HEAP32[HEAP32[49079] + 4 >> 2] = 0;
 HEAP32[HEAP32[49079] + 8 >> 2] = 0;
 HEAP16[HEAP32[49079] + 2 >> 1] = 0;
 jslGetNextToken();
 __stack_pointer = $1 + 16 | 0;
}

function jspGetConstructor($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = jspGetPrototype(HEAP32[$1 + 8 >> 2]);
 label$1: {
  if (HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 4 >> 2], 120855);
   if (jsvIsFunction(HEAP32[$1 >> 2]) & 1) {
    jsvUnLock(HEAP32[$1 + 4 >> 2]);
    HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
    break label$1;
   }
   jsvUnLock2(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2]);
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvSetString($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 HEAP32[$3 + 52 >> 2] = $2;
 jsvStringIteratorNew($3 + 16 | 0, HEAP32[$3 + 60 >> 2], 0);
 HEAP32[$3 + 12 >> 2] = 0;
 while (1) {
  if (HEAPU32[$3 + 12 >> 2] < HEAPU32[$3 + 52 >> 2]) {
   jsvStringIteratorSetCharAndNext($3 + 16 | 0, HEAP8[HEAP32[$3 + 56 >> 2] + HEAP32[$3 + 12 >> 2] | 0]);
   HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 jsvStringIteratorFree_1($3 + 16 | 0);
 __stack_pointer = $3 - -64 | 0;
}

function double_20const__20std____2__min_double_2c_20std____2____less_double_2c_20double___28double_20const__2c_20double_20const__2c_20std____2____less_double_2c_20double__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1: {
  if (std____2____less_double_2c_20double___operator_28_29_28double_20const__2c_20double_20const__29_20const($2 + 8 | 0, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jswrap_graphics_scroll($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 96 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP32[$3 + 80 >> 2] = $2;
 label$1: {
  if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  graphicsScroll($3 + 8 | 0, HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2]);
  graphicsSetVar($3 + 8 | 0);
  HEAP32[$3 + 92 >> 2] = jsvLockAgain(HEAP32[$3 + 88 >> 2]);
 }
 __stack_pointer = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}

function jsvNewArrayBufferWithData($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = jsvNewArrayBufferWithPtr(HEAP32[$2 + 24 >> 2], $2 + 16 | 0);
 label$1: {
  if (!HEAP32[$2 + 16 >> 2]) {
   jsvUnLock(HEAP32[$2 + 12 >> 2]);
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  __memcpy(HEAP32[$2 + 16 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$2 + 24 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jswrap_waveform_stop($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jsvObjectGetBoolChild(HEAP32[$1 + 12 >> 2], 129992) & 1;
 label$1: {
  if (!(HEAP8[$1 + 11 | 0] & 1)) {
   jsExceptionHere(1, 129976, 0);
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = jswrap_waveform_getBuffer(HEAP32[$1 + 12 >> 2], 0, 0);
  if (!(jstStopBufferTimerTask(HEAP32[$1 + 4 >> 2]) & 1)) {
   jsExceptionHere(1, 133800, 0);
  }
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  jswrap_waveform_idle();
 }
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_graphics_clear($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 96 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP8[$2 + 87 | 0] = $1;
 if (HEAP8[$2 + 87 | 0] & 1) {
  jsvUnLock(jswrap_graphics_reset(HEAP32[$2 + 88 >> 2]));
 }
 label$2: {
  if (!(graphicsGetFromVar($2 + 8 | 0, HEAP32[$2 + 88 >> 2]) & 1)) {
   HEAP32[$2 + 92 >> 2] = 0;
   break label$2;
  }
  graphicsClear($2 + 8 | 0);
  graphicsSetVar($2 + 8 | 0);
  HEAP32[$2 + 92 >> 2] = jsvLockAgain(HEAP32[$2 + 88 >> 2]);
 }
 __stack_pointer = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}

function TfLiteStatus_20tflite__internal__FlatBufferVectorToTfLiteTypeArray_float_2c_20TfLiteFloatArray__28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__2c_20flatbuffers__Vector_float__20const__2c_20TfLiteFloatArray___29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 label$1: {
  if (!HEAP32[$4 + 8 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (!HEAP32[$4 + 4 >> 2]) {
   break label$2;
  }
 }
 HEAP32[HEAP32[$4 >> 2] >> 2] = HEAP32[$4 + 4 >> 2];
 return 0;
}

function _jswrap_string_charCodeAt($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP32[$2 + 52 >> 2] = $1;
 label$1: {
  if (!(jsvIsString(HEAP32[$2 + 56 >> 2]) & 1)) {
   HEAP32[$2 + 60 >> 2] = -1;
   break label$1;
  }
  jsvStringIteratorNewUTF8($2 + 16 | 0, HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2]);
  HEAP32[$2 + 12 >> 2] = jsvStringIteratorGetUTF8CharAndNext($2 + 16 | 0);
  jsvStringIteratorFree_10($2 + 16 | 0);
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}

function jswrap_graphics_getFontHeight($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 112 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 104 >> 2] = $0;
 label$1: {
  if (!(graphicsGetFromVar($1 + 32 | 0, HEAP32[$1 + 104 >> 2]) & 1)) {
   HEAP32[$1 + 108 >> 2] = 0;
   break label$1;
  }
  _jswrap_graphics_getFontInfo($1 + 32 | 0, $1 + 8 | 0);
  HEAP32[$1 + 4 >> 2] = _jswrap_graphics_getFontHeightInternal($1 + 32 | 0, $1 + 8 | 0);
  _jswrap_graphics_freeFontInfo($1 + 8 | 0);
  HEAP32[$1 + 108 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 __stack_pointer = $1 + 112 | 0;
 return HEAP32[$1 + 108 >> 2];
}

function jspeExpression() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 label$1: {
  while (1) {
   if (((HEAP32[91094] & 80) != 0 ^ -1) & 1) {
    HEAP32[$0 + 8 >> 2] = jspeAssignmentExpression();
    if (HEAP16[HEAP32[49079] + 2 >> 1] != 44) {
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
     break label$1;
    } else {
     jsvCheckReferenceError(HEAP32[$0 + 8 >> 2]);
     jsvUnLock(HEAP32[$0 + 8 >> 2]);
     jslGetNextToken();
     continue;
    }
   }
   break;
  }
  HEAP32[$0 + 12 >> 2] = 0;
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function tflite__SimpleMemoryAllocator__GetAvailableMemory_28unsigned_20long_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = tflite__AlignPointerUp_28unsigned_20char__2c_20unsigned_20long_29(HEAP32[$0 + 16 >> 2], HEAP32[$2 + 8 >> 2]);
 HEAP32[$2 >> 2] = tflite__AlignPointerDown_28unsigned_20char__2c_20unsigned_20long_29(HEAP32[$0 + 20 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 >> 2] - HEAP32[$2 + 4 >> 2] | 0;
}

function jshFlashGetPage($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 8 >> 2] = $0;
 HEAP32[$3 + 4 >> 2] = $1;
 HEAP32[$3 >> 2] = $2;
 label$1: {
  if (HEAPU32[$3 + 8 >> 2] < 134217728) {
   HEAP8[$3 + 15 | 0] = 0;
   break label$1;
  }
  $1 = HEAP32[$3 + 4 >> 2];
  $4 = Math_floor(+(HEAP32[$3 + 8 >> 2] >>> 12 >>> 0)) * 4096;
  label$3: {
   if ($4 < 4294967296 & $4 >= 0) {
    $0 = ~~$4 >>> 0;
    break label$3;
   }
   $0 = 0;
  }
  HEAP32[$1 >> 2] = $0;
  HEAP32[HEAP32[$3 >> 2] >> 2] = 4096;
  HEAP8[$3 + 15 | 0] = 1;
 }
 return HEAP8[$3 + 15 | 0] & 1;
}

function round($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $4 = wasm2js_scratch_load_i32(0) | 0;
 $3 = $1 >>> 20 & 2047;
 if ($3 >>> 0 <= 1074) {
  if ($3 >>> 0 <= 1021) {
   return $0 * 0;
  }
  $0 = ($1 | 0) > 0 | ($1 | 0) >= 0 ? $0 : -$0;
  $2 = $0 + 4503599627370496 + -4503599627370496 - $0;
  label$3: {
   if ($2 > .5) {
    $0 = $0 + $2 + -1;
    break label$3;
   }
   $0 = $0 + $2;
   if (!($2 <= -.5)) {
    break label$3;
   }
   $0 = $0 + 1;
  }
  $0 = ($1 | 0) > 0 | ($1 | 0) >= 0 ? $0 : -$0;
 }
 return $0;
}

function unsigned_20char_20const__20std____2__min_unsigned_20char__28unsigned_20char_20const__2c_20unsigned_20char_20const__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = unsigned_20char_20const__20std____2__min_unsigned_20char_2c_20std____2____less_unsigned_20char_2c_20unsigned_20char___28unsigned_20char_20const__2c_20unsigned_20char_20const__2c_20std____2____less_unsigned_20char_2c_20unsigned_20char__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function unsigned_20char_20const__20std____2__max_unsigned_20char__28unsigned_20char_20const__2c_20unsigned_20char_20const__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = unsigned_20char_20const__20std____2__max_unsigned_20char_2c_20std____2____less_unsigned_20char_2c_20unsigned_20char___28unsigned_20char_20const__2c_20unsigned_20char_20const__2c_20std____2____less_unsigned_20char_2c_20unsigned_20char__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function TfLiteStatus_20tflite__internal__FlatBufferVectorToTfLiteTypeArray_int_2c_20TfLiteIntArray__28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__2c_20flatbuffers__Vector_int__20const__2c_20TfLiteIntArray___29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 label$1: {
  if (!HEAP32[$4 + 8 >> 2]) {
   break label$1;
  }
 }
 label$2: {
  if (!HEAP32[$4 + 4 >> 2]) {
   break label$2;
  }
 }
 HEAP32[HEAP32[$4 >> 2] >> 2] = HEAP32[$4 + 4 >> 2];
 return 0;
}

function jsvStringIteratorGetPtrAndNext($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 16 >> 2] + HEAP32[HEAP32[$3 + 12 >> 2] >> 2];
 HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] - HEAP32[HEAP32[$3 + 12 >> 2] >> 2];
 HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2] - 1;
 jsvStringIteratorNextInline(HEAP32[$3 + 12 >> 2]);
 __stack_pointer = $3 + 16 | 0;
}

function float_20const__20std____2__min_float_2c_20std____2____less_float_2c_20float___28float_20const__2c_20float_20const__2c_20std____2____less_float_2c_20float__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1: {
  if (std____2____less_float_2c_20float___operator_28_29_28float_20const__2c_20float_20const__29_20const($2 + 8 | 0, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function float_20const__20std____2__max_float_2c_20std____2____less_float_2c_20float___28float_20const__2c_20float_20const__2c_20std____2____less_float_2c_20float__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1: {
  if (std____2____less_float_2c_20float___operator_28_29_28float_20const__2c_20float_20const__29_20const($2 + 8 | 0, HEAP32[$2 + 4 >> 2], HEAP32[$2 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jswrap_graphics_drawCString($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = jsvNewFromString(HEAP32[$4 + 16 >> 2]);
 $0 = HEAP32[$4 + 28 >> 2];
 jsvUnLock2(jswrap_graphics_drawString(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), HEAP32[$4 + 12 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], 0), HEAP32[$4 + 12 >> 2]);
 __stack_pointer = $4 + 32 | 0;
}

function jsvGetCharInString($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP32[$2 + 52 >> 2] = $1;
 label$1: {
  if (!(jsvIsString(HEAP32[$2 + 56 >> 2]) & 1)) {
   HEAP32[$2 + 60 >> 2] = 0;
   break label$1;
  }
  jsvStringIteratorNewUTF8($2 + 16 | 0, HEAP32[$2 + 56 >> 2], HEAP32[$2 + 52 >> 2]);
  HEAP32[$2 + 12 >> 2] = jsvStringIteratorGetUTF8CharAndNext($2 + 16 | 0);
  jsvStringIteratorFree_1($2 + 16 | 0);
  HEAP32[$2 + 60 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 - -64 | 0;
 return HEAP32[$2 + 60 >> 2];
}

function jslPrintTokenisedString($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 HEAP32[$3 + 52 >> 2] = $2;
 HEAP8[$3 + 51 | 0] = 0;
 HEAP32[$3 + 44 >> 2] = 0;
 HEAP32[$3 + 40 >> 2] = 0;
 jsvStringIteratorNew($3, HEAP32[$3 + 60 >> 2], 0);
 while (1) {
  if (jsvStringIteratorHasChar($3) & 1) {
   jslPrintTokenisedChar($3, $3 + 51 | 0, $3 + 44 | 0, $3 + 40 | 0, HEAP32[$3 + 56 >> 2], HEAP32[$3 + 52 >> 2]);
   continue;
  }
  break;
 }
 jsvStringIteratorFree($3);
 __stack_pointer = $3 - -64 | 0;
}

function jsfVarFromName($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 28 | 0] = 0;
 $2 = $0;
 $0 = HEAP32[$2 >> 2];
 $3 = HEAP32[$2 + 4 >> 2];
 HEAP32[$1 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = $3;
 HEAP32[$1 + 24 >> 2] = HEAP32[$2 + 24 >> 2];
 $0 = HEAP32[$2 + 20 >> 2];
 $3 = HEAP32[$2 + 16 >> 2];
 HEAP32[$1 + 16 >> 2] = $3;
 HEAP32[$1 + 20 >> 2] = $0;
 $3 = HEAP32[$2 + 12 >> 2];
 $0 = HEAP32[$2 + 8 >> 2];
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 12 >> 2] = $3;
 $0 = jsvNewFromString($1);
 __stack_pointer = $1 + 32 | 0;
 return $0;
}

function tf_invoke($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 24 >> 2];
 HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 20 >> 2];
 HEAP32[$1 + 12 >> 2] = tflite__MicroInterpreter__Invoke_28_29(HEAP32[$1 + 20 >> 2] + 400 | 0);
 label$1: {
  if (HEAP32[$1 + 12 >> 2]) {
   tflite__ErrorReporter__Report_28char_20const__2c_20____29(HEAP32[$1 + 16 >> 2], 134103, 0);
   HEAP8[$1 + 31 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 31 | 0] = 1;
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP8[$1 + 31 | 0] & 1;
}

function _jswrap_io_peek($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (HEAP32[$2 + 4 >> 2] == 1) {
   HEAP32[$2 + 12 >> 2] = HEAPU8[HEAP32[$2 + 8 >> 2]];
   break label$1;
  }
  if (HEAP32[$2 + 4 >> 2] == 2) {
   HEAP32[$2 + 12 >> 2] = HEAPU8[HEAP32[$2 + 8 >> 2]] | HEAPU8[HEAP32[$2 + 8 >> 2] + 1 | 0] << 8;
   break label$1;
  }
  if (HEAP32[$2 + 4 >> 2] == 4) {
   HEAP32[$2 + 12 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 0;
 }
 return HEAP32[$2 + 12 >> 2];
}

function jswIsBuiltInObject($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = 159526;
 HEAP32[$1 >> 2] = HEAP32[$1 + 4 >> 2];
 label$1: {
  while (1) {
   if (HEAPU8[HEAP32[$1 >> 2]]) {
    if (strcmp(HEAP32[$1 >> 2], HEAP32[$1 + 8 >> 2])) {
     HEAP32[$1 >> 2] = (strlen(HEAP32[$1 >> 2]) + 1 | 0) + HEAP32[$1 >> 2];
     continue;
    } else {
     HEAP8[$1 + 15 | 0] = 1;
     break label$1;
    }
   }
   break;
  }
  HEAP8[$1 + 15 | 0] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}

function jswrap_object_values_or_entries($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP8[$2 + 23 | 0] = $1;
 HEAP32[$2 + 12 >> 2] = jsvNewEmptyArray();
 HEAP32[$2 + 16 >> 2] = HEAP32[$2 + 24 >> 2];
 label$1: {
  if (!HEAP32[$2 + 12 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  jswrap_object_keys_or_property_names_cb(HEAP32[$2 + 24 >> 2], 0, HEAP8[$2 + 23 | 0] & 1 ? 624 : 625, $2 + 12 | 0);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function tflite__MicroMutableOpResolver_9u___AddDepthwiseConv2D_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 tflite__ops__micro__Register_DEPTHWISE_CONV_2D_28_29($1 + 8 | 0);
 $0 = tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 4, $1 + 8 | 0, 733);
 __stack_pointer = $1 + 48 | 0;
 return $0;
}

function jsvSetCharInString($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 44 >> 2] = $0;
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP8[$4 + 39 | 0] = $2;
 HEAP8[$4 + 38 | 0] = $3;
 if (jsvIsString(HEAP32[$4 + 44 >> 2]) & 1) {
  jsvStringIteratorNew($4, HEAP32[$4 + 44 >> 2], HEAP32[$4 + 40 >> 2]);
  if (HEAP8[$4 + 38 | 0] & 1) {
   HEAP8[$4 + 39 | 0] = jsvStringIteratorGetChar_1($4) << 24 >> 24 | HEAP8[$4 + 39 | 0];
  }
  jsvStringIteratorSetChar($4, HEAP8[$4 + 39 | 0]);
  jsvStringIteratorFree_1($4);
 }
 __stack_pointer = $4 + 48 | 0;
}

function tflite__MicroMutableOpResolver_9u___AddFullyConnected_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 tflite__ops__micro__Register_FULLY_CONNECTED_28_29($1 + 8 | 0);
 $0 = tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 9, $1 + 8 | 0, 736);
 __stack_pointer = $1 + 48 | 0;
 return $0;
}

function jsvHasCharacterData($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  label$3: {
   if (HEAP8[$1 + 7 | 0] >= 18) {
    $0 = 1;
    if (HEAP8[$1 + 7 | 0] <= 40) {
     break label$3;
    }
   }
   $2 = HEAP8[$1 + 7 | 0] >= 41 ? HEAP8[$1 + 7 | 0] <= 51 : $2;
   $0 = $2;
  }
  HEAP8[$1 + 15 | 0] = $0 & 1;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function _jswrap_banglejs_setVibration() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 if (HEAP32[97749] & 128) {
  HEAP32[$0 + 12 >> 2] = HEAPU16[195569];
 }
 label$2: {
  if (!(HEAPU8[391136] | HEAP32[$0 + 12 >> 2])) {
   jshPinOutput(19, 0);
   break label$2;
  }
  label$4: {
   if (!HEAP32[$0 + 12 >> 2]) {
    jshPinAnalogOutput(19, +HEAPU8[391136] * .6 / 255 + .4, 1e3, 0);
    break label$4;
   }
   jshPinAnalogOutput(19, +HEAPU8[391136] * .6 / 255 + .2, +HEAP32[$0 + 12 >> 2], 0);
  }
 }
 __stack_pointer = $0 + 16 | 0;
}

function tflite__MicroMutableOpResolver_9u___AddAveragePool2D_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 tflite__ops__micro__Register_AVERAGE_POOL_2D_28_29($1 + 8 | 0);
 $0 = tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 1, $1 + 8 | 0, 735);
 __stack_pointer = $1 + 48 | 0;
 return $0;
}

function jspParse() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 while (1) {
  $1 = 0;
  $1 = HEAP32[91094] & 80 ? $1 : HEAP16[HEAP32[49079] + 2 >> 1] != 0;
  if ($1) {
   jsvUnLock(HEAP32[$0 + 12 >> 2]);
   HEAP32[$0 + 12 >> 2] = jspeBlockOrStatement();
   while (1) {
    if (HEAP16[HEAP32[49079] + 2 >> 1] == 59) {
     jslGetNextToken();
     continue;
    }
    break;
   }
   jsvCheckReferenceError(HEAP32[$0 + 12 >> 2]);
   continue;
  }
  break;
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function tflite__MicroMutableOpResolver_9u___AddMaxPool2D_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 tflite__ops__micro__Register_MAX_POOL_2D_28_29($1 + 8 | 0);
 $0 = tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 17, $1 + 8 | 0, 735);
 __stack_pointer = $1 + 48 | 0;
 return $0;
}

function jsvNewFromInteger($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = jsvNewWithFlags(10);
 label$1: {
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 4 >> 2];
  $2 = HEAP32[$1 + 8 >> 2];
  HEAP8[$0 | 0] = $2;
  HEAP8[$0 + 1 | 0] = $2 >>> 8;
  HEAP8[$0 + 2 | 0] = $2 >>> 16;
  HEAP8[$0 + 3 | 0] = $2 >>> 24;
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvAppendStringBuf($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 36 >> 2] = $2;
 jsvStringIteratorNew($3, HEAP32[$3 + 44 >> 2], 0);
 jsvStringIteratorGotoEnd($3);
 while (1) {
  if (HEAP32[$3 + 36 >> 2]) {
   $0 = HEAP32[$3 + 40 >> 2];
   HEAP32[$3 + 40 >> 2] = $0 + 1;
   jsvStringIteratorAppend($3, HEAP8[$0 | 0]);
   HEAP32[$3 + 36 >> 2] = HEAP32[$3 + 36 >> 2] - 1;
   continue;
  }
  break;
 }
 jsvStringIteratorFree_1($3);
 __stack_pointer = $3 + 48 | 0;
}

function jsonNewLine($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 FUNCTION_TABLE[HEAP32[$4 + 20 >> 2]](148266, HEAP32[$4 + 16 >> 2]);
 HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 28 >> 2] >>> 14;
 while (1) {
  $0 = HEAP32[$4 + 12 >> 2];
  HEAP32[$4 + 12 >> 2] = $0 - 1;
  if ($0) {
   FUNCTION_TABLE[HEAP32[$4 + 20 >> 2]](HEAP32[$4 + 24 >> 2], HEAP32[$4 + 16 >> 2]);
   continue;
  }
  break;
 }
 __stack_pointer = $4 + 32 | 0;
}

function tflite__MicroMutableOpResolver_9u___AddDequantize_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 tflite__ops__micro__Register_DEQUANTIZE_28_29($1 + 8 | 0);
 $0 = tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 6, $1 + 8 | 0, 739);
 __stack_pointer = $1 + 48 | 0;
 return $0;
}

function jsvNewFromBool($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 11 | 0] = $0;
 HEAP32[$1 + 4 >> 2] = jsvNewWithFlags(12);
 label$1: {
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 4 >> 2];
  $2 = HEAP8[$1 + 11 | 0] & 1;
  HEAP8[$0 | 0] = $2;
  HEAP8[$0 + 1 | 0] = $2 >>> 8;
  HEAP8[$0 + 2 | 0] = $2 >>> 16;
  HEAP8[$0 + 3 | 0] = $2 >>> 24;
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvIsBasic($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  label$3: {
   if (HEAP8[$1 + 7 | 0] >= 10) {
    $0 = 1;
    if (HEAP8[$1 + 7 | 0] <= 17) {
     break label$3;
    }
   }
   $2 = HEAP8[$1 + 7 | 0] >= 18 ? HEAP8[$1 + 7 | 0] <= 40 : $2;
   $0 = $2;
  }
  HEAP8[$1 + 15 | 0] = $0 & 1;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function chtod($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 11 | 0] = $0;
 label$1: {
  if (!(HEAP8[$1 + 11 | 0] < 48 | HEAP8[$1 + 11 | 0] > 57)) {
   HEAP32[$1 + 12 >> 2] = HEAP8[$1 + 11 | 0] - 48;
   break label$1;
  }
  if (!(HEAP8[$1 + 11 | 0] < 97 | HEAP8[$1 + 11 | 0] > 122)) {
   HEAP32[$1 + 12 >> 2] = HEAP8[$1 + 11 | 0] - 87;
   break label$1;
  }
  if (!(HEAP8[$1 + 11 | 0] < 65 | HEAP8[$1 + 11 | 0] > 90)) {
   HEAP32[$1 + 12 >> 2] = HEAP8[$1 + 11 | 0] - 55;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = -1;
 }
 return HEAP32[$1 + 12 >> 2];
}

function tflite__MicroMutableOpResolver_9u___AddQuantize_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 tflite__ops__micro__Register_QUANTIZE_28_29($1 + 8 | 0);
 $0 = tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 114, $1 + 8 | 0, 738);
 __stack_pointer = $1 + 48 | 0;
 return $0;
}

function i2c_rd($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 HEAP32[$2 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 while (1) {
  if (HEAP32[$2 + 4 >> 2] < 8) {
   HEAP32[$2 >> 2] = HEAP32[$2 >> 2] << 1 | i2c_rd_bit(HEAP32[$2 + 12 >> 2]) & 1;
   HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
   continue;
  }
  break;
 }
 i2c_wr_bit(HEAP32[$2 + 12 >> 2], HEAP8[$2 + 11 | 0] & 1);
 i2c_pin_wr1(HEAPU8[HEAP32[$2 + 12 >> 2] + 1 | 0]);
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 >> 2];
}

function jsiSetTimeout($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAPF64[$2 + 16 >> 3] = $1;
 HEAP32[$2 + 12 >> 2] = jsvNewNativeFunction(HEAP32[$2 + 24 >> 2], 0);
 label$1: {
  if (!HEAP32[$2 + 12 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 8 >> 2] = jswrap_interface_setTimeout(HEAP32[$2 + 12 >> 2], HEAPF64[$2 + 16 >> 3], 0);
  jsvUnLock(HEAP32[$2 + 12 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 8 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function jsvNewTypedArray($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 27 | 0] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = jsvNewFromInteger(HEAP32[$2 + 20 >> 2]);
 label$1: {
  if (!HEAP32[$2 + 16 >> 2]) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jswrap_typedarray_constructor(HEAPU8[$2 + 27 | 0], HEAP32[$2 + 16 >> 2], 0, 0);
  jsvUnLock(HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function tflite__MicroMutableOpResolver_9u___AddSoftmax_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 tflite__ops__micro__Register_SOFTMAX_28_29($1 + 8 | 0);
 $0 = tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 25, $1 + 8 | 0, 737);
 __stack_pointer = $1 + 48 | 0;
 return $0;
}

function tflite__MicroMutableOpResolver_9u___AddReshape_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 tflite__ops__micro__Register_RESHAPE_28_29($1 + 8 | 0);
 $0 = tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 22, $1 + 8 | 0, 740);
 __stack_pointer = $1 + 48 | 0;
 return $0;
}

function signed_20char_20const__20std____2__min_signed_20char__28signed_20char_20const__2c_20signed_20char_20const__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = signed_20char_20const__20std____2__min_signed_20char_2c_20std____2____less_signed_20char_2c_20signed_20char___28signed_20char_20const__2c_20signed_20char_20const__2c_20std____2____less_signed_20char_2c_20signed_20char__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function signed_20char_20const__20std____2__max_signed_20char__28signed_20char_20const__2c_20signed_20char_20const__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = signed_20char_20const__20std____2__max_signed_20char_2c_20std____2____less_signed_20char_2c_20signed_20char___28signed_20char_20const__2c_20signed_20char_20const__2c_20std____2____less_signed_20char_2c_20signed_20char__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jswrap_graphics_getWidthOrHeight($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 96 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP8[$2 + 87 | 0] = $1;
 label$1: {
  if (!(graphicsGetFromVar($2 + 8 | 0, HEAP32[$2 + 88 >> 2]) & 1)) {
   HEAP32[$2 + 92 >> 2] = 0;
   break label$1;
  }
  label$3: {
   if (HEAP8[$2 + 87 | 0] & 1) {
    $0 = graphicsGetHeight($2 + 8 | 0) & 65535;
    break label$3;
   }
   $0 = graphicsGetWidth($2 + 8 | 0) & 65535;
  }
  HEAP32[$2 + 92 >> 2] = $0;
 }
 __stack_pointer = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}

function jsvAddFunctionParameter($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 if (!HEAP32[$3 + 8 >> 2]) {
  HEAP32[$3 + 8 >> 2] = jsvNewFromEmptyString_1();
 }
 if (HEAP32[$3 + 8 >> 2]) {
  HEAP32[$3 + 8 >> 2] = jsvMakeFunctionParameter(HEAP32[$3 + 8 >> 2]);
  jsvSetValueOfName(HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
  jsvAddName(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
  jsvUnLock(HEAP32[$3 + 8 >> 2]);
 }
 __stack_pointer = $3 + 16 | 0;
}

function jsiIsInHistory($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 + 20 >> 2] = jsiGetHistory();
 label$1: {
  if (!HEAP32[$1 + 20 >> 2]) {
   HEAP8[$1 + 31 | 0] = 0;
   break label$1;
  }
  HEAP32[$1 + 16 >> 2] = jsvGetIndexOf(HEAP32[$1 + 20 >> 2], HEAP32[$1 + 24 >> 2], 1);
  HEAP8[$1 + 15 | 0] = HEAP32[$1 + 16 >> 2] != 0;
  jsvUnLock2(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
  HEAP8[$1 + 31 | 0] = HEAP8[$1 + 15 | 0] & 1;
 }
 __stack_pointer = $1 + 32 | 0;
 return HEAP8[$1 + 31 | 0] & 1;
}

function int_20const__20std____2__min_int_2c_20std____2____less_int_2c_20int___28int_20const__2c_20int_20const__2c_20std____2____less_int_2c_20int__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1: {
  if (std____2____less_int_2c_20int___operator_28_29_28int_20const__2c_20int_20const__29_20const($2 + 8 | 0, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function int_20const__20std____2__max_int_2c_20std____2____less_int_2c_20int___28int_20const__2c_20int_20const__2c_20std____2____less_int_2c_20int__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 >> 2] = $1;
 label$1: {
  if (std____2____less_int_2c_20int___operator_28_29_28int_20const__2c_20int_20const__29_20const($2 + 8 | 0, HEAP32[$2 + 4 >> 2], HEAP32[$2 >> 2]) & 1) {
   $0 = HEAP32[$2 >> 2];
   break label$1;
  }
  $0 = HEAP32[$2 + 4 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function tflite__MicroMutableOpResolver_9u___AddConv2D_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 $0 = HEAP32[$1 + 44 >> 2];
 tflite__ops__micro__Register_CONV_2D_28_29($1 + 8 | 0);
 $0 = tflite__MicroMutableOpResolver_9u___AddBuiltin_28tflite__BuiltinOperator_2c_20TfLiteRegistration_20const__2c_20TfLiteStatus_20_28__29_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29_29($0, 3, $1 + 8 | 0, 734);
 __stack_pointer = $1 + 48 | 0;
 return $0;
}

function lcdSetPixel_ArrayBuffer_flat8($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $1 = HEAP32[$4 + 12 >> 2];
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP8[(HEAP32[$4 + 8 >> 2] + Math_imul(HEAP32[$4 + 4 >> 2], HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) | 0) + (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) | 0] = HEAP32[$4 >> 2];
}

function lcdInit_JS($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 jsvObjectSetChild(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 128800, HEAP32[$3 + 8 >> 2]);
 $0 = HEAP32[$3 + 12 >> 2];
 jsvObjectSetChild(HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24), 117919, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
}

function jswrap_pin_toggle($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP8[$1 + 7 | 0] = jshGetPinFromVar(HEAP32[$1 + 8 >> 2]);
 label$1: {
  if (!(jshIsPinValid(HEAPU8[$1 + 7 | 0]) & 1)) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 6 | 0] = ((jshPinGetState(HEAPU8[$1 + 7 | 0]) & 16) != 0 ^ -1) & 1;
  jshPinOutput(HEAPU8[$1 + 7 | 0], HEAP8[$1 + 6 | 0] & 1);
  HEAP8[$1 + 15 | 0] = HEAP8[$1 + 6 | 0] & 1;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}

function jsvFindOrCreateRoot() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP16[$0 + 10 >> 1] = 1;
 label$1: {
  while (1) {
   if (HEAPU16[$0 + 10 >> 1] <= 12e3) {
    if (jsvIsRoot(jsvGetAddressOf(HEAPU16[$0 + 10 >> 1])) & 1) {
     HEAP32[$0 + 12 >> 2] = jsvLock(HEAPU16[$0 + 10 >> 1]);
     break label$1;
    } else {
     HEAP16[$0 + 10 >> 1] = HEAPU16[$0 + 10 >> 1] + 1;
     continue;
    }
   }
   break;
  }
  HEAP32[$0 + 12 >> 2] = jsvRef(jsvNewWithFlags(1));
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function jswrap_object_addEventListener($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP16[$4 + 18 >> 1] = $3;
 HEAP32[$4 + 12 >> 2] = jsvNewFromString(HEAP32[$4 + 24 >> 2]);
 HEAP32[$4 + 8 >> 2] = jsvNewNativeFunction(HEAP32[$4 + 20 >> 2], HEAPU16[$4 + 18 >> 1]);
 jswrap_object_on(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2]);
 jsvUnLock2(HEAP32[$4 + 8 >> 2], HEAP32[$4 + 12 >> 2]);
 __stack_pointer = $4 + 32 | 0;
}

function jsiPacketExit() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP8[364428] = 0;
 HEAP16[182240] = 0;
 HEAP32[$0 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 136570);
 if (HEAP32[$0 + 12 >> 2]) {
  jsiClearTimeout(HEAP32[$0 + 12 >> 2]);
  jsvUnLock(HEAP32[$0 + 12 >> 2]);
 }
 jsvObjectRemoveChild(HEAP32[91087], 136570);
 jsiInputLineCursorMoved();
 jsvUnLock(HEAP32[91104]);
 HEAP32[91104] = jsvObjectGetChildIfExists(HEAP32[91087], 137348);
 jsvObjectRemoveChild(HEAP32[91087], 137348);
 __stack_pointer = $0 + 16 | 0;
}

function isValidBPP($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = 1;
 label$1: {
  if (HEAP32[$1 + 12 >> 2] == 1) {
   break label$1;
  }
  $0 = 1;
  if (HEAP32[$1 + 12 >> 2] == 2) {
   break label$1;
  }
  $0 = 1;
  if (HEAP32[$1 + 12 >> 2] == 4) {
   break label$1;
  }
  $0 = 1;
  if (HEAP32[$1 + 12 >> 2] == 8) {
   break label$1;
  }
  $0 = 1;
  if (HEAP32[$1 + 12 >> 2] == 16) {
   break label$1;
  }
  $0 = 1;
  if (HEAP32[$1 + 12 >> 2] == 24) {
   break label$1;
  }
  $0 = HEAP32[$1 + 12 >> 2] == 32;
 }
 return $0;
}

function tflite__internal__ContextHelper__GetTensor_28TfLiteContext_20const__2c_20int_29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2];
 $0 = HEAP32[HEAP32[$2 + 4 >> 2] >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 4 >> 2]]($0, HEAP32[HEAP32[$2 + 4 >> 2] + 8 >> 2], HEAP32[HEAP32[$2 + 4 >> 2] + 12 >> 2], HEAP32[$2 + 8 >> 2]) | 0;
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function _jswrap_banglejs_getHealthStatusObject($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvNewObject();
 if (HEAP32[$1 + 8 >> 2]) {
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 117605, jsvNewFromInteger(HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2] / HEAPU16[HEAP32[$1 + 12 >> 2] + 8 >> 1] | 0));
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 8 >> 2], 120069, jsvNewFromInteger(HEAPU16[HEAP32[$1 + 12 >> 2] + 10 >> 1]));
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jsiMoveCursorChar($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 if (HEAP32[$3 + 24 >> 2] != HEAP32[$3 + 20 >> 2]) {
  jsvGetLineAndCol(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], $3 + 12 | 0, $3 + 16 | 0);
  jsvGetLineAndCol(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 20 >> 2], $3 + 4 | 0, $3 + 8 | 0);
  jsiMoveCursor(HEAP32[$3 + 16 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 }
 __stack_pointer = $3 + 32 | 0;
}

function jsiExecuteEventCallbackOn($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[91086], HEAP32[$4 + 28 >> 2]);
 HEAP8[$4 + 11 | 0] = jsiExecuteEventCallbackName(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]) & 1;
 jsvUnLock(HEAP32[$4 + 12 >> 2]);
 __stack_pointer = $4 + 32 | 0;
 return HEAP8[$4 + 11 | 0] & 1;
}

function tflite__internal__ContextHelper__ContextHelper_28tflite__ErrorReporter__2c_20tflite__MicroAllocator__2c_20tflite__Model_20const__29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$4 + 4 >> 2];
 HEAP32[$0 + 4 >> 2] = HEAP32[$4 + 8 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[$4 >> 2];
 HEAP32[$0 + 16 >> 2] = -1;
 return $0 | 0;
}

function jslInit($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvLockAgain(HEAP32[$1 + 12 >> 2]);
 HEAP32[HEAP32[49079] + 84 >> 2] = $0;
 HEAP16[HEAP32[49079] + 2 >> 1] = 0;
 HEAP32[HEAP32[49079] + 4 >> 2] = 0;
 HEAP32[HEAP32[49079] + 8 >> 2] = 0;
 HEAP8[HEAP32[49079] + 80 | 0] = 0;
 HEAP32[HEAP32[49079] + 76 >> 2] = 0;
 jsvStringIteratorNew(HEAP32[49079] + 88 | 0, HEAP32[HEAP32[49079] + 84 >> 2], 0);
 jsvUnLock(HEAP32[HEAP32[49079] + 100 >> 2]);
 jslPreload();
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_graphics_fillCircle($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = jswrap_graphics_fillEllipse(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2] - HEAP32[$4 >> 2] | 0, HEAP32[$4 + 4 >> 2] - HEAP32[$4 >> 2] | 0, HEAP32[$4 + 8 >> 2] + HEAP32[$4 >> 2] | 0, HEAP32[$4 + 4 >> 2] + HEAP32[$4 >> 2] | 0);
 __stack_pointer = $4 + 16 | 0;
 return $0 | 0;
}

function jswrap_graphics_drawCircle($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = jswrap_graphics_drawEllipse(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2] - HEAP32[$4 >> 2] | 0, HEAP32[$4 + 4 >> 2] - HEAP32[$4 >> 2] | 0, HEAP32[$4 + 8 >> 2] + HEAP32[$4 >> 2] | 0, HEAP32[$4 + 4 >> 2] + HEAP32[$4 >> 2] | 0);
 __stack_pointer = $4 + 16 | 0;
 return $0 | 0;
}

function jspGetPrototype($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 8 >> 2], 135865);
  if (jsvIsObject(HEAP32[$1 + 4 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
   break label$1;
  }
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsfListFiles($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = jsvNewEmptyArray();
 label$1: {
  if (!HEAP32[$3 + 12 >> 2]) {
   HEAP32[$3 + 28 >> 2] = 0;
   break label$1;
  }
  jsfBankListFiles(HEAP32[$3 + 12 >> 2], 134217728, HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], HEAP32[$3 + 16 >> 2], 0);
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 12 >> 2];
 }
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 28 >> 2];
}

function jspIsConstructor($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = jsvObjectGetChildIfExists(HEAP32[91086], HEAP32[$2 + 20 >> 2]);
 label$1: {
  if (!HEAP32[$2 + 16 >> 2]) {
   HEAP8[$2 + 31 | 0] = 0;
   break label$1;
  }
  HEAP8[$2 + 15 | 0] = HEAP32[$2 + 16 >> 2] == HEAP32[$2 + 24 >> 2];
  jsvUnLock(HEAP32[$2 + 16 >> 2]);
  HEAP8[$2 + 31 | 0] = HEAP8[$2 + 15 | 0] & 1;
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP8[$2 + 31 | 0] & 1;
}

function getDay($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = 0;
 label$1: {
  while (1) {
   if (HEAP32[$1 + 4 >> 2] < 7) {
    if (strcmp(HEAP32[$1 + 8 >> 2], HEAP32[48928] + (HEAP32[$1 + 4 >> 2] << 2) | 0)) {
     HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
     continue;
    } else {
     HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
     break label$1;
    }
   }
   break;
  }
  HEAP32[$1 + 12 >> 2] = -1;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvAsFlatString($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (jsvIsFlatString(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = jsvAsString(HEAP32[$1 + 8 >> 2]);
  HEAP32[$1 >> 2] = jsvNewFlatStringFromStringVar(HEAP32[$1 + 4 >> 2], 0, 2147483647);
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jswIdle() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP8[$0 + 15 | 0] = 0;
 if (jswrap_banglejs_idle() & 1) {
  HEAP8[$0 + 15 | 0] = 1;
 }
 if (jswrap_pipe_idle() & 1) {
  HEAP8[$0 + 15 | 0] = 1;
 }
 if (jswrap_serial_idle() & 1) {
  HEAP8[$0 + 15 | 0] = 1;
 }
 if (jswrap_waveform_idle() & 1) {
  HEAP8[$0 + 15 | 0] = 1;
 }
 if (jswrap_graphics_idle() & 1) {
  HEAP8[$0 + 15 | 0] = 1;
 }
 if (jswrap_terminal_idle() & 1) {
  HEAP8[$0 + 15 | 0] = 1;
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP8[$0 + 15 | 0] & 1;
}

function jsvUnRef($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP16[$1 + 10 >> 1] = jsvGetRefs(HEAP32[$1 + 12 >> 2]);
 if (HEAPU16[$1 + 10 >> 1] < 255) {
  HEAP16[$1 + 10 >> 1] = HEAPU16[$1 + 10 >> 1] - 1;
  jsvSetRefs(HEAP32[$1 + 12 >> 2], HEAPU16[$1 + 10 >> 1]);
  label$2: {
   if (HEAPU16[$1 + 10 >> 1]) {
    break label$2;
   }
   if (jsvGetLocks(HEAP32[$1 + 12 >> 2]) & 255) {
    break label$2;
   }
   jsvUnLockFreeIfNeeded(HEAP32[$1 + 12 >> 2]);
  }
 }
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_promise_reject($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 >> 2] = jspromise_create_prombox($1 + 4 | 0);
 label$1: {
  if (!HEAP32[$1 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2]) {
   _jswrap_prombox_queuereject(HEAP32[$1 >> 2], HEAP32[$1 + 8 >> 2]);
  }
  jsvUnLock(HEAP32[$1 >> 2]);
  HEAP32[$1 + 12 >> 2] = jsvLockAgainSafe(HEAP32[$1 + 4 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsfFindFileFromAddr($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (!(HEAPU32[$2 + 8 >> 2] < 134217728 | HEAPU32[$2 + 8 >> 2] > 142606336)) {
   HEAP32[$2 >> 2] = jsfBankFindFileFromAddr(134217728, 142606336, HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
   if (HEAP32[$2 >> 2]) {
    HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
    break label$1;
   }
  }
  HEAP32[$2 + 12 >> 2] = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jsvCheckReferenceError($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (!(jsvIsBasicName(HEAP32[$1 + 12 >> 2]) & 1)) {
   break label$1;
  }
  if (jsvGetRefs(HEAP32[$1 + 12 >> 2]) & 65535) {
   break label$1;
  }
  if (jsvIsNewChild(HEAP32[$1 + 12 >> 2]) & 1) {
   break label$1;
  }
  if (jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535) {
   break label$1;
  }
  HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
  jsExceptionHere(5, 133958, $1);
 }
 __stack_pointer = $1 + 16 | 0;
}

function std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_20void__28tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
 return $0;
}

function jsiShouldExecuteWatch($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 HEAP32[$2 + 4 >> 2] = jsvObjectGetIntegerChild(HEAP32[$2 + 12 >> 2], 132661);
 __stack_pointer = $2 + 16 | 0;
 $0 = 1;
 label$1: {
  if (!HEAP32[$2 + 4 >> 2]) {
   break label$1;
  }
  if (HEAP8[$2 + 11 | 0] & 1) {
   $0 = 1;
   if (HEAP32[$2 + 4 >> 2] > 0) {
    break label$1;
   }
  }
  $3 = HEAP8[$2 + 11 | 0] & 1 ? $3 : HEAP32[$2 + 4 >> 2] < 0;
  $0 = $3;
 }
 return $0 & 1;
}

function int_20gemmlowp__SelectUsingMask_int__28int_2c_20int_2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = int_20gemmlowp__BitXor_int__28int_2c_20int_29(int_20gemmlowp__BitAnd_int__28int_2c_20int_29(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]), int_20gemmlowp__BitAnd_int__28int_2c_20int_29(int_20gemmlowp__BitNot_int__28int_29(HEAP32[$3 + 12 >> 2]), HEAP32[$3 + 4 >> 2]));
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function jswrap_graphics_getBPP($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 80 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 72 >> 2] = $0;
 label$1: {
  if (!(graphicsGetFromVar($1, HEAP32[$1 + 72 >> 2]) & 1)) {
   HEAP32[$1 + 76 >> 2] = 0;
   break label$1;
  }
  if ((HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24)) == 6) {
   HEAP32[$1 + 76 >> 2] = 3;
   break label$1;
  }
  HEAP32[$1 + 76 >> 2] = HEAPU8[$1 + 16 | 0];
 }
 __stack_pointer = $1 + 80 | 0;
 return HEAP32[$1 + 76 >> 2];
}

function jswrap_date_setDate($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 60 >> 2] = $0;
 HEAP32[$2 + 56 >> 2] = $1;
 getTimeFromDateVar($2 + 24 | 0, HEAP32[$2 + 60 >> 2], 0);
 getCalendarDate($2, HEAP32[$2 + 24 >> 2]);
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 56 >> 2];
 HEAP32[$2 + 24 >> 2] = fromCalendarDate($2);
 setCorrectTimeZone($2 + 24 | 0);
 $3 = jswrap_date_setTime(HEAP32[$2 + 60 >> 2], fromTimeInDay($2 + 24 | 0));
 __stack_pointer = $2 - -64 | 0;
 return +$3;
}

function jswrap_graphics_reset($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 80 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 72 >> 2] = $0;
 label$1: {
  if (!(graphicsGetFromVar($1, HEAP32[$1 + 72 >> 2]) & 1)) {
   HEAP32[$1 + 76 >> 2] = 0;
   break label$1;
  }
  jsvUnLock(jswrap_graphics_setFontSizeX(HEAP32[$1 + 72 >> 2], 8193, 0));
  graphicsStructResetState($1);
  graphicsSetVar($1);
  HEAP32[$1 + 76 >> 2] = jswrap_graphics_setFontSizeX(HEAP32[$1 + 72 >> 2], 8193, 0);
 }
 __stack_pointer = $1 + 80 | 0;
 return HEAP32[$1 + 76 >> 2];
}

function jshPinGetValue($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 HEAP32[$1 + 8 >> 2] = 196132;
 $0 = HEAP32[$1 + 8 >> 2];
 HEAP8[$1 + 6 | 0] = 105;
 HEAP8[$1 + 7 | 0] = 0;
 HEAP32[$1 >> 2] = HEAPU8[$1 + 15 | 0];
 HEAP8[$1 + 14 | 0] = (emscripten_asm_const_int($0 | 0, $1 + 6 | 0, $1 | 0) | 0) != 0;
 if (HEAPU8[Math_imul(HEAPU8[$1 + 15 | 0], 3) + 180752 | 0] & 16) {
  HEAP8[$1 + 14 | 0] = (HEAPU8[$1 + 14 | 0] ^ -1) & 1;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 14 | 0] & 1;
}

function lcdMemLCD_setOverlay($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 if (HEAP32[97739]) {
  jsvUnLock(HEAP32[97739]);
 }
 label$2: {
  if (HEAP32[$3 + 12 >> 2]) {
   HEAP32[97739] = jsvLockAgain(HEAP32[$3 + 12 >> 2]);
   HEAP16[195481] = HEAP32[$3 + 8 >> 2];
   HEAP16[195480] = HEAP32[$3 + 4 >> 2];
   break label$2;
  }
  HEAP32[97739] = 0;
  HEAP16[195481] = 0;
  HEAP16[195480] = 0;
 }
 __stack_pointer = $3 + 16 | 0;
}

function tflite__ops__micro__activations__SoftmaxInit_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (!HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]) {
   break label$1;
  }
 }
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]](HEAP32[$3 + 12 >> 2], 56) | 0;
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function tflite___28anonymous_20namespace_29__OpNameFromRegistration_28TfLiteRegistration_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (HEAP32[HEAP32[$1 + 8 >> 2] + 20 >> 2] == 32) {
   HEAP32[$1 + 12 >> 2] = HEAP32[HEAP32[$1 + 8 >> 2] + 24 >> 2];
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = tflite__EnumNameBuiltinOperator_28tflite__BuiltinOperator_29(HEAP32[HEAP32[$1 + 8 >> 2] + 20 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function graphicsBlendGfxColor($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = HEAP32[$2 + 12 >> 2];
 $0 = graphicsBlendColor(HEAP32[$2 + 12 >> 2], HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8 | (HEAPU8[$0 + 19 | 0] << 16 | HEAPU8[$0 + 20 | 0] << 24), HEAPU8[$1 + 21 | 0] | HEAPU8[$1 + 22 | 0] << 8 | (HEAPU8[$1 + 23 | 0] << 16 | HEAPU8[$1 + 24 | 0] << 24), HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function tflite__MicroAllocator__AllocatePersistentTfLiteTensorInternal_28tflite__Model_20const__2c_20TfLiteEvalTensor__2c_20int_29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = HEAP32[HEAP32[$4 + 12 >> 2] + 4 >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 12 >> 2]]($0, 40, 4) | 0;
 __stack_pointer = $4 + 16 | 0;
 return $0 | 0;
}

function tflite__ops__micro__fully_connected__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (!HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]) {
   break label$1;
  }
 }
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]](HEAP32[$3 + 12 >> 2], 32) | 0;
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function jsvIsFunction($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $0 = 1;
  label$3: {
   if (HEAP8[$1 + 7 | 0] == 7) {
    break label$3;
   }
   $0 = 1;
   if (HEAP8[$1 + 7 | 0] == 9) {
    break label$3;
   }
   $0 = HEAP8[$1 + 7 | 0] == 8;
  }
  HEAP8[$1 + 15 | 0] = $0;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function jslMatchError($0) {
 var $1 = 0;
 $1 = __stack_pointer - 96 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 92 >> 2] = $0;
 jslGetTokenString($1 + 48 | 0, 30);
 jslTokenAsString(HEAP32[$1 + 92 >> 2], $1 + 16 | 0, 30);
 HEAP32[$1 + 12 >> 2] = HEAP32[HEAP32[49079] + 8 >> 2];
 HEAP32[HEAP32[49079] + 8 >> 2] = HEAP32[HEAP32[49079] + 4 >> 2];
 HEAP32[$1 + 4 >> 2] = $1 + 16;
 HEAP32[$1 >> 2] = $1 + 48;
 jsExceptionHere(2, 120663, $1);
 HEAP32[HEAP32[49079] + 8 >> 2] = HEAP32[$1 + 12 >> 2];
 jslGetNextToken();
 __stack_pointer = $1 + 96 | 0;
}

function jsiFreeMoreMemory() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 116128);
 label$1: {
  if (!HEAP32[$0 + 8 >> 2]) {
   HEAP8[$0 + 15 | 0] = 0;
   break label$1;
  }
  HEAP32[$0 + 4 >> 2] = jsvArrayPopFirst(HEAP32[$0 + 8 >> 2]);
  HEAP8[$0 + 3 | 0] = HEAP32[$0 + 4 >> 2] != 0;
  jsvUnLock2(HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2]);
  HEAP8[$0 + 15 | 0] = HEAP8[$0 + 3 | 0] & 1;
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP8[$0 + 15 | 0] & 1;
}

function flatbuffers__Vector_unsigned_20char__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_unsigned_20char__20const___28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = flatbuffers__Vector_unsigned_20char__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_unsigned_20char__20const___28unsigned_20short_29(HEAP32[$2 + 12 >> 2], HEAPU16[$2 + 10 >> 1]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode____Get_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = flatbuffers__IndirectHelper_flatbuffers__Offset_tflite__OperatorCode____Read_28unsigned_20char_20const__2c_20unsigned_20int_29(flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode____Data_28_29_20const(HEAP32[$2 + 12 >> 2]), HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function tflite__ops__micro__depthwise_conv__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (!HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]) {
   break label$1;
  }
 }
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]](HEAP32[$3 + 12 >> 2], 52) | 0;
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function tflite__internal__ContextHelper__ReportOpError_28TfLiteContext__2c_20char_20const__2c_20____29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2];
 HEAP32[$3 >> 2] = $2;
 $0 = HEAP32[HEAP32[$3 + 4 >> 2] + 4 >> 2];
 FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 8 >> 2]]($0, HEAP32[$3 + 8 >> 2], HEAP32[$3 >> 2]) | 0;
 __stack_pointer = $3 + 16 | 0;
}

function jsvGetChildren($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP16[$1 + 6 >> 1] = jsvGetFirstChild(HEAP32[$1 + 12 >> 2]);
 while (1) {
  if (HEAPU16[$1 + 6 >> 1]) {
   HEAP32[$1 >> 2] = jsvLock(HEAPU16[$1 + 6 >> 1]);
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
   HEAP16[$1 + 6 >> 1] = jsvGetNextSibling(HEAP32[$1 >> 2]);
   jsvUnLock(HEAP32[$1 >> 2]);
   continue;
  }
  break;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jsiPacketReply($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP16[$2 + 14 >> 1] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP16[$2 + 6 >> 1] = HEAPU16[$2 + 14 >> 1] | jsvGetStringLength(HEAP32[$2 + 8 >> 2]) & 65535;
 jsiConsolePrintChar(16);
 jsiConsolePrintChar(1);
 jsiConsolePrintChar(HEAPU16[$2 + 6 >> 1] >>> 8 << 24 >> 24);
 jsiConsolePrintChar((HEAPU16[$2 + 6 >> 1] & 255) << 24 >> 24);
 if (HEAP32[$2 + 8 >> 2]) {
  jsiConsolePrintStringVar(HEAP32[$2 + 8 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function jsiHandleEnd() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = jsvGetStringLength(HEAP32[91104]);
 while (1) {
  $1 = 0;
  if (HEAPU32[91106] < HEAPU32[$0 + 12 >> 2]) {
   $1 = (jsvGetCharInString(HEAP32[91104], HEAP32[91106]) | 0) != 10;
  }
  if ($1) {
   if (jsiShowInputLine() & 1) {
    jsiConsolePrintChar(jsvGetCharInString(HEAP32[91104], HEAP32[91106]) << 24 >> 24);
   }
   HEAP32[91106] = HEAP32[91106] + 1;
   continue;
  }
  break;
 }
 __stack_pointer = $0 + 16 | 0;
}

function std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator_20bool_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[std____2____compressed_pair_TfLiteFullyConnectedParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const(HEAP32[$1 + 12 >> 2]) >> 2];
 __stack_pointer = $1 + 16 | 0;
 return ($0 | 0) != 0;
}

function jswrap_string_charAt_undefined($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 20 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = _jswrap_string_charCodeAt(HEAP32[$2 + 24 >> 2], HEAP32[$2 + 20 >> 2]);
 label$1: {
  if (HEAP32[$2 + 16 >> 2] < 0) {
   HEAP32[$2 + 28 >> 2] = 0;
   break label$1;
  }
  HEAP8[$2 + 15 | 0] = HEAP32[$2 + 16 >> 2];
  HEAP32[$2 + 28 >> 2] = jsvNewStringOfLength(1, $2 + 15 | 0);
 }
 __stack_pointer = $2 + 32 | 0;
 return HEAP32[$2 + 28 >> 2];
}

function tflite__ops__micro__dequantize__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (!HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]) {
   break label$1;
  }
 }
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]](HEAP32[$3 + 12 >> 2], 32) | 0;
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator_20bool_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[std____2____compressed_pair_TfLiteDepthwiseConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const(HEAP32[$1 + 12 >> 2]) >> 2];
 __stack_pointer = $1 + 16 | 0;
 return ($0 | 0) != 0;
}

function jswrap_graphics_getPixel($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 96 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 88 >> 2] = $0;
 HEAP32[$3 + 84 >> 2] = $1;
 HEAP32[$3 + 80 >> 2] = $2;
 label$1: {
  if (!(graphicsGetFromVar($3 + 8 | 0, HEAP32[$3 + 88 >> 2]) & 1)) {
   HEAP32[$3 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 92 >> 2] = graphicsGetPixel($3 + 8 | 0, HEAP32[$3 + 84 >> 2], HEAP32[$3 + 80 >> 2]);
 }
 __stack_pointer = $3 + 96 | 0;
 return HEAP32[$3 + 92 >> 2];
}

function jsiPacketFileSetTimeout($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 136581);
 if (HEAP32[$1 + 8 >> 2]) {
  jsiClearTimeout(HEAP32[$1 + 8 >> 2]);
  jsvUnLock(HEAP32[$1 + 8 >> 2]);
 }
 label$2: {
  if (HEAP8[$1 + 15 | 0] & 1) {
   jsvObjectSetChildAndUnLock(HEAP32[91087], 136581, jsiSetTimeout(566, 1e4));
   break label$2;
  }
  jsvObjectRemoveChild(HEAP32[91087], 136581);
 }
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_espruino_memoryArea($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (!(HEAP32[$2 + 4 >> 2] >= 0 ? HEAP32[$2 + 8 >> 2] : 0)) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 >> 2] = jshFlashGetMemMapAddress(HEAP32[$2 + 8 >> 2]);
  HEAP32[$2 + 12 >> 2] = jsvNewNativeString(HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function tflite__ops__micro__quantize__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (!HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]) {
   break label$1;
  }
 }
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]](HEAP32[$3 + 12 >> 2], 32) | 0;
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function tflite__ops__micro__pooling__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (!HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]) {
   break label$1;
  }
 }
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]](HEAP32[$3 + 12 >> 2], 32) | 0;
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function jsiHandleIOEventForConsole($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = ((HEAPU8[HEAP32[$1 + 12 >> 2]] & 96) >>> 5 | 0) + 1;
 jsiSetBusy(1, 1);
 HEAP32[$1 + 8 >> 2] = 0;
 while (1) {
  if (HEAP32[$1 + 8 >> 2] < HEAP32[$1 + 4 >> 2]) {
   jsiHandleChar(HEAP8[HEAP32[$1 + 8 >> 2] + (HEAP32[$1 + 12 >> 2] + 1 | 0) | 0]);
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 jsiSetBusy(1, 0);
 __stack_pointer = $1 + 16 | 0;
}
function _jswrap_promise_new_reaction($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 >> 2] = jsvNewObject();
 label$1: {
  if (!HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  jsvObjectSetChild(HEAP32[$2 >> 2], 135710, HEAP32[$2 + 4 >> 2]);
  jsvObjectSetChild(HEAP32[$2 >> 2], 117121, HEAP32[$2 + 8 >> 2]);
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function strncmp($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 if (!$2) {
  return 0;
 }
 $3 = HEAPU8[$0 | 0];
 label$2: {
  if (!$3) {
   break label$2;
  }
  while (1) {
   label$4: {
    $4 = HEAPU8[$1 | 0];
    if (!$4) {
     break label$4;
    }
    $2 = $2 - 1 | 0;
    if (!$2 | ($3 | 0) != ($4 | 0)) {
     break label$4;
    }
    $1 = $1 + 1 | 0;
    $3 = HEAPU8[$0 + 1 | 0];
    $0 = $0 + 1 | 0;
    if ($3) {
     continue;
    }
    break label$2;
   }
   break;
  }
  $5 = $3;
 }
 return ($5 & 255) - HEAPU8[$1 | 0] | 0;
}

function tflite__MicroAllocator__MicroAllocator_28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP32[$0 >> 2] = 189772;
 HEAP32[$0 + 4 >> 2] = HEAP32[$3 + 8 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[$3 + 4 >> 2];
 HEAP8[$0 + 12 | 0] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 return $0 | 0;
}

function jswrap_graphics_clearRect($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 28 >> 2] = $0;
 HEAP32[$5 + 24 >> 2] = $1;
 HEAP32[$5 + 20 >> 2] = $2;
 HEAP32[$5 + 16 >> 2] = $3;
 HEAP32[$5 + 12 >> 2] = $4;
 $0 = _jswrap_graphics_fillRect_col(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 12 >> 2], 0);
 __stack_pointer = $5 + 32 | 0;
 return $0 | 0;
}

function jshGetPinFromVar($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(!(jsvIsString(HEAP32[$1 + 8 >> 2]) & 1) | HEAP8[HEAP32[$1 + 8 >> 2] + 5 | 0])) {
   HEAP8[$1 + 15 | 0] = jshGetPinFromString(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  if (jsvIsInt(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP8[$1 + 15 | 0] = jsvGetInteger(HEAP32[$1 + 8 >> 2]);
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = 255;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAPU8[$1 + 15 | 0];
}

function tflite__ops__micro__conv__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (!HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]) {
   break label$1;
  }
 }
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2]](HEAP32[$3 + 12 >> 2], 52) | 0;
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function tflite__RuntimeShape__Dims_28int_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 label$1: {
  if (HEAP32[$2 + 8 >> 2] < 0) {
   break label$1;
  }
 }
 label$2: {
  if (HEAP32[$2 + 8 >> 2] >= HEAP32[$0 >> 2]) {
   break label$2;
  }
 }
 if (HEAP32[$0 >> 2] > 5) {
  $0 = HEAP32[HEAP32[$0 + 4 >> 2] + (HEAP32[$2 + 8 >> 2] << 2) >> 2];
 } else {
  $0 = HEAP32[($0 + 4 | 0) + (HEAP32[$2 + 8 >> 2] << 2) >> 2];
 }
 return $0;
}

function jswrap_graphics_fillRect($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 28 >> 2] = $0;
 HEAP32[$5 + 24 >> 2] = $1;
 HEAP32[$5 + 20 >> 2] = $2;
 HEAP32[$5 + 16 >> 2] = $3;
 HEAP32[$5 + 12 >> 2] = $4;
 $0 = _jswrap_graphics_fillRect_col(HEAP32[$5 + 28 >> 2], HEAP32[$5 + 24 >> 2], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 12 >> 2], 1);
 __stack_pointer = $5 + 32 | 0;
 return $0 | 0;
}

function jswrap_espruino_setBootCode($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 label$1: {
  if (jsvIsString(HEAP32[$2 + 12 >> 2]) & 1) {
   HEAP32[$2 + 12 >> 2] = jsvLockAgain(HEAP32[$2 + 12 >> 2]);
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvNewFromEmptyString_9();
 }
 jsfSaveBootCodeToFlash(HEAP32[$2 + 12 >> 2], HEAP8[$2 + 11 | 0] & 1);
 jsvUnLock(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
}

function graphicsClear($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = HEAP32[$1 + 12 >> 2];
 $3 = HEAP32[$1 + 12 >> 2];
 $0 = HEAP32[$1 + 12 >> 2];
 graphicsFillRectDevice(HEAP32[$1 + 12 >> 2], 0, 0, (HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8) - 1 | 0, (HEAPU8[$3 + 14 | 0] | HEAPU8[$3 + 15 | 0] << 8) - 1 | 0, HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24));
 __stack_pointer = $1 + 16 | 0;
}

function jsiQueueObjectCallbacks($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2]);
 if (HEAP32[$4 + 12 >> 2]) {
  jsiQueueEvents(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 12 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
  jsvUnLock(HEAP32[$4 + 12 >> 2]);
 }
 __stack_pointer = $4 + 32 | 0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph____Get_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = flatbuffers__IndirectHelper_flatbuffers__Offset_tflite__SubGraph____Read_28unsigned_20char_20const__2c_20unsigned_20int_29(flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph____Data_28_29_20const(HEAP32[$2 + 12 >> 2]), HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Operator____Get_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = flatbuffers__IndirectHelper_flatbuffers__Offset_tflite__Operator____Read_28unsigned_20char_20const__2c_20unsigned_20int_29(flatbuffers__Vector_flatbuffers__Offset_tflite__Operator____Data_28_29_20const(HEAP32[$2 + 12 >> 2]), HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Metadata____Get_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = flatbuffers__IndirectHelper_flatbuffers__Offset_tflite__Metadata____Read_28unsigned_20char_20const__2c_20unsigned_20int_29(flatbuffers__Vector_flatbuffers__Offset_tflite__Metadata____Data_28_29_20const(HEAP32[$2 + 12 >> 2]), HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator__Allocate_28unsigned_20long_2c_20unsigned_20long_29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[HEAP32[$3 + 12 >> 2] + 4 >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 12 >> 2]]($0, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]) | 0;
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function flatbuffers__IndirectHelper_flatbuffers__Offset_tflite__OperatorCode____Read_28unsigned_20char_20const__2c_20unsigned_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 8 >> 2] << 2);
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 + $1 | 0;
}

function jsvUnLockInline($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 12 >> 2]) {
   break label$1;
  }
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) - 1024 | 0;
  HEAP8[$0 + 12 | 0] = $2;
  HEAP8[$0 + 13 | 0] = $2 >>> 8;
  HEAP16[$1 + 10 >> 1] = $2;
  if (HEAPU16[$1 + 10 >> 1] & 15360) {
   break label$1;
  }
  jsvUnLockFreeIfNeeded(HEAP32[$1 + 12 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
}

function jslGetTokenValueAsString() {
 var $0 = 0;
 HEAP8[HEAPU8[HEAP32[49079] + 80 | 0] + (HEAP32[49079] + 12 | 0) | 0] = 0;
 if (!(HEAPU8[HEAP32[49079] + 80 | 0] | HEAP16[HEAP32[49079] + 2 >> 1] < 163 | HEAP16[HEAP32[49079] + 2 >> 1] > 198)) {
  jslTokenAsString(HEAP16[HEAP32[49079] + 2 >> 1], HEAP32[49079] + 12 | 0, 64);
  strcpy(HEAP32[49079] + 12 | 0, jslReservedWordAsString(HEAP16[HEAP32[49079] + 2 >> 1]));
  $0 = strlen(HEAP32[49079] + 12 | 0);
  HEAP8[HEAP32[49079] + 80 | 0] = $0;
 }
 return HEAP32[49079] + 12 | 0;
}

function _jswrap_io_poke($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (HEAP32[$3 + 4 >> 2] == 1) {
   HEAP8[HEAP32[$3 + 12 >> 2]] = HEAP32[$3 + 8 >> 2];
   break label$1;
  }
  label$3: {
   if (HEAP32[$3 + 4 >> 2] == 2) {
    HEAP16[HEAP32[$3 + 12 >> 2] >> 1] = HEAP32[$3 + 8 >> 2];
    break label$3;
   }
   if (HEAP32[$3 + 4 >> 2] == 4) {
    HEAP32[HEAP32[$3 + 12 >> 2] >> 2] = HEAP32[$3 + 8 >> 2];
   }
  }
 }
}

function mbedtls_sha512($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 240 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 236 >> 2] = $0;
 HEAP32[$4 + 232 >> 2] = $1;
 HEAP32[$4 + 228 >> 2] = $2;
 HEAP32[$4 + 224 >> 2] = $3;
 mbedtls_sha512_init($4 + 8 | 0);
 mbedtls_sha512_starts($4 + 8 | 0, HEAP32[$4 + 224 >> 2]);
 mbedtls_sha512_update($4 + 8 | 0, HEAP32[$4 + 236 >> 2], HEAP32[$4 + 232 >> 2]);
 mbedtls_sha512_finish($4 + 8 | 0, HEAP32[$4 + 228 >> 2]);
 mbedtls_sha512_free($4 + 8 | 0);
 __stack_pointer = $4 + 240 | 0;
}

function float_20tflite__ActivationFunctionWithMinMax_float__28float_2c_20float_2c_20float_29($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAPF32[$3 + 12 >> 2] = $0;
 HEAPF32[$3 + 8 >> 2] = $1;
 HEAPF32[$3 + 4 >> 2] = $2;
 $4 = float_20const__20std____2__min_float__28float_20const__2c_20float_20const__29(float_20const__20std____2__max_float__28float_20const__2c_20float_20const__29($3 + 12 | 0, $3 + 8 | 0), $3 + 4 | 0);
 __stack_pointer = $3 + 16 | 0;
 return HEAPF32[$4 >> 2];
}

function tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Init_28unsigned_20long_2c_20unsigned_20long_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP32[$0 + 8 >> 2] = HEAP32[$3 + 8 >> 2];
 HEAP32[$0 + 12 >> 2] = HEAP32[$3 + 4 >> 2];
 $0 = tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Allocate_28_29($0);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_long_20long__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_long_20long__20const___28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = flatbuffers__Vector_long_20long__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_long_20long__20const___28unsigned_20short_29(HEAP32[$2 + 12 >> 2], HEAPU16[$2 + 10 >> 1]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator_20bool_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[std____2____compressed_pair_TfLiteSoftmaxParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const(HEAP32[$1 + 12 >> 2]) >> 2];
 __stack_pointer = $1 + 16 | 0;
 return ($0 | 0) != 0;
}

function std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator_20bool_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[std____2____compressed_pair_TfLiteReshapeParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const(HEAP32[$1 + 12 >> 2]) >> 2];
 __stack_pointer = $1 + 16 | 0;
 return ($0 | 0) != 0;
}

function jswrap_json_parse_ext($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 160 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 156 >> 2] = $0;
 HEAP32[$2 + 152 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = jsvAsString(HEAP32[$2 + 156 >> 2]);
 HEAP32[$2 + 16 >> 2] = jslSetLex($2 + 24 | 0);
 jslInit(HEAP32[$2 + 20 >> 2]);
 jsvUnLock(HEAP32[$2 + 20 >> 2]);
 HEAP32[$2 + 12 >> 2] = jswrap_json_parse_internal(HEAP32[$2 + 152 >> 2]);
 jslKill();
 jslSetLex(HEAP32[$2 + 16 >> 2]);
 __stack_pointer = $2 + 160 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jspFindPrototypeFor($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[91086], HEAP32[$1 + 8 >> 2]);
 label$1: {
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 4 >> 2], 132159);
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function flatbuffers__IndirectHelper_flatbuffers__Offset_tflite__SubGraph____Read_28unsigned_20char_20const__2c_20unsigned_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 8 >> 2] << 2);
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 + $1 | 0;
}

function flatbuffers__IndirectHelper_flatbuffers__Offset_tflite__Operator____Read_28unsigned_20char_20const__2c_20unsigned_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 8 >> 2] << 2);
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 + $1 | 0;
}

function flatbuffers__IndirectHelper_flatbuffers__Offset_tflite__Metadata____Read_28unsigned_20char_20const__2c_20unsigned_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 8 >> 2] << 2);
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 + $1 | 0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor____Get_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = flatbuffers__IndirectHelper_flatbuffers__Offset_tflite__Tensor____Read_28unsigned_20char_20const__2c_20unsigned_20int_29(flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor____Data_28_29_20const(HEAP32[$2 + 12 >> 2]), HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer____Get_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = flatbuffers__IndirectHelper_flatbuffers__Offset_tflite__Buffer____Read_28unsigned_20char_20const__2c_20unsigned_20int_29(flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer____Data_28_29_20const(HEAP32[$2 + 12 >> 2]), HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_TfLiteFullyConnectedParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$0 >> 2];
}

function flatbuffers__IndirectHelper_flatbuffers__Offset_tflite__Tensor____Read_28unsigned_20char_20const__2c_20unsigned_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 8 >> 2] << 2);
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 + $1 | 0;
}

function flatbuffers__IndirectHelper_flatbuffers__Offset_tflite__Buffer____Read_28unsigned_20char_20const__2c_20unsigned_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 8 >> 2] << 2);
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 + $1 | 0;
}

function std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 std____2__unique_ptr_TfLiteFullyConnectedParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___reset_28TfLiteFullyConnectedParams__29($0, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__QuantizeMultiplierGreaterThanOne_28double_2c_20int__2c_20int__29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAPF64[$3 + 8 >> 3] = $0;
 HEAP32[$3 + 4 >> 2] = $1;
 HEAP32[$3 >> 2] = $2;
 if (!(HEAPF64[$3 + 8 >> 3] > 1)) {
  abort();
  abort();
 }
 tflite__QuantizeMultiplier_28double_2c_20int__2c_20int__29(HEAPF64[$3 + 8 >> 3], HEAP32[$3 + 4 >> 2], HEAP32[$3 >> 2]);
 if (HEAP32[HEAP32[$3 >> 2] >> 2] < 0) {
  abort();
  abort();
 }
 __stack_pointer = $3 + 16 | 0;
}

function strlen($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = $0;
 label$1: {
  if ($1 & 3) {
   while (1) {
    if (!HEAPU8[$1 | 0]) {
     break label$1;
    }
    $1 = $1 + 1 | 0;
    if ($1 & 3) {
     continue;
    }
    break;
   }
  }
  while (1) {
   $2 = $1;
   $1 = $1 + 4 | 0;
   $3 = HEAP32[$2 >> 2];
   if (!(($3 ^ -1) & $3 - 16843009 & -2139062144)) {
    continue;
   }
   break;
  }
  while (1) {
   $1 = $2;
   $2 = $1 + 1 | 0;
   if (HEAPU8[$1 | 0]) {
    continue;
   }
   break;
  }
 }
 return $1 - $0 | 0;
}

function std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_TfLiteDepthwiseConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$0 >> 2];
}

function push_literal_byte($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP16[$2 + 6 >> 1] = HEAPU16[HEAP32[$2 + 12 >> 2] + 2 >> 1] - 1;
 HEAP16[$2 + 4 >> 1] = (get_input_offset(HEAP32[$2 + 12 >> 2]) & 65535) + HEAPU16[$2 + 6 >> 1];
 HEAP8[$2 + 3 | 0] = HEAPU8[HEAPU16[$2 + 4 >> 1] + (HEAP32[$2 + 12 >> 2] + 15 | 0) | 0];
 push_bits(HEAP32[$2 + 12 >> 2], 8, HEAPU8[$2 + 3 | 0], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_banglejs_kill() {
 jsvUnLock(HEAP32[97789]);
 HEAP32[97789] = 0;
 jsvUnLock(HEAP32[97790]);
 HEAP32[97790] = 0;
 if (HEAPU16[195569]) {
  jswrap_banglejs_beep_callback();
 }
 if (HEAPU8[391136]) {
  jswrap_banglejs_buzz_callback();
 }
 jshPinWatch(17, 0, 0);
 jshSetPinShouldStayWatched(17, 0);
 lcdMemLCD_setOverlay(0, 0, 0);
 jsvUnLock(HEAPU8[366800] | HEAPU8[366801] << 8 | (HEAPU8[366802] << 16 | HEAPU8[366803] << 24));
 HEAP8[366800] = 0;
 HEAP8[366801] = 0;
 HEAP8[366802] = 0;
 HEAP8[366803] = 0;
}

function jswrap_array_splice_i($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = jsvNewFromInteger(HEAP32[$4 + 20 >> 2]);
 HEAP32[$4 + 8 >> 2] = jswrap_array_splice(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 12 >> 2], HEAP32[$4 + 16 >> 2]);
 jsvUnLock(HEAP32[$4 + 12 >> 2]);
 __stack_pointer = $4 + 32 | 0;
 return HEAP32[$4 + 8 >> 2];
}

function std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator_20bool_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[std____2____compressed_pair_TfLitePoolParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const(HEAP32[$1 + 12 >> 2]) >> 2];
 __stack_pointer = $1 + 16 | 0;
 return ($0 | 0) != 0;
}

function std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 std____2__unique_ptr_TfLiteDepthwiseConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___reset_28TfLiteDepthwiseConvParams__29($0, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator_20bool_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const(HEAP32[$1 + 12 >> 2]) >> 2];
 __stack_pointer = $1 + 16 | 0;
 return ($0 | 0) != 0;
}

function jswrap_object_keys_or_property_names($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 >> 2] = jsvNewEmptyArray();
 label$1: {
  if (!HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  jswrap_object_keys_or_property_names_cb(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2], 623, HEAP32[$2 >> 2]);
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function tflite__QuantizationParameters_20const__20flatbuffers__Table__GetPointer_tflite__QuantizationParameters_20const___28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = tflite__QuantizationParameters_20const__20flatbuffers__Table__GetPointer_tflite__QuantizationParameters_20const___28unsigned_20short_29(HEAP32[$2 + 12 >> 2], HEAPU16[$2 + 10 >> 1]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jswrap_string_charCodeAt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 >> 2] = _jswrap_string_charCodeAt(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
 label$1: {
  if (HEAP32[$2 >> 2] < 0) {
   HEAP32[$2 + 12 >> 2] = jsvNewFromFloat(nan);
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvNewFromInteger(HEAP32[$2 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jsvArrayBufferIteratorSetValueAndRewind($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP32[$2 + 40 >> 2] = $1;
 jsvStringIteratorClone($2, HEAP32[$2 + 44 >> 2]);
 jsvArrayBufferIteratorSetValue(HEAP32[$2 + 44 >> 2], HEAP32[$2 + 40 >> 2], 0);
 jsvStringIteratorFree_2(HEAP32[$2 + 44 >> 2]);
 jsvStringIteratorClone(HEAP32[$2 + 44 >> 2], $2);
 jsvStringIteratorFree_2($2);
 HEAP8[HEAP32[$2 + 44 >> 2] + 52 | 0] = 0;
 __stack_pointer = $2 + 48 | 0;
}

function jshSleep($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 12 >> 2] = $1;
 HEAPF64[$2 >> 3] = jshGetMillisecondsFromTime(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2]);
 if (HEAPF64[$2 >> 3] > 2147483647) {
  HEAPF64[$2 >> 3] = 2147483647;
 }
 $3 = HEAPF64[$2 >> 3];
 label$2: {
  if (Math_abs($3) < 2147483648) {
   $0 = ~~$3;
   break label$2;
  }
  $0 = -2147483648;
 }
 HEAP32[48918] = $0;
 __stack_pointer = $2 + 16 | 0;
 return 0;
}

function tflite__OpResolver__GetDelegates_28int_29_20const($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 std____2__vector_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29_____vector_28_29($0);
 __stack_pointer = $3 + 16 | 0;
}

function jswrap_array_findIndex($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 >> 2] = _jswrap_array_iterate_with_callback(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2], 0, 3, 1, 1);
 label$1: {
  if (HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvNewFromInteger(-1);
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jsvArrayBufferIteratorHasElement($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAPU8[HEAP32[$1 + 8 >> 2] + 36 | 0]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  if (HEAP8[HEAP32[$1 + 8 >> 2] + 52 | 0] & 1) {
   HEAP8[$1 + 15 | 0] = 1;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = HEAPU32[HEAP32[$1 + 8 >> 2] + 40 >> 2] >= HEAP32[HEAP32[$1 + 8 >> 2] + 44 >> 2] + (HEAPU8[HEAP32[$1 + 8 >> 2] + 36 | 0] & 15) >>> 0;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function lcdGetPixel_ArrayBuffer_flat8($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $1 = HEAP32[$3 + 12 >> 2];
 $0 = HEAP32[$3 + 12 >> 2];
 return HEAPU8[(HEAP32[$3 + 8 >> 2] + Math_imul(HEAP32[$3 + 4 >> 2], HEAPU8[$1 + 12 | 0] | HEAPU8[$1 + 13 | 0] << 8) | 0) + (HEAPU8[$0 + 48 | 0] | HEAPU8[$0 + 49 | 0] << 8 | (HEAPU8[$0 + 50 | 0] << 16 | HEAPU8[$0 + 51 | 0] << 24)) | 0];
}

function jsiReplaceInputLine($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (jsiShowInputLine() & 1) {
  jsiMoveCursorChar(HEAP32[91104], HEAP32[91106], 0);
  jsiConsoleEraseAfterCursor();
  jsiConsolePrintStringVarWithNewLineChar(HEAP32[$1 + 12 >> 2], 0, 58);
 }
 jsiInputLineCursorMoved();
 jsvUnLock(HEAP32[91104]);
 HEAP32[91104] = jsvLockAgain(HEAP32[$1 + 12 >> 2]);
 HEAP32[91106] = jsvGetStringLength(HEAP32[91104]);
 __stack_pointer = $1 + 16 | 0;
}

function jsfCompact($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 14 | 0] = $0;
 label$1: {
  if ((jswrap_banglejs_getBattery() | 0) < 10) {
   jsiConsolePrintf(146535, 0);
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  jsfCacheClear();
  HEAP32[91095] = 0;
  HEAP32[91096] = 0;
  HEAP8[$1 + 13 | 0] = jsfBankCompact(134217728, HEAP8[$1 + 14 | 0] & 1) & 1;
  HEAP8[$1 + 15 | 0] = HEAP8[$1 + 13 | 0] & 1;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}

function jsvArrayBufferIteratorDataToFloat($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 HEAP32[$2 + 28 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 20 >> 2] = HEAPU8[HEAP32[$2 + 28 >> 2] + 36 | 0] & 15;
 HEAPF64[$2 + 8 >> 3] = 0;
 label$1: {
  if (HEAP32[$2 + 20 >> 2] == 4) {
   HEAPF64[$2 + 8 >> 3] = HEAPF32[HEAP32[$2 + 24 >> 2] >> 2];
   break label$1;
  }
  if (HEAP32[$2 + 20 >> 2] == 8) {
   HEAPF64[$2 + 8 >> 3] = HEAPF64[HEAP32[$2 + 24 >> 2] >> 3];
  }
 }
 return HEAPF64[$2 + 8 >> 3];
}

function graphicsGetSetPixelFn($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = HEAP32[$1 + 8 >> 2];
 label$1: {
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 112) {
   HEAP32[$1 + 12 >> 2] = 581;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP32[$1 + 12 >> 2] = HEAPU8[$0 + 52 | 0] | HEAPU8[$0 + 53 | 0] << 8 | (HEAPU8[$0 + 54 | 0] << 16 | HEAPU8[$0 + 55 | 0] << 24);
 }
 return HEAP32[$1 + 12 >> 2];
}

function void_20std____2____debug_db_insert_c_std____2__vector_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29_____28std____2__vector_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29__2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29_____29($0) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
}

function std____2____compressed_pair_elem_std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29___2c_201_2c_20true_____compressed_pair_elem_28std____2____default_init_tag_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 4 >> 2] = $0;
 $0 = HEAP32[$1 + 4 >> 2];
 std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29____allocator_28_29($0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsvFindOrAddChildFromString($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvFindChildFromString(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 if (!HEAP32[$2 + 4 >> 2]) {
  HEAP32[$2 + 4 >> 2] = jsvNewNameFromString(HEAP32[$2 + 8 >> 2]);
  if (HEAP32[$2 + 4 >> 2]) {
   jsvAddName(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2]);
  }
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 4 >> 2];
}

function std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_TfLiteSoftmaxParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$0 >> 2];
}

function std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_TfLiteReshapeParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$0 >> 2];
}

function jsiIsAboutToEditInputLine() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 if (HEAP8[364429] & 1) {
  HEAP8[364429] = 0;
  if (jsiIsInHistory(HEAP32[91104]) & 1) {
   HEAP32[$0 + 12 >> 2] = jsvCopy(HEAP32[91104], 0);
   if (HEAP32[$0 + 12 >> 2]) {
    jsiInputLineCursorMoved();
    jsvUnLock(HEAP32[91104]);
    HEAP32[91104] = HEAP32[$0 + 12 >> 2];
   }
  }
 }
 if (HEAP32[48917] < 0) {
  HEAP32[48917] = jsvGetStringLength(HEAP32[91104]);
 }
 __stack_pointer = $0 + 16 | 0;
}

function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SaturatingRoundingMultiplyByPOT__2_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromRaw_28int_29(int_20gemmlowp__SaturatingRoundingMultiplyByPOT__2_2c_20int__28int_29(HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($1) >> 2]));
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__SaturatingRoundingMultiplyByPOT__1_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromRaw_28int_29(int_20gemmlowp__SaturatingRoundingMultiplyByPOT__1_2c_20int__28int_29(HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($1) >> 2]));
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jsfGetJSONWhitespace($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 60 >> 2] = $0;
 HEAP32[$4 + 56 >> 2] = $1;
 HEAP32[$4 + 52 >> 2] = $2;
 HEAP32[$4 + 48 >> 2] = $3;
 jsvStringIteratorNew($4 + 8 | 0, HEAP32[$4 + 56 >> 2], 0);
 jsvStringIteratorGotoEnd($4 + 8 | 0);
 jsfGetJSONWithCallback(HEAP32[$4 + 60 >> 2], 0, HEAP32[$4 + 52 >> 2], HEAP32[$4 + 48 >> 2], 2, $4 + 8 | 0);
 jsvStringIteratorFree_8($4 + 8 | 0);
 __stack_pointer = $4 - -64 | 0;
}

function tflite__ElementCount_28TfLiteIntArray_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 1;
 HEAP32[$1 + 4 >> 2] = 0;
 while (1) {
  if (HEAP32[$1 + 4 >> 2] < HEAP32[HEAP32[$1 + 12 >> 2] >> 2]) {
   HEAP32[$1 + 8 >> 2] = Math_imul(HEAP32[(HEAP32[$1 + 12 >> 2] + 4 | 0) + (HEAP32[$1 + 4 >> 2] << 2) >> 2], HEAP32[$1 + 8 >> 2]);
   HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
   continue;
  }
  break;
 }
 return HEAP32[$1 + 8 >> 2];
}

function jsvGetLinesInString($0) {
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 HEAP32[$1 + 40 >> 2] = 1;
 jsvStringIteratorNew($1, HEAP32[$1 + 44 >> 2], 0);
 while (1) {
  if (jsvStringIteratorHasChar_1($1) & 1) {
   if ((jsvStringIteratorGetCharAndNext($1) & 255) == 10) {
    HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 40 >> 2] + 1;
   }
   continue;
  }
  break;
 }
 jsvStringIteratorFree_1($1);
 __stack_pointer = $1 + 48 | 0;
 return HEAP32[$1 + 40 >> 2];
}

function jspGetPrototypeOwner($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  label$2: {
   if (!(jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1)) {
    if (!(jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1)) {
     break label$2;
    }
   }
   HEAP32[$1 + 12 >> 2] = jsvSkipNameAndUnLock(jsvObjectGetChildIfExists(HEAP32[$1 + 8 >> 2], 120855));
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvMakeFunctionParameter($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (!(jsvIsName(HEAP32[$1 + 12 >> 2]) & 1)) {
  HEAP32[$1 + 12 >> 2] = jsvMakeIntoVariableName(HEAP32[$1 + 12 >> 2], 0);
 }
 $0 = HEAP32[$1 + 12 >> 2];
 $2 = HEAP32[$1 + 12 >> 2];
 $2 = HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8 | 128;
 HEAP8[$0 + 12 | 0] = $2;
 HEAP8[$0 + 13 | 0] = $2 >>> 8;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jshGetEventFlagsForPin($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 14 | 0] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 label$1: {
  while (1) {
   if (HEAP32[$1 + 8 >> 2] < 16) {
    if (HEAPU8[HEAP32[$1 + 8 >> 2] + 390976 | 0] == HEAPU8[$1 + 14 | 0]) {
     HEAP8[$1 + 15 | 0] = HEAP32[$1 + 8 >> 2] + 1;
     break label$1;
    } else {
     HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
     continue;
    }
   }
   break;
  }
  HEAP8[$1 + 15 | 0] = 0;
 }
 return HEAPU8[$1 + 15 | 0];
}

function std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_TfLitePoolParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$0 >> 2];
}

function std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___operator___28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$0 >> 2];
}

function st_tag_bit($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = get_bits(HEAP32[$1 + 8 >> 2], 1) & 65535;
 label$1: {
  if (HEAP32[$1 + 4 >> 2] == 65535) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  if (HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 1;
   break label$1;
  }
  HEAP16[HEAP32[$1 + 8 >> 2] + 6 >> 1] = 0;
  HEAP32[$1 + 12 >> 2] = 3;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function mbedtls_ccm_init($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 48 >> 2] = 0;
 HEAP32[$0 + 52 >> 2] = 0;
 HEAP32[$0 + 40 >> 2] = 0;
 HEAP32[$0 + 44 >> 2] = 0;
 HEAP32[$0 + 32 >> 2] = 0;
 HEAP32[$0 + 36 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
}

function mbedtls_aes_crypt_ecb($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 label$1: {
  if (HEAP32[$4 + 8 >> 2] == 1) {
   mbedtls_aes_encrypt(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
   break label$1;
  }
  mbedtls_aes_decrypt(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
 }
 __stack_pointer = $4 + 16 | 0;
 return 0;
}

function jshPinInput($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 HEAP8[$1 + 14 | 0] = 0;
 label$1: {
  if (jshIsPinValid(HEAPU8[$1 + 15 | 0]) & 1) {
   if (!(jshGetPinStateIsManual(HEAPU8[$1 + 15 | 0]) & 1)) {
    jshPinSetState(HEAPU8[$1 + 15 | 0], 4);
   }
   HEAP8[$1 + 14 | 0] = jshPinGetValue(HEAPU8[$1 + 15 | 0]) & 1;
   break label$1;
  }
  jsExceptionHere(1, 128480, 0);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 14 | 0] & 1;
}

function flatbuffers__Vector_float__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_float__20const___28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = flatbuffers__Vector_float__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_float__20const___28unsigned_20short_29(HEAP32[$2 + 12 >> 2], HEAPU16[$2 + 10 >> 1]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function _jswrap_promise_is_promise($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jspGetConstructor(HEAP32[$1 + 12 >> 2]);
 if (HEAP32[$1 + 8 >> 2]) {
  $0 = HEAP32[$1 + 8 >> 2];
  $2 = (HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) == 20;
 }
 HEAP8[$1 + 7 | 0] = $2;
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 7 | 0] & 1;
}

function std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 std____2__unique_ptr_TfLiteSoftmaxParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___reset_28TfLiteSoftmaxParams__29($0, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 std____2__unique_ptr_TfLiteReshapeParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___reset_28TfLiteReshapeParams__29($0, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function st_backref_index_msb($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP8[$1 + 7 | 0] = 8;
 HEAP16[$1 + 4 >> 1] = get_bits(HEAP32[$1 + 8 >> 2], HEAPU8[$1 + 7 | 0] - 8 & 255);
 label$1: {
  if (HEAPU16[$1 + 4 >> 1] == 65535) {
   HEAP32[$1 + 12 >> 2] = 2;
   break label$1;
  }
  HEAP16[HEAP32[$1 + 8 >> 2] + 6 >> 1] = HEAPU16[$1 + 4 >> 1] << 8;
  HEAP32[$1 + 12 >> 2] = 3;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function st_backref_count_msb($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP8[$1 + 7 | 0] = 6;
 HEAP16[$1 + 4 >> 1] = get_bits(HEAP32[$1 + 8 >> 2], HEAPU8[$1 + 7 | 0] - 8 & 255);
 label$1: {
  if (HEAPU16[$1 + 4 >> 1] == 65535) {
   HEAP32[$1 + 12 >> 2] = 4;
   break label$1;
  }
  HEAP16[HEAP32[$1 + 8 >> 2] + 4 >> 1] = HEAPU16[$1 + 4 >> 1] << 8;
  HEAP32[$1 + 12 >> 2] = 5;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_string_charAt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 >> 2] = jswrap_string_charAt_undefined(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
 label$1: {
  if (HEAP32[$2 >> 2]) {
   HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2];
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvNewFromEmptyString_8();
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function tflite___28anonymous_20namespace_29__AllocationInfoBuilder__AllocationInfoBuilder_28tflite__ErrorReporter__2c_20tflite__SimpleMemoryAllocator__29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$3 + 8 >> 2];
 HEAP32[$0 + 4 >> 2] = HEAP32[$3 + 4 >> 2];
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 return $0;
}

function jswrap_banglejs_hwinit() {
 graphicsStructInit(366800, 176, 176, 3);
 HEAP8[366804] = 6;
 HEAP8[366805] = 0;
 HEAP8[366806] = 0;
 HEAP8[366807] = 0;
 HEAP8[366816] = 16;
 HEAP8[366808] = 0;
 HEAP8[366809] = 0;
 HEAP8[366810] = 0;
 HEAP8[366811] = 0;
 HEAP8[366825] = 1;
 HEAP8[366826] = 64;
 lcdMemLCD_init(366800);
 jswrap_banglejs_pwrBacklight(1);
 graphicsSetCallbacks(366800);
 jswrap_banglejs_setTheme();
 graphicsFillRect(366800, 0, 0, 175, 175, HEAPU8[366787] | HEAPU8[366788] << 8);
}

function jsvIsInternalObjectKey($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (jsvIsString(HEAP32[$1 + 12 >> 2]) & 1) {
  $2 = 1;
  label$2: {
   if (HEAP8[HEAP32[$1 + 12 >> 2]] == -1) {
    break label$2;
   }
   $2 = 1;
   if (jsvIsStringEqual(HEAP32[$1 + 12 >> 2], 135865) & 1) {
    break label$2;
   }
   $2 = jsvIsStringEqual(HEAP32[$1 + 12 >> 2], 120855);
  }
 }
 __stack_pointer = $1 + 16 | 0;
 return $2 & 1;
}

function i2c_wr($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = 0;
 while (1) {
  if (HEAP32[$2 + 4 >> 2] < 8) {
   i2c_wr_bit(HEAP32[$2 + 12 >> 2], (HEAP32[$2 + 8 >> 2] & 128) != 0);
   HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] << 1;
   HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
   continue;
  }
  break;
 }
 i2c_rd_bit(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return 1;
}

function jsvObjectIteratorRemoveAndGotoNext($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 if (HEAP32[HEAP32[$2 + 12 >> 2] >> 2]) {
  HEAP16[$2 + 6 >> 1] = jsvGetNextSibling(HEAP32[HEAP32[$2 + 12 >> 2] >> 2]);
  jsvRemoveChildAndUnLock(HEAP32[$2 + 8 >> 2], HEAP32[HEAP32[$2 + 12 >> 2] >> 2]);
  $0 = jsvLockSafe(HEAPU16[$2 + 6 >> 1]);
  HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = $0;
 }
 __stack_pointer = $2 + 16 | 0;
}

function jshGetTimeFromMilliseconds($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = HEAPF64[$1 + 8 >> 3] * 1e3;
 label$1: {
  if (Math_abs($0) < 0x8000000000000000) {
   $1 = Math_abs($0) >= 1 ? ~~($0 > 0 ? Math_min(Math_floor($0 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($0 - +(~~$0 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
   $2 = ~~$0 >>> 0;
   break label$1;
  }
  $1 = -2147483648;
 }
 i64toi32_i32$HIGH_BITS = $1;
 return $2;
}

function std____2____compressed_pair_TfLiteFullyConnectedParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___second_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____get_28_29(HEAP32[$1 + 12 >> 2] + 4 | 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_onewire_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 11 | 0] = $0;
 HEAP32[$1 + 4 >> 2] = jspNewObject(0, 132150);
 label$1: {
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  jsvObjectSetChildAndUnLock(HEAP32[$1 + 4 >> 2], 128488, jsvNewFromPin(HEAPU8[$1 + 11 | 0]));
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function std____2____compressed_pair_TfLiteDepthwiseConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___second_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____get_28_29(HEAP32[$1 + 12 >> 2] + 4 | 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_serial_setConsole($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 HEAP8[$2 + 10 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 12 >> 2]);
 label$1: {
  if (!(HEAPU8[$2 + 10 | 0] < 17 | HEAPU8[$2 + 10 | 0] > 22)) {
   jsiSetConsoleDevice(HEAPU8[$2 + 10 | 0], HEAP8[$2 + 11 | 0] & 1);
   break label$1;
  }
  jsExceptionHere(1, 120399, 0);
 }
 __stack_pointer = $2 + 16 | 0;
}

function hexToByte($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 11 | 0] = $0;
 HEAP8[$2 + 10 | 0] = $1;
 HEAP32[$2 + 4 >> 2] = chtod(HEAP8[$2 + 11 | 0]);
 HEAP32[$2 >> 2] = chtod(HEAP8[$2 + 10 | 0]);
 label$1: {
  if ((HEAP32[$2 + 4 >> 2] | HEAP32[$2 >> 2]) < 0) {
   HEAP32[$2 + 12 >> 2] = -1;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 >> 2] | HEAP32[$2 + 4 >> 2] << 4;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function gemmlowp__FixedPoint_int_2c_2012__20gemmlowp__Rescale_12_2c_20int_2c_200__28gemmlowp__FixedPoint_int_2c_200__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 >> 2] = $0;
 $0 = int_20gemmlowp__SaturatingRoundingMultiplyByPOT__12_2c_20int__28int_29(HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($1) >> 2]);
 HEAP32[gemmlowp__FixedPoint_int_2c_2012___raw_28_29($1 + 8 | 0) >> 2] = $0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function tflite__RuntimeShape__ReplaceWith_28int_2c_20int_20const__29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 tflite__RuntimeShape__Resize_28int_29($0, HEAP32[$3 + 8 >> 2]);
 HEAP32[$3 >> 2] = tflite__RuntimeShape__DimsData_28_29($0);
 __memcpy(HEAP32[$3 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$3 + 8 >> 2] << 2);
 __stack_pointer = $3 + 16 | 0;
}

function jsvAppendString($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP32[$2 + 40 >> 2] = $1;
 jsvStringIteratorNew($2, HEAP32[$2 + 44 >> 2], 0);
 jsvStringIteratorGotoEnd($2);
 while (1) {
  if (HEAPU8[HEAP32[$2 + 40 >> 2]]) {
   $0 = HEAP32[$2 + 40 >> 2];
   HEAP32[$2 + 40 >> 2] = $0 + 1;
   jsvStringIteratorAppend($2, HEAP8[$0 | 0]);
   continue;
  }
  break;
 }
 jsvStringIteratorFree_1($2);
 __stack_pointer = $2 + 48 | 0;
}

function isWhitespaceInline_1($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = 1;
 label$1: {
  if (HEAP8[$1 + 15 | 0] == 9) {
   break label$1;
  }
  $0 = 1;
  if (HEAP8[$1 + 15 | 0] == 11) {
   break label$1;
  }
  $0 = 1;
  if (HEAP8[$1 + 15 | 0] == 12) {
   break label$1;
  }
  $0 = 1;
  if (HEAP8[$1 + 15 | 0] == 32) {
   break label$1;
  }
  $0 = 1;
  if (HEAP8[$1 + 15 | 0] == 10) {
   break label$1;
  }
  $0 = HEAP8[$1 + 15 | 0] == 13;
 }
 return $0;
}

function flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29(HEAP32[$2 + 12 >> 2], HEAPU16[$2 + 10 >> 1]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function _jswrap_object_values_cb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 >> 2] = jsvAsArrayIndex(HEAP32[$2 + 8 >> 2]);
 jsvArrayPushAndUnLock(HEAP32[HEAP32[$2 + 4 >> 2] >> 2], jspGetVarNamedField(HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2], HEAP32[$2 >> 2], 0));
 jsvUnLock(HEAP32[$2 >> 2]);
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_tfmicrointerpreter_getTFMI($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvObjectGetChildIfExists(HEAP32[$1 + 12 >> 2], 129322);
 HEAP32[$1 >> 2] = jsvGetDataPointer(HEAP32[$1 + 8 >> 2], $1 + 4 | 0);
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 if (!HEAP32[$1 >> 2]) {
  jsExceptionHere(1, 133576, 0);
 }
 HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + 15 & -16;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 >> 2];
}

function jspromise_resolve_or_reject($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 HEAP32[$3 >> 2] = jsvNewObject();
 if (HEAP32[$3 >> 2]) {
  jsvObjectSetChild(HEAP32[$3 >> 2], 128686, HEAP32[$3 + 12 >> 2]);
  _jswrap_prombox_queueresolve_or_reject(HEAP32[$3 >> 2], HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
  jsvUnLock(HEAP32[$3 >> 2]);
 }
 __stack_pointer = $3 + 16 | 0;
}

function jspGetStackTrace() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = jsvFindChildFromString(HEAP32[91087], 132883);
 label$1: {
  if (HEAP32[$0 + 8 >> 2]) {
   HEAP32[$0 + 4 >> 2] = jsvSkipName(HEAP32[$0 + 8 >> 2]);
   jsvRemoveChildAndUnLock(HEAP32[91087], HEAP32[$0 + 8 >> 2]);
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 4 >> 2];
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = 0;
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function bool_20flatbuffers__IsOutRange_tflite__BuiltinOperator__28tflite__BuiltinOperator_20const__2c_20tflite__BuiltinOperator_20const__2c_20tflite__BuiltinOperator_20const__29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = 1;
 $0 = HEAP32[HEAP32[$3 + 12 >> 2] >> 2] >= HEAP32[HEAP32[$3 + 8 >> 2] >> 2] ? HEAP32[HEAP32[$3 + 4 >> 2] >> 2] < HEAP32[HEAP32[$3 + 12 >> 2] >> 2] : $0;
 return $0;
}

function tflite__ErrorReporter__ReportError_28void__2c_20char_20const__2c_20____29($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 $0 = HEAP32[$4 + 28 >> 2];
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 8 >> 2]]($0, HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
 __stack_pointer = $4 + 32 | 0;
 return HEAP32[$4 + 12 >> 2];
}

function std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 std____2__unique_ptr_TfLitePoolParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___reset_28TfLitePoolParams__29($0, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter____unique_ptr_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 std____2__unique_ptr_TfLiteConvParams_2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___reset_28TfLiteConvParams__29($0, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsvIsNameInt($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $0 = 1;
  if (HEAP8[$1 + 7 | 0] != 16) {
   $2 = HEAP8[$1 + 7 | 0] >= 18 ? HEAP8[$1 + 7 | 0] <= 22 : $2;
   $0 = $2;
  }
  HEAP8[$1 + 15 | 0] = $0 & 1;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function isWhitespaceInline($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = 1;
 label$1: {
  if (HEAP8[$1 + 15 | 0] == 9) {
   break label$1;
  }
  $0 = 1;
  if (HEAP8[$1 + 15 | 0] == 11) {
   break label$1;
  }
  $0 = 1;
  if (HEAP8[$1 + 15 | 0] == 12) {
   break label$1;
  }
  $0 = 1;
  if (HEAP8[$1 + 15 | 0] == 32) {
   break label$1;
  }
  $0 = 1;
  if (HEAP8[$1 + 15 | 0] == 10) {
   break label$1;
  }
  $0 = HEAP8[$1 + 15 | 0] == 13;
 }
 return $0;
}

function jsvIterateCallbackToBytesCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 if (HEAPU32[HEAP32[$2 + 4 >> 2] + 4 >> 2] < HEAPU32[HEAP32[$2 + 4 >> 2] + 8 >> 2]) {
  HEAP8[HEAP32[HEAP32[$2 + 4 >> 2] >> 2] + HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] | 0] = HEAP32[$2 + 12 >> 2];
 }
 $0 = HEAP32[$2 + 4 >> 2];
 HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
}

function jswrap_eval($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = jsvAsString(HEAP32[$1 + 8 >> 2]);
  HEAP32[$1 >> 2] = jspEvaluateVar(HEAP32[$1 + 4 >> 2], 0, 0);
  jsvUnLock(HEAP32[$1 + 4 >> 2]);
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 >> 2];
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function gemmlowp__FixedPoint_int_2c_202__20gemmlowp__Rescale_2_2c_20int_2c_204__28gemmlowp__FixedPoint_int_2c_204__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 >> 2] = $0;
 $0 = int_20gemmlowp__SaturatingRoundingMultiplyByPOT_2_2c_20int__28int_29(HEAP32[gemmlowp__FixedPoint_int_2c_204___raw_28_29($1) >> 2]);
 HEAP32[gemmlowp__FixedPoint_int_2c_202___raw_28_29($1 + 8 | 0) >> 2] = $0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__Rescale_0_2c_20int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 >> 2] = $0;
 $0 = int_20gemmlowp__SaturatingRoundingMultiplyByPOT_5_2c_20int__28int_29(HEAP32[gemmlowp__FixedPoint_int_2c_205___raw_28_29($1) >> 2]);
 HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($1 + 8 | 0) >> 2] = $0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__Rescale_0_2c_20int_2c_201__28gemmlowp__FixedPoint_int_2c_201__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 >> 2] = $0;
 $0 = int_20gemmlowp__SaturatingRoundingMultiplyByPOT_1_2c_20int__28int_29(HEAP32[gemmlowp__FixedPoint_int_2c_201___raw_28_29($1) >> 2]);
 HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($1 + 8 | 0) >> 2] = $0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = $2 >>> 16 | 0;
 $5 = $0 >>> 16 | 0;
 $3 = (Math_imul($4, $5) + Math_imul($1, $2) | 0) + Math_imul($3, $0) | 0;
 $2 = $2 & 65535;
 $0 = $0 & 65535;
 $1 = Math_imul($2, $0);
 $2 = ($1 >>> 16 | 0) + Math_imul($2, $5) | 0;
 $3 = $3 + ($2 >>> 16 | 0) | 0;
 $2 = Math_imul($0, $4) + ($2 & 65535) | 0;
 i64toi32_i32$HIGH_BITS = $3 + ($2 >>> 16 | 0) | 0;
 return $1 & 65535 | $2 << 16;
}

function std____2____compressed_pair_TfLiteSoftmaxParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___second_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____get_28_29(HEAP32[$1 + 12 >> 2] + 4 | 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function std____2____compressed_pair_TfLiteReshapeParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___second_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____get_28_29(HEAP32[$1 + 12 >> 2] + 4 | 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_number_toFixed($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 76 >> 2] = $0;
 HEAP32[$2 + 72 >> 2] = $1;
 if (HEAP32[$2 + 72 >> 2] < 0) {
  HEAP32[$2 + 72 >> 2] = 0;
 }
 if (HEAP32[$2 + 72 >> 2] > 20) {
  HEAP32[$2 + 72 >> 2] = 20;
 }
 ftoa_bounded_extra(jsvGetFloat(HEAP32[$2 + 76 >> 2]), $2, 70, 10, HEAP32[$2 + 72 >> 2]);
 $0 = jsvNewFromString($2);
 __stack_pointer = $2 + 80 | 0;
 return $0 | 0;
}

function jswrap_graphics_stringWidth($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 96 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 88 >> 2] = $0;
 HEAP32[$2 + 84 >> 2] = $1;
 label$1: {
  if (!(graphicsGetFromVar($2 + 8 | 0, HEAP32[$2 + 88 >> 2]) & 1)) {
   HEAP32[$2 + 92 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 92 >> 2] = _jswrap_graphics_stringWidth($2 + 8 | 0, HEAP32[$2 + 84 >> 2], -1);
 }
 __stack_pointer = $2 + 96 | 0;
 return HEAP32[$2 + 92 >> 2];
}

function mbedtls_sha256($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 128 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 124 >> 2] = $0;
 HEAP32[$4 + 120 >> 2] = $1;
 HEAP32[$4 + 116 >> 2] = $2;
 HEAP32[$4 + 112 >> 2] = $3;
 mbedtls_sha256_init($4);
 mbedtls_sha256_starts($4, HEAP32[$4 + 112 >> 2]);
 mbedtls_sha256_update($4, HEAP32[$4 + 124 >> 2], HEAP32[$4 + 120 >> 2]);
 mbedtls_sha256_finish($4, HEAP32[$4 + 116 >> 2]);
 mbedtls_sha256_free($4);
 __stack_pointer = $4 + 128 | 0;
}

function jswrap_interface_setSleepIndicator($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = HEAPU8[195666];
 HEAP8[195666] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
 if (HEAPU8[195666] != HEAPU8[$1 + 11 | 0]) {
  if (HEAPU8[$1 + 11 | 0] != 255) {
   jshPinOutput(HEAPU8[$1 + 11 | 0], 0);
  }
  if (HEAPU8[195666] != 255) {
   jshPinOutput(HEAPU8[195666], 1);
  }
 }
 __stack_pointer = $1 + 16 | 0;
}

function jspeiGetScopesAsVar() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 label$1: {
  if (!HEAP32[91088]) {
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  if ((jsvGetArrayLength(HEAP32[91088]) | 0) == 1) {
   HEAP32[$0 + 8 >> 2] = jsvGetLastArrayItem(HEAP32[91088]);
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = jsvCopy(HEAP32[91088], 1);
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function int_20tflite__reference_ops__depthwise_conv__DepthwiseConvRound__28tflite__DepthwiseConvOutputRounding_291__28int_2c_20int_2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = tflite__MultiplyByQuantizedMultiplier_28int_2c_20int_2c_20int_29(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function std____2____compressed_pair_TfLitePoolParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___second_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____get_28_29(HEAP32[$1 + 12 >> 2] + 4 | 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___second_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____get_28_29(HEAP32[$1 + 12 >> 2] + 4 | 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_interface_setBusyIndicator($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = HEAPU8[195665];
 HEAP8[195665] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
 if (HEAPU8[195665] != HEAPU8[$1 + 11 | 0]) {
  if (HEAPU8[$1 + 11 | 0] != 255) {
   jshPinOutput(HEAPU8[$1 + 11 | 0], 0);
  }
  if (HEAPU8[195665] != 255) {
   jshPinOutput(HEAPU8[195665], 1);
  }
 }
 __stack_pointer = $1 + 16 | 0;
}

function graphicsSetPixel($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 graphicsToDeviceCoordinates(HEAP32[$4 + 12 >> 2], $4 + 8 | 0, $4 + 4 | 0);
 graphicsSetPixelDevice(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
 __stack_pointer = $4 + 16 | 0;
}

function tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29_1($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29($0);
 tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator__operator_20delete_28void__29($0);
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_waveform_startInput($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = +$2;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP8[$4 + 27 | 0] = $1;
 HEAPF64[$4 + 16 >> 3] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 if (!(jshPinAnalog(HEAPU8[$4 + 27 | 0]) < 0)) {
  jswrap_waveform_start(HEAP32[$4 + 28 >> 2], HEAPU8[$4 + 27 | 0], HEAPF64[$4 + 16 >> 3], HEAP32[$4 + 12 >> 2], 0);
 }
 __stack_pointer = $4 + 32 | 0;
}

function double_20const__20std____2__min_double__28double_20const__2c_20double_20const__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = double_20const__20std____2__min_double_2c_20std____2____less_double_2c_20double___28double_20const__2c_20double_20const__2c_20std____2____less_double_2c_20double__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function _jswrap_prombox_queueresolve_or_reject($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 HEAP32[$3 >> 2] = _jswrap_promise_native_with_prombox(HEAP8[$3 + 7 | 0] & 1 ? 650 : 651, HEAP32[$3 + 12 >> 2]);
 if (HEAP32[$3 >> 2]) {
  jsiQueueEvents(HEAP32[$3 + 12 >> 2], HEAP32[$3 >> 2], $3 + 8 | 0, 1);
  jsvUnLock(HEAP32[$3 >> 2]);
 }
 __stack_pointer = $3 + 16 | 0;
}

function tflite__MicroMutableOpResolver_9u___MicroMutableOpResolver_28tflite__ErrorReporter__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 tflite__MicroOpResolver__MicroOpResolver_28_29($0);
 HEAP32[$0 >> 2] = 190072;
 HEAP32[$0 + 292 >> 2] = 0;
 HEAP32[$0 + 368 >> 2] = 0;
 HEAP32[$0 + 372 >> 2] = HEAP32[$2 + 8 >> 2];
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jswrap_regexp_test($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jswrap_regexp_exec(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 if (HEAP32[$2 + 4 >> 2]) {
  $3 = jsvIsNull(HEAP32[$2 + 4 >> 2]) ^ -1;
 }
 HEAP8[$2 + 3 | 0] = $3 & 1;
 jsvUnLock(HEAP32[$2 + 4 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return HEAP8[$2 + 3 | 0] & 1;
}

function tflite__GetInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = tflite___28anonymous_20namespace_29__GetMutableInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function tflite__EspruinoErrorReporter__Report_28char_20const__2c_20void__29($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 288 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 284 >> 2] = $0;
 HEAP32[$3 + 280 >> 2] = $1;
 HEAP32[$3 + 276 >> 2] = $2;
 espruino_snprintf_va($3 + 16 | 0, 256, HEAP32[$3 + 280 >> 2], HEAP32[$3 + 276 >> 2]);
 HEAP32[$3 >> 2] = $3 + 16;
 jsExceptionHere(1, 120693, $3);
 __stack_pointer = $3 + 288 | 0;
 return 0;
}

function jsvObjectSetOrRemoveChild($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (HEAP32[$3 + 4 >> 2]) {
   jsvObjectSetChild(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
   break label$1;
  }
  jsvObjectRemoveChild(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2]);
 }
 __stack_pointer = $3 + 16 | 0;
 return HEAP32[$3 + 4 >> 2];
}

function heatshrink_encoder_finish($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 12 >> 2] = -1;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$0 + 11 | 0] = HEAPU8[$0 + 11 | 0] | 1;
  if (!HEAPU8[HEAP32[$1 + 8 >> 2] + 12 | 0]) {
   HEAP8[HEAP32[$1 + 8 >> 2] + 12 | 0] = 1;
  }
  HEAP32[$1 + 12 >> 2] = HEAPU8[HEAP32[$1 + 8 >> 2] + 12 | 0] != 9;
 }
 return HEAP32[$1 + 12 >> 2];
}

function jslFunctionCharAsString($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP8[$3 + 15 | 0] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 label$1: {
  if (HEAPU8[$3 + 15 | 0] >= 128) {
   jslTokenAsString(HEAPU8[$3 + 15 | 0], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
   break label$1;
  }
  HEAP8[HEAP32[$3 + 8 >> 2]] = HEAPU8[$3 + 15 | 0];
  HEAP8[HEAP32[$3 + 8 >> 2] + 1 | 0] = 0;
 }
 __stack_pointer = $3 + 16 | 0;
}

function jswrap_banglejs_getLogo() {
 var $0 = 0;
 $0 = __stack_pointer - 496 | 0;
 __stack_pointer = $0;
 __memcpy($0 + 16 | 0, 180896, 467);
 HEAP32[$0 + 12 >> 2] = jsvNewNativeString($0 + 16 | 0, 467);
 HEAP32[$0 + 8 >> 2] = jswrap_heatshrink_decompress(HEAP32[$0 + 12 >> 2]);
 HEAP32[$0 + 4 >> 2] = jsvGetArrayBufferBackingString(HEAP32[$0 + 8 >> 2], 0);
 jsvUnLock2(HEAP32[$0 + 12 >> 2], HEAP32[$0 + 8 >> 2]);
 __stack_pointer = $0 + 496 | 0;
 return HEAP32[$0 + 4 >> 2];
}

function jshPinOutput($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 label$1: {
  if (jshIsPinValid(HEAPU8[$2 + 15 | 0]) & 1) {
   jshPinSetValue(HEAPU8[$2 + 15 | 0], HEAP8[$2 + 14 | 0] & 1);
   if (!(jshGetPinStateIsManual(HEAPU8[$2 + 15 | 0]) & 1)) {
    jshPinSetState(HEAPU8[$2 + 15 | 0], 1);
   }
   break label$1;
  }
  jsExceptionHere(1, 128480, 0);
 }
 __stack_pointer = $2 + 16 | 0;
}

function tflite__micro__GetEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = tflite__micro__GetMutableEvalInput_28TfLiteContext_20const__2c_20TfLiteNode_20const__2c_20int_29(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function jsvUnLockFreeIfNeeded($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (jsvGetRefs(HEAP32[$1 + 12 >> 2]) & 65535) {
   break label$1;
  }
  if (!(jsvHasRef(HEAP32[$1 + 12 >> 2]) & 1)) {
   break label$1;
  }
  $0 = HEAP32[$1 + 12 >> 2];
  if (!((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63)) {
   break label$1;
  }
  jsvFreePtr(HEAP32[$1 + 12 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
}

function flatbuffers__String_20const__20flatbuffers__Table__GetPointer_flatbuffers__String_20const___28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = flatbuffers__String_20const__20flatbuffers__Table__GetPointer_flatbuffers__String_20const___28unsigned_20short_29(HEAP32[$2 + 12 >> 2], HEAPU16[$2 + 10 >> 1]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator__MicroBuiltinDataAllocator_28tflite__SimpleMemoryAllocator__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 tflite__BuiltinDataAllocator__BuiltinDataAllocator_28_29($0);
 HEAP32[$0 >> 2] = 189828;
 HEAP32[$0 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jsvResetVariable($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 HEAP32[$2 + 4 >> 2] = 0;
 while (1) {
  if (HEAPU32[$2 + 4 >> 2] < 14) {
   HEAP8[HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 4 >> 2] | 0] = 0;
   HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
   continue;
  }
  break;
 }
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = HEAPU16[$2 + 10 >> 1] | 1024;
 HEAP8[$0 + 12 | 0] = $1;
 HEAP8[$0 + 13 | 0] = $1 >>> 8;
}

function jsvNewFromPin($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvNewFromInteger(HEAP32[$1 + 12 >> 2]);
 if (HEAP32[$1 + 8 >> 2]) {
  $0 = HEAP32[$1 + 8 >> 2];
  $2 = HEAP32[$1 + 8 >> 2];
  $2 = (HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8) & -64 | 13;
  HEAP8[$0 + 12 | 0] = $2;
  HEAP8[$0 + 13 | 0] = $2 >>> 8;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jsspiHardwareFunc($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP8[$4 + 15 | 0] = HEAPU8[HEAP32[$4 + 16 >> 2]];
 jshSPISendMany(HEAPU8[$4 + 15 | 0], HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], 0);
 __stack_pointer = $4 + 32 | 0;
}

function graphicsGetHeight($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1: {
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 16) {
   $0 = HEAP32[$1 + 12 >> 2];
   $0 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8;
   break label$1;
  }
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8;
 }
 return $0;
}

function float_20const__20std____2__min_float__28float_20const__2c_20float_20const__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = float_20const__20std____2__min_float_2c_20std____2____less_float_2c_20float___28float_20const__2c_20float_20const__2c_20std____2____less_float_2c_20float__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function float_20const__20std____2__max_float__28float_20const__2c_20float_20const__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = float_20const__20std____2__max_float_2c_20std____2____less_float_2c_20float___28float_20const__2c_20float_20const__2c_20std____2____less_float_2c_20float__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jsvStringIteratorGetUTF8CharAndNext($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(jsvStringIteratorHasChar_2(HEAP32[$1 + 8 >> 2]) & 1)) {
   jsvStringIteratorNext(HEAP32[$1 + 8 >> 2]);
   HEAP32[$1 + 12 >> 2] = -1;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvStringIteratorGetCharAndNext(HEAP32[$1 + 8 >> 2]) & 255;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function graphicsGetWidth($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1: {
  if ((HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) & 16) {
   $0 = HEAP32[$1 + 12 >> 2];
   $0 = HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8;
   break label$1;
  }
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8;
 }
 return $0;
}

function tflite__internal__ContextHelper__AllocatePersistentBuffer_28TfLiteContext__2c_20unsigned_20long_29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = tflite__MicroAllocator__AllocatePersistentBuffer_28unsigned_20long_29(HEAP32[HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function jswrap_array_shift($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jswrap_array_splice_i(HEAP32[$1 + 12 >> 2], 0, 1, 0);
 HEAP32[$1 + 4 >> 2] = 0;
 if (jsvIsArray(HEAP32[$1 + 8 >> 2]) & 1) {
  HEAP32[$1 + 4 >> 2] = jsvSkipNameAndUnLock(jsvArrayPop(HEAP32[$1 + 8 >> 2]));
 }
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 4 >> 2];
}

function std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29____allocator_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 std____2____non_trivial_if_true_2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29_______non_trivial_if_28_29($0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_espruino_getAddressOf($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP8[$2 + 7 | 0] = $1;
 label$1: {
  if (HEAP8[$2 + 7 | 0] & 1) {
   HEAP32[$2 >> 2] = 0;
   HEAP32[$2 + 12 >> 2] = jsvGetDataPointer(HEAP32[$2 + 8 >> 2], $2);
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 8 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jsvIsNewChild($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = 0;
 label$1: {
  if (!(jsvIsName(HEAP32[$1 + 12 >> 2]) & 1)) {
   break label$1;
  }
  $0 = 0;
  if (!(jsvGetNextSibling(HEAP32[$1 + 12 >> 2]) & 65535)) {
   break label$1;
  }
  $0 = (jsvGetNextSibling(HEAP32[$1 + 12 >> 2]) & 65535) == (jsvGetPrevSibling(HEAP32[$1 + 12 >> 2]) & 65535);
 }
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_date_setMilliseconds($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 44 >> 2] = $0;
 HEAP32[$2 + 40 >> 2] = $1;
 getTimeFromDateVar($2 + 8 | 0, HEAP32[$2 + 44 >> 2], 0);
 HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 40 >> 2];
 setCorrectTimeZone($2 + 8 | 0);
 $3 = jswrap_date_setTime(HEAP32[$2 + 44 >> 2], fromTimeInDay($2 + 8 | 0));
 __stack_pointer = $2 + 48 | 0;
 return +$3;
}

function jsvArrayAddUnique($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvGetIndexOf(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
 label$1: {
  if (!HEAP32[$2 + 4 >> 2]) {
   jsvArrayPush(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
   break label$1;
  }
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function jsiSetBusy($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 label$1: {
  if (HEAP8[$2 + 14 | 0] & 1) {
   HEAP8[364432] = HEAPU8[$2 + 15 | 0] | HEAPU8[364432];
   break label$1;
  }
  HEAP8[364432] = HEAPU8[364432] & ((HEAPU8[$2 + 15 | 0] ^ -1) & 255);
 }
 if (HEAPU8[195665] != 255) {
  jshPinOutput(HEAPU8[195665], HEAPU8[364432] != 0);
 }
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_e_dumpStr() {
 var $0 = 0;
 $0 = __stack_pointer - 48 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 40 >> 2] = jsvNewFromEmptyString_9();
 label$1: {
  if (!HEAP32[$0 + 40 >> 2]) {
   HEAP32[$0 + 44 >> 2] = 0;
   break label$1;
  }
  jsvStringIteratorNew($0, HEAP32[$0 + 40 >> 2], 0);
  jsiDumpState(2, $0);
  jsvStringIteratorFree_11($0);
  HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 40 >> 2];
 }
 __stack_pointer = $0 + 48 | 0;
 return HEAP32[$0 + 44 >> 2];
}

function mbedtls_sha1_starts($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = 0;
 HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] = 0;
 HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] = 1732584193;
 HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] = -271733879;
 HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2] = -1732584194;
 HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2] = 271733878;
 HEAP32[HEAP32[$1 + 12 >> 2] + 24 >> 2] = -1009589776;
}

function OneWireReset($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jshPinSetState(HEAPU8[$1 + 15 | 0], 3);
 jshPinSetValue(HEAPU8[$1 + 15 | 0], 0);
 jshDelayMicroseconds(500);
 jshPinSetValue(HEAPU8[$1 + 15 | 0], 1);
 jshDelayMicroseconds(80);
 HEAP8[$1 + 14 | 0] = (jshPinGetValue(HEAPU8[$1 + 15 | 0]) ^ -1) & 1;
 jshDelayMicroseconds(420);
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 14 | 0] & 1;
}

function mbedtls_sha1($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 112 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 108 >> 2] = $0;
 HEAP32[$3 + 104 >> 2] = $1;
 HEAP32[$3 + 100 >> 2] = $2;
 mbedtls_sha1_init($3 + 8 | 0);
 mbedtls_sha1_starts($3 + 8 | 0);
 mbedtls_sha1_update($3 + 8 | 0, HEAP32[$3 + 108 >> 2], HEAP32[$3 + 104 >> 2]);
 mbedtls_sha1_finish($3 + 8 | 0, HEAP32[$3 + 100 >> 2]);
 mbedtls_sha1_free($3 + 8 | 0);
 __stack_pointer = $3 + 112 | 0;
}

function jsvStringIteratorGetCharOrMinusOne($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(HEAPU32[HEAP32[$1 + 8 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 8 >> 2] + 4 >> 2] ? HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] : 0)) {
   HEAP32[$1 + 12 >> 2] = -1;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
 }
 return HEAP32[$1 + 12 >> 2];
}

function flatbuffers__IndirectHelper_long_20long___Read_28unsigned_20char_20const__2c_20unsigned_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 8 >> 2] << 3) | 0;
 $0 = long_20long_20flatbuffers__EndianScalar_long_20long__28long_20long_29(HEAP32[$0 >> 2], HEAP32[$0 + 4 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function heatshrink_var_input_cb($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 4 >> 2] = -1;
 if (jsvIteratorHasElement(HEAP32[$1 + 8 >> 2]) & 1) {
  HEAP32[$1 + 4 >> 2] = jsvIteratorGetIntegerValue(HEAP32[$1 + 8 >> 2]) & 255;
 }
 jsvIteratorNext(HEAP32[$1 + 8 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 4 >> 2];
}

function tflite__MultiplyByQuantizedMultiplierGreaterThanOne_28int_2c_20int_2c_20int_29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = int_20gemmlowp__SaturatingRoundingDoublingHighMul_int__28int_2c_20int_29(Math_imul(HEAP32[$3 + 12 >> 2], 1 << HEAP32[$3 + 4 >> 2]), HEAP32[$3 + 8 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function jshPushIOEvent($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP8[$3 + 31 | 0] = $0;
 HEAP32[$3 + 16 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP8[$3 + 8 | 0] = HEAPU8[$3 + 31 | 0];
 $0 = HEAP32[$3 + 16 >> 2];
 HEAP8[$3 + 9 | 0] = $0;
 HEAP8[$3 + 10 | 0] = $0 >>> 8;
 HEAP8[$3 + 11 | 0] = $0 >>> 16;
 HEAP8[$3 + 12 | 0] = $0 >>> 24;
 jshPushEvent($3 + 8 | 0);
 jshHadEvent();
 __stack_pointer = $3 + 32 | 0;
}

function flatbuffers__Vector_float___Get_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0, $3 = Math_fround(0);
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $3 = flatbuffers__IndirectHelper_float___Read_28unsigned_20char_20const__2c_20unsigned_20int_29(flatbuffers__Vector_float___Data_28_29_20const(HEAP32[$2 + 12 >> 2]), HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $3;
}

function tflite__MicroOpResolver__FindOp_28tflite__BuiltinOperator_2c_20int_29_20const($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 20 >> 2]]($0, HEAP32[$3 + 8 >> 2]) | 0;
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function jsiHandleIOEventForSerial($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP32[$2 >> 2] = jsiExtractIOEventData(HEAP32[$2 + 8 >> 2], $2 + 4 | 0);
 if (HEAP32[$2 >> 2]) {
  jswrap_stream_pushData(HEAP32[$2 + 12 >> 2], HEAP32[$2 >> 2], 1);
  jsvUnLock(HEAP32[$2 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 4 >> 2];
}

function jswrap_crypto_error($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 HEAP32[$1 + 24 >> 2] = jswrap_crypto_error_to_str(HEAP32[$1 + 28 >> 2]);
 label$1: {
  if (HEAP32[$1 + 24 >> 2]) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 24 >> 2];
   jsError(120693, $1);
   break label$1;
  }
  HEAP32[$1 + 16 >> 2] = 0 - HEAP32[$1 + 28 >> 2];
  jsError(116503, $1 + 16 | 0);
 }
 __stack_pointer = $1 + 32 | 0;
}

function jsvStringIteratorPrintfCallback($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 while (1) {
  if (HEAPU8[HEAP32[$2 + 12 >> 2]]) {
   $1 = HEAP32[$2 + 8 >> 2];
   $0 = HEAP32[$2 + 12 >> 2];
   HEAP32[$2 + 12 >> 2] = $0 + 1;
   jsvStringIteratorAppend($1, HEAP8[$0 | 0]);
   continue;
  }
  break;
 }
 __stack_pointer = $2 + 16 | 0;
}

function jsvArrayBufferIteratorFloatToData($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAPF64[$4 + 8 >> 3] = $3;
 label$1: {
  if (HEAP32[$4 + 24 >> 2] == 4) {
   HEAPF32[HEAP32[$4 + 28 >> 2] >> 2] = HEAPF64[$4 + 8 >> 3];
   break label$1;
  }
  if (HEAP32[$4 + 24 >> 2] == 8) {
   HEAPF64[HEAP32[$4 + 28 >> 2] >> 3] = HEAPF64[$4 + 8 >> 3];
  }
 }
}

function flatbuffers__Vector_long_20long___Get_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = flatbuffers__IndirectHelper_long_20long___Read_28unsigned_20char_20const__2c_20unsigned_20int_29(flatbuffers__Vector_long_20long___Data_28_29_20const(HEAP32[$2 + 12 >> 2]), HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function gen_jswrap_Graphics_setBgColor($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = jswrap_graphics_setColorX(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2], 0);
 __stack_pointer = $4 + 16 | 0;
 return $0 | 0;
}

function jswrap_crypto_AES_ccmEncrypt($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = jswrap_crypto_AES_ccmCrypt(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2], 1);
 __stack_pointer = $4 + 16 | 0;
 return $0 | 0;
}

function jswrap_crypto_AES_ccmDecrypt($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = jswrap_crypto_AES_ccmCrypt(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2], 0);
 __stack_pointer = $4 + 16 | 0;
 return $0 | 0;
}

function std____2____compressed_pair_TfLiteFullyConnectedParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_TfLiteFullyConnectedParams__2c_200_2c_20false_____get_28_29_20const(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function lcdMemLCD_convert16toLCD($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = HEAPU16[(((HEAP32[$3 + 4 >> 2] & 1) << 2) + 170592 | 0) + ((HEAP32[$3 + 8 >> 2] & 1) << 1) >> 1] + (HEAP32[$3 + 12 >> 2] & 59164);
 return !!(HEAP32[$3 + 12 >> 2] & 65536) | (HEAP32[$3 + 12 >> 2] & 2048 ? 2 : 0) | (HEAP32[$3 + 12 >> 2] & 32 ? 4 : 0);
}

function jswrap_espruino_setTimeZone($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 jswrap_espruino_setDST(0);
 $3 = HEAP32[91087];
 $0 = HEAPF64[$1 + 8 >> 3] * 60;
 label$1: {
  if (Math_abs($0) < 2147483648) {
   $2 = ~~$0;
   break label$1;
  }
  $2 = -2147483648;
 }
 jsvObjectSetChildAndUnLock($3, 116073, jsvNewFromInteger($2));
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_espruino_clip($0, $1, $2) {
 $0 = +$0;
 $1 = +$1;
 $2 = +$2;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 HEAPF64[$3 + 24 >> 3] = $0;
 HEAPF64[$3 + 16 >> 3] = $1;
 HEAPF64[$3 + 8 >> 3] = $2;
 if (HEAPF64[$3 + 24 >> 3] < HEAPF64[$3 + 16 >> 3]) {
  HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 16 >> 3];
 }
 if (HEAPF64[$3 + 24 >> 3] > HEAPF64[$3 + 8 >> 3]) {
  HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 8 >> 3];
 }
 return +HEAPF64[$3 + 24 >> 3];
}

function jsiGetClassNameFromDevice($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 11 | 0] = $0;
 HEAP32[$1 + 4 >> 2] = jshGetDeviceString(HEAPU8[$1 + 11 | 0]);
 label$1: {
  if (!HEAPU8[HEAP32[$1 + 4 >> 2]]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvFindChildFromString(HEAP32[91086], HEAP32[$1 + 4 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function gen_jswrap_Graphics_setColor($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = jswrap_graphics_setColorX(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2], 1);
 __stack_pointer = $4 + 16 | 0;
 return $0 | 0;
}

function std____2____compressed_pair_TfLiteDepthwiseConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_TfLiteDepthwiseConvParams__2c_200_2c_20false_____get_28_29_20const(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function isNegativeZero($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = __stack_pointer - 32 | 0;
 HEAPF64[$1 + 24 >> 3] = $0;
 HEAPF64[$1 + 16 >> 3] = -0;
 HEAP32[$1 + 12 >> 2] = $1 + 16;
 HEAP32[$1 + 8 >> 2] = $1 + 24;
 $2 = HEAP32[$1 + 8 >> 2];
 $3 = HEAP32[$2 >> 2];
 $4 = HEAP32[$2 + 4 >> 2];
 $2 = HEAP32[$1 + 12 >> 2];
 $1 = HEAP32[$2 + 4 >> 2];
 $5 = HEAP32[$2 >> 2];
 $2 = $3;
 return ($5 | 0) == ($2 | 0) & ($4 | 0) == ($1 | 0);
}

function int_20const__20std____2__min_int__28int_20const__2c_20int_20const__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = int_20const__20std____2__min_int_2c_20std____2____less_int_2c_20int___28int_20const__2c_20int_20const__2c_20std____2____less_int_2c_20int__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function int_20const__20std____2__max_int__28int_20const__2c_20int_20const__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = int_20const__20std____2__max_int_2c_20std____2____less_int_2c_20int___28int_20const__2c_20int_20const__2c_20std____2____less_int_2c_20int__29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jswrap_io_getPinMode($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 11 | 0] = $0;
 label$1: {
  if (!(jshIsPinValid(HEAPU8[$1 + 11 | 0]) & 1)) {
   jsExceptionHere(1, 128480, 0);
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jshGetPinStateString(jshPinGetState(HEAPU8[$1 + 11 | 0]) & 255);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvArrayBufferGetFromName($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvGetInteger(HEAP32[$1 + 12 >> 2]);
 HEAP32[$1 + 4 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535);
 HEAP32[$1 >> 2] = jsvArrayBufferGet(HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2]);
 jsvUnLock(HEAP32[$1 + 4 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 >> 2];
}

function jswrap_math_sign($0) {
 $0 = +$0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 >> 3] = $0;
 label$1: {
  label$2: {
   if (HEAPF64[$1 >> 3] != 0) {
    if (!(isNegativeZero(HEAPF64[$1 >> 3]) & 1)) {
     break label$2;
    }
   }
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = HEAPF64[$1 >> 3] > 0 ? 1 : -1;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_math_clip($0, $1, $2) {
 $0 = +$0;
 $1 = +$1;
 $2 = +$2;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 HEAPF64[$3 + 24 >> 3] = $0;
 HEAPF64[$3 + 16 >> 3] = $1;
 HEAPF64[$3 + 8 >> 3] = $2;
 if (HEAPF64[$3 + 24 >> 3] < HEAPF64[$3 + 16 >> 3]) {
  HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 16 >> 3];
 }
 if (HEAPF64[$3 + 24 >> 3] > HEAPF64[$3 + 8 >> 3]) {
  HEAPF64[$3 + 24 >> 3] = HEAPF64[$3 + 8 >> 3];
 }
 return +HEAPF64[$3 + 24 >> 3];
}

function tflite__MicroOpResolver__FindOp_28char_20const__2c_20int_29_20const($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 24 >> 2]]($0, HEAP32[$3 + 8 >> 2]) | 0;
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function jswrap_pin_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP8[$1 + 7 | 0] = jshGetPinFromVar(HEAP32[$1 + 8 >> 2]);
 label$1: {
  if (!(jshIsPinValid(HEAPU8[$1 + 7 | 0]) & 1)) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvNewFromPin(HEAPU8[$1 + 7 | 0]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvGetInternalFunctionCheckerFor($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (jsvIsFunction(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 3;
   break label$1;
  }
  if (jsvIsObject(HEAP32[$1 + 8 >> 2]) & 1) {
   HEAP32[$1 + 12 >> 2] = 4;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jshPushIOCharEventHandler($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 label$1: {
  if (HEAP8[$2 + 14 | 0] != 3) {
   break label$1;
  }
  if (HEAPU8[$2 + 15 | 0] != (jsiGetConsoleDevice() & 255)) {
   break label$1;
  }
  jsiCtrlC();
 }
 $0 = jswOnCharEvent(HEAPU8[$2 + 15 | 0], HEAP8[$2 + 14 | 0]);
 __stack_pointer = $2 + 16 | 0;
 return $0 & 1;
}

function tflite___28anonymous_20namespace_29__ConvertPadding_28tflite__Padding_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  label$2: {
   switch (HEAP32[$1 + 8 >> 2]) {
   case 0:
    HEAP32[$1 + 12 >> 2] = 1;
    break label$1;

   case 1:
    HEAP32[$1 + 12 >> 2] = 2;
    break label$1;

   default:
    break label$2;
   }
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 return HEAP32[$1 + 12 >> 2];
}

function tflite__Operator__builtin_options_as_DepthwiseConv2DOptions_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1: {
  if ((tflite__Operator__builtin_options_type_28_29_20const($0) | 0) == 2) {
   $0 = tflite__Operator__builtin_options_28_29_20const($0);
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_onewire_reset($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP8[$1 + 7 | 0] = onewire_getpin(HEAP32[$1 + 8 >> 2]);
 label$1: {
  if (!(jshIsPinValid(HEAPU8[$1 + 7 | 0]) & 1)) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = OneWireReset(HEAPU8[$1 + 7 | 0]) & 1;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}

function jswGetBuiltInJSLibrary($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!strcmp(HEAP32[$1 + 8 >> 2], 132625)) {
   HEAP32[$1 + 12 >> 2] = 114586;
   break label$1;
  }
  if (!strcmp(HEAP32[$1 + 8 >> 2], 117216)) {
   HEAP32[$1 + 12 >> 2] = 121902;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jspAppendStackTrace($0) {
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 44 >> 2] = $0;
 jsvStringIteratorNew($1 + 8 | 0, HEAP32[$1 + 44 >> 2], 0);
 jsvStringIteratorGotoEnd($1 + 8 | 0);
 jslPrintPosition(2, $1 + 8 | 0, HEAP32[HEAP32[49079] + 8 >> 2]);
 jslPrintTokenLineMarker(2, $1 + 8 | 0, HEAP32[HEAP32[49079] + 8 >> 2], 0);
 jsvStringIteratorFree_4($1 + 8 | 0);
 __stack_pointer = $1 + 48 | 0;
}

function tflite__Operator__builtin_options_as_FullyConnectedOptions_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1: {
  if ((tflite__Operator__builtin_options_type_28_29_20const($0) | 0) == 8) {
   $0 = tflite__Operator__builtin_options_28_29_20const($0);
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function lcd_flip($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 if (HEAP8[$2 + 11 | 0] & 1) {
  HEAP8[366840] = 0;
  HEAP8[366841] = 0;
  HEAP8[366842] = 0;
  HEAP8[366843] = 0;
  HEAP8[366844] = 175;
  HEAP8[366845] = 0;
  HEAP8[366846] = 175;
  HEAP8[366847] = 0;
 }
 graphicsInternalFlip();
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_object_valueOf($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 8 >> 2];
   jsExceptionHere(3, 130151, $1);
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[$1 + 8 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsiConsolePrintString($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 while (1) {
  if (HEAPU8[HEAP32[$1 + 12 >> 2]]) {
   if (HEAP8[HEAP32[$1 + 12 >> 2]] == 10) {
    jsiConsolePrintChar(13);
   }
   $0 = HEAP32[$1 + 12 >> 2];
   HEAP32[$1 + 12 >> 2] = $0 + 1;
   jsiConsolePrintChar(HEAP8[$0 | 0]);
   continue;
  }
  break;
 }
 __stack_pointer = $1 + 16 | 0;
}

function tflite__Model__operator_codes_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode___20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 6);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_string_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!jsvGetArrayLength(HEAP32[$1 + 8 >> 2])) {
   HEAP32[$1 + 12 >> 2] = jsvNewFromEmptyString_8();
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvAsStringAndUnLock(jsvGetArrayItem(HEAP32[$1 + 8 >> 2], 0));
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvIterateCallbackToBytes($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 HEAP32[$3 + 8 >> 2] = HEAP32[$3 + 24 >> 2];
 HEAP32[$3 + 12 >> 2] = 0;
 HEAP32[$3 + 16 >> 2] = HEAP32[$3 + 20 >> 2];
 jsvIterateCallback(HEAP32[$3 + 28 >> 2], 6, $3 + 8 | 0);
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 + 12 >> 2];
}

function jshGetPinString($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 HEAP8[HEAP32[$2 + 12 >> 2]] = 0;
 label$1: {
  if (HEAPU8[$2 + 11 | 0] < 48) {
   HEAP8[HEAP32[$2 + 12 >> 2]] = 68;
   itostr_2(HEAPU8[$2 + 11 | 0], HEAP32[$2 + 12 >> 2] + 1 | 0, 10);
   break label$1;
  }
  strcpy(HEAP32[$2 + 12 >> 2], 133948);
 }
 __stack_pointer = $2 + 16 | 0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode____operator_5b_5d_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode____Get_28unsigned_20int_29_20const(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function tflite__RuntimeShape__RuntimeShape_28int_2c_20int_20const__29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP32[$0 >> 2] = 0;
 tflite__RuntimeShape__ReplaceWith_28int_2c_20int_20const__29($0, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function jsvObjectGetChildIfExists($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (!HEAP32[$2 + 8 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromString(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]));
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jsvIsFunctionParameter($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = 0;
 label$1: {
  if (!HEAP32[$1 + 12 >> 2]) {
   break label$1;
  }
  $2 = HEAP32[$1 + 12 >> 2];
  $0 = 0;
  if (!((HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8) & 128)) {
   break label$1;
  }
  $0 = jsvIsString(HEAP32[$1 + 12 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return $0 & 1;
}

function jsvAppendPrintf($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 60 >> 2] = $0;
 HEAP32[$3 + 56 >> 2] = $1;
 jsvStringIteratorNew($3 + 16 | 0, HEAP32[$3 + 60 >> 2], 0);
 jsvStringIteratorGotoEnd($3 + 16 | 0);
 HEAP32[$3 + 12 >> 2] = $2;
 vcbprintf(2, $3 + 16 | 0, HEAP32[$3 + 56 >> 2], HEAP32[$3 + 12 >> 2]);
 jsvStringIteratorFree_1($3 + 16 | 0);
 __stack_pointer = $3 - -64 | 0;
}

function jsnCallFunction($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 28 >> 2] = $0;
 HEAP16[$5 + 26 >> 1] = $1;
 HEAP32[$5 + 20 >> 2] = $2;
 HEAP32[$5 + 16 >> 2] = $3;
 HEAP32[$5 + 12 >> 2] = $4;
 $0 = jswCallFunctionHack(HEAP32[$5 + 28 >> 2], HEAPU16[$5 + 26 >> 1], HEAP32[$5 + 20 >> 2], HEAP32[$5 + 16 >> 2], HEAP32[$5 + 12 >> 2]);
 __stack_pointer = $5 + 32 | 0;
 return $0;
}

function gemmlowp__FixedPoint_int_2c_20_1_20__202__20gemmlowp__ExactMulByPot__1_2c_20int_2c_202__28gemmlowp__FixedPoint_int_2c_202__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 >> 2] = $0;
 $0 = HEAP32[gemmlowp__FixedPoint_int_2c_202___raw_28_29($1) >> 2];
 HEAP32[gemmlowp__FixedPoint_int_2c_201___raw_28_29($1 + 8 | 0) >> 2] = $0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function tflite__internal__ContextHelper__GetScratchBuffer_28TfLiteContext__2c_20int_29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = tflite__MicroAllocator__GetScratchBuffer_28int_29_20const(HEAP32[HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function std____2____compressed_pair_TfLiteSoftmaxParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_TfLiteSoftmaxParams__2c_200_2c_20false_____get_28_29_20const(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function std____2____compressed_pair_TfLiteReshapeParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_TfLiteReshapeParams__2c_200_2c_20false_____get_28_29_20const(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_tfmicrointerpreter_invoke($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jswrap_tfmicrointerpreter_getTFMI(HEAP32[$1 + 12 >> 2]);
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   break label$1;
  }
  if (tf_invoke(HEAP32[$1 + 8 >> 2]) & 1) {
   break label$1;
  }
  jsExceptionHere(3, 134070, 0);
 }
 __stack_pointer = $1 + 16 | 0;
}

function tflite__Operator__builtin_options_as_ReshapeOptions_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1: {
  if ((tflite__Operator__builtin_options_type_28_29_20const($0) | 0) == 17) {
   $0 = tflite__Operator__builtin_options_28_29_20const($0);
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsvIsNameWithValue($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $2 = HEAP8[$1 + 7 | 0] >= 16 ? HEAP8[$1 + 7 | 0] <= 22 : $2;
  HEAP8[$1 + 15 | 0] = $2;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function jspeiLoadScopesFromVar($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[91088]);
 HEAP32[91088] = 0;
 if (HEAP32[$1 + 12 >> 2]) {
  label$2: {
   if (jsvIsArray(HEAP32[$1 + 12 >> 2]) & 1) {
    HEAP32[91088] = jsvCopy(HEAP32[$1 + 12 >> 2], 1);
    break label$2;
   }
   HEAP32[91088] = jsvNewArray($1 + 12 | 0, 1);
  }
 }
 __stack_pointer = $1 + 16 | 0;
}

function tflite__ops__micro__conv__RuntimePaddingType_28TfLitePadding_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  label$2: {
   switch (HEAP32[$1 + 8 >> 2] - 1 | 0) {
   case 0:
    HEAP8[$1 + 15 | 0] = 1;
    break label$1;

   case 1:
    HEAP8[$1 + 15 | 0] = 2;
    break label$1;

   default:
    break label$2;
   }
  }
  HEAP8[$1 + 15 | 0] = 0;
 }
 return HEAPU8[$1 + 15 | 0];
}

function tflite__Operator__builtin_options_as_SoftmaxOptions_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1: {
  if ((tflite__Operator__builtin_options_type_28_29_20const($0) | 0) == 9) {
   $0 = tflite__Operator__builtin_options_28_29_20const($0);
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function std____2____compressed_pair_TfLiteFullyConnectedParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_TfLiteFullyConnectedParams__2c_200_2c_20false_____get_28_29(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_waveform_startOutput($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = +$2;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP8[$4 + 27 | 0] = $1;
 HEAPF64[$4 + 16 >> 3] = $2;
 HEAP32[$4 + 12 >> 2] = $3;
 jswrap_waveform_start(HEAP32[$4 + 28 >> 2], HEAPU8[$4 + 27 | 0], HEAPF64[$4 + 16 >> 3], HEAP32[$4 + 12 >> 2], 1);
 __stack_pointer = $4 + 32 | 0;
}

function gen_jswrap_DataView_setFloat64($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 40, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 __stack_pointer = $4 + 16 | 0;
}

function gen_jswrap_DataView_setFloat32($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 36, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 __stack_pointer = $4 + 16 | 0;
}

function tflite__Operator__builtin_options_as_Pool2DOptions_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1: {
  if ((tflite__Operator__builtin_options_type_28_29_20const($0) | 0) == 5) {
   $0 = tflite__Operator__builtin_options_28_29_20const($0);
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__Operator__builtin_options_as_Conv2DOptions_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1: {
  if ((tflite__Operator__builtin_options_type_28_29_20const($0) | 0) == 1) {
   $0 = tflite__Operator__builtin_options_28_29_20const($0);
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function lcdSetPixel_ArrayBuffer_flat($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 lcdSetPixels_ArrayBuffer_flat(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], 1, HEAP32[$4 >> 2]);
 __stack_pointer = $4 + 16 | 0;
}

function jsvIsBasicString($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $2 = HEAP8[$1 + 7 | 0] >= 28 ? HEAP8[$1 + 7 | 0] <= 37 : $2;
  HEAP8[$1 + 15 | 0] = $2;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function aes_crypt_ecb_wrap($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 $0 = mbedtls_aes_crypt_ecb(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
 __stack_pointer = $4 + 16 | 0;
 return $0 | 0;
}

function std____2____compressed_pair_TfLiteDepthwiseConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_TfLiteDepthwiseConvParams__2c_200_2c_20false_____get_28_29(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsvStringIteratorSetCharAndNext($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 if (jsvStringIteratorHasChar_2(HEAP32[$2 + 12 >> 2]) & 1) {
  HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] + HEAP32[HEAP32[$2 + 12 >> 2] >> 2] | 0] = HEAPU8[$2 + 11 | 0];
 }
 jsvStringIteratorNextInline(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
}

function jsvObjectGetChildI($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (!HEAP32[$2 + 8 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = jsvSkipNameAndUnLock(jsvFindChildFromStringI(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]));
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jstRestartUtilTimer() {
 var $0 = 0, $1 = 0;
 $0 = Math_imul(HEAPU8[366354], 25) + 366368 | 0;
 HEAP32[91589] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
 $0 = jshGetSystemTime();
 HEAP32[91694] = $0;
 $1 = i64toi32_i32$HIGH_BITS;
 HEAP32[91695] = $1;
 if (HEAP32[91589] < 0) {
  HEAP32[91589] = 0;
 }
 $1 = HEAP32[91589];
 $0 = $1 >> 31;
 jshUtilTimerStart($1, $0);
}

function isHexadecimal($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 label$1: {
  if (HEAP8[$1 + 15 | 0] >= 48) {
   $0 = 1;
   if (HEAP8[$1 + 15 | 0] <= 57) {
    break label$1;
   }
  }
  if (HEAP8[$1 + 15 | 0] >= 97) {
   $0 = 1;
   if (HEAP8[$1 + 15 | 0] <= 102) {
    break label$1;
   }
  }
  $2 = HEAP8[$1 + 15 | 0] >= 65 ? HEAP8[$1 + 15 | 0] <= 70 : $2;
  $0 = $2;
 }
 return $0 & 1;
}

function gen_jswrap_DataView_setUint32($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 4, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 __stack_pointer = $4 + 16 | 0;
}

function gen_jswrap_DataView_setUint16($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 2, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 __stack_pointer = $4 + 16 | 0;
}

function gen_jswrap_DataView_setInt32($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 20, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 __stack_pointer = $4 + 16 | 0;
}

function gen_jswrap_DataView_setInt16($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 18, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 __stack_pointer = $4 + 16 | 0;
}

function tflite__ErrorReporter__Report_28char_20const__2c_20____29($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 $0 = HEAP32[$3 + 12 >> 2];
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 8 >> 2]]($0, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return HEAP32[$3 >> 2];
}

function jsvIsStringExt($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $2 = HEAP8[$1 + 7 | 0] >= 41 ? HEAP8[$1 + 7 | 0] <= 51 : $2;
  HEAP8[$1 + 15 | 0] = $2;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function jsvIsBoolean($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $0 = 1;
  $0 = HEAP8[$1 + 7 | 0] != 12 ? HEAP8[$1 + 7 | 0] == 17 : $0;
  HEAP8[$1 + 15 | 0] = $0;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function jsvIsBasicName($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $2 = HEAP8[$1 + 7 | 0] >= 23 ? HEAP8[$1 + 7 | 0] <= 27 : $2;
  HEAP8[$1 + 15 | 0] = $2;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function gen_jswrap_DataView_setUint8($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 1, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 __stack_pointer = $4 + 16 | 0;
}

function gen_jswrap_DataView_setInt8($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 3 | 0] = $3;
 jswrap_dataview_set(HEAP32[$4 + 12 >> 2], 17, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP8[$4 + 3 | 0] & 1);
 __stack_pointer = $4 + 16 | 0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph____operator_5b_5d_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph____Get_28unsigned_20int_29_20const(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function charToUpperCase($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 label$1: {
  if (!(!(HEAP8[$1 + 15 | 0] <= 122 & HEAP8[$1 + 15 | 0] >= 97 | HEAP8[$1 + 15 | 0] >>> 0 <= 246 & HEAP8[$1 + 15 | 0] >>> 0 >= 224) & (HEAP8[$1 + 15 | 0] >>> 0 < 248 | HEAP8[$1 + 15 | 0] >>> 0 > 254))) {
   $0 = HEAP8[$1 + 15 | 0] - 32 | 0;
   break label$1;
  }
  $0 = HEAP8[$1 + 15 | 0];
 }
 return $0 << 24 >> 24;
}

function tflite__SubGraph__operators_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__Operator___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Operator___20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 10);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function std____2____compressed_pair_TfLitePoolParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_TfLitePoolParams__2c_200_2c_20false_____get_28_29_20const(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_TfLiteConvParams__2c_200_2c_20false_____get_28_29_20const(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function charToLowerCase($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 label$1: {
  if (!(!(HEAP8[$1 + 15 | 0] <= 90 & HEAP8[$1 + 15 | 0] >= 65 | HEAP8[$1 + 15 | 0] >>> 0 <= 214 & HEAP8[$1 + 15 | 0] >>> 0 >= 192) & (HEAP8[$1 + 15 | 0] >>> 0 < 216 | HEAP8[$1 + 15 | 0] >>> 0 > 222))) {
   $0 = HEAP8[$1 + 15 | 0] + 32 | 0;
   break label$1;
  }
  $0 = HEAP8[$1 + 15 | 0];
 }
 return $0 << 24 >> 24;
}

function jsvIsNumeric($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $2 = HEAP8[$1 + 7 | 0] >= 10 ? HEAP8[$1 + 7 | 0] <= 17 : $2;
  HEAP8[$1 + 15 | 0] = $2;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function flatbuffers__Vector_int___Get_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = flatbuffers__IndirectHelper_int___Read_28unsigned_20char_20const__2c_20unsigned_20int_29(flatbuffers__Vector_int___Data_28_29_20const(HEAP32[$2 + 12 >> 2]), HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jsvIsString($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $2 = HEAP8[$1 + 7 | 0] >= 18 ? HEAP8[$1 + 7 | 0] <= 40 : $2;
  HEAP8[$1 + 15 | 0] = $2;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function jsvIsObject($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $0 = 1;
  $0 = HEAP8[$1 + 7 | 0] != 5 ? HEAP8[$1 + 7 | 0] == 1 : $0;
  HEAP8[$1 + 15 | 0] = $0;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function jsvGetLastArrayItem($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP16[$1 + 6 >> 1] = jsvGetLastChild(HEAP32[$1 + 8 >> 2]);
 label$1: {
  if (!HEAPU16[$1 + 6 >> 1]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipNameAndUnLock(jsvLock(HEAPU16[$1 + 6 >> 1]));
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function getCalendarDate($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $1;
 getDateFromDayNumber(HEAP32[$2 + 12 >> 2], $0 + 12 | 0, $0 + 8 | 0, $0 + 4 | 0);
 HEAP32[$0 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 + 16 >> 2] = (HEAP32[$0 >> 2] + 4 | 0) % 7;
 if (HEAP32[$0 + 16 >> 2] < 0) {
  HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + 7;
 }
 __stack_pointer = $2 + 16 | 0;
}

function _jsiInitNamedArray($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvObjectGetChild(HEAP32[91087], HEAP32[$1 + 12 >> 2], 3);
 HEAP16[$1 + 6 >> 1] = 0;
 if (HEAP32[$1 + 8 >> 2]) {
  HEAP16[$1 + 6 >> 1] = jsvGetRef(jsvRef(HEAP32[$1 + 8 >> 2]));
 }
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAPU16[$1 + 6 >> 1];
}

function tflite__Model__20flatbuffers__GetMutableRoot_tflite__Model__28void__29($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 flatbuffers__EndianCheck_28_29();
 $0 = HEAP32[$1 + 12 >> 2];
 $2 = unsigned_20int_20flatbuffers__EndianScalar_unsigned_20int__28unsigned_20int_29(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0 + $2 | 0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer____operator_5b_5d_28unsigned_20int_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer____Get_28unsigned_20int_29_20const(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function tflite__Model__subgraphs_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph___20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 8);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__Model__metadata_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__Metadata___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Metadata___20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 16);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsvIsName($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  $2 = HEAP8[$1 + 7 | 0] >= 14 ? HEAP8[$1 + 7 | 0] <= 27 : $2;
  HEAP8[$1 + 15 | 0] = $2;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function st_e_yield_literal($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 label$1: {
  if (can_take_byte(HEAP32[$2 + 4 >> 2])) {
   push_literal_byte(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 4 >> 2]);
   HEAP32[$2 + 12 >> 2] = 2;
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 4;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function mbedtls_cipher_free($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  if (HEAP32[HEAP32[$1 + 12 >> 2] + 52 >> 2]) {
   FUNCTION_TABLE[HEAP32[HEAP32[HEAP32[HEAP32[$1 + 12 >> 2] >> 2] + 28 >> 2] + 20 >> 2]](HEAP32[HEAP32[$1 + 12 >> 2] + 52 >> 2]);
  }
  mbedtls_zeroize_5(HEAP32[$1 + 12 >> 2], 56);
 }
 __stack_pointer = $1 + 16 | 0;
}

function fromTimeInDay($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return +HEAP32[HEAP32[$1 + 12 >> 2] >> 2] * 864e5 + +(HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] + Math_imul(HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + Math_imul((HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] + Math_imul(HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2], 60) | 0) - HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2] | 0, 60) | 0, 1e3) | 0);
}

function tflite__SubGraph__tensors_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor___20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 4);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function lcdSetPixel_ArrayBuffer($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 lcdSetPixels_ArrayBuffer(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], 1, HEAP32[$4 >> 2]);
 __stack_pointer = $4 + 16 | 0;
}

function jsvObjectIteratorNext($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[HEAP32[$1 + 12 >> 2] >> 2]) {
  HEAP16[$1 + 10 >> 1] = jsvGetNextSibling(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
  $0 = jsvLockSafe(HEAPU16[$1 + 10 >> 1]);
  HEAP32[HEAP32[$1 + 12 >> 2] >> 2] = $0;
 }
 __stack_pointer = $1 + 16 | 0;
}

function jsvArrayBufferGet($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 76 >> 2] = $0;
 HEAP32[$2 + 72 >> 2] = $1;
 jsvArrayBufferIteratorNew($2 + 16 | 0, HEAP32[$2 + 76 >> 2], HEAP32[$2 + 72 >> 2]);
 HEAP32[$2 + 12 >> 2] = jsvArrayBufferIteratorGetValue($2 + 16 | 0, 0);
 jsvArrayBufferIteratorFree($2 + 16 | 0);
 __stack_pointer = $2 + 80 | 0;
 return HEAP32[$2 + 12 >> 2];
}

function jsiObjectHasCallbacks($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvObjectGetChildIfExists(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 HEAP8[$2 + 3 | 0] = (jsvIsUndefined(HEAP32[$2 + 4 >> 2]) ^ -1) & 1;
 jsvUnLock(HEAP32[$2 + 4 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return HEAP8[$2 + 3 | 0] & 1;
}

function flatbuffers__IndirectHelper_float___Read_28unsigned_20char_20const__2c_20unsigned_20int_29($0, $1) {
 var $2 = 0, $3 = Math_fround(0);
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $3 = float_20flatbuffers__EndianScalar_float__28float_29(HEAPF32[HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 8 >> 2] << 2) >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $3;
}

function tflite__Model__buffers_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer___20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer___20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 12);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function terminalGetGFX($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(HEAPU8[366852] | HEAPU8[366853] << 8 | (HEAPU8[366854] << 16 | HEAPU8[366855] << 24))) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  __memcpy(HEAP32[$1 + 8 >> 2], 366800, 72);
  HEAP8[$1 + 15 | 0] = 1;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}

function espruino_snprintf($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = espruino_snprintf_va(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2]);
 __stack_pointer = $4 + 32 | 0;
 return HEAP32[$4 + 12 >> 2];
}

function std____2____compressed_pair_TfLiteSoftmaxParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_TfLiteSoftmaxParams__2c_200_2c_20false_____get_28_29(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function std____2____compressed_pair_TfLiteReshapeParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_TfLiteReshapeParams__2c_200_2c_20false_____get_28_29(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsvArrayBufferSet($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 80 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 76 >> 2] = $0;
 HEAP32[$3 + 72 >> 2] = $1;
 HEAP32[$3 + 68 >> 2] = $2;
 jsvArrayBufferIteratorNew($3 + 8 | 0, HEAP32[$3 + 76 >> 2], HEAP32[$3 + 72 >> 2]);
 jsvArrayBufferIteratorSetValue($3 + 8 | 0, HEAP32[$3 + 68 >> 2], 0);
 jsvArrayBufferIteratorFree($3 + 8 | 0);
 __stack_pointer = $3 + 80 | 0;
}

function jswrap_object_removeAllListeners_cstr($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvNewFromString(HEAP32[$2 + 8 >> 2]);
 if (HEAP32[$2 + 4 >> 2]) {
  jswrap_object_removeAllListeners(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2]);
  jsvUnLock(HEAP32[$2 + 4 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function jsvIsVariableDefined($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = 1;
 label$1: {
  if (!(jsvIsName(HEAP32[$1 + 12 >> 2]) & 1)) {
   break label$1;
  }
  $0 = 1;
  if (jsvIsNameWithValue(HEAP32[$1 + 12 >> 2]) & 1) {
   break label$1;
  }
  $0 = (jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535) != 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jspeiAddScope($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 if (!HEAP32[91088]) {
  HEAP32[91088] = jsvNewEmptyArray();
 }
 label$2: {
  if (!HEAP32[91088]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$2;
  }
  jsvArrayPush(HEAP32[91088], HEAP32[$1 + 8 >> 2]);
  HEAP8[$1 + 15 | 0] = 1;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}

function jsiGetDeviceFromClass($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(!HEAP32[$1 + 8 >> 2] | HEAP8[HEAP32[$1 + 8 >> 2]] != 68 | (HEAP8[HEAP32[$1 + 8 >> 2] + 1 | 0] != 69 | HEAP8[HEAP32[$1 + 8 >> 2] + 2 | 0] != 86))) {
   HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[$1 + 8 >> 2] + 3 | 0];
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = 0;
 }
 return HEAPU8[$1 + 15 | 0];
}

function gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 4 >> 2] = $0;
 $0 = int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(HEAP32[$1 + 4 >> 2]);
 HEAP32[gemmlowp__FixedPoint_int_2c_2012___raw_28_29($1 + 8 | 0) >> 2] = $0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jsiAppendToInputLine($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 if (!HEAP32[91112]) {
  jsvStringIteratorNew(364436, HEAP32[91104], 0);
  jsvStringIteratorGotoEnd(364436);
  HEAP32[48917] = jsvGetStringLength(HEAP32[91104]);
 }
 jsvStringIteratorAppend(364436, HEAP8[$1 + 15 | 0]);
 HEAP32[48917] = HEAP32[48917] + 1;
 __stack_pointer = $1 + 16 | 0;
}

function jsvGetPathTo($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $2;
 HEAP32[$4 + 16 >> 2] = $3;
 HEAP32[$4 + 12 >> 2] = 0;
 $0 = jsvGetPathTo_int(HEAP32[$4 + 28 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2], $4 + 12 | 0);
 __stack_pointer = $4 + 32 | 0;
 return $0;
}

function gemmlowp__FixedPoint_int_2c_205___FromScalarRaw_28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 4 >> 2] = $0;
 $0 = int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(HEAP32[$1 + 4 >> 2]);
 HEAP32[gemmlowp__FixedPoint_int_2c_205___raw_28_29($1 + 8 | 0) >> 2] = $0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function gemmlowp__FixedPoint_int_2c_202___FromScalarRaw_28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 4 >> 2] = $0;
 $0 = int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(HEAP32[$1 + 4 >> 2]);
 HEAP32[gemmlowp__FixedPoint_int_2c_202___raw_28_29($1 + 8 | 0) >> 2] = $0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function gemmlowp__FixedPoint_int_2c_200___FromScalarRaw_28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 4 >> 2] = $0;
 $0 = int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29(HEAP32[$1 + 4 >> 2]);
 HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($1 + 8 | 0) >> 2] = $0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function void_20const__20flatbuffers__Table__GetPointer_void_20const___28unsigned_20short_29_20const($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP16[$2 + 10 >> 1] = $1;
 $0 = void_20const__20flatbuffers__Table__GetPointer_void_20const___28unsigned_20short_29(HEAP32[$2 + 12 >> 2], HEAPU16[$2 + 10 >> 1]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jsvRemoveAllChildren($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 while (1) {
  if (jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535) {
   HEAP32[$1 + 8 >> 2] = jsvLock(jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535);
   jsvRemoveChildAndUnLock(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2]);
   continue;
  }
  break;
 }
 __stack_pointer = $1 + 16 | 0;
}

function gen_jswrap_Uint8ClampedArray_Uint8ClampedArray($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(65, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function std____2____compressed_pair_TfLitePoolParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_TfLitePoolParams__2c_200_2c_20false_____get_28_29(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function std____2____compressed_pair_TfLiteConvParams__2c_20tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter___first_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = std____2____compressed_pair_elem_TfLiteConvParams__2c_200_2c_20false_____get_28_29(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jshSetFlowControlAllReady() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 if (HEAP8[366352] & 1) {
  HEAP32[$0 + 12 >> 2] = 0;
  while (1) {
   if (HEAP32[$0 + 12 >> 2] < 2) {
    jshSetFlowControlXON(HEAP32[$0 + 12 >> 2] + 21 & 255, 1);
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    continue;
   }
   break;
  }
  HEAP8[366352] = 0;
 }
 __stack_pointer = $0 + 16 | 0;
}

function jswrap_serial_inject($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP8[$2 + 7 | 0] = jsiGetDeviceFromClass(HEAP32[$2 + 12 >> 2]);
 if (!(HEAPU8[$2 + 7 | 0] < 17 | HEAPU8[$2 + 7 | 0] > 22)) {
  jsvIterateCallback(HEAP32[$2 + 8 >> 2], 657, $2 + 7 | 0);
 }
 __stack_pointer = $2 + 16 | 0;
}

function jsvStringIteratorCatchUp($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 while (1) {
  $0 = 0;
  $0 = HEAP32[HEAP32[$1 + 12 >> 2] >> 2] ? HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] >= HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2] : $0;
  if ($0) {
   jsvStringIteratorLoadInline(HEAP32[$1 + 12 >> 2]);
   continue;
  }
  break;
 }
 __stack_pointer = $1 + 16 | 0;
}

function jsvNewWritableStringFromStringVar($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 >> 2] = jsvNewFromEmptyString_1();
 jsvAppendStringVar(HEAP32[$3 >> 2], HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return HEAP32[$3 >> 2];
}

function jsvGetFirstChild($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 $1 = HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24);
 $0 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
 $1 = ($1 & 268435455) << 4 | $0 >>> 28;
 return $1 & 16383;
}

function jslCharPosNew($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jsvStringIteratorNew(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 $0 = jsvStringIteratorGetCharAndNext(HEAP32[$3 + 12 >> 2]);
 HEAP8[HEAP32[$3 + 12 >> 2] + 36 | 0] = $0;
 __stack_pointer = $3 + 16 | 0;
}

function jsvGetPrevSibling($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 $1 = HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24);
 $0 = HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24);
 $1 = ($1 & 16383) << 18 | $0 >>> 14;
 return $1 & 16383;
}

function jswrap_espruino_toArrayBuffer($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(jsvIsString(HEAP32[$1 + 8 >> 2]) & 1)) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvNewArrayBufferFromString(HEAP32[$1 + 8 >> 2], 0);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsSendTouchEvent($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 touchHandlerInternal(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
 __stack_pointer = $4 + 16 | 0;
}

function jswrap_interface_setInterval($0, $1, $2) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAPF64[$3 + 16 >> 3] = $1;
 HEAP32[$3 + 12 >> 2] = $2;
 $0 = _jswrap_interface_setTimeoutOrInterval(HEAP32[$3 + 28 >> 2], HEAPF64[$3 + 16 >> 3], HEAP32[$3 + 12 >> 2], 0);
 __stack_pointer = $3 + 32 | 0;
 return $0 | 0;
}

function jswrap_espruino_getConsole() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP8[$0 + 11 | 0] = jsiGetConsoleDevice();
 label$1: {
  if (!HEAPU8[$0 + 11 | 0]) {
   HEAP32[$0 + 12 >> 2] = jsvNewNull_1();
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = jsvNewFromString(jshGetDeviceString(HEAPU8[$0 + 11 | 0]));
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function jsvTraceLockInfo($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvGetRef(HEAP32[$1 + 12 >> 2]);
 $2 = jsvGetRefs(HEAP32[$1 + 12 >> 2]);
 HEAP32[$1 + 8 >> 2] = jsvGetLocks(HEAP32[$1 + 12 >> 2]) & 255;
 HEAP32[$1 + 4 >> 2] = $2 & 65535;
 HEAP32[$1 >> 2] = $0 & 65535;
 jsiConsolePrintf(146171, $1);
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_interface_setTimeout($0, $1, $2) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAPF64[$3 + 16 >> 3] = $1;
 HEAP32[$3 + 12 >> 2] = $2;
 $0 = _jswrap_interface_setTimeoutOrInterval(HEAP32[$3 + 28 >> 2], HEAPF64[$3 + 16 >> 3], HEAP32[$3 + 12 >> 2], 1);
 __stack_pointer = $3 + 32 | 0;
 return $0 | 0;
}

function jsvFreePtrInternal($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 + 12 | 0] = 0;
 HEAP8[$0 + 13 | 0] = 0;
 jshInterruptOff();
 jsvSetNextSibling(HEAP32[$1 + 12 >> 2], HEAPU16[98162]);
 HEAP16[98162] = jsvGetRef(HEAP32[$1 + 12 >> 2]);
 HEAP8[196321] = 1;
 jshInterruptOn();
 __stack_pointer = $1 + 16 | 0;
}

function heatshrink_decode($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 >> 2] = HEAP32[$3 + 4 >> 2];
 $0 = heatshrink_decode_cb(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2] ? 575 : 0, HEAP32[$3 + 4 >> 2] ? $3 : 0);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function jswrap_json_parse_liberal($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 HEAP32[$2 + 4 >> 2] = jswrap_json_parse_ext(HEAP32[$2 + 12 >> 2], 512);
 if (HEAP8[$2 + 11 | 0] & 1) {
  jsvUnLock(jspGetException());
  HEAP32[91094] = HEAP32[91094] & -33;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 4 >> 2];
}

function jsvUnLockMany($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 while (1) {
  if (HEAP32[$2 + 12 >> 2]) {
   $1 = HEAP32[$2 + 8 >> 2];
   $0 = HEAP32[$2 + 12 >> 2] - 1 | 0;
   HEAP32[$2 + 12 >> 2] = $0;
   jsvUnLockInline(HEAP32[($0 << 2) + $1 >> 2]);
   continue;
  }
  break;
 }
 __stack_pointer = $2 + 16 | 0;
}

function jshSetPinShouldStayWatched($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 $1 = (HEAPU8[$2 + 15 | 0] >>> 5 << 2) + 364396 | 0;
 if (HEAP8[$2 + 14 | 0] & 1) {
  $0 = 1 << HEAPU8[$2 + 15 | 0];
 } else {
  $0 = 0;
 }
 HEAP32[$1 >> 2] = $0 | HEAP32[(HEAPU8[$2 + 15 | 0] >>> 5 << 2) + 364396 >> 2] & __wasm_rotl_i32(-2, HEAPU8[$2 + 15 | 0]);
}

function gen_jswrap_Float64Array_Float64Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(40, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_Float32Array_Float32Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(36, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function graphicsGetPixel($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 graphicsToDeviceCoordinates(HEAP32[$3 + 12 >> 2], $3 + 8 | 0, $3 + 4 | 0);
 $0 = graphicsGetPixelDevice(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function jsvLock($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP16[$1 + 14 >> 1] = $0;
 HEAP32[$1 + 8 >> 2] = jsvGetAddressOf(HEAPU16[$1 + 14 >> 1]);
 $0 = HEAP32[$1 + 8 >> 2];
 $2 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) + 1024 | 0;
 HEAP8[$0 + 12 | 0] = $2;
 HEAP8[$0 + 13 | 0] = $2 >>> 8;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jshSetPinStateIsManual($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 $1 = (HEAPU8[$2 + 15 | 0] >>> 5 << 2) + 364388 | 0;
 if (HEAP8[$2 + 14 | 0] & 1) {
  $0 = 1 << HEAPU8[$2 + 15 | 0];
 } else {
  $0 = 0;
 }
 HEAP32[$1 >> 2] = $0 | HEAP32[(HEAPU8[$2 + 15 | 0] >>> 5 << 2) + 364388 >> 2] & __wasm_rotl_i32(-2, HEAPU8[$2 + 15 | 0]);
}

function gen_jswrap_Uint32Array_Uint32Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(4, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_Uint24Array_Uint24Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(3, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_Uint16Array_Uint16Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(2, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_Int32Array_Int32Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(20, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_Int16Array_Int16Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(18, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__operator_28_29_28void__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[HEAP32[$2 + 12 >> 2] >> 2];
 FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 4 >> 2]]($0, HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_flash_erasePage($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (!(jsvIsInt(HEAP32[$1 + 12 >> 2]) & 1)) {
   HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
   jsExceptionHere(1, 118604, $1);
   break label$1;
  }
  jshFlashErasePage(jsvGetInteger(HEAP32[$1 + 12 >> 2]));
 }
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorNew($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 label$1: {
  if (jsvHasChildren(HEAP32[$2 + 8 >> 2]) & 1) {
   $0 = jsvLockSafe(jsvGetFirstChild(HEAP32[$2 + 8 >> 2]) & 65535);
   break label$1;
  }
  $0 = 0;
 }
 HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = $0;
 __stack_pointer = $2 + 16 | 0;
}

function jspEvaluateExpressionVar($0) {
 var $1 = 0;
 $1 = __stack_pointer - 144 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 140 >> 2] = $0;
 HEAP32[$1 + 12 >> 2] = jslSetLex($1 + 16 | 0);
 jslInit(HEAP32[$1 + 140 >> 2]);
 HEAP32[$1 + 8 >> 2] = jspeExpression();
 jslKill();
 jslSetLex(HEAP32[$1 + 12 >> 2]);
 $0 = jsvSkipNameAndUnLock(HEAP32[$1 + 8 >> 2]);
 __stack_pointer = $1 + 144 | 0;
 return $0;
}

function jsiClearInputLine($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 if (!(jsvIsEmptyString(HEAP32[91104]) & 1)) {
  if (HEAP8[$1 + 15 | 0] & 1) {
   jsiConsoleRemoveInputLine();
  }
  jsiInputLineCursorMoved();
  jsvUnLock(HEAP32[91104]);
  HEAP32[91104] = jsvNewFromEmptyString_5();
  HEAP32[91106] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
}

function gen_jswrap_Uint8Array_Uint8Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(1, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function jswrap_array_filter($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = _jswrap_array_iterate_with_callback(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1, 1, 1);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function jspNewBuiltin($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = jswFindBuiltInFunction(0, HEAP32[$1 + 8 >> 2]);
 label$1: {
  if (!HEAP32[$1 + 4 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 4 >> 2];
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsonNeedsNewLine($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = 1;
 label$1: {
  if (jsvIsUndefined(HEAP32[$1 + 12 >> 2]) & 1) {
   break label$1;
  }
  $0 = 1;
  if (jsvIsNull(HEAP32[$1 + 12 >> 2]) & 1) {
   break label$1;
  }
  $0 = jsvIsNumeric(HEAP32[$1 + 12 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return ($0 ^ -1) & 1;
}

function jshI2CInitInfo($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 4 | 0] = 255;
 HEAP8[HEAP32[$1 + 12 >> 2] + 5 | 0] = 255;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 | 0] = 160;
 HEAP8[$0 + 1 | 0] = 134;
 HEAP8[$0 + 2 | 0] = 1;
 HEAP8[$0 + 3 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 6 | 0] = 0;
 HEAP8[HEAP32[$1 + 12 >> 2] + 7 | 0] = 1;
}

function gen_jswrap_Int8Array_Int8Array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_typedarray_constructor(17, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function jswrap_array_every($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = _jswrap_array_iterate_with_callback(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0, 1, 1);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function strcmp($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAPU8[$0 | 0];
 $3 = HEAPU8[$1 | 0];
 label$1: {
  if (!$2 | ($3 | 0) != ($2 | 0)) {
   break label$1;
  }
  while (1) {
   $3 = HEAPU8[$1 + 1 | 0];
   $2 = HEAPU8[$0 + 1 | 0];
   if (!$2) {
    break label$1;
   }
   $1 = $1 + 1 | 0;
   $0 = $0 + 1 | 0;
   if (($2 | 0) == ($3 | 0)) {
    continue;
   }
   break;
  }
 }
 return $2 - $3 | 0;
}

function jswrap_array_some($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = _jswrap_array_iterate_with_callback(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0, 1, 0);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_String_includes($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_string_indexOf(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
 __stack_pointer = $3 + 16 | 0;
 return ($0 | 0) >= 0 | 0;
}

function tflite__MicroMutableOpResolver_9u____MicroMutableOpResolver_28_29_1($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite__MicroMutableOpResolver_9u____MicroMutableOpResolver_28_29($0);
 tflite__MicroMutableOpResolver_9u___operator_20delete_28void__29($0);
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_array_map($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = _jswrap_array_iterate_with_callback(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1, 0, 0);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function jsvUnLock4($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 jsvUnLockInline(HEAP32[$4 + 12 >> 2]);
 jsvUnLockInline(HEAP32[$4 + 8 >> 2]);
 jsvUnLockInline(HEAP32[$4 + 4 >> 2]);
 jsvUnLockInline(HEAP32[$4 >> 2]);
 __stack_pointer = $4 + 16 | 0;
}

function jsvIsInternalFunctionKey($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (jsvIsString(HEAP32[$1 + 12 >> 2]) & 1) {
   $0 = 1;
   if (HEAP8[HEAP32[$1 + 12 >> 2]] == -1) {
    break label$1;
   }
  }
  $0 = jsvIsFunctionParameter(HEAP32[$1 + 12 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return $0 & 1;
}

function jslMatch($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (HEAP16[HEAP32[49079] + 2 >> 1] != HEAP32[$1 + 8 >> 2]) {
   jslMatchError(HEAP32[$1 + 8 >> 2]);
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  jslGetNextToken();
  HEAP8[$1 + 15 | 0] = 1;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}

function jshGetEventDataPin($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 14 | 0] = $0;
 HEAP32[$1 + 8 >> 2] = HEAPU8[$1 + 14 | 0] - 1;
 label$1: {
  if ((HEAP32[(HEAP32[$1 + 8 >> 2] << 2) + 364496 >> 2] & -256) == -256) {
   HEAP8[$1 + 15 | 0] = HEAP32[(HEAP32[$1 + 8 >> 2] << 2) + 364496 >> 2];
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = 255;
 }
 return HEAPU8[$1 + 15 | 0];
}

function tflite__FullyConnectedOptions__asymmetric_quantize_inputs_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20char_20flatbuffers__Table__GetField_unsigned_20char__28unsigned_20short_2c_20unsigned_20char_29_20const(HEAP32[$1 + 12 >> 2], 10, 0) & 255;
 __stack_pointer = $1 + 16 | 0;
 return ($0 | 0) != 0;
}

function jswrap_espruino_toJS($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 8896;
 HEAP32[$1 + 4 >> 2] = jsvNewFromEmptyString_9();
 if (HEAP32[$1 + 4 >> 2]) {
  jsfGetJSON(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 4 >> 2];
}

function jswOnCharEvent($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 14 | 0] = $0;
 HEAP8[$2 + 13 | 0] = $1;
 label$1: {
  if (HEAPU8[$2 + 14 | 0] == 22) {
   HEAP8[$2 + 15 | 0] = jswrap_banglejs_gps_character(HEAP8[$2 + 13 | 0]) & 1;
   break label$1;
  }
  HEAP8[$2 + 15 | 0] = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return HEAP8[$2 + 15 | 0] & 1;
}

function gen_jswrap_Graphics_drawPolyAA($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_graphics_drawPoly_X(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1, 1);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function tflite__AlignPointerUp_28unsigned_20char__2c_20unsigned_20long_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 >> 2] = Math_imul(HEAP32[$2 + 8 >> 2], (HEAP32[$2 + 4 >> 2] + (HEAP32[$2 + 8 >> 2] - 1 | 0) >>> 0) / HEAPU32[$2 + 8 >> 2] | 0);
 return HEAP32[$2 >> 2];
}

function jsvArrayPush2Int($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jsvArrayPushAndUnLock(HEAP32[$3 + 12 >> 2], jsvNewFromInteger(HEAP32[$3 + 8 >> 2]));
 jsvArrayPushAndUnLock(HEAP32[$3 + 12 >> 2], jsvNewFromInteger(HEAP32[$3 + 4 >> 2]));
 __stack_pointer = $3 + 16 | 0;
}

function tflite__QuantizationParameters__zero_point_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_long_20long__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_long_20long__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 10);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_spi_write_cb($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 FUNCTION_TABLE[HEAP32[HEAP32[$3 + 4 >> 2] >> 2]](HEAP32[$3 + 12 >> 2], 0, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2] + 4 | 0);
 __stack_pointer = $3 + 16 | 0;
}

function jspeCheckBreakContinue() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 label$1: {
  label$2: {
   if (HEAP32[91094] & 4) {
    HEAP32[91094] = HEAP32[91094] & -64 | 1;
    break label$2;
   }
   if (HEAP32[91094] & 2) {
    HEAP32[91094] = HEAP32[91094] & -64 | 1;
    HEAP8[$0 + 15 | 0] = 1;
    break label$1;
   }
  }
  HEAP8[$0 + 15 | 0] = 0;
 }
 return HEAP8[$0 + 15 | 0] & 1;
}

function gen_jswrap_Graphics_drawPoly($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_graphics_drawPoly_X(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1, 0);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function flatbuffers__IndirectHelper_int___Read_28unsigned_20char_20const__2c_20unsigned_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = int_20flatbuffers__EndianScalar_int__28int_29(HEAP32[HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 8 >> 2] << 2) >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function tflite__Operator__custom_options_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_unsigned_20char__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_unsigned_20char__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 14);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__MicroAllocator__AllocatePersistentBuffer_28unsigned_20long_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2];
 $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 12 >> 2]]($0, HEAP32[$2 + 8 >> 2], 16) | 0;
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function gen_jswrap_E_showPrompt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 $0 = jspExecuteJSFunctionCode(134511, 141346, 1365, 0, 2, $2);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function tflite__RuntimeShape__Resize_28int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 if (HEAP32[$0 >> 2] > 5) {
  abort();
  abort();
 }
 HEAP32[$0 >> 2] = HEAP32[$2 + 8 >> 2];
 if (HEAP32[$2 + 8 >> 2] > 5) {
  abort();
  abort();
 }
 __stack_pointer = $2 + 16 | 0;
}

function std____2____compressed_pair_elem_TfLiteFullyConnectedParams__2c_200_2c_20false_____compressed_pair_elem_TfLiteFullyConnectedParams___2c_20void__28TfLiteFullyConnectedParams___29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
 return $0;
}

function jswrap_espruino_memoryMap($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 $0 = jspExecuteJSFunctionCode(129151, 138385, 0, 0, 2, $2);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_String_lastIndexOf($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_string_indexOf(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_E_showAlert($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 $0 = jspExecuteJSFunctionCode(135861, 162989, 239, 0, 2, $2);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_DataView_getFloat64($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 40, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_DataView_getFloat32($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 36, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function std____2____compressed_pair_elem_TfLiteDepthwiseConvParams__2c_200_2c_20false_____compressed_pair_elem_TfLiteDepthwiseConvParams___2c_20void__28TfLiteDepthwiseConvParams___29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
 return $0;
}

function jswrap_storagefile_read($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 if (HEAP32[$2 + 8 >> 2] < 0) {
  HEAP32[$2 + 8 >> 2] = 0;
 }
 $0 = jswrap_storagefile_read_internal(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function jsvTrace($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP8[$2 + 7 | 0] = HEAPU8[196322];
 HEAP8[196322] = 0;
 _jsvTrace(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2], 0);
 HEAP8[196322] = HEAPU8[$2 + 7 | 0];
 jsiConsolePrintf(148266, 0);
 __stack_pointer = $2 + 16 | 0;
}

function gen_jswrap_DataView_getUint32($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 4, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_DataView_getUint16($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 2, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_DataView_getInt32($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 20, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_DataView_getInt16($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 18, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function __sin($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = $0 * $0;
 $5 = $3 * ($3 * $3) * ($3 * 1.58969099521155e-10 + -2.5050760253406863e-8) + ($3 * ($3 * 27557313707070068e-22 + -.0001984126982985795) + .00833333333332249);
 $4 = $3 * $0;
 if (!$2) {
  return $4 * ($3 * $5 + -.16666666666666632) + $0;
 }
 return $0 - ($3 * ($1 * .5 - $5 * $4) - $1 + $4 * .16666666666666632);
}

function jsvObjectRemoveChild($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvFindChildFromString(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 if (HEAP32[$2 + 4 >> 2]) {
  jsvRemoveChildAndUnLock(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 4 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function gen_jswrap_DataView_getUint8($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 1, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_DataView_getInt8($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jswrap_dataview_get(HEAP32[$3 + 12 >> 2], 17, HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function TfLiteFullyConnectedParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteFullyConnectedParams__28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] >> 2]]($0, 12, 4);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jswrap_string_replaceAll($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = _jswrap_string_replace(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function jsvIsGetterOrSetter($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  HEAP8[$1 + 15 | 0] = HEAP8[$1 + 7 | 0] == 6;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function gen_jswrap_String_indexOf($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_string_indexOf(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function tflite__DepthwiseConv2DOptions__fused_activation_function_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const(HEAP32[$1 + 12 >> 2], 12, 0) << 24;
 __stack_pointer = $1 + 16 | 0;
 return $0 >> 24;
}

function std____2____compressed_pair_elem_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29___2c_200_2c_20false_____compressed_pair_elem_std__nullptr_t_2c_20void__28std__nullptr_t___29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 >> 2] = 0;
 return $0;
}

function jsvIsNativeString($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  HEAP8[$1 + 15 | 0] = HEAP8[$1 + 7 | 0] == 39;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function TfLiteDepthwiseConvParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteDepthwiseConvParams__28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] >> 2]]($0, 28, 4);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jsvNegateAndUnLock($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvNewFromInteger(0);
 HEAP32[$1 + 4 >> 2] = jsvMathsOpSkipNames(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2], 45);
 jsvUnLock2(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 4 >> 2];
}

function jsvIsFlashString($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  HEAP8[$1 + 15 | 0] = HEAP8[$1 + 7 | 0] == 40;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function jsvGetLongIntegerAndUnLock($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 >> 2] = jsvGetLongInteger(HEAP32[$1 + 12 >> 2]);
 HEAP32[$1 + 4 >> 2] = i64toi32_i32$HIGH_BITS;
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
 return HEAP32[$1 >> 2];
}

function gen_jswrap_String_padStart($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_string_padX(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function _jswrap_promise_native_with_prombox($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvNewNativeFunction(HEAP32[$2 + 12 >> 2], 32776);
 jsvObjectSetChild(HEAP32[$2 + 4 >> 2], 120157, HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 4 >> 2];
}

function tflite__internal__ContextHelper__GetEvalTensor_28TfLiteContext_20const__2c_20int_29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2];
 return HEAP32[HEAP32[$2 + 4 >> 2] + 12 >> 2] + Math_imul(HEAP32[$2 + 8 >> 2], 12) | 0;
}

function tflite__FullyConnectedOptions__fused_activation_function_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const(HEAP32[$1 + 12 >> 2], 4, 0) << 24;
 __stack_pointer = $1 + 16 | 0;
 return $0 >> 24;
}

function jswrap_string_replace($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = _jswrap_string_replace(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function jsvObjectIteratorGetValue_17($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetValue_16($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetValue_15($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetValue_14($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetValue_13($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetValue_12($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetValue_11($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetValue_10($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvIsFlatString($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  HEAP8[$1 + 15 | 0] = HEAP8[$1 + 7 | 0] == 38;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function jsvGetArrayLength($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP32[$1 + 12 >> 2] = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
 }
 return HEAP32[$1 + 12 >> 2];
}

function tflite__FullyConnectedOptions__keep_num_dims_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20char_20flatbuffers__Table__GetField_unsigned_20char__28unsigned_20short_2c_20unsigned_20char_29_20const(HEAP32[$1 + 12 >> 2], 8, 0) & 255;
 __stack_pointer = $1 + 16 | 0;
 return ($0 | 0) != 0;
}

function jsvObjectIteratorGetValue_9($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetValue_8($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetValue_7($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetValue_6($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetValue_5($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetValue_4($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetValue_3($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetValue_2($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetValue_1($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function gen_jswrap_String_padEnd($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = jswrap_string_padX(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_E_showMessage($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 jsvUnLock(jspExecuteJSFunctionCode(135857, 144386, 563, 0, 2, $2));
 __stack_pointer = $2 + 16 | 0;
}

function gen_jswrap_Bangle_setUI($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 jsvUnLock(jspExecuteJSFunctionCode(132890, 159948, 3040, 0, 2, $2));
 __stack_pointer = $2 + 16 | 0;
}

function mbedtls_zeroize_5($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 while (1) {
  $0 = HEAP32[$2 + 8 >> 2];
  HEAP32[$2 + 8 >> 2] = $0 - 1;
  if ($0) {
   $0 = HEAP32[$2 + 4 >> 2];
   HEAP32[$2 + 4 >> 2] = $0 + 1;
   HEAP8[$0 | 0] = 0;
   continue;
  }
  break;
 }
}

function mbedtls_zeroize_4($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 while (1) {
  $0 = HEAP32[$2 + 8 >> 2];
  HEAP32[$2 + 8 >> 2] = $0 - 1;
  if ($0) {
   $0 = HEAP32[$2 + 4 >> 2];
   HEAP32[$2 + 4 >> 2] = $0 + 1;
   HEAP8[$0 | 0] = 0;
   continue;
  }
  break;
 }
}

function mbedtls_zeroize_3($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 while (1) {
  $0 = HEAP32[$2 + 8 >> 2];
  HEAP32[$2 + 8 >> 2] = $0 - 1;
  if ($0) {
   $0 = HEAP32[$2 + 4 >> 2];
   HEAP32[$2 + 4 >> 2] = $0 + 1;
   HEAP8[$0 | 0] = 0;
   continue;
  }
  break;
 }
}

function mbedtls_zeroize_2($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 while (1) {
  $0 = HEAP32[$2 + 8 >> 2];
  HEAP32[$2 + 8 >> 2] = $0 - 1;
  if ($0) {
   $0 = HEAP32[$2 + 4 >> 2];
   HEAP32[$2 + 4 >> 2] = $0 + 1;
   HEAP8[$0 | 0] = 0;
   continue;
  }
  break;
 }
}

function mbedtls_zeroize_1($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 while (1) {
  $0 = HEAP32[$2 + 8 >> 2];
  HEAP32[$2 + 8 >> 2] = $0 - 1;
  if ($0) {
   $0 = HEAP32[$2 + 4 >> 2];
   HEAP32[$2 + 4 >> 2] = $0 + 1;
   HEAP8[$0 | 0] = 0;
   continue;
  }
  break;
 }
}

function jsvStringIteratorNextInline($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
 if (HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] >= HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) {
  jsvStringIteratorLoadInline(HEAP32[$1 + 12 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorGetKey_9($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetKey_8($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetKey_7($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetKey_6($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetKey_5($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetKey_4($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetKey_3($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetKey_2($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorGetKey_1($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvIsEmptyString($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(jsvHasCharacterData(HEAP32[$1 + 8 >> 2]) & 1)) {
   HEAP8[$1 + 15 | 0] = 1;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = !jsvGetCharactersInVar(HEAP32[$1 + 8 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 15 | 0] & 1;
}

function jspeBlockOrStatement() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 label$1: {
  if (HEAP16[HEAP32[49079] + 2 >> 1] == 123) {
   jspeBlock();
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 8 >> 2] = jspeStatement();
  HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function jshPushIOCharEventFlowControl($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 label$1: {
  if (HEAPU8[$1 + 15 | 0] < 21 | HEAPU8[$1 + 15 | 0] > 22) {
   break label$1;
  }
  if ((jshGetEventsUsed() | 0) <= 191) {
   break label$1;
  }
  jshSetFlowControlXON(HEAPU8[$1 + 15 | 0], 0);
 }
 __stack_pointer = $1 + 16 | 0;
}

function tflite__EspruinoErrorReporter___EspruinoErrorReporter_28_29_1($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite__EspruinoErrorReporter___EspruinoErrorReporter_28_29($0);
 tflite__EspruinoErrorReporter__operator_20delete_28void__29($0);
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_pin_pulse($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP8[$3 + 11 | 0] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jswrap_io_digitalPulse(jshGetPinFromVar(HEAP32[$3 + 12 >> 2]) & 255, HEAP8[$3 + 11 | 0] & 1, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
}

function jswrap_array_forEach($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 _jswrap_array_iterate_with_callback(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0, 0, 0);
 __stack_pointer = $3 + 16 | 0;
}

function jsvObjectIteratorGetValue($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvSkipName(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function isAlphaInline_1($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 label$1: {
  if (HEAP8[$1 + 15 | 0] >= 97) {
   $0 = 1;
   if (HEAP8[$1 + 15 | 0] <= 122) {
    break label$1;
   }
  }
  if (HEAP8[$1 + 15 | 0] >= 65) {
   $0 = 1;
   if (HEAP8[$1 + 15 | 0] <= 90) {
    break label$1;
   }
  }
  $0 = HEAP8[$1 + 15 | 0] == 95;
 }
 return $0;
}

function aes_ctx_alloc() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = jsvMalloc(280);
 label$1: {
  if (!HEAP32[$0 + 8 >> 2]) {
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  mbedtls_aes_init(HEAP32[$0 + 8 >> 2]);
  HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 8 >> 2];
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function _jswrap_espruino_toUint8Array_char($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsvArrayBufferIteratorSetByteValue(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2] << 24 >> 24);
 jsvArrayBufferIteratorNext(HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
}

function tflite__Buffer__data_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_unsigned_20char__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_unsigned_20char__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 4);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function mbedtls_zeroize($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 while (1) {
  $0 = HEAP32[$2 + 8 >> 2];
  HEAP32[$2 + 8 >> 2] = $0 - 1;
  if ($0) {
   $0 = HEAP32[$2 + 4 >> 2];
   HEAP32[$2 + 4 >> 2] = $0 + 1;
   HEAP8[$0 | 0] = 0;
   continue;
  }
  break;
 }
}

function jsvObjectIteratorGetKey($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvLockAgain(HEAP32[HEAP32[$1 + 8 >> 2] >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_pin_pwm($0, $1, $2) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAPF64[$3 + 16 >> 3] = $1;
 HEAP32[$3 + 12 >> 2] = $2;
 jswrap_io_analogWrite(jshGetPinFromVar(HEAP32[$3 + 28 >> 2]) & 255, HEAPF64[$3 + 16 >> 3], HEAP32[$3 + 12 >> 2]);
 __stack_pointer = $3 + 32 | 0;
}

function isAlphaInline($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 label$1: {
  if (HEAP8[$1 + 15 | 0] >= 97) {
   $0 = 1;
   if (HEAP8[$1 + 15 | 0] <= 122) {
    break label$1;
   }
  }
  if (HEAP8[$1 + 15 | 0] >= 65) {
   $0 = 1;
   if (HEAP8[$1 + 15 | 0] <= 90) {
    break label$1;
   }
  }
  $0 = HEAP8[$1 + 15 | 0] == 95;
 }
 return $0;
}

function aes_setkey_enc_wrap($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = mbedtls_aes_setkey_enc(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function aes_setkey_dec_wrap($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = mbedtls_aes_setkey_dec(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function jsfHashFiles($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 >> 2] = -1412571974;
 jsfBankListFiles(0, 134217728, HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], $3);
 __stack_pointer = $3 + 16 | 0;
 return HEAP32[$3 >> 2];
}

function gemmlowp__FixedPoint_int_2c_202___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_202___28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(HEAP32[$1 + 12 >> 2], 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function gemmlowp__FixedPoint_int_2c_200___ScalarRawType_20gemmlowp__RescaleConstantInitializer_gemmlowp__FixedPoint_int_2c_200___28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(HEAP32[$1 + 12 >> 2], 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function ccm_aes_setkey_wrap($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = mbedtls_ccm_setkey(HEAP32[$3 + 12 >> 2], 2, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
 return $0 | 0;
}

function tflite__Tensor__quantization_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = tflite__QuantizationParameters_20const__20flatbuffers__Table__GetPointer_tflite__QuantizationParameters_20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 12);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__QuantizationParameters__scale_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_float__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_float__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 8);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__Pool2DOptions__fused_activation_function_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const(HEAP32[$1 + 12 >> 2], 14, 0) << 24;
 __stack_pointer = $1 + 16 | 0;
 return $0 >> 24;
}

function tflite__Conv2DOptions__fused_activation_function_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const(HEAP32[$1 + 12 >> 2], 10, 0) << 24;
 __stack_pointer = $1 + 16 | 0;
 return $0 >> 24;
}

function jsvIsRoot($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  HEAP8[$1 + 15 | 0] = HEAP8[$1 + 7 | 0] == 1;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function jsvIsPin($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
  HEAP8[$1 + 15 | 0] = HEAP8[$1 + 7 | 0] == 13;
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function jslGetTokenLength() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 label$1: {
  if (HEAP32[HEAP32[49079] + 76 >> 2]) {
   HEAP32[$0 + 12 >> 2] = jsvGetStringLength(HEAP32[HEAP32[49079] + 76 >> 2]);
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = HEAPU8[HEAP32[49079] + 80 | 0];
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function tflite__ParseDequantize_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 return 0;
}

function jsiConsoleReturnInputLine() {
 if (HEAP8[364420] & 1) {
  HEAP8[364420] = 0;
  if (jsiEcho() & 1) {
   if (jsiPasswordProtected() & 1) {
    jsiConsolePrintString(132903);
   }
   jsiConsolePrintChar(62);
   jsiConsolePrintStringVarWithNewLineChar(HEAP32[91104], 0, 58);
   jsiMoveCursorChar(HEAP32[91104], jsvGetStringLength(HEAP32[91104]), HEAP32[91106]);
  }
 }
}

function jsvStringIteratorSetChar($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 if (jsvStringIteratorHasChar_2(HEAP32[$2 + 12 >> 2]) & 1) {
  HEAP8[HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] + HEAP32[HEAP32[$2 + 12 >> 2] >> 2] | 0] = HEAPU8[$2 + 11 | 0];
 }
 __stack_pointer = $2 + 16 | 0;
}

function jslKill() {
 HEAP16[HEAP32[49079] + 2 >> 1] = 0;
 if (HEAP32[HEAP32[49079] + 100 >> 2]) {
  jsvLockAgain(HEAP32[HEAP32[49079] + 100 >> 2]);
 }
 jsvStringIteratorFree(HEAP32[49079] + 88 | 0);
 if (HEAP32[HEAP32[49079] + 76 >> 2]) {
  jsvUnLock(HEAP32[HEAP32[49079] + 76 >> 2]);
  HEAP32[HEAP32[49079] + 76 >> 2] = 0;
 }
 jsvUnLock(HEAP32[HEAP32[49079] + 84 >> 2]);
}

function tflite__ParseQuantize_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 return 0;
}

function TfLiteReshapeParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteReshapeParams__28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] >> 2]]($0, 36, 4);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function unsigned_20short_20flatbuffers__ReadScalar_unsigned_20short__28void_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20short_20flatbuffers__EndianScalar_unsigned_20short__28unsigned_20short_29(HEAPU16[HEAP32[$1 + 12 >> 2] >> 1]);
 __stack_pointer = $1 + 16 | 0;
 return $0 & 65535;
}

function tflite__FullyConnectedOptions__weights_format_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const(HEAP32[$1 + 12 >> 2], 6, 0) << 24;
 __stack_pointer = $1 + 16 | 0;
 return $0 >> 24;
}

function TfLiteSoftmaxParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteSoftmaxParams__28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] >> 2]]($0, 4, 4);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function memcmp($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  if (!$2) {
   break label$1;
  }
  while (1) {
   $3 = HEAPU8[$0 | 0];
   $4 = HEAPU8[$1 | 0];
   if (($3 | 0) == ($4 | 0)) {
    $1 = $1 + 1 | 0;
    $0 = $0 + 1 | 0;
    $2 = $2 - 1 | 0;
    if ($2) {
     continue;
    }
    break label$1;
   }
   break;
  }
  $5 = $3 - $4 | 0;
 }
 return $5;
}

function int_20gemmlowp__AddSaturatingIf16Bit_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = gemmlowp__AddSaturatingIf16BitImpl_int_2c_20false___Run_28int_2c_20int_29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function std____2____compressed_pair_elem_TfLiteSoftmaxParams__2c_200_2c_20false_____compressed_pair_elem_TfLiteSoftmaxParams___2c_20void__28TfLiteSoftmaxParams___29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
 return $0;
}

function std____2____compressed_pair_elem_TfLiteReshapeParams__2c_200_2c_20false_____compressed_pair_elem_TfLiteReshapeParams___2c_20void__28TfLiteReshapeParams___29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
 return $0;
}

function tflite__ReshapeOptions__new_shape_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 4);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jshInit() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 while (1) {
  if (HEAP32[$0 + 12 >> 2] < 16) {
   HEAP8[HEAP32[$0 + 12 >> 2] + 390976 | 0] = 255;
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
   continue;
  }
  break;
 }
 jshInitDevices();
 HEAP8[195676] = 1;
 __stack_pointer = $0 + 16 | 0;
}

function strncat($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = strlen($0) + $0 | 0;
 label$1: {
  if (!$2) {
   break label$1;
  }
  while (1) {
   $4 = HEAPU8[$1 | 0];
   if (!$4) {
    break label$1;
   }
   HEAP8[$3 | 0] = $4;
   $3 = $3 + 1 | 0;
   $1 = $1 + 1 | 0;
   $2 = $2 - 1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
 HEAP8[$3 | 0] = 0;
 return $0;
}

function jsvGetFlatStringPointer($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(jsvIsFlatString(HEAP32[$1 + 8 >> 2]) & 1)) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2] + 14;
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jspeStatementThrow() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = 0;
 jslGetNextToken();
 HEAP32[$0 + 12 >> 2] = jsvSkipNameAndUnLock(jspeExpression());
 if ((HEAP32[91094] & 63) == 1) {
  jspSetException(HEAP32[$0 + 12 >> 2]);
 }
 jsvUnLock(HEAP32[$0 + 12 >> 2]);
 __stack_pointer = $0 + 16 | 0;
 return 0;
}

function TfLitePoolParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLitePoolParams__28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] >> 2]]($0, 40, 4);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function TfLiteConvParams__20tflite__BuiltinDataAllocator__AllocatePOD_TfLiteConvParams__28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 8 >> 2] = FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] >> 2]]($0, 24, 4);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function tflite__Tensor__is_variable_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20char_20flatbuffers__Table__GetField_unsigned_20char__28unsigned_20short_2c_20unsigned_20char_29_20const(HEAP32[$1 + 12 >> 2], 14, 0) & 255;
 __stack_pointer = $1 + 16 | 0;
 return ($0 | 0) != 0;
}

function tflite__Operator__builtin_options_type_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20char_20flatbuffers__Table__GetField_unsigned_20char__28unsigned_20short_2c_20unsigned_20char_29_20const(HEAP32[$1 + 12 >> 2], 10, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 & 255;
}

function tflite__DepthwiseConv2DOptions__padding_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const(HEAP32[$1 + 12 >> 2], 4, 0) << 24;
 __stack_pointer = $1 + 16 | 0;
 return $0 >> 24;
}

function lcdSetCallbacks_JS($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 + 52 | 0] = 90;
 HEAP8[$0 + 53 | 0] = 2;
 HEAP8[$0 + 54 | 0] = 0;
 HEAP8[$0 + 55 | 0] = 0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP8[$0 + 56 | 0] = 91;
 HEAP8[$0 + 57 | 0] = 2;
 HEAP8[$0 + 58 | 0] = 0;
 HEAP8[$0 + 59 | 0] = 0;
}

function jswrap_object_prependListener($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jswrap_object_on_X(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 1);
 __stack_pointer = $3 + 16 | 0;
}

function jswrap_array_unshift($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsvUnLock(jswrap_array_splice_i(HEAP32[$2 + 12 >> 2], 0, 0, HEAP32[$2 + 8 >> 2]));
 $0 = jsvGetLength(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function _jswrap_graphics_stringWidth($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = $0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 20 >> 2] = $2;
 _jswrap_graphics_stringMetrics(HEAP32[$3 + 28 >> 2], HEAP32[$3 + 24 >> 2], HEAP32[$3 + 20 >> 2], $3);
 __stack_pointer = $3 + 32 | 0;
 return HEAP32[$3 >> 2];
}

function jsvStringIteratorGetChar_6($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
 }
 return HEAP8[$1 + 15 | 0];
}

function jsvStringIteratorGetChar_5($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
 }
 return HEAP8[$1 + 15 | 0];
}

function jsvStringIteratorGetChar_4($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
 }
 return HEAP8[$1 + 15 | 0];
}

function jsvStringIteratorGetChar_3($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
 }
 return HEAP8[$1 + 15 | 0];
}

function jsvStringIteratorGetChar_2($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
 }
 return HEAP8[$1 + 15 | 0];
}

function jsvStringIteratorGetChar_1($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
 }
 return HEAP8[$1 + 15 | 0];
}

function tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite__BuiltinDataAllocator___BuiltinDataAllocator_28_29($0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jsvIsStringEqualOrStartsWith($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jsvIsStringEqualOrStartsWithOffset(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1, 0, 0);
 __stack_pointer = $3 + 16 | 0;
 return $0 & 1;
}

function AccelFilter_init($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 while (1) {
  if (HEAP32[$1 + 8 >> 2] < 7) {
   HEAP8[HEAP32[$1 + 12 >> 2] + HEAP32[$1 + 8 >> 2] | 0] = 0;
   HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] + 1;
   continue;
  }
  break;
 }
 HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] = 0;
}

function mbedtls_cipher_get_block_size($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(HEAP32[HEAP32[$1 + 8 >> 2] >> 2] ? HEAP32[$1 + 8 >> 2] : 0)) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = HEAP32[HEAP32[HEAP32[$1 + 8 >> 2] >> 2] + 24 >> 2];
 }
 return HEAP32[$1 + 12 >> 2];
}

function lcdMemLCD_waitForSendComplete() {
 var $0 = 0, $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = 1e6;
 while (1) {
  $0 = 0;
  if (HEAP8[390952] & 1) {
   $0 = HEAP32[$1 + 12 >> 2] - 1 | 0;
   HEAP32[$1 + 12 >> 2] = $0;
   $0 = ($0 | 0) != 0;
  }
  if ($0) {
   continue;
  }
  break;
 }
 if (HEAP8[390952] & 1) {
  HEAP8[390952] = 0;
 }
}

function jsvStringIteratorGetChar($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = HEAPU8[HEAP32[HEAP32[$1 + 8 >> 2] + 16 >> 2] + HEAP32[HEAP32[$1 + 8 >> 2] >> 2] | 0];
 }
 return HEAP8[$1 + 15 | 0];
}

function tflite__OperatorCode__builtin_code_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const(HEAP32[$1 + 12 >> 2], 4, 0) << 24;
 __stack_pointer = $1 + 16 | 0;
 return $0 >> 24;
}

function std____2____compressed_pair_elem_TfLitePoolParams__2c_200_2c_20false_____compressed_pair_elem_TfLitePoolParams___2c_20void__28TfLitePoolParams___29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
 return $0;
}

function std____2____compressed_pair_elem_TfLiteConvParams__2c_200_2c_20false_____compressed_pair_elem_TfLiteConvParams___2c_20void__28TfLiteConvParams___29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
 return $0;
}

function jswrap_object_clone($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvCopy(HEAP32[$1 + 8 >> 2], 1);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function __cos($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = $0 * $0;
 $3 = $2 * .5;
 $4 = 1 - $3;
 $5 = 1 - $4 - $3;
 $3 = $2 * $2;
 return $4 + ($5 + ($2 * ($2 * ($2 * ($2 * 2480158728947673e-20 + -.001388888888887411) + .0416666666666666) + $3 * $3 * ($2 * ($2 * -11359647557788195e-27 + 2.087572321298175e-9) + -2.7557314351390663e-7)) - $0 * $1));
}

function tflite__SubGraph__outputs_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 8);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__Operator__outputs_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 8);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function graphicsFallbackGetPixel($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 $0 = HEAP32[$3 + 12 >> 2];
 return HEAPU8[$0 + 21 | 0] | HEAPU8[$0 + 22 | 0] << 8 | (HEAPU8[$0 + 23 | 0] << 16 | HEAPU8[$0 + 24 | 0] << 24);
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode____size_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__EndianScalar_unsigned_20int__28unsigned_20int_29(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function unsigned_20char_20flatbuffers__ReadScalar_unsigned_20char__28void_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20char_20flatbuffers__EndianScalar_unsigned_20char__28unsigned_20char_29(HEAPU8[HEAP32[$1 + 12 >> 2]]);
 __stack_pointer = $1 + 16 | 0;
 return $0 & 255;
}

function tflite__SubGraph__inputs_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 6);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__Operator__inputs_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 6);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__OperatorCode__custom_code_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__String_20const__20flatbuffers__Table__GetPointer_flatbuffers__String_20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 6);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__AlignPointerDown_28unsigned_20char__2c_20unsigned_20long_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 12 >> 2];
 HEAP32[$2 >> 2] = Math_imul(HEAP32[$2 + 8 >> 2], HEAPU32[$2 + 4 >> 2] / HEAPU32[$2 + 8 >> 2] | 0);
 return HEAP32[$2 >> 2];
}

function jsvMathsOpError($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 60 >> 2] = $0;
 HEAP32[$2 + 56 >> 2] = $1;
 jslTokenAsString(HEAP32[$2 + 60 >> 2], $2 + 16 | 0, 32);
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 56 >> 2];
 HEAP32[$2 >> 2] = $2 + 16;
 jsError(132169, $2);
 __stack_pointer = $2 - -64 | 0;
 return 0;
}

function jsiTimerAdd($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvLock(HEAPU16[182204]);
 HEAP32[$1 + 4 >> 2] = jsvArrayAddToEnd(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2], 1) - 1;
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 4 >> 2];
}

function graphicsGetMemoryRequired($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 $2 = HEAP32[$1 + 12 >> 2];
 return Math_imul(HEAPU8[HEAP32[$1 + 12 >> 2] + 16 | 0], Math_imul(HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8, HEAPU8[$2 + 14 | 0] | HEAPU8[$2 + 15 | 0] << 8)) + 7 >>> 3 | 0;
}

function tflite__Pool2DOptions__padding_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const(HEAP32[$1 + 12 >> 2], 4, 0) << 24;
 __stack_pointer = $1 + 16 | 0;
 return $0 >> 24;
}

function tflite__Conv2DOptions__padding_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const(HEAP32[$1 + 12 >> 2], 4, 0) << 24;
 __stack_pointer = $1 + 16 | 0;
 return $0 >> 24;
}

function std____2____less_unsigned_20char_2c_20unsigned_20char___operator_28_29_28unsigned_20char_20const__2c_20unsigned_20char_20const__29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 return HEAPU8[HEAP32[$3 + 8 >> 2]] < HEAPU8[HEAP32[$3 + 4 >> 2]];
}

function jswrap_banglejs_getLCDMode() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = 0;
 label$1: {
  if (!HEAP32[$0 + 8 >> 2]) {
   HEAP32[$0 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = jsvNewFromString(HEAP32[$0 + 8 >> 2]);
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function jsiLoop() {
 jshIdle();
 jsiIdle();
 jsiCheckErrors();
 if (!(!(HEAP32[91094] & 6144) | HEAPU8[364428] <= 4 & HEAPU8[364428] >= 2)) {
  HEAP32[91094] = HEAP32[91094] & -6145;
  label$3: {
   if (!(jsvIsEmptyString(HEAP32[91104]) & 1)) {
    break label$3;
   }
  }
  jsiClearInputLine(1);
 }
 jsiConsoleReturnInputLine();
 return !HEAPU8[364430];
}

function tflite__Tensor__shape_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int__20const__20flatbuffers__Table__GetPointer_flatbuffers__Vector_int__20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 4);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function setCorrectTimeZone($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2] = 0;
 $0 = jsdGetEffectiveTimeZone(fromTimeInDay(HEAP32[$1 + 12 >> 2]), 1, HEAP32[$1 + 12 >> 2] + 24 | 0);
 HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2] = $0;
 __stack_pointer = $1 + 16 | 0;
}

function jspCheckStackPosition() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 label$1: {
  if (jsuGetFreeStack() >>> 0 < 512) {
   jsExceptionHere(1, 116540, 0);
   jspSetInterrupted(1);
   HEAP8[$0 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$0 + 15 | 0] = 1;
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP8[$0 + 15 | 0] & 1;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph____size_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__EndianScalar_unsigned_20int__28unsigned_20int_29(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Operator____size_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__EndianScalar_unsigned_20int__28unsigned_20int_29(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Metadata____size_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__EndianScalar_unsigned_20int__28unsigned_20int_29(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__AlignSizeUp_28unsigned_20long_2c_20unsigned_20long_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = Math_imul(HEAP32[$2 + 8 >> 2], (HEAP32[$2 + 12 >> 2] + (HEAP32[$2 + 8 >> 2] - 1 | 0) >>> 0) / HEAPU32[$2 + 8 >> 2] | 0);
 return HEAP32[$2 + 4 >> 2];
}

function jsiGetPreferredConsoleDevice() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP8[$0 + 15 | 0] = 21;
 if (!(jshIsDeviceInitialised(HEAPU8[$0 + 15 | 0]) & 1)) {
  HEAP8[$0 + 15 | 0] = 20;
 }
 if (jshIsUSBSERIALConnected() & 1) {
  HEAP8[$0 + 15 | 0] = 21;
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAPU8[$0 + 15 | 0];
}

function signed_20char_20flatbuffers__ReadScalar_signed_20char__28void_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__EndianScalar_signed_20char__28signed_20char_29(HEAP8[HEAP32[$1 + 12 >> 2]]) << 24;
 __stack_pointer = $1 + 16 | 0;
 return $0 >> 24;
}

function jswrap_espruino_setPassword($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  HEAP32[$1 + 12 >> 2] = jsvAsString(HEAP32[$1 + 12 >> 2]);
 }
 jsvUnLock(jsvObjectSetChild(HEAP32[91087], 132894, HEAP32[$1 + 12 >> 2]));
 __stack_pointer = $1 + 16 | 0;
}

function gemmlowp__AddSaturatingIf16BitImpl_int_2c_20false___Run_28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = int_20gemmlowp__Add_int__28int_2c_20int_29(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor____size_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__EndianScalar_unsigned_20int__28unsigned_20int_29(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function unsigned_20int_20flatbuffers__ReadScalar_unsigned_20int__28void_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__EndianScalar_unsigned_20int__28unsigned_20int_29(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__SoftmaxOptions__beta_28_29_20const($0) {
 var $1 = 0, $2 = Math_fround(0);
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = float_20flatbuffers__Table__GetField_float__28unsigned_20short_2c_20float_29_20const(HEAP32[$1 + 12 >> 2], 4, Math_fround(0));
 __stack_pointer = $1 + 16 | 0;
 return $2;
}

function jswrap_object_on($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jswrap_object_on_X(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
 __stack_pointer = $3 + 16 | 0;
}

function _jswrap_serial_inject_cb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP8[$2 + 7 | 0] = HEAPU8[HEAP32[$2 + 8 >> 2]];
 jshPushIOCharEvent(HEAPU8[$2 + 7 | 0], HEAP32[$2 + 12 >> 2] << 24 >> 24);
 __stack_pointer = $2 + 16 | 0;
}

function _jswrap_drawImageLayerNextX($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 180 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 164 >> 2] + HEAP32[$0 + 180 >> 2];
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 184 >> 2] = HEAP32[$0 + 184 >> 2] - HEAP32[HEAP32[$1 + 12 >> 2] + 168 >> 2];
}

function jsvObjectSetChildAndUnLock($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jsvObjectSetChild(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 jsvUnLock(HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
}

function int_20gemmlowp__MaskIfZero_int_2c_205__28gemmlowp__FixedPoint_int_2c_205__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = $0;
 $0 = int_20gemmlowp__MaskIfZero_int__28int_29(HEAP32[gemmlowp__FixedPoint_int_2c_205___raw_28_29($1 + 8 | 0) >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__Operator__opcode_index_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const(HEAP32[$1 + 12 >> 2], 4, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsvAddNamedChildAndUnLock($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jsvUnLock2(jsvAddNamedChild(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]), HEAP32[$3 + 8 >> 2]);
 __stack_pointer = $3 + 16 | 0;
}

function tflite__Tensor__type_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = signed_20char_20flatbuffers__Table__GetField_signed_20char__28unsigned_20short_2c_20signed_20char_29_20const(HEAP32[$1 + 12 >> 2], 6, 0) << 24;
 __stack_pointer = $1 + 16 | 0;
 return $0 >> 24;
}

function tflite__Metadata__name_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__String_20const__20flatbuffers__Table__GetPointer_flatbuffers__String_20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 4);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function std____2____less_signed_20char_2c_20signed_20char___operator_28_29_28signed_20char_20const__2c_20signed_20char_20const__29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 return HEAP8[HEAP32[$3 + 8 >> 2]] < HEAP8[HEAP32[$3 + 4 >> 2]];
}

function gen_jswrap_Math_randInt($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (HEAP32[$1 + 12 >> 2] > 0) {
   $0 = (rand() | 0) % HEAP32[$1 + 12 >> 2] | 0;
   break label$1;
  }
  $0 = rand() ^ rand() << 1;
 }
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function tflite__MicroInterpreter__outputs_size_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int___Length_28_29_20const(tflite__SubGraph__outputs_28_29_20const(HEAP32[HEAP32[$1 + 12 >> 2] + 116 >> 2]));
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function push_byte($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $1 = HEAPU8[$3 + 7 | 0];
 $0 = HEAP32[HEAP32[$3 + 8 >> 2] >> 2];
 $3 = HEAP32[HEAP32[$3 + 8 >> 2] + 8 >> 2];
 $2 = HEAP32[$3 >> 2];
 HEAP32[$3 >> 2] = $2 + 1;
 HEAP8[$2 + $0 | 0] = $1;
}

function jsGfxGetPtr($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(HEAP32[$1 + 8 >> 2] < 176 & HEAP32[$1 + 8 >> 2] >= 0)) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = Math_imul(HEAP32[$1 + 8 >> 2], 68) + 366882;
 }
 return HEAP32[$1 + 12 >> 2];
}

function heatshrink_var_output_cb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 jsvStringIteratorSetCharAndNext(HEAP32[$2 + 4 >> 2], HEAP8[$2 + 15 | 0]);
 __stack_pointer = $2 + 16 | 0;
}

function tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29_1($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 FUNCTION_TABLE[668]($0) | 0;
 tflite__SimpleMemoryAllocator__operator_20delete_28void__29($0);
 __stack_pointer = $1 + 16 | 0;
}

function tflite__MicroInterpreter__inputs_size_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int___Length_28_29_20const(tflite__SubGraph__inputs_28_29_20const(HEAP32[HEAP32[$1 + 12 >> 2] + 116 >> 2]));
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jshIsTopEvent($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 14 | 0] = $0;
 label$1: {
  if (HEAPU8[364486] == HEAPU8[364487]) {
   HEAP8[$1 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = HEAPU8[$1 + 14 | 0] == (HEAPU8[Math_imul(HEAPU8[364487], 5) + 365072 | 0] & 31);
 }
 return HEAP8[$1 + 15 | 0] & 1;
}

function tflite__Metadata__buffer_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const(HEAP32[$1 + 12 >> 2], 6, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function lcdMemLCD_extcominBacklight($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 HEAP8[390964] = HEAP8[$1 + 15 | 0] & 1;
 label$1: {
  if (HEAP8[$1 + 15 | 0] & 1) {
   jshPinAnalogOutput(6, 3e-4, 120, 0);
   break label$1;
  }
  jshPinOutput(6, 0);
 }
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_pin_write($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 HEAP8[$2 + 10 | 0] = jshGetPinFromVar(HEAP32[$2 + 12 >> 2]);
 jshPinOutput(HEAPU8[$2 + 10 | 0], HEAP8[$2 + 11 | 0] & 1);
 __stack_pointer = $2 + 16 | 0;
}

function jsvLockSafe($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP16[$1 + 10 >> 1] = $0;
 label$1: {
  if (!HEAPU16[$1 + 10 >> 1]) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = jsvLock(HEAPU16[$1 + 10 >> 1]);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function tflite__Tensor__buffer_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const(HEAP32[$1 + 12 >> 2], 8, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__Model__version_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__Table__GetField_unsigned_20int__28unsigned_20short_2c_20unsigned_20int_29_20const(HEAP32[$1 + 12 >> 2], 4, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsvIterateCallbackCountCb($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 >> 2] = HEAP32[$3 + 4 >> 2];
 $0 = HEAP32[$3 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$3 + 8 >> 2] + HEAP32[$0 >> 2];
}

function jsvArrayBufferIteratorSetByteValue($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 if ((HEAPU8[HEAP32[$2 + 12 >> 2] + 36 | 0] & 15) == 1) {
  jsvStringIteratorSetChar(HEAP32[$2 + 12 >> 2], HEAP8[$2 + 11 | 0]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function heatshrink_ptr_output_cb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
 $0 = HEAPU8[$2 + 15 | 0];
 $2 = HEAP32[$2 + 4 >> 2];
 $1 = HEAP32[$2 >> 2];
 HEAP32[$2 >> 2] = $1 + 1;
 HEAP8[$1 | 0] = $0;
}

function jsvRef($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if ((jsvGetRefs(HEAP32[$1 + 12 >> 2]) & 65535) >>> 0 < 255) {
  jsvSetRefs(HEAP32[$1 + 12 >> 2], (jsvGetRefs(HEAP32[$1 + 12 >> 2]) & 65535) + 1 & 65535);
 }
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvArrayPushAndUnLock($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 4 >> 2] = jsvArrayPush(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 jsvUnLock(HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return HEAP32[$2 + 4 >> 2];
}

function jstGetLastBufferTimerTask($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP16[$2 + 6 >> 1] = jsvGetRef(HEAP32[$2 + 12 >> 2]);
 $0 = utilTimerGetLastTask(568, $2 + 6 | 0, HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 & 1;
}

function jshGetDeviceToTransmit() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 label$1: {
  if (!(jshHasTransmitData() & 1)) {
   HEAP8[$0 + 15 | 0] = 0;
   break label$1;
  }
  HEAP8[$0 + 15 | 0] = HEAPU8[(HEAPU8[364485] << 1) + 364560 | 0] & 31;
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAPU8[$0 + 15 | 0];
}

function int_20gemmlowp__SaturatingRoundingMultiplyByPOT__12_2c_20int__28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = gemmlowp__ImplSaturatingRoundingMultiplyByPOT__12_2c_20int_2c_20_1___eval_28int_29(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function int_20gemmlowp__MaskIfGreaterThan_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(HEAP32[$2 + 12 >> 2] > HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function __lseek($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = __wasi_syscall_ret(legalfunc$__wasi_fd_seek($0, $1, $2, $3 & 255, $4 + 8 | 0));
 __stack_pointer = $4 + 16 | 0;
 $2 = HEAP32[$4 + 12 >> 2];
 i64toi32_i32$HIGH_BITS = $3 ? -1 : $2;
 $1 = HEAP32[$4 + 8 >> 2];
 return $3 ? -1 : $1;
}

function tflite__GreedyMemoryPlanner___GreedyMemoryPlanner_28_29_1($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 FUNCTION_TABLE[727]($0) | 0;
 tflite__GreedyMemoryPlanner__operator_20delete_28void__29($0);
 __stack_pointer = $1 + 16 | 0;
}

function jsError($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 jsiConsoleRemoveInputLine();
 jsiConsolePrintString(146256);
 HEAP32[$2 + 8 >> 2] = $1;
 vcbprintf(7, 0, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 jsiConsolePrintString(148266);
 __stack_pointer = $2 + 16 | 0;
}

function tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter__BuiltinDataDeleter_28tflite__BuiltinDataAllocator__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$2 + 8 >> 2];
 return $0;
}

function tflite__QuantizationParameters__quantized_dimension_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const(HEAP32[$1 + 12 >> 2], 16, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsWarn($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 jsiConsoleRemoveInputLine();
 jsiConsolePrintString(146264);
 HEAP32[$2 + 8 >> 2] = $1;
 vcbprintf(7, 0, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 jsiConsolePrintString(148266);
 __stack_pointer = $2 + 16 | 0;
}

function int_20gemmlowp__SaturatingRoundingMultiplyByPOT__2_2c_20int__28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = gemmlowp__ImplSaturatingRoundingMultiplyByPOT__2_2c_20int_2c_20_1___eval_28int_29(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function int_20gemmlowp__SaturatingRoundingMultiplyByPOT__1_2c_20int__28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = gemmlowp__ImplSaturatingRoundingMultiplyByPOT__1_2c_20int_2c_20_1___eval_28int_29(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__Model_20const__20flatbuffers__GetRoot_tflite__Model__28void_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = tflite__Model__20flatbuffers__GetMutableRoot_tflite__Model__28void__29(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_onewire_skip($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = onewire_getpin(HEAP32[$1 + 12 >> 2]);
 if (jshIsPinValid(HEAPU8[$1 + 11 | 0]) & 1) {
  OneWireWrite(HEAPU8[$1 + 11 | 0], 8, 204, 0);
 }
 __stack_pointer = $1 + 16 | 0;
}

function jsserialHardwareFunc($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP8[$2 + 7 | 0] = HEAPU8[HEAP32[$2 + 8 >> 2]];
 jshTransmit(HEAPU8[$2 + 7 | 0], HEAP32[$2 + 12 >> 2] & 255);
 __stack_pointer = $2 + 16 | 0;
}

function jshFlashGetMemMapAddress($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!(HEAPU32[$1 + 8 >> 2] < 134217728 | HEAPU32[$1 + 8 >> 2] >= 142606336)) {
   HEAP32[$1 + 12 >> 2] = 0;
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 8 >> 2];
 }
 return HEAP32[$1 + 12 >> 2];
}

function int_20gemmlowp__MaskIfLessThan_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29(HEAP32[$2 + 12 >> 2] < HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function tflite__DepthwiseConv2DOptions__dilation_w_factor_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const(HEAP32[$1 + 12 >> 2], 14, 1);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__DepthwiseConv2DOptions__dilation_h_factor_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const(HEAP32[$1 + 12 >> 2], 16, 1);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_array_find($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = _jswrap_array_iterate_with_callback(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0, 2, 1, 1);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function jsvUnLock3($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jsvUnLockInline(HEAP32[$3 + 12 >> 2]);
 jsvUnLockInline(HEAP32[$3 + 8 >> 2]);
 jsvUnLockInline(HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
}

function gen_jswrap_Graphics_setFontVector($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jswrap_graphics_setFontSizeX(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function cbprintf($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
 vcbprintf(HEAP32[$4 + 12 >> 2], HEAP32[$4 + 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 >> 2]);
 __stack_pointer = $4 + 16 | 0;
}

function tflite__DepthwiseConv2DOptions__depth_multiplier_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const(HEAP32[$1 + 12 >> 2], 10, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function int_20gemmlowp__SaturatingRoundingMultiplyByPOT_5_2c_20int__28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = gemmlowp__ImplSaturatingRoundingMultiplyByPOT_5_2c_20int_2c_201___eval_28int_29(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function int_20gemmlowp__SaturatingRoundingMultiplyByPOT_2_2c_20int__28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = gemmlowp__ImplSaturatingRoundingMultiplyByPOT_2_2c_20int_2c_201___eval_28int_29(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function int_20gemmlowp__SaturatingRoundingMultiplyByPOT_1_2c_20int__28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = gemmlowp__ImplSaturatingRoundingMultiplyByPOT_1_2c_20int_2c_201___eval_28int_29(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_unsigned_20char___size_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__EndianScalar_unsigned_20int__28unsigned_20int_29(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function std____2____less_double_2c_20double___operator_28_29_28double_20const__2c_20double_20const__29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 return HEAPF64[HEAP32[$3 + 8 >> 2] >> 3] < HEAPF64[HEAP32[$3 + 4 >> 2] >> 3];
}

function gemmlowp__ImplSaturatingRoundingMultiplyByPOT__12_2c_20int_2c_20_1___eval_28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(HEAP32[$1 + 12 >> 2], 12);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function gen_jswrap_Graphics_fillPolyAA($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jswrap_graphics_fillPoly_X(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function float_20flatbuffers__ReadScalar_float__28void_20const__29($0) {
 var $1 = 0, $2 = Math_fround(0);
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = float_20flatbuffers__EndianScalar_float__28float_29(HEAPF32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $2;
}

function flatbuffers__Vector_long_20long___size_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__EndianScalar_unsigned_20int__28unsigned_20int_29(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__Operator__builtin_options_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = void_20const__20flatbuffers__Table__GetPointer_void_20const___28unsigned_20short_29_20const(HEAP32[$1 + 12 >> 2], 12);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function std____2____less_float_2c_20float___operator_28_29_28float_20const__2c_20float_20const__29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 return HEAPF32[HEAP32[$3 + 8 >> 2] >> 2] < HEAPF32[HEAP32[$3 + 4 >> 2] >> 2];
}

function jspeBlockEnd($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[91090]) {
  jspeiRemoveScope();
  jsvUnLock(HEAP32[91090]);
  HEAP32[91090] = 0;
 }
 HEAP32[91090] = HEAP32[$1 + 12 >> 2];
 HEAP8[364364] = HEAPU8[364364] - 1;
 __stack_pointer = $1 + 16 | 0;
}

function gemmlowp__ImplSaturatingRoundingMultiplyByPOT__2_2c_20int_2c_20_1___eval_28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(HEAP32[$1 + 12 >> 2], 2);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function gemmlowp__ImplSaturatingRoundingMultiplyByPOT__1_2c_20int_2c_20_1___eval_28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20gemmlowp__RoundingDivideByPOT_int__28int_2c_20int_29(HEAP32[$1 + 12 >> 2], 1);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function memmove($0, $1, $2) {
 var $3 = 0;
 if ($0 >>> 0 < $1 >>> 0) {
  return __memcpy($0, $1, $2);
 }
 if ($2) {
  $3 = $0 + $2 | 0;
  $1 = $1 + $2 | 0;
  while (1) {
   $3 = $3 - 1 | 0;
   $1 = $1 - 1 | 0;
   HEAP8[$3 | 0] = HEAPU8[$1 | 0];
   $2 = $2 - 1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
 return $0;
}

function jsvStringIteratorGetCharAndNext($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jsvStringIteratorGetChar_2(HEAP32[$1 + 12 >> 2]);
 jsvStringIteratorNextInline(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 11 | 0];
}

function gen_jswrap_Graphics_fillPoly($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jswrap_graphics_fillPoly_X(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function gemmlowp__FixedPoint_int_2c_2012___FromRaw_28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 4 >> 2] = $0;
 $0 = HEAP32[$1 + 4 >> 2];
 HEAP32[gemmlowp__FixedPoint_int_2c_2012___raw_28_29($1 + 8 | 0) >> 2] = $0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jsvGetIndexOf($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 $0 = jsvGetIndexOfFull(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP8[$3 + 7 | 0] & 1, 0, 0);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function jsSendPinWatchEvent($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jshGetEventFlagsForPin(HEAP32[$1 + 12 >> 2] & 255);
 if (HEAPU8[$1 + 11 | 0]) {
  jshPushIOWatchEvent(HEAPU8[$1 + 11 | 0]);
 }
 __stack_pointer = $1 + 16 | 0;
}

function getCalendarDateFromDateVar($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = $1;
 HEAP8[$3 + 43 | 0] = $2;
 getTimeFromDateVar($3 + 8 | 0, HEAP32[$3 + 44 >> 2], HEAP8[$3 + 43 | 0] & 1);
 getCalendarDate($0, HEAP32[$3 + 8 >> 2]);
 __stack_pointer = $3 + 48 | 0;
}

function tflite__Conv2DOptions__dilation_w_factor_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const(HEAP32[$1 + 12 >> 2], 12, 1);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__Conv2DOptions__dilation_h_factor_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const(HEAP32[$1 + 12 >> 2], 14, 1);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_trace($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (jsvIsUndefined(HEAP32[$1 + 12 >> 2]) & 1) {
   jsvTrace(HEAP32[91086], 0);
   break label$1;
  }
  jsvTrace(HEAP32[$1 + 12 >> 2], 0);
 }
 __stack_pointer = $1 + 16 | 0;
}

function int_20gemmlowp__MaskIfNonZero_int__28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (HEAP32[$1 + 12 >> 2]) {
   $0 = int_20gemmlowp__BitNot_int__28int_29(0);
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function gemmlowp__FixedPoint_int_2c_205___FromRaw_28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 4 >> 2] = $0;
 $0 = HEAP32[$1 + 4 >> 2];
 HEAP32[gemmlowp__FixedPoint_int_2c_205___raw_28_29($1 + 8 | 0) >> 2] = $0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function gemmlowp__FixedPoint_int_2c_202___FromRaw_28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 4 >> 2] = $0;
 $0 = HEAP32[$1 + 4 >> 2];
 HEAP32[gemmlowp__FixedPoint_int_2c_202___raw_28_29($1 + 8 | 0) >> 2] = $0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function gemmlowp__FixedPoint_int_2c_200___FromRaw_28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 4 >> 2] = $0;
 $0 = HEAP32[$1 + 4 >> 2];
 HEAP32[gemmlowp__FixedPoint_int_2c_200___raw_28_29($1 + 8 | 0) >> 2] = $0;
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function gemmlowp__FixedPoint_int_2c_200__20gemmlowp__FixedPoint_int_2c_200___ConstantPOT__3__28_29() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromScalarRaw_28int_29(268435456);
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 8 >> 2];
}

function tflite__ops__micro__Register_RESHAPE_28_29($0) {
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 723;
 HEAP32[$0 + 12 >> 2] = 724;
}

function tflite__DepthwiseConv2DOptions__stride_w_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const(HEAP32[$1 + 12 >> 2], 6, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__DepthwiseConv2DOptions__stride_h_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const(HEAP32[$1 + 12 >> 2], 8, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_espruino_lockConsole() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = jsvObjectGetChildIfExists(HEAP32[91087], 132894);
 if (HEAP32[$0 + 12 >> 2]) {
  HEAP16[182206] = HEAPU16[182206] | 1024;
 }
 jsvUnLock(HEAP32[$0 + 12 >> 2]);
 __stack_pointer = $0 + 16 | 0;
}

function gemmlowp__FixedPoint_int_2c_205__20gemmlowp__FixedPoint_int_2c_205___ConstantPOT__2__28_29() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_205___FromScalarRaw_28int_29(16777216);
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 8 >> 2];
}

function jshGetSystemTime() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = 196161;
 $1 = HEAP32[$0 + 12 >> 2];
 HEAP8[$0 + 11 | 0] = 0;
 $1 = jshGetTimeFromMilliseconds(+emscripten_asm_const_double($1 | 0, $0 + 11 | 0, 0));
 __stack_pointer = $0 + 16 | 0;
 return $1;
}

function gemmlowp__FixedPoint_int_2c_200___One_28_29() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_200___FromScalarRaw_28int_29(gemmlowp__FixedPoint_int_2c_200___ScalarRawMax_28_29());
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 8 >> 2];
}

function flatbuffers__Vector_float___size_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__EndianScalar_unsigned_20int__28unsigned_20int_29(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__SafeBuiltinDataAllocator_28tflite__BuiltinDataAllocator__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$2 + 8 >> 2];
 return $0;
}

function tflite__MicroAllocator___MicroAllocator_28_29_1($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 FUNCTION_TABLE[681]($0) | 0;
 tflite__MicroAllocator__operator_20delete_28void__29($0);
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_serial_flush($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jsiGetDeviceFromClass(HEAP32[$1 + 12 >> 2]);
 if (HEAPU8[$1 + 11 | 0]) {
  jshTransmitFlushDevice(HEAPU8[$1 + 11 | 0]);
 }
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorSetValue($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 if (HEAP32[HEAP32[$2 + 12 >> 2] >> 2]) {
  jsvSetValueOfName(HEAP32[HEAP32[$2 + 12 >> 2] >> 2], HEAP32[$2 + 8 >> 2]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function jsvObjectIteratorClone($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[HEAP32[$2 + 12 >> 2] >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
 jsvLockAgainSafe(HEAP32[HEAP32[$2 + 12 >> 2] >> 2]);
 __stack_pointer = $2 + 16 | 0;
}

function integerDivideFloor($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 if (HEAP32[$2 + 12 >> 2] < 0) {
  $0 = (HEAP32[$2 + 12 >> 2] - HEAP32[$2 + 8 >> 2] | 0) + 1 | 0;
 } else {
  $0 = HEAP32[$2 + 12 >> 2];
 }
 return ($0 | 0) / HEAP32[$2 + 8 >> 2] | 0;
}

function _jswrap_espruino_toString_char($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsvStringIteratorSetCharAndNext(HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2] << 24 >> 24);
 __stack_pointer = $2 + 16 | 0;
}

function tflite__Pool2DOptions__filter_height_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const(HEAP32[$1 + 12 >> 2], 12, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__MicroMutableOpResolver_9u____MicroMutableOpResolver_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite__MicroOpResolver___MicroOpResolver_28_29($0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function flatbuffers__Vector_int___size_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = unsigned_20int_20flatbuffers__EndianScalar_unsigned_20int__28unsigned_20int_29(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__Pool2DOptions__filter_width_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const(HEAP32[$1 + 12 >> 2], 10, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function _jswrap_graphics_freeFontInfo($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[HEAP32[$1 + 12 >> 2] >> 2] & 32768) {
  jsvUnLock2(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2], HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorGotoUTF8($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jsvStringIteratorGoto(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
}

function tflite__EspruinoErrorReporter__EspruinoErrorReporter_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite__ErrorReporter__ErrorReporter_28_29($0);
 HEAP32[$0 >> 2] = 190032;
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function std____2____less_int_2c_20int___operator_28_29_28int_20const__2c_20int_20const__29_20const($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 return HEAP32[HEAP32[$3 + 8 >> 2] >> 2] < HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
}

function jshIsEventForPin($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 $0 = HEAPU8[HEAP32[$2 + 12 >> 2]] & 31;
 $1 = jshGetEventFlagsForPin(HEAPU8[$2 + 11 | 0]) & 255;
 __stack_pointer = $2 + 16 | 0;
 return ($0 | 0) == ($1 | 0);
}

function _jswrap_prombox_queueresolve($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 _jswrap_prombox_queueresolve_or_reject(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_graphics_setFontPBF($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jsExceptionHere(1, 133284, 0);
 __stack_pointer = $3 + 16 | 0;
 return 0;
}

function jsvStringIteratorNewUTF8($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jsvStringIteratorNew(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
}

function jspeiRemoveScope() {
 label$1: {
  if (!HEAP32[91088]) {
   break label$1;
  }
  if (!jsvGetArrayLength(HEAP32[91088])) {
   break label$1;
  }
  jsvUnLock(jsvArrayPop(HEAP32[91088]));
  if (jsvGetFirstChild(HEAP32[91088]) & 65535) {
   break label$1;
  }
  jsvUnLock(HEAP32[91088]);
  HEAP32[91088] = 0;
 }
}

function jsfResetStorage() {
 jsiConsolePrintf(147899, 0);
 jsfEraseAll();
 jsiConsolePrintf(147738, 0);
 label$1: {
  if (HEAP32[256] < 8388608) {
   jsiConsolePrintf(146309, 0);
   jsfResetStorage_progress(1040, 134217728, HEAP32[256]);
   jsiConsolePrintf(147720, 0);
   break label$1;
  }
  jsWarn(148197, 0);
 }
}

function btn1Handler($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 if (!(HEAP32[97749] & 4194304)) {
  btnHandlerCommon(1, HEAP8[$2 + 15 | 0] & 1, HEAPU8[$2 + 14 | 0]);
 }
 __stack_pointer = $2 + 16 | 0;
}

function _jswrap_prombox_queuereject($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 _jswrap_prombox_queueresolve_or_reject(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_espruino_reverseByte($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2] & 255;
 return Math_imul(Math_imul(HEAP32[$1 + 8 >> 2], 2050) & 139536 | Math_imul(HEAP32[$1 + 8 >> 2], 32800) & 558144, 65793) >>> 16 & 255;
}

function jsfSetFlag($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 label$1: {
  if (HEAP8[$2 + 14 | 0] & 1) {
   HEAP8[196320] = HEAPU8[$2 + 15 | 0] | HEAPU8[196320];
   break label$1;
  }
  HEAP8[196320] = HEAPU8[196320] & (HEAPU8[$2 + 15 | 0] ^ -1);
 }
}

function gen_jswrap_E_showScroller($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2];
 $0 = jspExecuteJSFunctionCode(135109, 130215, 1288, 0, 1, $1 + 8 | 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function tflite__Pool2DOptions__stride_w_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const(HEAP32[$1 + 12 >> 2], 6, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__Pool2DOptions__stride_h_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const(HEAP32[$1 + 12 >> 2], 8, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__Conv2DOptions__stride_w_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const(HEAP32[$1 + 12 >> 2], 6, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__Conv2DOptions__stride_h_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const(HEAP32[$1 + 12 >> 2], 8, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_date_from_milliseconds($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 HEAP32[$1 + 4 >> 2] = jspNewObject(0, 132066);
 jswrap_date_setTime(HEAP32[$1 + 4 >> 2], HEAPF64[$1 + 8 >> 3]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 4 >> 2];
}

function jsvObjectGetFloatChild($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $3 = jsvGetFloatAndUnLock(jsvObjectGetChildIfExists(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]));
 __stack_pointer = $2 + 16 | 0;
 return $3;
}

function tflite__OperatorCode__version_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__Table__GetField_int__28unsigned_20short_2c_20int_29_20const(HEAP32[$1 + 12 >> 2], 8, 1);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_modules_removeAllCached() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = jswrap_modules_getModuleList();
 if (HEAP32[$0 + 12 >> 2]) {
  jsvRemoveAllChildren(HEAP32[$0 + 12 >> 2]);
  jsvUnLock(HEAP32[$0 + 12 >> 2]);
 }
 __stack_pointer = $0 + 16 | 0;
}

function jswrap_math_sqrt($0) {
 $0 = +$0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 label$1: {
  if (HEAPF64[$1 + 8 >> 3] >= 0) {
   $0 = exp(log(HEAPF64[$1 + 8 >> 3]) * .5);
   break label$1;
  }
  $0 = nan;
 }
 __stack_pointer = $1 + 16 | 0;
 return +$0;
}

function jsiHandleHome() {
 var $0 = 0;
 while (1) {
  $0 = 0;
  if (HEAP32[91106]) {
   $0 = (jsvGetCharInString(HEAP32[91104], HEAP32[91106] - 1 | 0) | 0) != 10;
  }
  if ($0) {
   if (jsiShowInputLine() & 1) {
    jsiConsolePrintChar(8);
   }
   HEAP32[91106] = HEAP32[91106] - 1;
   continue;
  }
  break;
 }
}

function gen_jswrap_Math_tan($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = jswrap_math_sin(HEAPF64[$1 + 8 >> 3]);
 $2 = jswrap_math_sin(HEAPF64[$1 + 8 >> 3] + 1.5707963267948966);
 __stack_pointer = $1 + 16 | 0;
 return +($0 / $2);
}

function jswrap_promise_catch($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jswrap_promise_then(HEAP32[$2 + 12 >> 2], 0, HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_E_showMenu($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2];
 $0 = jspExecuteJSFunctionCode(128023, 163229, 3200, 0, 1, $1 + 8 | 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function tflite__EspruinoErrorReporter___EspruinoErrorReporter_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite__ErrorReporter___ErrorReporter_28_29($0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jsvLockAgainSafe($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (HEAP32[$1 + 12 >> 2]) {
   $0 = jsvLockAgain(HEAP32[$1 + 12 >> 2]);
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function tflite__MicroAllocator__ResetTempAllocations_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
 FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 20 >> 2]]($0);
 __stack_pointer = $1 + 16 | 0;
}

function gen_jswrap_ArrayBufferView_byteLength($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return Math_imul(HEAPU8[HEAP32[$1 + 12 >> 2] + 5 | 0] & 15, HEAPU8[$0 + 4 | 0] << 16 | (HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8)) | 0;
}

function flatbuffers__Table__GetVTable_28_29_20const($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 $2 = int_20flatbuffers__ReadScalar_int__28void_20const__29($0);
 __stack_pointer = $1 + 16 | 0;
 return $0 - $2 | 0;
}

function jswrap_pin_mode($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jswrap_io_pinMode(jshGetPinFromVar(HEAP32[$2 + 12 >> 2]) & 255, HEAP32[$2 + 8 >> 2], 0);
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_banglejs_setTheme() {
 HEAP8[366785] = 0;
 HEAP8[366786] = 0;
 HEAP8[366787] = 255;
 HEAP8[366788] = 255;
 HEAP8[366789] = 0;
 HEAP8[366790] = 0;
 HEAP8[366791] = 255;
 HEAP8[366792] = 191;
 HEAP8[366793] = 0;
 HEAP8[366794] = 0;
 HEAP8[366795] = 255;
 HEAP8[366796] = 7;
 HEAP8[366797] = 0;
}

function _jswrap_prombox_resolve($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 _jswrap_prombox_resolve_or_reject(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
 __stack_pointer = $2 + 16 | 0;
}

function tflite__GreedyMemoryPlanner___GreedyMemoryPlanner_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite__MemoryPlanner___MemoryPlanner_28_29($0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jslTokenAppendChar($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 if (HEAPU8[HEAP32[49079] + 80 | 0] < 63) {
  $2 = HEAPU8[$1 + 15 | 0];
  $0 = HEAP32[49079];
  $1 = HEAPU8[$0 + 80 | 0];
  HEAP8[$0 + 80 | 0] = $1 + 1;
  HEAP8[($0 + 12 | 0) + $1 | 0] = $2;
 }
}

function _jswrap_prombox_reject($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 _jswrap_prombox_resolve_or_reject(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_graphics_init() {
 HEAP8[366785] = 255;
 HEAP8[366786] = 255;
 HEAP8[366787] = 0;
 HEAP8[366788] = 0;
 HEAP8[366789] = 255;
 HEAP8[366790] = 255;
 HEAP8[366791] = 0;
 HEAP8[366792] = 0;
 HEAP8[366793] = 255;
 HEAP8[366794] = 255;
 HEAP8[366795] = 0;
 HEAP8[366796] = 0;
 HEAP8[366797] = 1;
}

function jsfGetJSON($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 jsfGetJSONWhitespace(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 4 >> 2], 0);
 __stack_pointer = $3 + 16 | 0;
}

function jsvSetInteger($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = HEAP32[$2 + 12 >> 2];
 $1 = HEAP32[$2 + 8 >> 2];
 HEAP8[$0 | 0] = $1;
 HEAP8[$0 + 1 | 0] = $1 >>> 8;
 HEAP8[$0 + 2 | 0] = $1 >>> 16;
 HEAP8[$0 + 3 | 0] = $1 >>> 24;
}

function gen_jswrap_peek32($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jswrap_io_peek(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 4);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_peek16($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jswrap_io_peek(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 2);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function unsigned_20char_20const__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 12 >> 2]) {
   break label$1;
  }
 }
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
}

function gen_jswrap_peek8($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jswrap_io_peek(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function ftoa_bounded($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAPF64[$3 + 8 >> 3] = $0;
 HEAP32[$3 + 4 >> 2] = $1;
 HEAP32[$3 >> 2] = $2;
 ftoa_bounded_extra(HEAPF64[$3 + 8 >> 3], HEAP32[$3 + 4 >> 2], HEAP32[$3 >> 2], 10, -1);
 __stack_pointer = $3 + 16 | 0;
}

function jsvRefRef($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP16[$1 + 14 >> 1] = $0;
 HEAP32[$1 + 8 >> 2] = jsvLock(HEAPU16[$1 + 14 >> 1]);
 jsvRef(HEAP32[$1 + 8 >> 2]);
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAPU16[$1 + 14 >> 1];
}

function gen_jswrap_Bangle_load($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2];
 jsvUnLock(jspExecuteJSFunctionCode(135863, 144950, 130, 0, 1, $1 + 8 | 0));
 __stack_pointer = $1 + 16 | 0;
}

function tflite__MicroOpResolver__MicroOpResolver_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite__OpResolver__OpResolver_28_29($0);
 HEAP32[$0 >> 2] = 190112;
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function tflite__GetModel_28void_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = tflite__Model_20const__20flatbuffers__GetRoot_tflite__Model__28void_20const__29(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsvGetRef($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 8 >> 2]) {
   HEAP16[$1 + 14 >> 1] = 0;
   break label$1;
  }
  HEAP16[$1 + 14 >> 1] = ((HEAP32[$1 + 8 >> 2] - 196328 | 0) / 14 | 0) + 1;
 }
 return HEAPU16[$1 + 14 >> 1];
}

function signed_20char_20const__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 12 >> 2]) {
   break label$1;
  }
 }
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
}

function jswrap_math_asin($0) {
 $0 = +$0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = jswrap_math_atan(HEAPF64[$1 + 8 >> 3] / jswrap_math_sqrt(-HEAPF64[$1 + 8 >> 3] * HEAPF64[$1 + 8 >> 3] + 1));
 __stack_pointer = $1 + 16 | 0;
 return +$0;
}

function _jswrap_onewire_write_cb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 OneWireWrite(HEAPU8[HEAP32[$2 + 8 >> 2]], 8, HEAP32[$2 + 12 >> 2], 0);
 __stack_pointer = $2 + 16 | 0;
}

function tflite__NumElements_28TfLiteTensor_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = tflite__NumElements_28TfLiteIntArray_20const__29(HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function flatbuffers__Vector_unsigned_20char___data_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_unsigned_20char___Data_28_29_20const(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsiClearTimeout($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvNewArray($1 + 12 | 0, 1);
 jswrap_interface_clearTimeout(HEAP32[$1 + 8 >> 2]);
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function int_20flatbuffers__ReadScalar_int__28void_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20flatbuffers__EndianScalar_int__28int_29(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_serial_println($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 _jswrap_serial_print(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1, 1);
 __stack_pointer = $2 + 16 | 0;
}

function jsvIsUTF8String($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 if (HEAP32[$1 + 8 >> 2]) {
  $0 = HEAP32[$1 + 8 >> 2];
  HEAP8[$1 + 7 | 0] = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63;
 }
 HEAP8[$1 + 15 | 0] = 0;
 return HEAP8[$1 + 15 | 0] & 1;
}

function itostr_4($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 itostr_extra(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 1, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
}

function itostr_3($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 itostr_extra(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 1, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
}

function itostr_2($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 itostr_extra(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 1, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
}

function itostr_1($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 itostr_extra(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 1, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
}

function jsvArrayPushString($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jsvArrayPushAndUnLock(HEAP32[$2 + 12 >> 2], jsvNewFromString(HEAP32[$2 + 8 >> 2]));
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function jslCharPosFromLex($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvStringIteratorClone(HEAP32[$1 + 12 >> 2], HEAP32[49079] + 88 | 0);
 HEAP8[HEAP32[$1 + 12 >> 2] + 36 | 0] = HEAPU8[HEAP32[49079]];
 __stack_pointer = $1 + 16 | 0;
}

function jshGetEventsUsed() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 16 | 0;
 if (HEAPU8[364486] >= HEAPU8[364487]) {
  $1 = HEAPU8[364486] - HEAPU8[364487] | 0;
 } else {
  $1 = (HEAPU8[364486] + 256 | 0) - HEAPU8[364487] | 0;
 }
 HEAP32[$0 + 12 >> 2] = $1;
 return HEAP32[$0 + 12 >> 2];
}

function jswrap_serial_write($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 _jswrap_serial_print(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0, 0);
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_serial_print($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 _jswrap_serial_print(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1, 0);
 __stack_pointer = $2 + 16 | 0;
}

function jsvObjectGetBoolChild($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jsvObjectGetIntegerChild(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return ($0 | 0) != 0;
}

function jshGetPinFromVarAndUnLock($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAPU8[$1 + 11 | 0];
}

function itostr($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 itostr_extra(HEAP32[$3 + 12 >> 2], HEAP32[$3 + 8 >> 2], 1, HEAP32[$3 + 4 >> 2]);
 __stack_pointer = $3 + 16 | 0;
}

function tflite__MicroOpResolver___MicroOpResolver_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 tflite__OpResolver___OpResolver_28_29($0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jswrap_storage_getFree($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 47 | 0] = $0;
 HEAP32[$1 + 40 >> 2] = 0;
 jsfGetStorageStats($1 + 8 | 0, HEAP32[$1 + 40 >> 2], 1);
 __stack_pointer = $1 + 48 | 0;
 return HEAP32[$1 + 28 >> 2];
}

function jsvAsArrayIndexAndUnLock($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvAsArrayIndex(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jsfIsRealFile($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) {
  $2 = (jsfGetFileFlags(HEAP32[$1 + 12 >> 2]) & 32) != 0 ^ -1;
 }
 __stack_pointer = $1 + 16 | 0;
 return $2 & 1;
}

function getTimeFromDateVar($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $1;
 HEAP8[$3 + 11 | 0] = $2;
 getTimeFromMilliSeconds($0, jswrap_date_getTime(HEAP32[$3 + 12 >> 2]), HEAP8[$3 + 11 | 0] & 1);
 __stack_pointer = $3 + 16 | 0;
}

function dtohex($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] & 15;
 if (HEAP32[$1 + 12 >> 2] < 10) {
  $0 = HEAP32[$1 + 12 >> 2] + 48 | 0;
 } else {
  $0 = HEAP32[$1 + 12 >> 2] + 55 | 0;
 }
 return $0 << 24 >> 24;
}

function add_tag_bit($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP8[$3 + 7 | 0] = $2;
 push_bits(HEAP32[$3 + 12 >> 2], 1, HEAPU8[$3 + 7 | 0], HEAP32[$3 + 8 >> 2]);
 __stack_pointer = $3 + 16 | 0;
}

function jsvLockAgain($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 $2 = (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) + 1024 | 0;
 HEAP8[$0 + 12 | 0] = $2;
 HEAP8[$0 + 13 | 0] = $2 >>> 8;
 return HEAP32[$1 + 12 >> 2];
}

function tflite__MicroInterpreter__outputs_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = tflite__SubGraph__outputs_28_29_20const(HEAP32[HEAP32[$1 + 12 >> 2] + 116 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_pin_read($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
 $0 = jshPinInput(HEAPU8[$1 + 11 | 0]);
 __stack_pointer = $1 + 16 | 0;
 return $0 & 1;
}

function jsvSkipOneNameAndUnLock($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvSkipOneName(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jsvRemoveChildAndUnLock($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsvRemoveChild(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 jsvUnLock(HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
}

function jsvGetArrayItem($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jsvSkipNameAndUnLock(jsvGetArrayIndex(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]));
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function itoch($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 8 >> 2] = $0;
 label$1: {
  if (HEAP32[$1 + 8 >> 2] < 10) {
   HEAP8[$1 + 15 | 0] = HEAP32[$1 + 8 >> 2] + 48;
   break label$1;
  }
  HEAP8[$1 + 15 | 0] = HEAP32[$1 + 8 >> 2] + 87;
 }
 return HEAP8[$1 + 15 | 0];
}

function _jsvGetIntegerAndUnLock($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvGetInteger(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function _jsvGetBoolAndUnLock($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jsvGetBool(HEAP32[$1 + 12 >> 2]) & 1;
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP8[$1 + 11 | 0] & 1;
}

function vcbprintf_callback_jsiConsolePrintString($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsiConsolePrintString(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
}

function tflite__MicroInterpreter__inputs_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = tflite__SubGraph__inputs_28_29_20const(HEAP32[HEAP32[$1 + 12 >> 2] + 116 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsvIsStringEqual($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = jsvIsStringEqualOrStartsWith(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0);
 __stack_pointer = $2 + 16 | 0;
 return $0 & 1;
}

function tflite__RuntimeShape__DimsData_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1: {
  if (HEAP32[$0 >> 2] > 5) {
   $0 = HEAP32[$0 + 4 >> 2];
   break label$1;
  }
  $0 = $0 + 4 | 0;
 }
 return $0;
}

function jswrap_tfmicrointerpreter_getOutput($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_tfmicrointerpreter_tensorToArrayBuffer(HEAP32[$1 + 12 >> 2], 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jswrap_espruino_getErrorFlags() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP8[$0 + 15 | 0] = HEAPU8[364342];
 HEAP8[364342] = 0;
 $1 = jswrap_espruino_getErrorFlagArray(HEAPU8[$0 + 15 | 0]);
 __stack_pointer = $0 + 16 | 0;
 return $1 | 0;
}

function long_20long_20flatbuffers__EndianScalar_long_20long__28long_20long_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 12 >> 2] = $1;
 $1 = HEAP32[$2 + 8 >> 2];
 $2 = HEAP32[$2 + 12 >> 2];
 i64toi32_i32$HIGH_BITS = $2;
 return $1;
}

function jswrap_tfmicrointerpreter_getInput($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_tfmicrointerpreter_tensorToArrayBuffer(HEAP32[$1 + 12 >> 2], 1);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jsvUnRefRef($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP16[$1 + 14 >> 1] = $0;
 HEAP32[$1 + 8 >> 2] = jsvLock(HEAPU16[$1 + 14 >> 1]);
 jsvUnRef(HEAP32[$1 + 8 >> 2]);
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return 0;
}

function jsvIterateCallbackCount($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = 0;
 jsvIterateBufferCallback(HEAP32[$1 + 12 >> 2], 5, $1 + 8 | 0);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jswrap_flash_getFree() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = jshFlashGetFree();
 if (!HEAP32[$0 + 12 >> 2]) {
  HEAP32[$0 + 12 >> 2] = jsvNewEmptyArray();
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function jsvSkipNameAndUnLock($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvSkipName(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jsvAsStringAndUnLock($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvAsString(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jsvAsNumberAndUnLock($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvAsNumber(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function int_20gemmlowp__MaskIfZero_int__28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = int_20gemmlowp__MaskIfNonZero_int__28int_29((HEAP32[$1 + 12 >> 2] != 0 ^ -1) & 1);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function _jswrap_drawImageLayerStartX($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[HEAP32[$1 + 12 >> 2] + 180 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 172 >> 2];
 HEAP32[HEAP32[$1 + 12 >> 2] + 184 >> 2] = HEAP32[HEAP32[$1 + 12 >> 2] + 176 >> 2];
}

function jswrap_pipe_kill() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = pipeGetArray(0);
 if (HEAP32[$0 + 12 >> 2]) {
  jsvRemoveAllChildren(HEAP32[$0 + 12 >> 2]);
  jsvUnLock(HEAP32[$0 + 12 >> 2]);
 }
 __stack_pointer = $0 + 16 | 0;
}

function jswrap_interface_load($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP16[182206] = HEAPU16[182206] | 64;
 jsvObjectSetChild(HEAP32[91087], 134302, HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jstStopBufferTimerTask($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP16[$1 + 10 >> 1] = jsvGetRef(HEAP32[$1 + 12 >> 2]);
 $0 = utilTimerRemoveTask(568, $1 + 10 | 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 & 1;
}

function tflite__ops__micro__Register_DEPTHWISE_CONV_2D_28_29($0) {
 HEAP32[$0 >> 2] = 701;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 702;
 HEAP32[$0 + 12 >> 2] = 703;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}

function short_20const__20tflite__micro__GetTensorData_short__28TfLiteEvalTensor_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 12 >> 2]) {
   break label$1;
  }
 }
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
}

function gen_jswrap_poke32($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jswrap_io_poke(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 4);
 __stack_pointer = $2 + 16 | 0;
}

function gen_jswrap_poke16($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jswrap_io_poke(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 2);
 __stack_pointer = $2 + 16 | 0;
}

function float_20const__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 12 >> 2]) {
   break label$1;
  }
 }
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
}

function unsigned_20char__20tflite__micro__GetTensorData_unsigned_20char__28TfLiteEvalTensor__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
 } else {
  $0 = 0;
 }
 return $0;
}

function jswrap_banglejs_factoryReset($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jsfResetStorage();
 if (!(HEAP8[$1 + 15 | 0] & 1)) {
  HEAP16[182206] = HEAPU16[182206] | 64;
 }
 __stack_pointer = $1 + 16 | 0;
}

function gen_jswrap_poke8($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jswrap_io_poke(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
 __stack_pointer = $2 + 16 | 0;
}

function tflite__ops__micro__Register_FULLY_CONNECTED_28_29($0) {
 HEAP32[$0 >> 2] = 714;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 715;
 HEAP32[$0 + 12 >> 2] = 716;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}

function tflite__ops__micro__Register_AVERAGE_POOL_2D_28_29($0) {
 HEAP32[$0 >> 2] = 707;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 708;
 HEAP32[$0 + 12 >> 2] = 709;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}

function jswrap_interface_reset($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 HEAP16[182206] = HEAPU16[182206] | 128;
 if (HEAP8[$1 + 15 | 0] & 1) {
  jsfRemoveCodeFromFlash();
 }
 __stack_pointer = $1 + 16 | 0;
}

function jsvAppendStringVarComplete($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsvAppendStringVar(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 0, 2147483647);
 __stack_pointer = $2 + 16 | 0;
}

function gen_jswrap_Object_getOwnPropertyNames($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_object_keys_or_property_names(HEAP32[$1 + 12 >> 2], 1);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function _jsvGetFloatAndUnLock($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAPF64[$1 >> 3] = jsvGetFloat(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return HEAPF64[$1 >> 3];
}

function tflite__SizeOfDimension_28TfLiteTensor_20const__2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[(HEAP32[HEAP32[$2 + 12 >> 2] + 20 >> 2] + 4 | 0) + (HEAP32[$2 + 8 >> 2] << 2) >> 2];
}

function tflite__RuntimeShape__DimsData_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 label$1: {
  if (HEAP32[$0 >> 2] > 5) {
   $0 = HEAP32[$0 + 4 >> 2];
   break label$1;
  }
  $0 = $0 + 4 | 0;
 }
 return $0;
}

function std____2____non_trivial_if_true_2c_20std____2__allocator_std____2__unique_ptr_TfLiteDelegate_2c_20void_20_28__29_28TfLiteDelegate__29_______non_trivial_if_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function int_20const__20tflite__micro__GetTensorData_int__28TfLiteEvalTensor_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 label$1: {
  if (!HEAP32[$1 + 12 >> 2]) {
   break label$1;
  }
 }
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
}

function tflite__RuntimeShape___RuntimeShape_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 if (HEAP32[$0 >> 2] > 5) {
  abort();
  abort();
 }
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function signed_20char__20tflite__micro__GetTensorData_signed_20char__28TfLiteEvalTensor__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
 } else {
  $0 = 0;
 }
 return $0;
}

function jstGetLastPinTimerTask($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 $0 = utilTimerGetLastTask(567, $2 + 15 | 0, HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
 return $0 & 1;
}

function gemmlowp__FixedPoint_int_2c_202___One_28_29() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_202___FromScalarRaw_28int_29(536870912);
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 8 >> 2];
}

function tflite__ops__micro__Register_MAX_POOL_2D_28_29($0) {
 HEAP32[$0 >> 2] = 707;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 708;
 HEAP32[$0 + 12 >> 2] = 710;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}

function jswrap_math_atan2($0, $1) {
 $0 = +$0;
 $1 = +$1;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAPF64[$2 + 8 >> 3] = $0;
 HEAPF64[$2 >> 3] = $1;
 $0 = atan2(HEAPF64[$2 + 8 >> 3], HEAPF64[$2 >> 3]);
 __stack_pointer = $2 + 16 | 0;
 return +$0;
}

function jswrap_date_getFullYear($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getCalendarDateFromDateVar($1 + 8 | 0, HEAP32[$1 + 28 >> 2], 0);
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 20 >> 2];
}

function tflite__ops__micro__Register_DEQUANTIZE_28_29($0) {
 HEAP32[$0 >> 2] = 720;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 721;
 HEAP32[$0 + 12 >> 2] = 722;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}

function jsvGetRefs($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 $1 = HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24);
 $1 = $1 >>> 10 | 0;
 return $1 & 255;
}

function i2c_pin_wr1($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jshPinSetValue(HEAPU8[$1 + 15 | 0], 1);
 jshPinSetState(HEAPU8[$1 + 15 | 0], 1);
 jshPinSetState(HEAPU8[$1 + 15 | 0], 5);
 __stack_pointer = $1 + 16 | 0;
}

function flatbuffers__Vector_int___Length_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_int___size_28_29_20const(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_pin_reset($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
 jshPinOutput(HEAPU8[$1 + 11 | 0], 0);
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_date_getTimezoneOffset($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
 __stack_pointer = $1 + 32 | 0;
 return 0 - HEAP32[$1 + 20 >> 2] | 0;
}

function tflite__ops__micro__Register_QUANTIZE_28_29($0) {
 HEAP32[$0 >> 2] = 717;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 718;
 HEAP32[$0 + 12 >> 2] = 719;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}

function jswrap_date_getMonth($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getCalendarDateFromDateVar($1 + 8 | 0, HEAP32[$1 + 28 >> 2], 0);
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 16 >> 2];
}

function gen_jswrap_Graphics_setFontBitmap($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_graphics_setFontSizeX(HEAP32[$1 + 12 >> 2], 8193, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function tflite__ops__micro__Register_SOFTMAX_28_29($0) {
 HEAP32[$0 >> 2] = 711;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 712;
 HEAP32[$0 + 12 >> 2] = 713;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}

function jswrap_pin_set($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP8[$1 + 11 | 0] = jshGetPinFromVar(HEAP32[$1 + 12 >> 2]);
 jshPinOutput(HEAPU8[$1 + 11 | 0], 1);
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_interface_echo($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 label$1: {
  if (HEAP8[$1 + 15 | 0] & 1) {
   HEAP16[182206] = HEAPU16[182206] & -2;
   break label$1;
  }
  HEAP16[182206] = HEAPU16[182206] | 1;
 }
}

function jswrap_date_getDate($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getCalendarDateFromDateVar($1 + 8 | 0, HEAP32[$1 + 28 >> 2], 0);
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jshBusyIdle() {
 var $0 = 0, $1 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = 196089;
 $1 = HEAP32[$0 + 12 >> 2];
 HEAP8[$0 + 11 | 0] = 0;
 emscripten_asm_const_int($1 | 0, $0 + 11 | 0, 0) | 0;
 __stack_pointer = $0 + 16 | 0;
}

function gemmlowp__FixedPoint_int_2c_2012___Zero_28_29() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = gemmlowp__FixedPoint_int_2c_2012___FromScalarRaw_28int_29(0);
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 8 >> 2];
}

function tflite__ops__micro__Register_CONV_2D_28_29($0) {
 HEAP32[$0 >> 2] = 704;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 705;
 HEAP32[$0 + 12 >> 2] = 706;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}
function jswrap_date_getDay($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getCalendarDateFromDateVar($1 + 8 | 0, HEAP32[$1 + 28 >> 2], 0);
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 24 >> 2];
}

function flatbuffers__String__c_str_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = flatbuffers__Vector_char___Data_28_29_20const(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_referenceerror_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = _jswrap_error_constructor(HEAP32[$1 + 12 >> 2], 120964);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jswrap_graphics_dump($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsiConsolePrintf(141323, 0);
 jsvUnLock(jswrap_graphics_asBMP_X(HEAP32[$1 + 12 >> 2], 1));
 __stack_pointer = $1 + 16 | 0;
}

function gen_jswrap_ArrayBufferView_buffer($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvLock(jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function ccm_ctx_alloc() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = jsvMalloc(56);
 if (HEAP32[$0 + 12 >> 2]) {
  mbedtls_ccm_init(HEAP32[$0 + 12 >> 2]);
 }
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function jswrap_internalerror_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = _jswrap_error_constructor(HEAP32[$1 + 12 >> 2], 120940);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jsvGetFlatStringBlocks($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return ((HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24)) + 13 >>> 0) / 14 | 0;
}

function jsvArrayBufferIteratorFree($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAPU8[HEAP32[$1 + 12 >> 2] + 36 | 0]) {
  jsvStringIteratorFree_2(HEAP32[$1 + 12 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
}

function jspromise_resolve($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jspromise_resolve_or_reject(HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2], 1);
 __stack_pointer = $2 + 16 | 0;
}

function jshTransmitClearDevice($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 while (1) {
  if ((jshGetCharToTransmit(HEAPU8[$1 + 15 | 0]) | 0) >= 0) {
   continue;
  }
  break;
 }
 __stack_pointer = $1 + 16 | 0;
}

function gen_jswrap_Graphics_getHeight($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_graphics_getWidthOrHeight(HEAP32[$1 + 12 >> 2], 1);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jswrap_syntaxerror_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = _jswrap_error_constructor(HEAP32[$1 + 12 >> 2], 120928);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jswrap_storagefile_readLine($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_storagefile_read_internal(HEAP32[$1 + 12 >> 2], -1);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jsfPrintJSON($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsfGetJSONWithCallback(HEAP32[$2 + 12 >> 2], 0, HEAP32[$2 + 8 >> 2], 0, 7, 0);
 __stack_pointer = $2 + 16 | 0;
}

function gen_jswrap_Graphics_getWidth($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_graphics_getWidthOrHeight(HEAP32[$1 + 12 >> 2], 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function onewire_getpin($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jshGetPinFromVarAndUnLock(jsvObjectGetChildIfExists(HEAP32[$1 + 12 >> 2], 128488));
 __stack_pointer = $1 + 16 | 0;
 return $0 & 255;
}

function jswrap_pin_getMode($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_io_getPinMode(jshGetPinFromVar(HEAP32[$1 + 12 >> 2]) & 255);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jswrap_banglejs_pwrBacklight($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jshPinOutput(8, HEAP8[$1 + 15 | 0] & 1);
 lcdMemLCD_extcominBacklight(HEAP8[$1 + 15 | 0] & 1);
 __stack_pointer = $1 + 16 | 0;
}

function gen_jswrap_String_toUpperCase($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_string_toUpperLowerCase(HEAP32[$1 + 12 >> 2], 1);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_String_toLowerCase($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_string_toUpperLowerCase(HEAP32[$1 + 12 >> 2], 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function std____2____compressed_pair_elem_tflite___28anonymous_20namespace_29__SafeBuiltinDataAllocator__BuiltinDataDeleter_2c_201_2c_20false_____get_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_typeerror_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = _jswrap_error_constructor(HEAP32[$1 + 12 >> 2], 120954);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jsserialGetSerialList($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = jsvObjectGetChild(HEAP32[91087], 129067, (HEAP8[$1 + 15 | 0] & 1 ? 3 : 0) & 65535);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsfGetDriveBankAddress($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 HEAP8[$3 + 15 | 0] = $0;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[HEAP32[$3 + 8 >> 2] >> 2] = 134217728;
 HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = 142606336;
}

function gen_jswrap_Object_keys($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_object_keys_or_property_names(HEAP32[$1 + 12 >> 2], 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jswrap_date_getMilliseconds($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 4 >> 2];
}

function jsvUnLock2($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsvUnLockInline(HEAP32[$2 + 12 >> 2]);
 jsvUnLockInline(HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
}

function jsiPacketStart() {
 HEAP8[364428] = 2;
 jsiInputLineCursorMoved();
 jsvObjectSetChildAndUnLock(HEAP32[91087], 137348, HEAP32[91104]);
 jsvObjectSetChildAndUnLock(HEAP32[91087], 136570, jsiSetTimeout(565, 1e3));
 HEAP32[91104] = jsvNewFromEmptyString_5();
}

function gen_jswrap_Object_entries($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_object_values_or_entries(HEAP32[$1 + 12 >> 2], 1);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function srand($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[48914] = HEAP32[$1 + 12 >> 2] & 65535 | HEAP32[$1 + 12 >> 2] << 16;
 HEAP32[48915] = HEAP32[$1 + 12 >> 2] & -65536 | HEAP32[$1 + 12 >> 2] >>> 16;
}

function short__20tflite__micro__GetTensorData_short__28TfLiteEvalTensor__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
 } else {
  $0 = 0;
 }
 return $0;
}

function jswrap_pin_analog($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = jshPinAnalog(jshGetPinFromVar(HEAP32[$1 + 12 >> 2]) & 255);
 __stack_pointer = $1 + 16 | 0;
 return +$2;
}

function int_20tflite__CountLeadingZeros_unsigned_20int__28unsigned_20int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = Math_clz32(HEAP32[$1 + 12 >> 2]);
 } else {
  $0 = 32;
 }
 return $0;
}

function gen_jswrap_String_removeAccents($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_string_removeAccents(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_Object_values($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_object_values_or_entries(HEAP32[$1 + 12 >> 2], 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_Graphics_getBgColor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_graphics_getColorX(HEAP32[$1 + 12 >> 2], 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function float__20tflite__micro__GetTensorData_float__28TfLiteEvalTensor__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
 } else {
  $0 = 0;
 }
 return $0;
}

function jswrap_error_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = _jswrap_error_constructor(HEAP32[$1 + 12 >> 2], 120973);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jsvNewFromStringVarComplete($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvNewWritableStringFromStringVar(HEAP32[$1 + 12 >> 2], 0, 2147483647);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_espruino_toFlatString($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_espruino_toStringX(HEAP32[$1 + 12 >> 2], 1);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jswrap_date_getMinutes($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_date_getIsDST($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
 __stack_pointer = $1 + 32 | 0;
 return HEAP8[$1 + 24 | 0] & 1;
}

function jsvIsArrayBufferName($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 14;
 }
 return $2;
}

function gen_jswrap_Graphics_getColor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_graphics_getColorX(HEAP32[$1 + 12 >> 2], 1);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function tflite__internal__ContextHelper__SetTfLiteEvalTensors_28TfLiteEvalTensor__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[HEAP32[$2 + 12 >> 2] + 12 >> 2] = HEAP32[$2 + 8 >> 2];
}

function jswrap_object_getPrototypeOf($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jspGetNamedField(HEAP32[$1 + 12 >> 2], 135865, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jswrap_date_getSeconds($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 8 >> 2];
}

function jsiOneSecondAfterStartup() {
 label$1: {
  if (HEAPU8[195664] == 19) {
   HEAP8[195664] = jsiGetPreferredConsoleDevice();
   jshTransmitMove(19, HEAPU8[195664]);
   jshUSARTKick(HEAPU8[195664]);
   break label$1;
  }
  jshTransmitClearDevice(19);
 }
}

function dly($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]) {
  jshDelayMicroseconds(HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_date_getTime($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = jsvObjectGetFloatChild(HEAP32[$1 + 12 >> 2], 120133);
 __stack_pointer = $1 + 16 | 0;
 return +$2;
}

function jswrap_date_getHours($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 28 >> 2] = $0;
 getTimeFromDateVar($1, HEAP32[$1 + 28 >> 2], 0);
 __stack_pointer = $1 + 32 | 0;
 return HEAP32[$1 + 16 >> 2];
}

function jsvIsNativeFunction($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 8;
 }
 return $2;
}

function jsvIsFunctionReturn($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 9;
 }
 return $2;
}

function jsvFree($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = jsvGetFlatStringFromPointer(HEAP32[$1 + 12 >> 2]);
 jsvUnLock(HEAP32[$1 + 8 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsiConsoleRemoveInputLine() {
 if (!(HEAP8[364420] & 1)) {
  HEAP8[364420] = 1;
  if (!(!(jsiEcho() & 1) | !HEAP32[91104])) {
   jsiMoveCursorChar(HEAP32[91104], HEAP32[91106], 0);
   jsiConsolePrintChar(13);
   jsiConsoleEraseAfterCursor();
  }
 }
}

function int__20tflite__micro__GetTensorData_int__28TfLiteEvalTensor__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
 } else {
  $0 = 0;
 }
 return $0;
}

function graphicsFallbackSetPixel($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $0;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP32[$4 >> 2] = $3;
}

function jsvGetLastChild($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return (HEAPU8[$0 + 8 | 0] | HEAPU8[$0 + 9 | 0] << 8 | (HEAPU8[$0 + 10 | 0] << 16 | HEAPU8[$0 + 11 | 0] << 24)) >>> 18 | 0;
}

function gen_jswrap_Math_acos($0) {
 $0 = +$0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = jswrap_math_asin(HEAPF64[$1 + 8 >> 3]);
 __stack_pointer = $1 + 16 | 0;
 return +(1.5707963267948966 - $0);
}

function gen_jswrap_Array_pop($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvSkipNameAndUnLock(jsvArrayPop(HEAP32[$1 + 12 >> 2]));
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function pipeGetArray($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = jsvObjectGetChild(HEAP32[91087], 120225, (HEAP8[$1 + 15 | 0] & 1 ? 3 : 0) & 65535);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jswrap_interface_clearInterval($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 _jswrap_interface_clearTimeoutOrInterval(HEAP32[$1 + 12 >> 2], 0);
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_espruino_toString($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_espruino_toStringX(HEAP32[$1 + 12 >> 2], 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jsvIsNameIntBool($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 17;
 }
 return $2;
}

function jshGetMillisecondsFromTime($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 12 >> 2] = $1;
 $3 = +HEAPU32[$2 + 8 >> 2];
 $2 = HEAP32[$2 + 12 >> 2];
 return ($3 + +($2 | 0) * 4294967296) / 1e3;
}

function jswrap_interface_clearTimeout($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 _jswrap_interface_clearTimeoutOrInterval(HEAP32[$1 + 12 >> 2], 1);
 __stack_pointer = $1 + 16 | 0;
}

function jsvIsArrayBuffer($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 4;
 }
 return $2;
}

function jswrap_espruino_asm($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 jsExceptionHere(1, 134149, 0);
 __stack_pointer = $2 + 16 | 0;
}

function jsvIsSimpleInt($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 10;
 }
 return $2;
}

function jsvGetNextSibling($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return (HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 5 | 0] << 8 | (HEAPU8[$0 + 6 | 0] << 16 | HEAPU8[$0 + 7 | 0] << 24)) & 16383;
}

function jsiInit($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 HEAP16[182206] = 6144;
 HEAP8[195664] = 19;
 jsiSemiInit(HEAP8[$1 + 15 | 0] & 1, 0);
 jsiSetBusy(1, 0);
 __stack_pointer = $1 + 16 | 0;
}

function jsiConsolePrintf($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 vcbprintf(562, 0, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 8 >> 2]);
 __stack_pointer = $2 + 16 | 0;
}

function gen_jswrap_Serial_find($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = jshGetDeviceObjectFor(768, 848, HEAPU8[$1 + 15 | 0]);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jsvIsConstant($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 64) == 64;
 }
 return $2;
}

function jsvAppendCharacter_2($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 jsvAppendStringBuf(HEAP32[$2 + 12 >> 2], $2 + 11 | 0, 1);
 __stack_pointer = $2 + 16 | 0;
}

function jsvAppendCharacter_1($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 jsvAppendStringBuf(HEAP32[$2 + 12 >> 2], $2 + 11 | 0, 1);
 __stack_pointer = $2 + 16 | 0;
}

function jshGetWatchedPinState($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = jshPinGetValue(HEAPU8[(HEAPU8[$1 + 15 | 0] - 1 | 0) + 390976 | 0]);
 __stack_pointer = $1 + 16 | 0;
 return $0 & 1;
}

function jsvIsNullish($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = 1;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $0 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 2;
 }
 return $0;
}

function tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Size_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return HEAP32[$0 + 8 >> 2] + HEAP32[$0 + 12 >> 2] | 0;
}

function rand() {
 HEAP32[48915] = Math_imul(HEAP32[48915] & 65535, 36969) + (HEAP32[48915] >>> 16 | 0);
 HEAP32[48914] = Math_imul(HEAP32[48914] & 65535, 18e3) + (HEAP32[48914] >>> 16 | 0);
 return HEAP32[48914] + (HEAP32[48915] << 16) & 2147483647;
}

function jswrap_graphics_asBMP($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_graphics_asBMP_X(HEAP32[$1 + 12 >> 2], 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jsvArrayBufferIteratorGetIndex($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvNewFromInteger(HEAP32[HEAP32[$1 + 12 >> 2] + 48 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsvAppendCharacter($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP8[$2 + 11 | 0] = $1;
 jsvAppendStringBuf(HEAP32[$2 + 12 >> 2], $2 + 11 | 0, 1);
 __stack_pointer = $2 + 16 | 0;
}

function jspSetInterrupted($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 label$1: {
  if (HEAP8[$1 + 15 | 0] & 1) {
   HEAP32[91094] = HEAP32[91094] | 16;
   break label$1;
  }
  HEAP32[91094] = HEAP32[91094] & -17;
 }
}

function jspKill() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 jspSoftKill();
 HEAP32[$0 + 12 >> 2] = jsvFindOrCreateRoot();
 jsvUnRef(HEAP32[$0 + 12 >> 2]);
 jsvUnLock(HEAP32[$0 + 12 >> 2]);
 __stack_pointer = $0 + 16 | 0;
}

function gen_jswrap_crypto_SHA512($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_crypto_SHAx(HEAP32[$1 + 12 >> 2], 512);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_crypto_SHA384($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_crypto_SHAx(HEAP32[$1 + 12 >> 2], 384);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_crypto_SHA256($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_crypto_SHAx(HEAP32[$1 + 12 >> 2], 256);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_crypto_SHA224($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_crypto_SHAx(HEAP32[$1 + 12 >> 2], 224);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_SPI_find($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = jshGetDeviceObjectFor(512, 544, HEAPU8[$1 + 15 | 0]);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_I2C_find($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = jshGetDeviceObjectFor(640, 688, HEAPU8[$1 + 15 | 0]);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function mbedtls_ccm_free($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 mbedtls_cipher_free(HEAP32[$1 + 12 >> 2]);
 mbedtls_zeroize_3(HEAP32[$1 + 12 >> 2], 56);
 __stack_pointer = $1 + 16 | 0;
}

function jsvIsFloat($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 11;
 }
 return $2;
}

function jswrap_math_cos($0) {
 $0 = +$0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = jswrap_math_sin(HEAPF64[$1 + 8 >> 3] + 1.5707963267948966);
 __stack_pointer = $1 + 16 | 0;
 return +$0;
}

function jsvIsArray($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 3;
 }
 return $2;
}

function gen_jswrap_Math_min($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = jswrap_math_minmax(HEAP32[$1 + 12 >> 2], 0);
 __stack_pointer = $1 + 16 | 0;
 return +$2;
}

function gen_jswrap_Math_max($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = jswrap_math_minmax(HEAP32[$1 + 12 >> 2], 1);
 __stack_pointer = $1 + 16 | 0;
 return +$2;
}

function float_20tflite__TfLiteRound_float__28float_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAPF32[$1 + 12 >> 2] = $0;
 $0 = round_28float_29(HEAPF32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsvIsNull($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  $0 = HEAP32[$1 + 12 >> 2];
  $2 = ((HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) & 63) == 2;
 }
 return $2;
}

function jsfNameFromVarAndUnLock($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $1;
 jsfNameFromVar($0, HEAP32[$2 + 12 >> 2]);
 jsvUnLock(HEAP32[$2 + 12 >> 2]);
 __stack_pointer = $2 + 16 | 0;
}

function jswrap_pipe_src_close_listener($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jswrap_pipe_close_listener(HEAP32[$1 + 12 >> 2], 132796);
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_pipe_dst_close_listener($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jswrap_pipe_close_listener(HEAP32[$1 + 12 >> 2], 128459);
 __stack_pointer = $1 + 16 | 0;
}

function gen_jswrap_crypto_SHA1($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_crypto_SHAx(HEAP32[$1 + 12 >> 2], 1);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function gen_jswrap_ArrayBuffer_byteLength($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return HEAPU8[$0 + 4 | 0] << 16 | (HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8);
}

function jswrap_json_parse($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jswrap_json_parse_ext(HEAP32[$1 + 12 >> 2], 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jswrap_espruino_setClock($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jshSetSystemClock(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function mbedtls_sha512_free($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  mbedtls_zeroize_2(HEAP32[$1 + 12 >> 2], 216);
 }
 __stack_pointer = $1 + 16 | 0;
}

function mbedtls_sha256_free($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  mbedtls_zeroize_1(HEAP32[$1 + 12 >> 2], 108);
 }
 __stack_pointer = $1 + 16 | 0;
}

function ccm_ctx_free($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 mbedtls_ccm_free(HEAP32[$1 + 12 >> 2]);
 jsvFree(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function aes_ctx_free($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 mbedtls_aes_free(HEAP32[$1 + 12 >> 2]);
 jsvFree(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_storage_hash($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsfHashFiles(HEAP32[$1 + 12 >> 2], 0, 64);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jswrap_banglejs_setLocked($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 _jswrap_banglejs_setLocked(HEAP8[$1 + 15 | 0] & 1, 120149);
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_banglejs_setLCDPowerController($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jshPinOutput(6, 0);
 jshPinOutput(7, HEAP8[$1 + 15 | 0] & 1);
 __stack_pointer = $1 + 16 | 0;
}

function jsvSkipName($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvSkipNameWithParent(HEAP32[$1 + 12 >> 2], 1, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jsvNewFromString($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvNewNameOrString(HEAP32[$1 + 12 >> 2], 0);
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function jsvArrayIsEmpty($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = (jsvGetFirstChild(HEAP32[$1 + 12 >> 2]) & 65535) != 0 ^ -1;
 __stack_pointer = $1 + 16 | 0;
 return $0 & 1;
}

function mbedtls_aes_free($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  mbedtls_zeroize_4(HEAP32[$1 + 12 >> 2], 280);
 }
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_boolean_constructor($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvGetBool(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0 & 1;
}

function jswrap_banglejs_setOptions($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 _jswrap_banglejs_setOptions(HEAP32[$1 + 12 >> 2], 0);
 __stack_pointer = $1 + 16 | 0;
}

function jsvGetFlatStringFromPointer($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 12 >> 2];
 HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 8 >> 2] - 14;
 return HEAP32[$1 + 4 >> 2];
}

function jspSoftInit() {
 HEAP32[91086] = jsvFindOrCreateRoot();
 HEAP32[91087] = jsvObjectGetChild(HEAP32[91086], 113710, 5);
 HEAP32[91094] = 1;
 HEAP32[91088] = 0;
 HEAP32[91089] = HEAP32[91086];
 HEAP32[91090] = 0;
 HEAP8[364364] = 0;
}

function double_20tflite__TfLiteRound_double__28double_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = round(HEAPF64[$1 + 8 >> 3]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function mbedtls_sha1_free($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 if (HEAP32[$1 + 12 >> 2]) {
  mbedtls_zeroize(HEAP32[$1 + 12 >> 2], 92);
 }
 __stack_pointer = $1 + 16 | 0;
}

function jsiConsolePrintStringVar($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsiConsolePrintStringVarWithNewLineChar(HEAP32[$1 + 12 >> 2], 0, 0);
 __stack_pointer = $1 + 16 | 0;
}

function gen_jswrap_Array_isArray($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvIsArray(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0 & 1;
}

function tflite__internal__ContextHelper__SetNodeIndex_28int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[HEAP32[$2 + 12 >> 2] + 16 >> 2] = HEAP32[$2 + 8 >> 2];
}

function __memcpy($0, $1, $2) {
 var $3 = 0;
 if ($2) {
  $3 = $0;
  while (1) {
   HEAP8[$3 | 0] = HEAPU8[$1 | 0];
   $3 = $3 + 1 | 0;
   $1 = $1 + 1 | 0;
   $2 = $2 - 1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
 return $0;
}

function _jswrap_arraybufferview_sort_int($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[$2 + 12 >> 2] - HEAP32[$2 + 8 >> 2] | 0;
}

function stringToFloat($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = stringToFloatWithRadix(HEAP32[$1 + 12 >> 2], 0, 0);
 __stack_pointer = $1 + 16 | 0;
 return $2;
}

function jsvGetFloatAndUnLock($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $2 = _jsvGetFloatAndUnLock(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $2;
}

function i2c_pin_wr0($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jshPinSetValue(HEAPU8[$1 + 15 | 0], 0);
 jshPinSetState(HEAPU8[$1 + 15 | 0], 1);
 __stack_pointer = $1 + 16 | 0;
}

function tflite__SimpleMemoryAllocator__ResetTempAllocations_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 16 >> 2];
}

function healthStateClear($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
}

function tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator__Deallocate_28void__29($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
}

function legalstub$dynCall_jiji($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $0 = dynCall_jiji($0, $1, $2, $3, $4);
 $2 = i64toi32_i32$HIGH_BITS;
 setTempRet0($2 | 0);
 return $0 | 0;
}

function jslIsIDOrReservedWord() {
 var $0 = 0, $1 = 0;
 $0 = 1;
 if (HEAP16[HEAP32[49079] + 2 >> 1] != 128) {
  $1 = HEAP16[HEAP32[49079] + 2 >> 1] >= 163 ? HEAP16[HEAP32[49079] + 2 >> 1] <= 198 : $1;
  $0 = $1;
 }
 return $0 & 1;
}

function round_28float_29($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAPF32[$1 + 12 >> 2] = $0;
 $2 = round(+HEAPF32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return Math_fround($2);
}

function jsvGetIntegerAndUnLock($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = _jsvGetIntegerAndUnLock(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function get_input_offset($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = get_input_buffer_size(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0 & 65535;
}

function jsvGetBoolAndUnLock($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = _jsvGetBoolAndUnLock(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0 & 1;
}

function jsvSkipOneName($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvSkipNameWithParent(HEAP32[$1 + 12 >> 2], 0, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsvNewNameFromString($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvNewNameOrString(HEAP32[$1 + 12 >> 2], 1);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function stringToInt($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = stringToIntWithRadix(HEAP32[$1 + 12 >> 2], 0, 0, 0);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsiShowInputLine() {
 var $0 = 0;
 $0 = 0;
 label$1: {
  if (!(jsiEcho() & 1)) {
   break label$1;
  }
  $0 = 0;
  if (HEAP8[364420] & 1) {
   break label$1;
  }
  $0 = jsiPasswordProtected() ^ -1;
 }
 return $0 & 1;
}

function jshIsPinValid($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 $2 = HEAPU8[$1 + 15 | 0] < 48 ? (HEAPU8[Math_imul(HEAPU8[$1 + 15 | 0], 3) + 180752 | 0] & 15) != 0 : $2;
 return $2;
}

function _jswrap_graphics_freeImageInfo($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function _jswrap_arraybufferview_sort_float($0, $1) {
 $0 = +$0;
 $1 = +$1;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAPF64[$2 + 8 >> 3] = $0;
 HEAPF64[$2 >> 3] = $1;
 return +(HEAPF64[$2 + 8 >> 3] - HEAPF64[$2 >> 3]);
}

function jstReset() {
 jshUtilTimerDisable();
 HEAP8[366355] = 0;
 HEAP8[366353] = 0;
 HEAP8[366354] = 0;
 HEAP32[91692] = 0;
 HEAP32[91589] = 0;
 HEAP32[91694] = jshGetSystemTime();
 HEAP32[91695] = i64toi32_i32$HIGH_BITS;
}

function terminalSetGFX($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 __memcpy(366800, HEAP32[$1 + 12 >> 2], 72);
 HEAP8[391323] = 1;
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_espruino_asUTF8($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsExceptionHere(1, 133248, 0);
 __stack_pointer = $1 + 16 | 0;
 return 0;
}

function jsvGetArrayBufferLength($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return HEAPU8[$0 + 4 | 0] << 16 | (HEAPU8[$0 + 2 | 0] | HEAPU8[$0 + 3 | 0] << 8);
}

function jshIsPinStateDefault($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 $0 = 1;
 $0 = HEAPU8[$2 + 14 | 0] != 4 ? HEAPU8[$2 + 14 | 0] == 7 : $0;
 return $0;
}

function int_20gemmlowp__ShiftRight_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[$2 + 12 >> 2] >> HEAP32[$2 + 8 >> 2];
}

function ruy__profiler__ScopeLabel__ScopeLabel_char_20const___28char_20const__29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[$2 + 12 >> 2];
}

function err($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
 jsExceptionHere(1, 120682, $1);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree_16($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree_15($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree_14($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree_13($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree_12($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree_11($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree_10($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function std____2____compressed_pair_elem_TfLiteFullyConnectedParams__2c_200_2c_20false_____get_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvStringIteratorFree_9($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree_8($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree_7($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree_6($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree_5($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree_4($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree_3($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree_2($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree_1($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jshI2CWrite($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 16 | 0;
 HEAP8[$5 + 15 | 0] = $0;
 HEAP8[$5 + 14 | 0] = $1;
 HEAP32[$5 + 8 >> 2] = $2;
 HEAP32[$5 + 4 >> 2] = $3;
 HEAP8[$5 + 3 | 0] = $4;
}

function __DOUBLE_BITS_11($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
 return HEAP32[$1 >> 2];
}

function __DOUBLE_BITS_10($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
 return HEAP32[$1 >> 2];
}

function std____2____compressed_pair_elem_TfLiteDepthwiseConvParams__2c_200_2c_20false_____get_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_math_atan($0) {
 $0 = +$0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = atan(HEAPF64[$1 + 8 >> 3]);
 __stack_pointer = $1 + 16 | 0;
 return +$0;
}

function jsvHasRef($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = jsvIsStringExt(HEAP32[$1 + 12 >> 2]) ^ -1;
 __stack_pointer = $1 + 16 | 0;
 return $0 & 1;
}

function jshI2CRead($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 16 | 0;
 HEAP8[$5 + 15 | 0] = $0;
 HEAP8[$5 + 14 | 0] = $1;
 HEAP32[$5 + 8 >> 2] = $2;
 HEAP32[$5 + 4 >> 2] = $3;
 HEAP8[$5 + 3 | 0] = $4;
}

function isWhitespace($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = isWhitespaceInline_1(HEAP8[$1 + 15 | 0]);
 __stack_pointer = $1 + 16 | 0;
 return $0 & 1;
}

function int_20gemmlowp__Sub_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[$2 + 12 >> 2] - HEAP32[$2 + 8 >> 2] | 0;
}

function int_20gemmlowp__Add_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[$2 + 12 >> 2] + HEAP32[$2 + 8 >> 2] | 0;
}

function gen_jswrap_ArrayBufferView_byteOffset($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8;
}

function _jsvGetAddressOf($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP16[$1 + 14 >> 1] = $0;
 $0 = jsvGetAddressOf(HEAPU16[$1 + 14 >> 1]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function __DOUBLE_BITS_9($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
 return HEAP32[$1 >> 2];
}

function __DOUBLE_BITS_8($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
 return HEAP32[$1 >> 2];
}

function __DOUBLE_BITS_7($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
 return HEAP32[$1 >> 2];
}

function __DOUBLE_BITS_6($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
 return HEAP32[$1 >> 2];
}

function __DOUBLE_BITS_5($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
 return HEAP32[$1 >> 2];
}

function __DOUBLE_BITS_4($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
 return HEAP32[$1 >> 2];
}

function __DOUBLE_BITS_3($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
 return HEAP32[$1 >> 2];
}

function __DOUBLE_BITS_2($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
 return HEAP32[$1 >> 2];
}

function __DOUBLE_BITS_1($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
 return HEAP32[$1 >> 2];
}

function tflite___28anonymous_20namespace_29__AllocationInfoBuilder__Finish_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] + 16 >> 2];
}

function jsvStringIteratorNext($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvStringIteratorNextInline(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorFree($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function int_20gemmlowp__BitXor_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[$2 + 12 >> 2] ^ HEAP32[$2 + 8 >> 2];
}

function int_20gemmlowp__BitAnd_int__28int_2c_20int_29($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[$2 + 12 >> 2] & HEAP32[$2 + 8 >> 2];
}

function jswrap_math_sin($0) {
 $0 = +$0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAPF64[$1 + 8 >> 3] = $0;
 $0 = sin(HEAPF64[$1 + 8 >> 3]);
 __stack_pointer = $1 + 16 | 0;
 return +$0;
}

function jswrap_banglejs_setLCDMode($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsExceptionHere(1, 132842, 0);
 __stack_pointer = $1 + 16 | 0;
}

function __DOUBLE_BITS($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 HEAPF64[$1 >> 3] = HEAPF64[$1 + 8 >> 3];
 i64toi32_i32$HIGH_BITS = HEAP32[$1 + 4 >> 2];
 return HEAP32[$1 >> 2];
}

function jswrap_storage_compact($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jsfCompact(HEAP8[$1 + 15 | 0] & 1);
 __stack_pointer = $1 + 16 | 0;
}

function jswrap_espruino_compiledC($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsExceptionHere(1, 134225, 0);
 __stack_pointer = $1 + 16 | 0;
}

function jsvStringIteratorNextUTF8($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvStringIteratorNext(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_18($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_17($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_16($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_15($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_14($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_13($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_12($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_11($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_10($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jshSetEventDataPin($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
 HEAP32[(HEAPU8[$2 + 15 | 0] << 2) + 364492 >> 2] = HEAPU8[$2 + 14 | 0] | -256;
}

function jswrap_date_now() {
 return +((+(jshGetSystemTime() >>> 0) + +(i64toi32_i32$HIGH_BITS | 0) * 4294967296) * (1e3 / (+(jshGetTimeFromMilliseconds(1e3) >>> 0) + +(i64toi32_i32$HIGH_BITS | 0) * 4294967296)));
}

function jsvObjectIteratorFree_9($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_8($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_7($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_6($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_5($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_4($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_3($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_2($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsvObjectIteratorFree_1($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jspSetError($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 HEAP32[91094] = HEAP32[91094] & -2 | 64;
 if (HEAP8[$1 + 15 | 0] & 1) {
  HEAP32[91094] = HEAP32[91094] | 128;
 }
}

function tflite__BuiltinDataAllocator__BuiltinDataAllocator_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 >> 2] = 189852;
 return $0;
}

function std____2____compressed_pair_elem_TfLiteSoftmaxParams__2c_200_2c_20false_____get_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function std____2____compressed_pair_elem_TfLiteReshapeParams__2c_200_2c_20false_____get_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorFree($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLock(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jsiConsolePrintChar($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 jshTransmit(HEAPU8[195664], HEAPU8[$1 + 15 | 0]);
 __stack_pointer = $1 + 16 | 0;
}

function jshPinAnalogOutput($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 HEAP8[$4 + 31 | 0] = $0;
 HEAPF64[$4 + 16 >> 3] = $1;
 HEAPF64[$4 + 8 >> 3] = $2;
 HEAP32[$4 + 4 >> 2] = $3;
 return 0;
}

function isNumeric($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = isNumericInline_1(HEAP8[$1 + 15 | 0]);
 __stack_pointer = $1 + 16 | 0;
 return $0 & 1;
}

function std____2____compressed_pair_elem_TfLiteFullyConnectedParams__2c_200_2c_20false_____get_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function jswGetPowerUsage($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jswrap_banglejs_powerusage(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function jslNextCh() {
 var $0 = 0;
 if (HEAP32[HEAP32[49079] + 104 >> 2]) {
  $0 = HEAPU8[HEAP32[HEAP32[49079] + 104 >> 2] + HEAP32[HEAP32[49079] + 88 >> 2] | 0];
 } else {
  $0 = 0;
 }
 return $0 << 24 >> 24;
}

function std____2____compressed_pair_elem_TfLiteDepthwiseConvParams__2c_200_2c_20false_____get_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function jshSetEventCallback($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[(HEAPU8[$2 + 15 | 0] << 2) + 364492 >> 2] = HEAP32[$2 + 8 >> 2];
}

function std____2____compressed_pair_elem_TfLitePoolParams__2c_200_2c_20false_____get_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function std____2____compressed_pair_elem_TfLiteConvParams__2c_200_2c_20false_____get_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function gen_jswrap_getTime() {
 return +((+(jshGetSystemTime() >>> 0) + +(i64toi32_i32$HIGH_BITS | 0) * 4294967296) / (+(jshGetTimeFromMilliseconds(1e3) >>> 0) + +(i64toi32_i32$HIGH_BITS | 0) * 4294967296));
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__OperatorCode____Data_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] + 4 | 0;
}

function isAlpha($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP8[$1 + 15 | 0] = $0;
 $0 = isAlphaInline_1(HEAP8[$1 + 15 | 0]);
 __stack_pointer = $1 + 16 | 0;
 return $0 & 1;
}

function st_save_backlog($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 save_backlog(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return 0;
}

function jsvUnLock($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvUnLockInline(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function exp_28float_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAPF32[$1 + 12 >> 2] = $0;
 $0 = expf(HEAPF32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function __DOUBLE_BITS_13($0) {
 var $1 = 0, $2 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $2 = wasm2js_scratch_load_i32(0) | 0;
 i64toi32_i32$HIGH_BITS = $1;
 return $2;
}

function __DOUBLE_BITS_12($0) {
 var $1 = 0, $2 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $2 = wasm2js_scratch_load_i32(0) | 0;
 i64toi32_i32$HIGH_BITS = $1;
 return $2;
}

function jshGetPinShouldStayWatched($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 return HEAP32[(HEAPU8[$1 + 15 | 0] >>> 5 << 2) + 364396 >> 2] >>> HEAPU8[$1 + 15 | 0] & 1;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__SubGraph____Data_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] + 4 | 0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Operator____Data_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] + 4 | 0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Metadata____Data_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] + 4 | 0;
}

function unsigned_20short_20flatbuffers__EndianScalar_unsigned_20short__28unsigned_20short_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP16[$1 + 14 >> 1] = $0;
 return HEAPU16[$1 + 14 >> 1];
}

function std____2____compressed_pair_elem_TfLiteSoftmaxParams__2c_200_2c_20false_____get_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function std____2____compressed_pair_elem_TfLiteReshapeParams__2c_200_2c_20false_____get_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function jslSetLex($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = HEAP32[49079];
 HEAP32[49079] = HEAP32[$1 + 12 >> 2];
 return HEAP32[$1 + 8 >> 2];
}

function jslCharPosFree($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvStringIteratorFree(HEAP32[$1 + 12 >> 2]);
 __stack_pointer = $1 + 16 | 0;
}

function can_take_byte($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}

function memset($0, $1, $2) {
 var $3 = 0;
 if ($2) {
  $3 = $0;
  while (1) {
   HEAP8[$3 | 0] = $1;
   $3 = $3 + 1 | 0;
   $2 = $2 - 1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
 return $0;
}

function jsvStringIteratorGetIndex_6($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2] | 0;
}

function jsvStringIteratorGetIndex_5($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2] | 0;
}

function jsvStringIteratorGetIndex_4($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2] | 0;
}

function jsvStringIteratorGetIndex_3($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2] | 0;
}

function jsvStringIteratorGetIndex_2($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2] | 0;
}

function jsvStringIteratorGetIndex_1($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2] | 0;
}

function jshFlashGetFree() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 12 >> 2] = jsvNewEmptyArray();
 __stack_pointer = $0 + 16 | 0;
 return HEAP32[$0 + 12 >> 2];
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Tensor____Data_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] + 4 | 0;
}

function flatbuffers__Vector_flatbuffers__Offset_tflite__Buffer____Data_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] + 4 | 0;
}

function mbedtls_sha512_init($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 memset(HEAP32[$1 + 12 >> 2], 0, 216);
 __stack_pointer = $1 + 16 | 0;
}

function mbedtls_sha256_init($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 memset(HEAP32[$1 + 12 >> 2], 0, 108);
 __stack_pointer = $1 + 16 | 0;
}

function int_20gemmlowp__Dup_int__28gemmlowp__FixedPointRawTypeTraits_int___ScalarRawType_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function std____2____compressed_pair_elem_TfLitePoolParams__2c_200_2c_20false_____get_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function std____2____compressed_pair_elem_TfLiteConvParams__2c_200_2c_20false_____get_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvStringIteratorHasChar_12($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}

function jsvStringIteratorHasChar_11($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}

function jsvStringIteratorHasChar_10($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}

function jsvStringIteratorGetIndex($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2] + HEAP32[HEAP32[$1 + 12 >> 2] >> 2] | 0;
}

function jshGetPinStateIsManual($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 return HEAP32[(HEAPU8[$1 + 15 | 0] >>> 5 << 2) + 364388 >> 2] >>> HEAPU8[$1 + 15 | 0] & 1;
}

function jsInit() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[97742] = $0 + 12;
 jshInit();
 jswHWInit();
 jsvInit(12e3);
 jsiInit(1);
 __stack_pointer = $0 + 16 | 0;
}

function jsvStringIteratorHasChar_9($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}

function jsvStringIteratorHasChar_8($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}

function jsvStringIteratorHasChar_7($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}

function jsvStringIteratorHasChar_6($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}

function jsvStringIteratorHasChar_5($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}

function jsvStringIteratorHasChar_4($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}

function jsvStringIteratorHasChar_3($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}

function jsvStringIteratorHasChar_2($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}

function jsvStringIteratorHasChar_1($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}

function tflite__GreedyMemoryPlanner__GetBufferCount_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
}

function stepcount_init() {
 AccelFilter_init(196288);
 HEAP32[48912] = 98304;
 HEAP16[98150] = 0;
 HEAP16[98151] = 0;
 HEAP16[98152] = 0;
 HEAP32[49077] = 0;
 HEAP8[196312] = 0;
 HEAP8[196313] = 0;
}

function mbedtls_sha1_init($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 memset(HEAP32[$1 + 12 >> 2], 0, 92);
 __stack_pointer = $1 + 16 | 0;
}

function mbedtls_aes_init($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 memset(HEAP32[$1 + 12 >> 2], 0, 280);
 __stack_pointer = $1 + 16 | 0;
}

function jspeBlockStart() {
 var $0 = 0;
 HEAP8[364364] = HEAPU8[364364] + 1;
 $0 = __stack_pointer - 16 | 0;
 HEAP32[$0 + 12 >> 2] = HEAP32[91090];
 HEAP32[91090] = 0;
 return HEAP32[$0 + 12 >> 2];
}

function tflite__NumDimensions_28TfLiteTensor_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2] >> 2];
}

function tflite__MemoryPlanner__MemoryPlanner_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 >> 2] = 189968;
 return $0;
}

function tflite__ErrorReporter__ErrorReporter_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 >> 2] = 190052;
 return $0;
}

function jsvStringIteratorHasChar($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAPU32[HEAP32[$1 + 12 >> 2] >> 2] < HEAPU32[HEAP32[$1 + 12 >> 2] + 4 >> 2];
}

function jsvGetLocks($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 return (HEAPU8[$0 + 12 | 0] | HEAPU8[$0 + 13 | 0] << 8) >>> 10 & 15;
}

function unsigned_20int_20flatbuffers__EndianScalar_unsigned_20int__28unsigned_20int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function unsigned_20char_20flatbuffers__EndianScalar_unsigned_20char__28unsigned_20char_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 return HEAPU8[$1 + 15 | 0];
}

function jswrap_espruino_stopEventPropagation() {
 label$1: {
  if (HEAPU16[182206] & 8192) {
   HEAP16[182206] = HEAPU16[182206] | 16384;
   break label$1;
  }
  jsExceptionHere(1, 119587, 0);
 }
}

function tflite__SimpleMemoryAllocator__GetBufferHead_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] + 8 >> 2];
}

function tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function tflite__OpResolver__OpResolver_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 >> 2] = 190152;
 return $0;
}

function tflite__NumOutputs_28TfLiteNode_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[HEAP32[$1 + 12 >> 2] + 4 >> 2] >> 2];
}

function tflite__RuntimeShape__RuntimeShape_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = HEAP32[$1 + 12 >> 2];
 HEAP32[$0 >> 2] = 0;
 return $0;
}

function tflite__BuiltinDataAllocator___BuiltinDataAllocator_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function signed_20char_20flatbuffers__EndianScalar_signed_20char__28signed_20char_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 return HEAP8[$1 + 15 | 0];
}

function jswrap_banglejs_setBarometerPower($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return 0;
}

function tflite__SimpleMemoryAllocator__GetTail_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] + 20 >> 2];
}

function jswrap_banglejs_setCompassPower($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return 0;
}

function isNumericInline_1($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 $2 = HEAP8[$1 + 15 | 0] >= 48 ? HEAP8[$1 + 15 | 0] <= 57 : $2;
 return $2;
}

function tflite__NumInputs_28TfLiteNode_20const__29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[HEAP32[$1 + 12 >> 2] >> 2] >> 2];
}

function jswrap_banglejs_barometerRd($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return 0;
}

function jspeBlock() {
 if (jslMatch(123) & 1) {
  jspeBlockNoBrackets();
  if (!(HEAP32[91094] & 80)) {
   label$3: {
    if (jslMatch(125) & 1) {
     break label$3;
    }
   }
  }
 }
}

function isNumericInline($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 $2 = HEAP8[$1 + 15 | 0] >= 48 ? HEAP8[$1 + 15 | 0] <= 57 : $2;
 return $2;
}

function jswrap_banglejs_setHRMPower($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return 0;
}

function jswrap_banglejs_setGPSPower($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return 0;
}

function jswrap_banglejs_compassRd($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return 0;
}

function tflite__RuntimeShape__DimensionsCount_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2];
}

function flatbuffers__Vector_unsigned_20char___Data_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] + 4 | 0;
}

function jswrap_banglejs_accelRd($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return 0;
}

function jswrap_banglejs_hrmRd($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return 0;
}

function std____2____libcpp_numeric_limits_signed_20char_2c_20true___lowest_28_29() {
 return std____2____libcpp_numeric_limits_signed_20char_2c_20true___min_28_29() << 24 >> 24;
}

function flatbuffers__Vector_long_20long___Data_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] + 4 | 0;
}

function tflite__MicroAllocator___MicroAllocator_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function tflite__RuntimeShape__DimsDataUpTo5D_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] + 4 | 0;
}

function gen_jswrap_NRF_setAdvertising($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
}

function tflite__MemoryPlanner___MemoryPlanner_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function tflite__ErrorReporter___ErrorReporter_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_banglejs_barometerWr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
}

function gen_jswrap_NRF_setServices($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
}

function jswrap_banglejs_compassWr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
}

function flatbuffers__Vector_float___Data_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] + 4 | 0;
}

function jsvConvertFromUTF8Index($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[$2 + 8 >> 2];
}

function float_20flatbuffers__EndianScalar_float__28float_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF32[$1 + 12 >> 2] = $0;
 return HEAPF32[$1 + 12 >> 2];
}

function flatbuffers__Vector_char___Data_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] + 4 | 0;
}

function tf_get_size($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[$2 + 12 >> 2] + 560 | 0;
}

function jswrap_banglejs_touchWr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
}

function flatbuffers__Vector_int___Data_28_29_20const($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] + 4 | 0;
}

function tflite__OpResolver___OpResolver_28_29($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function jswrap_banglejs_setStepCount($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[97767] = HEAP32[$1 + 12 >> 2];
}

function jswrap_banglejs_setPollInterval_internal($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP16[$1 + 14 >> 1] = $0;
 HEAP16[195511] = HEAPU16[$1 + 14 >> 1];
}

function jsvConvertToUTF8Index($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
 return HEAP32[$2 + 8 >> 2];
}

function jswrap_banglejs_hrmWr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
}

function utilTimerIsFull() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 HEAP8[$0 + 15 | 0] = HEAPU8[366353] + 1 & 15;
 return HEAPU8[$0 + 15 | 0] == HEAPU8[366354];
}

function lcdMemLCD_getRowPtr($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return Math_imul(HEAP32[$1 + 12 >> 2], 68) + 378850 | 0;
}

function jspSoftKill() {
 jsvUnLock(HEAP32[91088]);
 HEAP32[91088] = 0;
 jsvUnLock(HEAP32[91087]);
 HEAP32[91087] = 0;
 jsvUnLock(HEAP32[91086]);
 HEAP32[91086] = 0;
}

function std____2____libcpp_numeric_limits_float_2c_20true___lowest_28_29() {
 return Math_fround(-std____2____libcpp_numeric_limits_float_2c_20true___max_28_29());
}

function jsvObjectIteratorHasValue_18($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_17($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_16($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_15($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_14($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_13($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_12($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_11($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_10($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_9($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_8($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_7($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_6($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_5($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_4($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_3($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_2($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvObjectIteratorHasValue_1($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function jsvInit($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 jsvReset();
 __stack_pointer = $1 + 16 | 0;
}

function jsGfxChanged() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 HEAP8[$0 + 15 | 0] = HEAP8[366872] & 1;
 HEAP8[366872] = 0;
 return HEAP8[$0 + 15 | 0] & 1;
}

function int_20flatbuffers__EndianScalar_int__28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function std____2__numeric_limits_signed_20char___lowest_28_29() {
 return std____2____libcpp_numeric_limits_signed_20char_2c_20true___lowest_28_29() << 24 >> 24;
}

function ruy__profiler__ScopeLabel___ScopeLabel_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvGetAddressOf($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP16[$1 + 14 >> 1] = $0;
 return Math_imul(HEAPU16[$1 + 14 >> 1], 14) + 196314 | 0;
}

function jshPinAnalog($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 HEAPF64[$1 >> 3] = 0;
 return +HEAPF64[$1 >> 3];
}

function gemmlowp__FixedPoint_int_2c_2012___raw_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function jsvObjectIteratorHasValue($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] != 0;
}

function gemmlowp__FixedPoint_int_2c_205___raw_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function gemmlowp__FixedPoint_int_2c_204___raw_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function gemmlowp__FixedPoint_int_2c_202___raw_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function gemmlowp__FixedPoint_int_2c_201___raw_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function gemmlowp__FixedPoint_int_2c_200___raw_28_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2];
}

function TfLiteIntArrayGetSizeInBytes($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return (HEAP32[$1 + 12 >> 2] << 2) + 4 | 0;
}

function __stdio_seek($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $2 = __lseek(HEAP32[$0 + 60 >> 2], $1, $2, $3);
 return $2 | 0;
}

function tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator__operator_20delete_28void__29($0) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
}

function int_20gemmlowp__BitNot_int__28int_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] ^ -1;
}

function jshSPISend($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 11 | 0] = $0;
 HEAP32[$2 + 4 >> 2] = $1;
 return HEAP32[$2 + 12 >> 2];
}

function jsfGetFileFlags($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] >>> 24 | 0;
}

function std____2__numeric_limits_signed_20char___min_28_29() {
 return std____2____libcpp_numeric_limits_signed_20char_2c_20true___min_28_29() << 24 >> 24;
}

function std____2__numeric_limits_signed_20char___max_28_29() {
 return std____2____libcpp_numeric_limits_signed_20char_2c_20true___max_28_29() << 24 >> 24;
}

function jsfGetFileSize($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[HEAP32[$1 + 12 >> 2] >> 2] & 16777215;
}

function std____2__numeric_limits_unsigned_20char___min_28_29() {
 return std____2____libcpp_numeric_limits_unsigned_20char_2c_20true___min_28_29() & 255;
}

function std____2__numeric_limits_unsigned_20char___max_28_29() {
 return std____2____libcpp_numeric_limits_unsigned_20char_2c_20true___max_28_29() & 255;
}

function tflite__BuiltinDataAllocator___BuiltinDataAllocator_28_29_1($0) {
 $0 = $0 | 0;
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
 abort();
}

function is_finishing($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP8[HEAP32[$1 + 12 >> 2] + 11 | 0] & 1;
}

function jshKickSoftWatchDog() {
 jswrap_banglejs_kickPollWatchdog();
 if (HEAP32[91094] & 4096) {
  HEAP32[91094] = HEAP32[91094] & -4097 | 2048;
 }
}

function jsfGetFlag($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP8[$1 + 15 | 0] = $0;
 return (HEAPU8[196320] & HEAPU8[$1 + 15 | 0]) != 0;
}

function jslCharPosClear($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 HEAP32[HEAP32[$1 + 12 >> 2] + 12 >> 2] = 0;
}

function jsiCtrlC() {
 if (!(jsiPasswordProtected() & 1 | !(HEAPU8[364428] < 2 | HEAPU8[364428] > 4))) {
  HEAP32[91094] = HEAP32[91094] | 2048;
 }
}

function jswrap_banglejs_beep_callback() {
 HEAP16[195569] = 0;
 if (HEAP32[97749] & 128) {
  _jswrap_banglejs_setVibration();
 }
 jshHadEvent();
}

function abs_28double_29($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 return Math_abs(HEAPF64[$1 + 8 >> 3]);
}

function jsfAlignAddress($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return HEAP32[$1 + 12 >> 2] + 3 & -4;
}

function __wasm_i64_udiv($0, $1, $2, $3) {
 $3 = _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E($0, $1, $2, $3);
 return $3;
}

function tflite__MicroOpResolver___MicroOpResolver_28_29_1($0) {
 $0 = $0 | 0;
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
 abort();
}

function std____2__numeric_limits_short___min_28_29() {
 return std____2____libcpp_numeric_limits_short_2c_20true___min_28_29() << 16 >> 16;
}

function std____2__numeric_limits_short___max_28_29() {
 return std____2____libcpp_numeric_limits_short_2c_20true___max_28_29() << 16 >> 16;
}

function jstSystemTimeChanged($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 12 >> 2] = $1;
}

function jsiInputLineCursorMoved() {
 if (HEAP32[91112]) {
  jsvStringIteratorFree_5(364436);
  HEAP32[91112] = 0;
 }
 HEAP32[48917] = -1;
}

function __wasm_rotl_i32($0, $1) {
 var $2 = 0;
 $2 = $1 & 31;
 $1 = 0 - $1 & 31;
 return (-1 >>> $2 & $0) << $2 | (-1 << $1 & $0) >>> $1;
}

function __wasm_i64_sdiv($0, $1, $2, $3) {
 $3 = _ZN17compiler_builtins3int4sdiv3Div3div17he78fc483e41d7ec7E($0, $1, $2, $3);
 return $3;
}

function tflite__MemoryPlanner___MemoryPlanner_28_29_1($0) {
 $0 = $0 | 0;
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
 abort();
}

function tflite__ErrorReporter___ErrorReporter_28_29_1($0) {
 $0 = $0 | 0;
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
 abort();
}

function jshUtilTimerStart($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 12 >> 2] = $1;
}

function legalfunc$__wasi_fd_seek($0, $1, $2, $3, $4) {
 return legalimport$__wasi_fd_seek($0 | 0, $1 | 0, $2 | 0, $3 | 0, $4 | 0) | 0;
}

function jshSetSystemTime($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 12 >> 2] = $1;
}

function __wasm_i64_mul($0, $1, $2, $3) {
 $3 = _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE($0, $1, $2, $3);
 return $3;
}

function std____2__numeric_limits_float___lowest_28_29() {
 return std____2____libcpp_numeric_limits_float_2c_20true___lowest_28_29();
}

function jsfEraseAll() {
 jsfCacheClear();
 HEAP32[91095] = 0;
 HEAP32[91096] = 0;
 return jshFlashErasePages(134217728, 8388608) & 1;
}

function jsvIsUndefined($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAP32[$1 + 12 >> 2] = $0;
 return !HEAP32[$1 + 12 >> 2];
}

function jshSPISetReceive($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
}

function tflite__MicroMutableOpResolver_9u___operator_20delete_28void__29($0) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
}

function fp_barrierf($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF32[$1 + 12 >> 2] = $0;
 return HEAPF32[$1 + 12 >> 2];
}

function tflite__OpResolver___OpResolver_28_29_1($0) {
 $0 = $0 | 0;
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
 abort();
}

function jshUSARTSetup($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
}

function jshPinSetState($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
}

function jsfCachePut($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP32[$2 + 12 >> 2] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
}

function jshSPISend16($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
}

function std____2__numeric_limits_float___max_28_29() {
 return std____2____libcpp_numeric_limits_float_2c_20true___max_28_29();
}

function jshSPISetup($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
}

function jshI2CSetup($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP32[$2 + 8 >> 2] = $1;
}

function fp_barrier($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 return HEAPF64[$1 + 8 >> 3];
}

function tflite__GreedyMemoryPlanner__per_buffer_size_28_29() {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = 40;
 return 40;
}

function jshSPISet16($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 HEAP8[$2 + 15 | 0] = $0;
 HEAP8[$2 + 14 | 0] = $1;
}

function tflite__SimpleMemoryAllocator__operator_20delete_28void__29($0) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
}

function tflite__EspruinoErrorReporter__operator_20delete_28void__29($0) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
}

function tflite__GreedyMemoryPlanner__operator_20delete_28void__29($0) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
}

function std____2__numeric_limits_int___min_28_29() {
 return std____2____libcpp_numeric_limits_int_2c_20true___min_28_29();
}

function std____2__numeric_limits_int___max_28_29() {
 return std____2____libcpp_numeric_limits_int_2c_20true___max_28_29();
}

function jswrap_terminal_idle() {
 if (HEAP8[391323] & 1) {
  graphicsInternalFlip();
  HEAP8[391323] = 0;
 }
 return 0;
}

function tflite__MicroAllocator__operator_20delete_28void__29($0) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
}

function terminalControlCharsReset() {
 HEAP8[391324] = 0;
 HEAP8[391325] = 0;
 HEAP8[391326] = 0;
 HEAP8[391327] = 0;
}

function std____2____libcpp_numeric_limits_float_2c_20true___max_28_29() {
 return Math_fround(34028234663852886e22);
}

function jshResetPinStateIsManual() {
 HEAP32[91097] = 0;
 HEAP32[91098] = 0;
 HEAP32[91099] = 0;
 HEAP32[91100] = 0;
}

function gemmlowp__FixedPoint_int_2c_200___ScalarRawMax_28_29() {
 return std____2__numeric_limits_int___max_28_29();
}

function jswrap_espruino_fromUTF8($0) {
 $0 = $0 | 0;
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
 return 0;
}

function gen_jswrap_Bangle_showRecoveryMenu() {
 jsvUnLock(jspExecuteJSFunctionCode(148267, 143325, 1057, 0, 0, 0));
}

function jswrap_espruino_isUTF8($0) {
 $0 = $0 | 0;
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
 return 0;
}

function stackAlloc($0) {
 $0 = $0 | 0;
 $0 = __stack_pointer - $0 & -16;
 __stack_pointer = $0;
 return $0 | 0;
}

function jswrap_banglejs_buzz_callback() {
 HEAP8[391136] = 0;
 _jswrap_banglejs_setVibration();
 jshHadEvent();
}
function gen_jswrap_Bangle_showLauncher() {
 jsvUnLock(jspExecuteJSFunctionCode(148267, 135111, 506, 0, 0, 0));
}

function __wasi_syscall_ret($0) {
 if (!$0) {
  return 0;
 }
 HEAP32[__errno_location() >> 2] = $0;
 return -1;
}

function gen_jswrap_Bangle_loadWidgets() {
 jsvUnLock(jspExecuteJSFunctionCode(148267, 115788, 258, 0, 0, 0));
}

function gen_jswrap_Bangle_drawWidgets() {
 jsvUnLock(jspExecuteJSFunctionCode(148267, 114195, 382, 0, 0, 0));
}

function jswrap_banglejs_setLCDOffset($0) {
 $0 = $0 | 0;
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
}

function gen_jswrap_Bangle_showClock() {
 jsvUnLock(jspExecuteJSFunctionCode(148267, 143095, 23, 0, 0, 0));
}

function jsfGetBankEndAddress($0) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
 return 142606336;
}

function jswrap_banglejs_gps_character($0) {
 HEAP8[(__stack_pointer - 16 | 0) + 15 | 0] = $0;
 return 1;
}

function dynCall_jiji($0, $1, $2, $3, $4) {
 $3 = FUNCTION_TABLE[$0 | 0]($1, $2, $3, $4) | 0;
 return $3;
}

function jswrap_terminal_init() {
 terminalControlCharsReset();
 HEAP8[391322] = 0;
 HEAP8[195720] = 21;
}

function jsiPacketFileEnd() {
 jsvObjectRemoveChild(HEAP32[91087], 137821);
 jsiPacketFileSetTimeout(0);
}

function __stdio_close($0) {
 $0 = $0 | 0;
 return __wasi_fd_close(dummy(HEAP32[$0 + 60 >> 2]) | 0) | 0;
}

function jswrap_graphics_getInstance() {
 return jsvObjectGetChildIfExists(HEAP32[91087], 116423) | 0;
}

function jspeAssignmentExpression() {
 return __jspeAssignmentExpression(jspeConditionalExpression());
}

function top12($0) {
 return (wasm2js_scratch_store_f32($0), wasm2js_scratch_load_i32(2)) >>> 20 | 0;
}

function get_input_buffer_size($0) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
 return 256;
}

function jslSingleChar() {
 HEAP16[HEAP32[49079] + 2 >> 1] = HEAPU8[HEAP32[49079]];
 jslGetNextCh();
}

function strchr($0, $1) {
 $0 = __strchrnul($0, $1);
 return HEAPU8[$0 | 0] == ($1 & 255) ? $0 : 0;
}

function jspeConditionalExpression() {
 return __jspeConditionalExpression(jspeBinaryExpression());
}

function jshIdle() {
 if (HEAP8[195676] & 1) {
  jsiOneSecondAfterStartup();
 }
 HEAP8[195676] = 0;
}

function __math_xflowf($0, $1) {
 return Math_fround(fp_barrierf($0 ? Math_fround(-$1) : $1) * $1);
}

function jshIsDeviceInitialised($0) {
 HEAP8[(__stack_pointer - 16 | 0) + 15 | 0] = $0;
 return 1;
}

function std____2____libcpp_numeric_limits_unsigned_20char_2c_20true___max_28_29() {
 return 255;
}

function get_lookahead_size($0) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
 return 64;
}

function __wasm_ctz_i32($0) {
 if ($0) {
  return 31 - Math_clz32($0 - 1 ^ $0) | 0;
 }
 return 32;
}
function std____2____libcpp_numeric_limits_signed_20char_2c_20true___min_28_29() {
 return -128;
}

function gen_jswrap_LED2() {
 return jspExecuteJSFunctionCode(148267, 113990, 204, 0, 0, 0) | 0;
}

function gen_jswrap_LED1() {
 return jspExecuteJSFunctionCode(148267, 113785, 204, 0, 0, 0) | 0;
}

function std____2____libcpp_numeric_limits_unsigned_20char_2c_20true___min_28_29() {
 return 0;
}

function std____2____libcpp_numeric_limits_signed_20char_2c_20true___max_28_29() {
 return 127;
}

function jswInit() {
 jswrap_graphics_init();
 jswrap_banglejs_init();
 jswrap_terminal_init();
}

function jshSetSystemClock($0) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
 return 0;
}

function jsfCacheFind($0, $1) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $1;
 return -1;
}

function jswrap_modules_getModuleList() {
 return jsvObjectGetChild(HEAP32[91087], 120238, 5);
}

function jswrap_banglejs_getPressure() {
 return HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2];
}

function flatbuffers__EndianCheck_28_29() {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = 1;
}

function std____2____libcpp_numeric_limits_int_2c_20true___min_28_29() {
 return -2147483648;
}

function std____2____libcpp_numeric_limits_int_2c_20true___max_28_29() {
 return 2147483647;
}

function jsvGetProcessorPowerUsage($0) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
}

function jswKill() {
 jswrap_banglejs_kill();
 jswrap_pipe_kill();
 jswrap_waveform_kill();
}

function jspeBinaryExpression() {
 return __jspeBinaryExpression(jspeUnaryExpression(), 0);
}

function _parse_int() {
 return stringToIntWithRadix(jslGetTokenValueAsString(), 10, 0, 0);
}

function std____2____libcpp_numeric_limits_short_2c_20true___min_28_29() {
 return -32768;
}

function jshPinGetState($0) {
 HEAP8[(__stack_pointer - 16 | 0) + 15 | 0] = $0;
 return 0;
}

function __math_uflowf($0) {
 return __math_xflowf($0, Math_fround(2524354896707238e-44));
}

function __math_oflowf($0) {
 return __math_xflowf($0, Math_fround(15845632502852868e13));
}

function std____2____libcpp_numeric_limits_short_2c_20true___max_28_29() {
 return 32767;
}

function jshDelayMicroseconds($0) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
}

function jshCanWatch($0) {
 HEAP8[(__stack_pointer - 16 | 0) + 15 | 0] = $0;
 return 1;
}

function jswrap_banglejs_getOptions() {
 return _jswrap_banglejs_setOptions(0, 1) | 0;
}

function jswrap_banglejs_isBacklightOn() {
 return (HEAP32[97749] & 131072) != 0 | 0;
}

function gen_jswrap_Math_random() {
 return +(+(rand() | 0) * 4.656612873077393e-10);
}

function jswrap_banglejs_isBarometerOn() {
 return (HEAP32[97749] & 32768) != 0 | 0;
}

function jsvReset() {
 HEAP16[98162] = 0;
 memset(196328, 0, 168e3);
 jsvSoftInit();
}

function jshEnableWatchDog($0) {
 HEAPF64[(__stack_pointer - 16 | 0) + 8 >> 3] = $0;
}

function jswOnCustomEvent($0) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
}

function jswrap_banglejs_isCompassOn() {
 return (HEAP32[97749] & 16384) != 0 | 0;
}

function emscripten_stack_init() {
 __stack_base = 5634240;
 __stack_end = 391360;
}

function emscripten_stack_get_free() {
 return __stack_pointer - __stack_end | 0;
}

function jswrap_banglejs_isLocked() {
 return (HEAP32[97749] & 262144) != 0 | 0;
}

function jsiPacketTimeoutHandler() {
 jsiConsolePrintChar(21);
 jsiPacketExit();
}

function jshUSARTUnSetup($0) {
 HEAP8[(__stack_pointer - 16 | 0) + 15 | 0] = $0;
}

function jsiGetHistory() {
 return jsvObjectGetChild(HEAP32[91087], 116128, 3);
}

function jswrap_banglejs_isLCDOn() {
 return (HEAP32[97749] & 65536) != 0 | 0;
}

function jswrap_banglejs_isCharging() {
 return (jshPinGetValue(23) ^ -1) & 1;
}

function do_indexing($0) {
 HEAP32[(__stack_pointer - 16 | 0) + 12 >> 2] = $0;
}

function jswrap_banglejs_isHRMOn() {
 return (HEAP32[97749] & 4096) != 0 | 0;
}

function jswrap_banglejs_isGPSOn() {
 return (HEAP32[97749] & 8192) != 0 | 0;
}

function jshUSARTKick($0) {
 HEAP8[(__stack_pointer - 16 | 0) + 15 | 0] = $0;
}

function gen_jswrap_process_version() {
 return jsvNewFromString(139436) | 0;
}

function __math_uflow($0) {
 return __math_xflow($0, 12882297539194267e-247);
}

function jspeiClearScopes() {
 jsvUnLock(HEAP32[91088]);
 HEAP32[91088] = 0;
}

function gen_jswrap_NRF_getAddress() {
 return jsvNewFromString(135713) | 0;
}

function jswrap_serial_constructor() {
 return jspNewObject(0, 129076) | 0;
}

function jshSPIWait($0) {
 HEAP8[(__stack_pointer - 16 | 0) + 15 | 0] = $0;
}

function jsIdle() {
 HEAP32[48918] = -1;
 jsiLoop();
 return HEAP32[48918];
}

function gen_jswrap_LoopbackB() {
 return jspNewObject(138143, 129076) | 0;
}

function gen_jswrap_LoopbackA() {
 return jspNewObject(138201, 129076) | 0;
}

function abs($0) {
 var $1 = 0;
 $1 = $0 >> 31;
 return ($1 ^ $0) - $1 | 0;
}

function __math_oflow($0) {
 return __math_xflow($0, 3105036184601418e216);
}

function jswrap_espruino_getTemperature() {
 return +jshReadTemperature();
}

function gen_jswrap_Terminal() {
 return jspNewObject(129058, 129076) | 0;
}

function jshHasTransmitData() {
 return HEAPU8[364484] != HEAPU8[364485];
}

function gen_jswrap_Serial1() {
 return jspNewObject(139865, 129076) | 0;
}

function gen_jswrap_NRF_getSecurityStatus() {
 return jsvNewObject() | 0;
}

function jswrap_spi_constructor() {
 return jspNewObject(0, 137555) | 0;
}

function jswrap_serial_idle() {
 return jsserialEventCallbackIdle() & 1;
}

function jswrap_i2c_constructor() {
 return jspNewObject(0, 138134) | 0;
}

function jsiPasswordProtected() {
 return (HEAPU16[182206] & 1024) != 0;
}

function gen_jswrap_TFMicroInterpreter_TFMicroInterpreter() {
 return 0;
}

function gen_jswrap_Number_MIN_VALUE() {
 return 22250738585072014e-324;
}

function jsiConsoleEraseAfterCursor() {
 jsiConsolePrintString(137458);
}

function gen_jswrap_Number_MAX_VALUE() {
 return 17976931348623157e292;
}

function __math_xflow($0, $1) {
 return fp_barrier($0 ? -$1 : $1) * $1;
}

function jswrap_espruino_getClock() {
 return jshGetSystemClock() | 0;
}

function jshIOEventOverflowed() {
 HEAP8[364342] = HEAPU8[364342] | 1;
}

function gen_jswrap_SPI1() {
 return jspNewObject(139913, 137555) | 0;
}

function gen_jswrap_I2C1() {
 return jspNewObject(139927, 138134) | 0;
}

function gen_jswrap_USB() {
 return jspNewObject(138161, 129076) | 0;
}

function jswrap_banglejs_softOff() {
 jsExceptionHere(1, 120874, 0);
}

function jsvIsMemoryFull() {
 return (HEAPU16[98162] != 0 ^ -1) & 1;
}

function jsiTimersChanged() {
 HEAP16[182206] = HEAPU16[182206] | 4;
}

function __cxa_pure_virtual() {
 abort_message(145807, 0);
 abort();
}

function tflite__EnumNamesBuiltinOperator_28_29() {
 return 189248;
}

function jswrap_global() {
 return jsvLockAgain(HEAP32[91086]) | 0;
}

function jshInitDevices() {
 HEAP8[364488] = 0;
 jshResetDevices();
}

function jshHasEvents() {
 return HEAPU8[364486] != HEAPU8[364487];
}

function jsfCreateFileTable() {
 jsfBankCreateFileTable(134217728);
}

function gen_jswrap_Number_NEGATIVE_INFINITY() {
 return -infinity;
}

function jswrap_banglejs_kickPollWatchdog() {
 HEAP16[195512] = 0;
}

function jsvNewFromEmptyString_14() {
 return jsvNewWithFlags(28);
}

function jsvNewFromEmptyString_13() {
 return jsvNewWithFlags(28);
}

function jsvNewFromEmptyString_12() {
 return jsvNewWithFlags(28);
}

function jsvNewFromEmptyString_11() {
 return jsvNewWithFlags(28);
}

function jsvNewFromEmptyString_10() {
 return jsvNewWithFlags(28);
}

function jspSetNoExecute() {
 HEAP32[91094] = HEAP32[91094] & -64;
}

function gen_jswrap_Number_POSITIVE_INFINITY() {
 return infinity;
}

function gen_jswrap_ArrayBufferView_ArrayBufferView() {
 return 0;
}

function jsvNewFromEmptyString_9() {
 return jsvNewWithFlags(28);
}

function jsvNewFromEmptyString_8() {
 return jsvNewWithFlags(28);
}

function jsvNewFromEmptyString_7() {
 return jsvNewWithFlags(28);
}

function jsvNewFromEmptyString_6() {
 return jsvNewWithFlags(28);
}

function jsvNewFromEmptyString_5() {
 return jsvNewWithFlags(28);
}

function jsvNewFromEmptyString_4() {
 return jsvNewWithFlags(28);
}

function jsvNewFromEmptyString_3() {
 return jsvNewWithFlags(28);
}

function jsvNewFromEmptyString_2() {
 return jsvNewWithFlags(28);
}

function jsvNewFromEmptyString_1() {
 return jsvNewWithFlags(28);
}

function stackRestore($0) {
 $0 = $0 | 0;
 __stack_pointer = $0;
}

function jswrap_espruino_dumpTimers() {
 jstDumpUtilityTimers();
}

function jswrap_banglejs_off() {
 jsExceptionHere(1, 120874, 0);
}

function jswrap_banglejs_getStepCount() {
 return HEAP32[97767];
}

function jspIsInterrupted() {
 return (HEAP32[91094] & 16) != 0;
}

function emscripten_stack_get_base() {
 return __stack_base | 0;
}

function jswrap_espruino_reboot() {
 jswrap_interface_reset(0);
}

function jsvNewFromEmptyString() {
 return jsvNewWithFlags(28);
}

function gen_jswrap_Math_SQRT1_2() {
 return .7071067811865476;
}

function gen_jswrap_E_getAnalogVRef() {
 return +jshReadVRef();
}

function jspromise_create() {
 return jspNewObject(0, 132091);
}

function jsfIsNameEqual($0, $1) {
 return !memcmp($0, $1, 28);
}

function gen_jswrap_Math_SQRT2() {
 return 1.4142135623730951;
}

function gen_jswrap_Math_LOG2E() {
 return 1.4426950408889634;
}

function gen_jswrap_Math_LOG10E() {
 return .4342944819032518;
}

function emscripten_stack_get_end() {
 return __stack_end | 0;
}

function jswrap_graphics_idle() {
 graphicsIdle();
 return 0;
}

function jswrap_espruino_kickWatchdog() {
 jshKickWatchDog();
}

function jstUtilTimerIsRunning() {
 return HEAP8[366355] & 1;
}

function jsiPacketFileTimeoutHandler() {
 jsiPacketFileEnd();
}

function jspHasError() {
 return (HEAP32[91094] & 112) != 0;
}

function jslPreload() {
 jslGetNextCh();
 jslGetNextToken();
}

function gen_jswrap_Math_LN10() {
 return 2.302585092994046;
}

function jswrap_storage_optimise() {
 jsfCreateFileTable();
}

function jsfSaveToFlash() {
 jsiConsolePrintString(147054);
}

function gen_jswrap_Math_LN2() {
 return .6931471805599453;
}

function graphicsInternalFlip() {
 lcdMemLCD_flip(366800);
}

function gen_jswrap_StorageFile_StorageFile() {
 return 0;
}

function gen_jswrap_Math_PI() {
 return 3.141592653589793;
}

function jsvNewEmptyArray() {
 return jsvNewWithFlags(3);
}

function jstGetUtilTimerOffset() {
 return HEAP32[91692];
}

function gen_jswrap_Math_E() {
 return 2.718281828459045;
}

function strcpy($0, $1) {
 __stpcpy($0, $1);
 return $0;
}

function jsiGetConsoleDevice() {
 return HEAPU8[195664];
}

function gen_jswrap_tensorflow_tensorflow() {
 return 0;
}

function gen_jswrap_heatshrink_heatshrink() {
 return 0;
}

function floor($0) {
 $0 = +$0;
 return +Math_floor($0);
}

function __wasm_call_ctors() {
 emscripten_stack_init();
}

function __ofl_lock() {
 __lock(391336);
 return 391340;
}

function jsKill() {
 jsiKill();
 jsvKill();
 jshKill();
}

function jswGetBuiltInLibraryNames() {
 return 117166;
}

function gen_jswrap_Bluetooth_Bluetooth() {
 return 0;
}

function ceil($0) {
 $0 = +$0;
 return +Math_ceil($0);
}

function jsvNewObject() {
 return jsvNewWithFlags(5);
}

function jsvNewNull_1() {
 return jsvNewWithFlags(2);
}

function fabs($0) {
 $0 = +$0;
 return +Math_abs($0);
}

function jswrap_storage_eraseAll() {
 jsfEraseAll();
}

function jsiEcho() {
 return !(HEAPU16[182206] & 3);
}

function gen_jswrap_Graphics_Graphics() {
 return 0;
}

function abort_message($0, $1) {
 abort();
 abort();
}

function stackSave() {
 return __stack_pointer | 0;
}

function jswrap_banglejs_getBattery() {
 return 50;
}

function jsvNewNull() {
 return jsvNewWithFlags(2);
}

function jshGetRandomNumber() {
 return rand() | 0;
}

function jswrap_espruino_getBattery() {
 return 0;
}

function jswrap_banglejs_getCompass() {
 return 0;
}

function jsvSoftInit() {
 jsvCreateEmptyVarList();
}

function gen_jswrap_process_process() {
 return 0;
}

function gen_jswrap_console_console() {
 return 0;
}

function gen_jswrap_Storage_Storage() {
 return 0;
}

function gen_jswrap_Modules_Modules() {
 return 0;
}

function gen_jswrap_Infinity() {
 return infinity;
}

function jswrap_banglejs_getGPSFix() {
 return 0;
}

function jswHWInit() {
 jswrap_banglejs_hwinit();
}

function jsvSoftKill() {
 jsvClearEmptyVarList();
}

function gen_jswrap_dump() {
 jsiDumpState(7, 0);
}

function jsiKill() {
 jsiSoftKill();
 jspKill();
}

function gen_jswrap_crypto_crypto() {
 return 0;
}

function gen_jswrap_Bangle_Bangle() {
 return 0;
}

function jshIsUSBSERIALConnected() {
 return 1;
}

function gen_jswrap_Number_NaN() {
 return nan;
}

function gen_jswrap_Flash_Flash() {
 return 0;
}

function __errno_location() {
 return 391348;
}

function jsvGetMemoryTotal() {
 return 12e3;
}

function jshReadTemperature() {
 return nan;
}

function jshHadEvent() {
 HEAP8[366784] = 1;
}

function gen_jswrap_Math_Math() {
 return 0;
}

function gen_jswrap_JSON_JSON() {
 return 0;
}

function __ofl_unlock() {
 __unlock(391336);
}

function gen_jswrap_VIBRATE() {
 return 19;
}

function gen_jswrap_Bluetooth_setConsole() {}

function gen_jswrap_NRF_NRF() {
 return 0;
}

function gen_jswrap_AES_AES() {
 return 0;
}

function jsuGetFreeStack() {
 return 1e6;
}

function jshReset() {
 jshResetDevices();
}

function jshGetSystemClock() {
 return 0;
}

function jswrap_banglejs_resetCompass() {}

function jshIsInInterrupt() {
 return 0;
}

function gen_jswrap_fs_fs() {
 return 0;
}

function gen_jswrap_NaN() {
 return nan;
}

function gen_jswrap_BTN1() {
 return 17;
}

function gen_jswrap_HIGH() {
 return 1;
}

function gen_jswrap_BTN() {
 return 17;
}

function gen_jswrap_LOW() {
 return 0;
}

function gen_jswrap_E_E() {
 return 0;
}

function jshReadVRef() {
 return nan;
}

function jswrap_banglejs_postInit() {}

function jspInit() {
 jspSoftInit();
}

function __lockfile($0) {
 return 1;
}

function jspDebuggerLoopIfCtrlC() {}

function jsfLoadStateFromFlash() {}

function dummy($0) {
 return $0;
}

function jshUtilTimerDisable() {}

function jsfCacheClearFile($0) {}

function jshKickWatchDog() {}

function jshInterruptOff() {}

function jshInterruptOn() {}

function __unlockfile($0) {}

function jsfCacheClear() {}

function graphicsIdle() {}

function __unlock($0) {}

function __lock($0) {}

function jsvKill() {}

function jshKill() {}


// EMSCRIPTEN_END_FUNCS

;
 bufferView = HEAPU8;
 initActiveSegments(env);
 var FUNCTION_TABLE = Table([null, jswrap_object_toString, jsvStringIteratorPrintfCallback, jsvIsInternalFunctionKey, jsvIsInternalObjectKey, jsvIterateCallbackCountCb, jsvIterateCallbackToBytesCb, vcbprintf_callback_jsiConsolePrintString, espruino_snprintf_cb, jswrap_eval, gen_jswrap_Graphics_Graphics, jswrap_dataview_constructor, jswrap_date_constructor, jswrap_error_constructor, jswrap_syntaxerror_constructor, jswrap_typeerror_constructor, jswrap_internalerror_constructor, jswrap_referenceerror_constructor, jswrap_regexp_constructor, jswrap_onewire_constructor, jswrap_promise_constructor, jswrap_serial_constructor, gen_jswrap_StorageFile_StorageFile, jswrap_spi_constructor, jswrap_i2c_constructor, jswrap_waveform_constructor, gen_jswrap_TFMicroInterpreter_TFMicroInterpreter, jswrap_pin_constructor, gen_jswrap_Bangle_Bangle, gen_jswrap_E_E, gen_jswrap_NRF_NRF, gen_jswrap_Bluetooth_Bluetooth, jswrap_array_constructor, gen_jswrap_console_console, gen_jswrap_JSON_JSON, jswrap_number_constructor, jswrap_object_constructor, jswrap_string_constructor, gen_jswrap_Modules_Modules, gen_jswrap_Math_Math, gen_jswrap_Flash_Flash, gen_jswrap_fs_fs, gen_jswrap_process_process, gen_jswrap_Storage_Storage, gen_jswrap_heatshrink_heatshrink, gen_jswrap_crypto_crypto, gen_jswrap_AES_AES, gen_jswrap_tensorflow_tensorflow, jswrap_arraybuffer_constructor, gen_jswrap_ArrayBufferView_ArrayBufferView, jswrap_function_constructor, jswrap_pin_analog, jswrap_pin_getInfo, jswrap_pin_getMode, jswrap_pin_mode, jswrap_pin_pulse, jswrap_pin_pwm, jswrap_pin_read, jswrap_pin_reset, jswrap_pin_set, jswrap_pin_toggle, jswrap_pin_write, jswrap_pin_writeAtTime, gen_jswrap_BTN, gen_jswrap_BTN1, jswrap_boolean_constructor, gen_jswrap_Float32Array_Float32Array, gen_jswrap_Float64Array_Float64Array, gen_jswrap_HIGH, gen_jswrap_I2C1, gen_jswrap_Infinity, gen_jswrap_Int16Array_Int16Array, gen_jswrap_Int32Array_Int32Array, gen_jswrap_Int8Array_Int8Array, gen_jswrap_LED1, gen_jswrap_LED2, gen_jswrap_LOW, gen_jswrap_LoopbackA, gen_jswrap_LoopbackB, gen_jswrap_NaN, gen_jswrap_SPI1, gen_jswrap_Serial1, gen_jswrap_Terminal, gen_jswrap_USB, gen_jswrap_Uint16Array_Uint16Array, gen_jswrap_Uint24Array_Uint24Array, gen_jswrap_Uint32Array_Uint32Array, gen_jswrap_Uint8Array_Uint8Array, gen_jswrap_Uint8ClampedArray_Uint8ClampedArray, gen_jswrap_VIBRATE, jshPinAnalog, jswrap_io_analogWrite, jswrap_arguments, jswrap_atob, jswrap_btoa, jswrap_interface_changeInterval, jswrap_interface_clearInterval, jswrap_interface_clearTimeout, jswrap_interface_clearWatch, jswrap_decodeURIComponent, jswrap_io_digitalPulse, jswrap_io_digitalRead, jswrap_io_digitalWrite, gen_jswrap_dump, jswrap_interface_echo, jswrap_interface_edit, jswrap_encodeURIComponent, jswrap_io_getPinMode, jswrap_interface_getSerial, gen_jswrap_getTime, jswrap_global, jswrap_isFinite, jswrap_isNaN, jswrap_interface_load, jswrap_parseFloat, jswrap_parseInt, gen_jswrap_peek16, gen_jswrap_peek32, gen_jswrap_peek8, jswrap_io_pinMode, gen_jswrap_poke16, gen_jswrap_poke32, gen_jswrap_poke8, jswrap_print, jswrap_require, jswrap_interface_reset, jswrap_interface_setBusyIndicator, jswrap_interface_setInterval, jswrap_interface_setSleepIndicator, jswrap_interactive_setTime, jswrap_interface_setTimeout, jswrap_interface_setWatch, jswrap_io_shiftOut, jswrap_trace, jswrap_banglejs_accelRd, jswrap_banglejs_appRect, jswrap_banglejs_barometerRd, jswrap_banglejs_barometerWr, jswrap_banglejs_beep, jswrap_banglejs_buzz, jswrap_banglejs_compassRd, jswrap_banglejs_compassWr, jswrap_banglejs_dbg, gen_jswrap_Bangle_drawWidgets, jswrap_banglejs_factoryReset, jswrap_banglejs_getAccel, jswrap_banglejs_getCompass, jswrap_banglejs_getGPSFix, jswrap_banglejs_getHealthStatus, jswrap_banglejs_getLCDMode, jswrap_banglejs_getLogo, jswrap_banglejs_getOptions, jswrap_banglejs_getPressure, jswrap_banglejs_getStepCount, jswrap_banglejs_hrmRd, jswrap_banglejs_hrmWr, jswrap_banglejs_isBacklightOn, jswrap_banglejs_isBarometerOn, jswrap_banglejs_isCharging, jswrap_banglejs_isCompassOn, jswrap_banglejs_isGPSOn, jswrap_banglejs_isHRMOn, jswrap_banglejs_isLCDOn, jswrap_banglejs_isLocked, jswrap_banglejs_lcdWr, gen_jswrap_Bangle_load, gen_jswrap_Bangle_loadWidgets, jswrap_banglejs_off, jswrap_banglejs_project, jswrap_banglejs_resetCompass, jswrap_banglejs_setLCDPowerBacklight, jswrap_banglejs_setBarometerPower, jswrap_banglejs_setCompassPower, jswrap_banglejs_setGPSPower, jswrap_banglejs_setHRMPower, jswrap_banglejs_setLCDBrightness, jswrap_banglejs_setLCDMode, jswrap_banglejs_setLCDOffset, jswrap_banglejs_setLCDOverlay, jswrap_banglejs_setLCDPower, jswrap_banglejs_setLCDTimeout, jswrap_banglejs_setLocked, jswrap_banglejs_setOptions, jswrap_banglejs_setPollInterval, jswrap_banglejs_setStepCount, gen_jswrap_Bangle_setUI, gen_jswrap_Bangle_showClock, gen_jswrap_Bangle_showLauncher, gen_jswrap_Bangle_showRecoveryMenu, jswrap_banglejs_softOff, jswrap_banglejs_touchWr, jswrap_espruino_CRC32, jswrap_espruino_FFT, jswrap_espruino_HSBtoRGB, jswrap_espruino_asUTF8, jswrap_espruino_asm, jswrap_espruino_clip, jswrap_espruino_compiledC, jswrap_espruino_convolve, jswrap_espruino_decodeUTF8, jsvDefragment, jswrap_e_dumpFragmentation, jswrap_e_dumpStr, jswrap_espruino_dumpTimers, jswrap_e_dumpVariables, jswrap_espruino_enableWatchdog, jswrap_espruino_fromUTF8, jswrap_espruino_getAddressOf, gen_jswrap_E_getAnalogVRef, jswrap_espruino_getBattery, jswrap_espruino_getClock, jswrap_espruino_getConsole, jswrap_espruino_getErrorFlags, jsfGetFlags, jswrap_espruino_getPowerUsage, jswrap_espruino_getSizeOf, jswrap_espruino_getTemperature, jshGetRandomNumber, jswrap_espruino_isUTF8, jswrap_espruino_kickWatchdog, jswrap_espruino_lockConsole, jswrap_espruino_lookupNoCase, jswrap_espruino_mapInPlace, jswrap_espruino_memoryArea, jswrap_espruino_memoryMap, jswrap_espruino_nativeCall, jswrap_pipe, jswrap_espruino_reboot, jswrap_espruino_reverseByte, jswrap_espruino_setBootCode, jswrap_espruino_setClock, jswrap_espruino_setConsole, jswrap_espruino_setDST, jsfSetFlags, jswrap_espruino_setPassword, jswrap_espruino_setTimeZone, gen_jswrap_E_showAlert, gen_jswrap_E_showMenu, gen_jswrap_E_showMessage, gen_jswrap_E_showPrompt, gen_jswrap_E_showScroller, srand, jswrap_espruino_stopEventPropagation, jswrap_espruino_sum, jswrap_espruino_toArrayBuffer, jswrap_espruino_toFlatString, jswrap_espruino_toJS, jswrap_espruino_toString, jswrap_espruino_toUint8Array, jswrap_espruino_variance, jswrap_graphics_asBMP, jswrap_graphics_asImage, jswrap_graphics_asURL, jswrap_graphics_blendColor, jswrap_graphics_blit, jswrap_graphics_clear, jswrap_graphics_clearRect, jswrap_graphics_drawCircle, jswrap_graphics_drawCircleAA, jswrap_graphics_drawEllipse, jswrap_graphics_drawImage, jswrap_graphics_drawImages, jswrap_graphics_drawLine, jswrap_graphics_drawLineAA, gen_jswrap_Graphics_drawPoly, gen_jswrap_Graphics_drawPolyAA, jswrap_graphics_drawRect, jswrap_graphics_drawString, jswrap_graphics_dump, jswrap_graphics_fillCircle, jswrap_graphics_fillEllipse, gen_jswrap_Graphics_fillPoly, gen_jswrap_Graphics_fillPolyAA, jswrap_graphics_fillRect, jswrap_graphics_floodFill, jswrap_graphics_getBPP, gen_jswrap_Graphics_getBgColor, gen_jswrap_Graphics_getColor, jswrap_graphics_getFont, jswrap_graphics_getFontHeight, jswrap_graphics_getFonts, gen_jswrap_Graphics_getHeight, jswrap_graphics_getModified, jswrap_graphics_getPixel, jswrap_graphics_getVectorFontPolys, gen_jswrap_Graphics_getWidth, jswrap_graphics_imageMetrics, jswrap_graphics_lineTo, jswrap_graphics_moveTo, jswrap_graphics_quadraticBezier, jswrap_graphics_reset, jswrap_graphics_scroll, gen_jswrap_Graphics_setBgColor, jswrap_graphics_setClipRect, gen_jswrap_Graphics_setColor, jswrap_graphics_setFont, jswrap_graphics_setFont12x20, jswrap_graphics_setFont6x15, jswrap_graphics_setFontAlign, gen_jswrap_Graphics_setFontBitmap, jswrap_graphics_setFontCustom, jswrap_graphics_setFontPBF, gen_jswrap_Graphics_setFontVector, jswrap_graphics_setPixel, jswrap_graphics_setRotation, jswrap_graphics_setTheme, jswrap_graphics_stringMetrics, jswrap_graphics_stringWidth, jswrap_graphics_theme, jswrap_graphics_toColor, jswrap_graphics_transformVertices, jswrap_graphics_wrapString, gen_jswrap_NRF_getAddress, gen_jswrap_NRF_getSecurityStatus, gen_jswrap_NRF_setAdvertising, gen_jswrap_NRF_setServices, gen_jswrap_Bluetooth_setConsole, jswrap_array_concat, jswrap_array_every, jswrap_array_fill, jswrap_array_filter, jswrap_array_find, jswrap_array_findIndex, jswrap_array_forEach, jswrap_array_includes, jswrap_array_indexOf, jswrap_array_join, jswrap_object_length, jswrap_array_map, gen_jswrap_Array_pop, jswrap_array_push, jswrap_array_reduce, jswrap_array_reverse, jswrap_array_shift, jswrap_array_slice, jswrap_array_some, jswrap_array_sort, jswrap_array_splice, jswrap_array_unshift, gen_jswrap_Array_isArray, gen_jswrap_ArrayBuffer_byteLength, gen_jswrap_ArrayBufferView_buffer, gen_jswrap_ArrayBufferView_byteLength, gen_jswrap_ArrayBufferView_byteOffset, jswrap_arraybufferview_map, jswrap_arraybufferview_set, jswrap_arraybufferview_sort, jswrap_arraybufferview_subarray, gen_jswrap_DataView_getFloat32, gen_jswrap_DataView_getFloat64, gen_jswrap_DataView_getInt16, gen_jswrap_DataView_getInt32, gen_jswrap_DataView_getInt8, gen_jswrap_DataView_getUint16, gen_jswrap_DataView_getUint32, gen_jswrap_DataView_getUint8, gen_jswrap_DataView_setFloat32, gen_jswrap_DataView_setFloat64, gen_jswrap_DataView_setInt16, gen_jswrap_DataView_setInt32, gen_jswrap_DataView_setInt8, gen_jswrap_DataView_setUint16, gen_jswrap_DataView_setUint32, gen_jswrap_DataView_setUint8, jswrap_date_now, jswrap_date_parse, jswrap_date_getDate, jswrap_date_getDay, jswrap_date_getFullYear, jswrap_date_getHours, jswrap_date_getIsDST, jswrap_date_getMilliseconds, jswrap_date_getMinutes, jswrap_date_getMonth, jswrap_date_getSeconds, jswrap_date_getTime, jswrap_date_getTimezoneOffset, jswrap_date_setDate, jswrap_date_setFullYear, jswrap_date_setHours, jswrap_date_setMilliseconds, jswrap_date_setMinutes, jswrap_date_setMonth, jswrap_date_setSeconds, jswrap_date_setTime, jswrap_date_toISOString, jswrap_date_toLocalISOString, jswrap_date_toString, jswrap_date_toUTCString, jswrap_error_toString, jswrap_json_parse, jswrap_json_stringify, gen_jswrap_Number_MAX_VALUE, gen_jswrap_Number_MIN_VALUE, gen_jswrap_Number_NEGATIVE_INFINITY, gen_jswrap_Number_NaN, gen_jswrap_Number_POSITIVE_INFINITY, jswrap_number_toFixed, jswrap_object_on, jswrap_object_clone, jswrap_object_emit, jswrap_object_hasOwnProperty, jswrap_object_prependListener, jswrap_object_removeAllListeners, jswrap_object_removeListener, jswrap_object_valueOf, jswrap_object_assign, jswrap_object_create, jswrap_object_defineProperties, jswrap_object_defineProperty, gen_jswrap_Object_entries, jswrap_object_fromEntries, jswrap_object_getOwnPropertyDescriptor, jswrap_object_getOwnPropertyDescriptors, gen_jswrap_Object_getOwnPropertyNames, jswrap_object_getPrototypeOf, gen_jswrap_Object_keys, jswrap_object_setPrototypeOf, gen_jswrap_Object_values, jswrap_function_apply_or_call, jswrap_function_bind, jswrap_function_replaceWith, jswrap_regexp_exec, jswrap_regexp_test, jswrap_string_charAt, jswrap_string_charCodeAt, jswrap_string_concat, jswrap_string_endsWith, gen_jswrap_String_includes, gen_jswrap_String_indexOf, gen_jswrap_String_lastIndexOf, jswrap_string_match, gen_jswrap_String_padEnd, gen_jswrap_String_padStart, gen_jswrap_String_removeAccents, jswrap_string_repeat, jswrap_string_replace, jswrap_string_replaceAll, jswrap_string_slice, jswrap_string_split, jswrap_string_startsWith, jswrap_string_substr, jswrap_string_substring, gen_jswrap_String_toLowerCase, gen_jswrap_String_toUpperCase, jswrap_string_trim, jswrap_string_fromCharCode, jswrap_modules_addCached, jswrap_modules_getCached, jswrap_modules_removeAllCached, jswrap_modules_removeCached, gen_jswrap_Math_E, gen_jswrap_Math_LN10, gen_jswrap_Math_LN2, gen_jswrap_Math_LOG10E, gen_jswrap_Math_LOG2E, gen_jswrap_Math_PI, gen_jswrap_Math_SQRT1_2, gen_jswrap_Math_SQRT2, fabs, gen_jswrap_Math_acos, jswrap_math_asin, jswrap_math_atan, jswrap_math_atan2, ceil, jswrap_math_clip, jswrap_math_cos, exp, floor, log, gen_jswrap_Math_max, gen_jswrap_Math_min, jswrap_math_pow, gen_jswrap_Math_randInt, gen_jswrap_Math_random, jswrap_math_round, jswrap_math_sign, jswrap_math_sin, jswrap_math_sqrt, gen_jswrap_Math_tan, wrapAround, jswrap_flash_erasePage, jswrap_flash_getFree, jswrap_flash_getPage, jswrap_flash_read, jswrap_flash_write, jswrap_process_env, jswrap_process_memory, gen_jswrap_process_version, jswrap_onewire_read, jswrap_onewire_reset, jswrap_onewire_search, jswrap_onewire_select, jswrap_onewire_skip, jswrap_onewire_write, jswrap_promise_all, jswrap_promise_reject, jswrap_promise_resolve, jswrap_promise_catch, jswrap_promise_then, gen_jswrap_Serial_find, jswrap_stream_available, jswrap_serial_flush, jswrap_serial_inject, jswrap_serial_isConnected, jswrap_serial_print, jswrap_serial_println, jswrap_stream_read, jswrap_serial_setConsole, jswrap_serial_setup, jswrap_serial_unsetup, jswrap_serial_write, jswrap_storage_compact, jswrap_storage_erase, jswrap_storage_eraseAll, jswrap_storage_getFree, jswrap_storage_getStats, jswrap_storage_hash, jswrap_storage_list, jswrap_storage_open, jswrap_storage_optimise, jswrap_storage_read, jswrap_storage_readArrayBuffer, jswrap_storage_readJSON, jswrap_storage_write, jswrap_storage_writeJSON, jswrap_storagefile_erase, jswrap_storagefile_getLength, jswrap_storagefile_read, jswrap_storagefile_readLine, jswrap_storagefile_write, gen_jswrap_SPI_find, jswrap_spi_send, jswrap_spi_send4bit, jswrap_spi_send8bit, jswrap_spi_setup, jswrap_spi_write, gen_jswrap_I2C_find, jswrap_i2c_readFrom, jswrap_i2c_readReg, jswrap_i2c_setup, jswrap_i2c_writeTo, jswrap_waveform_startInput, jswrap_waveform_startOutput, jswrap_waveform_stop, jswrap_heatshrink_compress, jswrap_heatshrink_decompress, jswrap_graphics_createArrayBuffer, jswrap_graphics_createCallback, jswrap_graphics_createImage, jswrap_graphics_getInstance, gen_jswrap_crypto_SHA1, gen_jswrap_crypto_SHA224, gen_jswrap_crypto_SHA256, gen_jswrap_crypto_SHA384, gen_jswrap_crypto_SHA512, jswrap_crypto_AES_ccmDecrypt, jswrap_crypto_AES_ccmEncrypt, jswrap_tensorflow_create, jswrap_tfmicrointerpreter_getInput, jswrap_tfmicrointerpreter_getOutput, jswrap_tfmicrointerpreter_invoke, jsiConsolePrintString, jsiTabComplete_findCommon, jsiTabComplete_printCommon, jsiPacketTimeoutHandler, jsiPacketFileTimeoutHandler, jstPinTaskChecker, jstBufferTaskChecker, jsserialHardwareFunc, jsserialSoftwareFunc, jsserialEventCallback, jsspiHardwareFunc, jsspiFastSoftwareFunc, jsspiSoftwareFunc, heatshrink_ptr_output_cb, graphicsFallbackSetPixel, graphicsFallbackGetPixel, graphicsFallbackFillRect, graphicsFallbackBlit, graphicsFallbackScroll, graphicsSetPixel, lcdSetPixel_ArrayBuffer_flat1, lcdGetPixel_ArrayBuffer_flat1, lcdFillRect_ArrayBuffer_flat1, lcdSetPixel_ArrayBuffer_flat2, lcdGetPixel_ArrayBuffer_flat2, lcdFillRect_ArrayBuffer_flat2, lcdSetPixel_ArrayBuffer_flat4, lcdGetPixel_ArrayBuffer_flat4, lcdFillRect_ArrayBuffer_flat4, lcdSetPixel_ArrayBuffer_flat8, lcdGetPixel_ArrayBuffer_flat8, lcdFillRect_ArrayBuffer_flat8, lcdScroll_ArrayBuffer_flat8, lcdSetPixel_ArrayBuffer_flat, lcdGetPixel_ArrayBuffer_flat, lcdFillRect_ArrayBuffer_flat, lcdScroll_ArrayBuffer_flat, lcdSetPixel_ArrayBuffer, lcdGetPixel_ArrayBuffer, lcdFillRect_ArrayBuffer, lcdSetPixel_JS, lcdFillRect_JS, lcdMemLCD_setPixel, lcdMemLCD_fillRect, lcdMemLCD_getPixel, lcdMemLCD_scroll, aes_crypt_ecb_wrap, aes_setkey_enc_wrap, aes_setkey_dec_wrap, aes_ctx_alloc, aes_ctx_free, ccm_aes_setkey_wrap, ccm_ctx_alloc, ccm_ctx_free, lcd_flip, btn1Handler, jswrap_banglejs_postInit, jswrap_banglejs_beep_callback, jswrap_banglejs_buzz_callback, _jswrap_arraybufferview_sort_float, _jswrap_arraybufferview_sort_int, jsvArrayAddUnique, _jswrap_object_entries_cb, _jswrap_object_values_cb, _jswrap_espruino_toString_char, _jswrap_espruino_toUint8Array_char, jswrap_io_shiftOutCallback, jswrap_pipe_src_close_listener, jswrap_pipe_drain_listener, jswrap_pipe_dst_close_listener, jsvLockAgainSafe, jsvUnLock, jsvSkipName, jsvMathsOp, jsvNewWithFlags, jsvNewFromFloat, jsvNewFromInteger, jsvNewFromString, jsvNewFromBool, jsvGetFloat, jsvGetInteger, jsvGetBool, jsvReplaceWith, jspeFunctionCall, jspGetNamedVariable, jspGetNamedField, jspGetVarNamedField, _jswrap_onewire_write_cb, _jswrap_prombox_resolve, _jswrap_prombox_reject, _jswrap_prombox_queueresolve, _jswrap_prombox_queuereject, _jswrap_prombox_all_reject, _jswrap_prombox_all_resolve, _jswrap_promise_reaction_call, _jswrap_serial_inject_cb, jswrap_spi_send_cb, jswrap_spi_write_cb, heatshrink_var_input_cb, heatshrink_var_output_cb, jswrap_graphics_getFonts_callback, graphicsFillPoly, _jswrap_graphics_getVectorFontPolys_cb, graphicsDrawLineAA, graphicsDrawLine, tflite__SimpleMemoryAllocator__SimpleMemoryAllocator_28tflite__ErrorReporter__2c_20unsigned_20char__2c_20unsigned_20long_29, tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29, tflite__SimpleMemoryAllocator___SimpleMemoryAllocator_28_29_1, tflite__SimpleMemoryAllocator__EnsureHeadSize_28unsigned_20long_2c_20unsigned_20long_29, tflite__SimpleMemoryAllocator__AllocateFromTail_28unsigned_20long_2c_20unsigned_20long_29, tflite__SimpleMemoryAllocator__AllocateTemp_28unsigned_20long_2c_20unsigned_20long_29, tflite__SimpleMemoryAllocator__ResetTempAllocations_28_29, tflite__internal__ContextHelper__ContextHelper_28tflite__ErrorReporter__2c_20tflite__MicroAllocator__2c_20tflite__Model_20const__29, tflite__internal__ContextHelper__ReportOpError_28TfLiteContext__2c_20char_20const__2c_20____29, tflite__internal__ContextHelper__GetTensor_28TfLiteContext_20const__2c_20int_29, tflite__internal__ContextHelper__GetEvalTensor_28TfLiteContext_20const__2c_20int_29, tflite__internal__ContextHelper__AllocatePersistentBuffer_28TfLiteContext__2c_20unsigned_20long_29, tflite__internal__ContextHelper__RequestScratchBufferInArena_28TfLiteContext__2c_20unsigned_20long_2c_20int__29, tflite__internal__ContextHelper__GetScratchBuffer_28TfLiteContext__2c_20int_29, tflite__MicroAllocator___MicroAllocator_28_29, tflite__MicroAllocator__MicroAllocator_28tflite__SimpleMemoryAllocator__2c_20tflite__ErrorReporter__29, tflite__MicroAllocator__AllocatePersistentTfLiteTensor_28tflite__Model_20const__2c_20TfLiteEvalTensor__2c_20int_29, tflite__MicroAllocator__AllocateTempTfLiteTensor_28tflite__Model_20const__2c_20TfLiteEvalTensor__2c_20int_29, tflite__MicroAllocator__ResetTempAllocations_28_29, tflite__MicroAllocator___MicroAllocator_28_29_1, tflite__MicroAllocator__AllocateNodeAndRegistrations_28tflite__Model_20const__2c_20tflite__NodeAndRegistration___29, tflite__MicroAllocator__PrepareNodeAndRegistrationDataFromFlatbuffer_28tflite__Model_20const__2c_20tflite__MicroOpResolver_20const__2c_20tflite__NodeAndRegistration__29, tflite__MicroAllocator__AllocateTfLiteEvalTensors_28tflite__Model_20const__2c_20TfLiteEvalTensor___29, tflite__MicroAllocator__AllocateVariables_28tflite__SubGraph_20const__2c_20TfLiteEvalTensor__29, tflite__MicroAllocator__AllocatePersistentTfLiteTensorInternal_28tflite__Model_20const__2c_20TfLiteEvalTensor__2c_20int_29, tflite__MicroAllocator__PopulateTfLiteTensorFromFlatbuffer_28tflite__Model_20const__2c_20tflite__SubGraph_20const__2c_20TfLiteTensor__2c_20int_2c_20bool_29, tflite__MicroAllocator__CommitStaticMemoryPlan_28tflite__Model_20const__2c_20tflite__SubGraph_20const__2c_20TfLiteEvalTensor__29, tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator__Allocate_28unsigned_20long_2c_20unsigned_20long_29, tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator__Deallocate_28void__29, tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29, tflite___28anonymous_20namespace_29__MicroBuiltinDataAllocator___MicroBuiltinDataAllocator_28_29_1, __cxa_pure_virtual, tflite__BuiltinDataAllocator___BuiltinDataAllocator_28_29, tflite__BuiltinDataAllocator___BuiltinDataAllocator_28_29_1, tflite__ops__micro__depthwise_conv__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29, tflite__ops__micro__depthwise_conv__Prepare_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__depthwise_conv__Eval_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__conv__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29, tflite__ops__micro__conv__Prepare_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__conv__Eval_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__pooling__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29, tflite__ops__micro__pooling__Prepare_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__pooling__AverageEval_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__pooling__MaxEval_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__activations__SoftmaxInit_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29, tflite__ops__micro__activations__SoftmaxPrepare_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__activations__SoftmaxEval_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__fully_connected__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29, tflite__ops__micro__fully_connected__Prepare_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__fully_connected__Eval_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__quantize__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29, tflite__ops__micro__quantize__Prepare_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__quantize__Eval_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__dequantize__Init_28TfLiteContext__2c_20char_20const__2c_20unsigned_20long_29, tflite__ops__micro__dequantize__Prepare_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__dequantize__Eval_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__reshape__Prepare_28TfLiteContext__2c_20TfLiteNode__29, tflite__ops__micro__reshape__Eval_28TfLiteContext__2c_20TfLiteNode__29, tflite__MemoryPlanner___MemoryPlanner_28_29, tflite__MemoryPlanner___MemoryPlanner_28_29_1, tflite__GreedyMemoryPlanner___GreedyMemoryPlanner_28_29, tflite__GreedyMemoryPlanner___GreedyMemoryPlanner_28_29_1, tflite__GreedyMemoryPlanner__AddBuffer_28tflite__ErrorReporter__2c_20int_2c_20int_2c_20int_29, tflite__GreedyMemoryPlanner__GetMaximumMemorySize_28_29, tflite__GreedyMemoryPlanner__GetBufferCount_28_29, tflite__GreedyMemoryPlanner__GetOffsetForBuffer_28tflite__ErrorReporter__2c_20int_2c_20int__29, tflite__ParseDepthwiseConv2D_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29, tflite__ParseConv2D_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29, tflite__ParsePool_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29, tflite__ParseFullyConnected_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29, tflite__ParseSoftmax_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29, tflite__ParseQuantize_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29, tflite__ParseDequantize_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29, tflite__ParseReshape_28tflite__Operator_20const__2c_20tflite__ErrorReporter__2c_20tflite__BuiltinDataAllocator__2c_20void___29, tflite__EspruinoErrorReporter___EspruinoErrorReporter_28_29, tflite__EspruinoErrorReporter___EspruinoErrorReporter_28_29_1, tflite__EspruinoErrorReporter__Report_28char_20const__2c_20void__29, tflite__ErrorReporter___ErrorReporter_28_29, tflite__ErrorReporter___ErrorReporter_28_29_1, tflite__MicroOpResolver__FindOp_28tflite__BuiltinOperator_2c_20int_29_20const, tflite__MicroOpResolver__FindOp_28char_20const__2c_20int_29_20const, tflite__OpResolver__GetDelegates_28int_29_20const, tflite__MicroMutableOpResolver_9u____MicroMutableOpResolver_28_29, tflite__MicroMutableOpResolver_9u____MicroMutableOpResolver_28_29_1, tflite__MicroMutableOpResolver_9u___FindOp_28tflite__BuiltinOperator_29_20const, tflite__MicroMutableOpResolver_9u___FindOp_28char_20const__29_20const, tflite__MicroMutableOpResolver_9u___GetOpDataParser_28tflite__BuiltinOperator_29_20const, tflite__MicroOpResolver___MicroOpResolver_28_29, tflite__MicroOpResolver___MicroOpResolver_28_29_1, tflite__OpResolver___OpResolver_28_29, tflite__OpResolver___OpResolver_28_29_1, __stdio_close, __stdio_write, __stdio_seek]);
 function __wasm_memory_size() {
  return buffer.byteLength / 65536 | 0;
}
 
 return {
  "__wasm_call_ctors": __wasm_call_ctors, 
  "__indirect_function_table": FUNCTION_TABLE, 
  "jshPushIOCharEvent": jshPushIOCharEvent, 
  "jshGetCharToTransmit": jshGetCharToTransmit, 
  "jshGetDeviceToTransmit": jshGetDeviceToTransmit, 
  "jsGfxChanged": jsGfxChanged, 
  "jsGfxGetPtr": jsGfxGetPtr, 
  "jsInit": jsInit, 
  "jsIdle": jsIdle, 
  "jsSendPinWatchEvent": jsSendPinWatchEvent, 
  "jsSendTouchEvent": jsSendTouchEvent, 
  "jsKill": jsKill, 
  "__errno_location": __errno_location, 
  "fflush": fflush, 
  "emscripten_stack_init": emscripten_stack_init, 
  "emscripten_stack_get_free": emscripten_stack_get_free, 
  "emscripten_stack_get_base": emscripten_stack_get_base, 
  "emscripten_stack_get_end": emscripten_stack_get_end, 
  "stackSave": stackSave, 
  "stackRestore": stackRestore, 
  "stackAlloc": stackAlloc, 
  "dynCall_jiji": legalstub$dynCall_jiji
};
}

  return asmFunc(asmLibraryArg);
}
// EMSCRIPTEN_END_ASM




)(asmLibraryArg);
  },

  instantiate: /** @suppress{checkTypes} */ function(binary, info) {
    return {
      then: function(ok) {
        var module = new WebAssembly.Module(binary);
        ok({
          'instance': new WebAssembly.Instance(module)
        });
        // Emulate a simple WebAssembly.instantiate(..).then(()=>{}).catch(()=>{}) syntax.
        return { catch: function() {} };
      }
    };
  },

  RuntimeError: Error
};

// We don't need to actually download a wasm binary, mark it as present but empty.
wasmBinary = [];

// end include: wasm2js.js
if (typeof WebAssembly != 'object') {
  abort('no native wasm support detected');
}

// Wasm globals

var wasmMemory;

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed' + (text ? ': ' + text : ''));
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
/** @param {string|null=} returnType
    @param {Array=} argTypes
    @param {Arguments|Array=} args
    @param {Object=} opts */
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') {
      
      return UTF8ToString(ret);
    }
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  assert(returnType !== 'array', 'Return type should not be "array".');
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);
  function onDone(ret) {
    if (stack !== 0) stackRestore(stack);
    return convertReturnValue(ret);
  }

  ret = onDone(ret);
  return ret;
}

/** @param {string=} returnType
    @param {Array=} argTypes
    @param {Object=} opts */
function cwrap(ident, returnType, argTypes, opts) {
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

// We used to include malloc/free by default in the past. Show a helpful error in
// builds with assertions.
function _malloc() {
  abort("malloc() called but not included in the build - add '_malloc' to EXPORTED_FUNCTIONS");
}
function _free() {
  // Show a helpful error since we used to include free by default in the past.
  abort("free() called but not included in the build - add '_free' to EXPORTED_FUNCTIONS");
}

// include: runtime_legacy.js


var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call

/**
 * allocate(): This function is no longer used by emscripten but is kept around to avoid
 *             breaking external users.
 *             You should normally not use allocate(), and instead allocate
 *             memory using _malloc()/stackAlloc(), initialize it with
 *             setValue(), and so forth.
 * @param {(Uint8Array|Array<number>)} slab: An array of data.
 * @param {number=} allocator : How to allocate memory, see ALLOC_*
 */
function allocate(slab, allocator) {
  var ret;
  assert(typeof allocator == 'number', 'allocate no longer takes a type argument')
  assert(typeof slab != 'number', 'allocate no longer takes a number as arg0')

  if (allocator == ALLOC_STACK) {
    ret = stackAlloc(slab.length);
  } else {
    ret = abort('malloc was not included, but is needed in allocate. Adding "_malloc" to EXPORTED_FUNCTIONS should fix that. This may be a bug in the compiler, please file an issue.');;
  }

  if (!slab.subarray && !slab.slice) {
    slab = new Uint8Array(slab);
  }
  HEAPU8.set(slab, ret);
  return ret;
}

// end include: runtime_legacy.js
// include: runtime_strings.js


// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.

var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.
/**
 * heapOrArray is either a regular array, or a JavaScript typed array view.
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = heapOrArray[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      if (u > 0x10FFFF) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}

// end include: runtime_strings.js
// include: runtime_strings_extra.js


// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;

function UTF16ToString(ptr, maxBytesToRead) {
  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  var maxIdx = idx + maxBytesToRead / 2;
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var str = '';

    // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition
    // will always evaluate to true. The loop is then terminated on the first null char.
    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) break;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }

    return str;
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)] = codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr, maxBytesToRead) {
  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
  var i = 0;

  var str = '';
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(i >= maxBytesToRead / 4)) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0) break;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
  return str;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)] = codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = abort('malloc was not included, but is needed in allocateUTF8. Adding "_malloc" to EXPORTED_FUNCTIONS should fix that. This may be a bug in the compiler, please file an issue.');;
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated
    @param {boolean=} dontAddNull */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')
  HEAP8.set(array, buffer);
}

/** @param {boolean=} dontAddNull */
function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    assert(str.charCodeAt(i) === (str.charCodeAt(i) & 0xff));
    HEAP8[((buffer++)>>0)] = str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;
}

// end include: runtime_strings_extra.js
// Memory management

var HEAP,
/** @type {!ArrayBuffer} */
  buffer,
/** @type {!Int8Array} */
  HEAP8,
/** @type {!Uint8Array} */
  HEAPU8,
/** @type {!Int16Array} */
  HEAP16,
/** @type {!Uint16Array} */
  HEAPU16,
/** @type {!Int32Array} */
  HEAP32,
/** @type {!Uint32Array} */
  HEAPU32,
/** @type {!Float32Array} */
  HEAPF32,
/** @type {!Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var TOTAL_STACK = 5242880;
if (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime')

var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;legacyModuleProp('INITIAL_MEMORY', 'INITIAL_MEMORY');

assert(INITIAL_MEMORY >= TOTAL_STACK, 'INITIAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');

// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,
       'JS engine does not provide full typed array support');

// In non-standalone/normal mode, we create the memory here.
// include: runtime_init_memory.js


// Create the wasm memory. (Note: this only applies if IMPORTED_MEMORY is defined)

  if (Module['wasmMemory']) {
    wasmMemory = Module['wasmMemory'];
  } else
  {
    wasmMemory = new WebAssembly.Memory({
      'initial': INITIAL_MEMORY / 65536,
      'maximum': INITIAL_MEMORY / 65536
    });
  }

if (wasmMemory) {
  buffer = wasmMemory.buffer;
}

// If the user provides an incorrect length, just use that length instead rather than providing the user to
// specifically provide the memory length with Module['INITIAL_MEMORY'].
INITIAL_MEMORY = buffer.byteLength;
assert(INITIAL_MEMORY % 65536 === 0);
updateGlobalBufferAndViews(buffer);

// end include: runtime_init_memory.js

// include: runtime_init_table.js
// In regular non-RELOCATABLE mode the table is exported
// from the wasm module and this will be assigned once
// the exports are available.
var wasmTable;

// end include: runtime_init_table.js
// include: runtime_stack_check.js


// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
function writeStackCookie() {
  var max = _emscripten_stack_get_end();
  assert((max & 3) == 0);
  // The stack grow downwards towards _emscripten_stack_get_end.
  // We write cookies to the final two words in the stack and detect if they are
  // ever overwritten.
  HEAP32[((max)>>2)] = 0x2135467;
  HEAP32[(((max)+(4))>>2)] = 0x89BACDFE;
  // Also test the global address 0 for integrity.
  HEAPU32[0] = 0x63736d65; /* 'emsc' */
}

function checkStackCookie() {
  if (ABORT) return;
  var max = _emscripten_stack_get_end();
  var cookie1 = HEAPU32[((max)>>2)];
  var cookie2 = HEAPU32[(((max)+(4))>>2)];
  if (cookie1 != 0x2135467 || cookie2 != 0x89BACDFE) {
    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x' + cookie2.toString(16) + ' 0x' + cookie1.toString(16));
  }
  // Also test the global address 0 for integrity.
  if (HEAPU32[0] !== 0x63736d65 /* 'emsc' */) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
}

// end include: runtime_stack_check.js
// include: runtime_assertions.js


// Endianness check
(function() {
  var h16 = new Int16Array(1);
  var h8 = new Int8Array(h16.buffer);
  h16[0] = 0x6373;
  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';
})();

// end include: runtime_assertions.js
var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;

function keepRuntimeAlive() {
  return noExitRuntime;
}

function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  assert(!runtimeInitialized);
  runtimeInitialized = true;

  checkStackCookie();

  
  callRuntimeCallbacks(__ATINIT__);
}

function postRun() {
  checkStackCookie();

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// include: runtime_math.js


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');

// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
var runDependencyTracking = {};

function getUniqueRunDependency(id) {
  var orig = id;
  while (1) {
    if (!runDependencyTracking[id]) return id;
    id = orig + Math.random();
  }
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(function() {
        if (ABORT) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
          return;
        }
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            err('still waiting on run dependencies:');
          }
          err('dependency: ' + dep);
        }
        if (shown) {
          err('(end of list)');
        }
      }, 10000);
    }
  } else {
    err('warning: run dependency added without ID');
  }
}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    err('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

/** @param {string|number=} what */
function abort(what) {
  {
    if (Module['onAbort']) {
      Module['onAbort'](what);
    }
  }

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  // FIXME This approach does not work in Wasm EH because it currently does not assume
  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
  // a trap or not based on a hidden field within the object. So at the moment
  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
  // allows this in the wasm spec.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // defintion for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// {{MEM_INITIALIZER}}

// include: memoryprofiler.js


// end include: memoryprofiler.js
// show errors on likely calls to FS when it was not included
var FS = {
  error: function() {
    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM');
  },
  init: function() { FS.error() },
  createDataFile: function() { FS.error() },
  createPreloadedFile: function() { FS.error() },
  createLazyFile: function() { FS.error() },
  open: function() { FS.error() },
  mkdev: function() { FS.error() },
  registerDevice: function() { FS.error() },
  analyzePath: function() { FS.error() },
  loadFilesFromDB: function() { FS.error() },

  ErrnoError: function ErrnoError() { FS.error() },
};
Module['FS_createDataFile'] = FS.createDataFile;
Module['FS_createPreloadedFile'] = FS.createPreloadedFile;

// include: URIUtils.js


// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  // Prefix of data URIs emitted by SINGLE_FILE and related options.
  return filename.startsWith(dataURIPrefix);
}

// Indicates whether filename is delivered via file protocol (as opposed to http/https)
function isFileURI(filename) {
  return filename.startsWith('file://');
}

// end include: URIUtils.js
/** @param {boolean=} fixedasm */
function createExportWrapper(name, fixedasm) {
  return function() {
    var displayName = name;
    var asm = fixedasm;
    if (!fixedasm) {
      asm = Module['asm'];
    }
    assert(runtimeInitialized, 'native function `' + displayName + '` called before runtime initialization');
    if (!asm[name]) {
      assert(asm[name], 'exported native function `' + displayName + '` not found');
    }
    return asm[name].apply(null, arguments);
  };
}

var wasmBinaryFile;
  wasmBinaryFile = 'emulator_banglejs2.wasm';
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }

function getBinary(file) {
  try {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    var binary = tryParseAsDataURI(file);
    if (binary) {
      return binary;
    }
    if (readBinary) {
      return readBinary(file);
    } else {
      throw "both async and sync fetching of the wasm failed";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // If we don't have the binary yet, try to to load it asynchronously.
  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
  // See https://github.com/github/fetch/pull/92#issuecomment-140665932
  // Cordova or Electron apps are typically loaded from a file:// url.
  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
    if (typeof fetch == 'function'
      && !isFileURI(wasmBinaryFile)
    ) {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        if (!response['ok']) {
          throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
        }
        return response['arrayBuffer']();
      }).catch(function () {
          return getBinary(wasmBinaryFile);
      });
    }
    else {
      if (readAsync) {
        // fetch is not available or url is file => try XHR (readAsync uses XHR internally)
        return new Promise(function(resolve, reject) {
          readAsync(wasmBinaryFile, function(response) { resolve(new Uint8Array(/** @type{!ArrayBuffer} */(response))) }, reject)
        });
      }
    }
  }

  // Otherwise, getBinary should be able to get it synchronously
  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg,
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    var exports = instance.exports;

    Module['asm'] = exports;

    wasmTable = Module['asm']['__indirect_function_table'];
    assert(wasmTable, "table not found in wasm exports");

    addOnInit(Module['asm']['__wasm_call_ctors']);

    removeRunDependency('wasm-instantiate');

  }
  // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  // Async compilation can be confusing when an error on the page overwrites Module
  // (for example, if the order of elements is wrong, and the one defining Module is
  // later), so we save Module and check it later.
  var trueModule = Module;
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
    trueModule = null;
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
    receiveInstance(result['instance']);
  }

  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(function (instance) {
      return instance;
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);

      // Warn on some common problems.
      if (isFileURI(wasmBinaryFile)) {
        err('warning: Loading from a file URI (' + wasmBinaryFile + ') is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing');
      }
      abort(reason);
    });
  }

  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming == 'function' &&
        !isDataURI(wasmBinaryFile) &&
        // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
        !isFileURI(wasmBinaryFile) &&
        // Avoid instantiateStreaming() on Node.js environment for now, as while
        // Node.js v18.1.0 implements it, it does not have a full fetch()
        // implementation yet.
        //
        // Reference:
        //   https://github.com/emscripten-core/emscripten/pull/16917
        !ENVIRONMENT_IS_NODE &&
        typeof fetch == 'function') {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        // Suppress closure warning here since the upstream definition for
        // instantiateStreaming only allows Promise<Repsponse> rather than
        // an actual Response.
        // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.
        /** @suppress {checkTypes} */
        var result = WebAssembly.instantiateStreaming(response, info);

        return result.then(
          receiveInstantiationResult,
          function(reason) {
            // We expect the most common failure cause to be a bad MIME type for the binary,
            // in which case falling back to ArrayBuffer instantiation should work.
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            return instantiateArrayBuffer(receiveInstantiationResult);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiationResult);
    }
  }

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  // Also pthreads and wasm workers initialize the wasm instance through this path.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  instantiateAsync();
  return {}; // no exports yet; we'll fill them in later
}

// Globals used by JS i64 conversions (see makeSetValue)
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  196089: () => { jsHandleIO(); },  
 196107: ($0, $1) => { hwSetPinValue($0,$1) },  
 196132: ($0) => { return hwGetPinValue($0) },  
 196161: () => { return Date.now(); },  
 196184: ($0, $1, $2) => { hwFlashWritePtr($0,$1,$2); },  
 196215: ($0) => { return hwFlashRead($0) },  
 196242: ($0, $1, $2) => { hwFlashWritePtr($0,$1,$2); }
};
function emscripten_memcpy_js(dest,src,numBytes) { var destHeap = new Uint8Array(Module.HEAPU8.buffer, dest, numBytes); var srcHeap = new Uint8Array(Module.HEAPU8.buffer, src, numBytes); destHeap.set(srcHeap); }





  function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        var callback = callbacks.shift();
        if (typeof callback == 'function') {
          callback(Module); // Pass the module as the first argument.
          continue;
        }
        var func = callback.func;
        if (typeof func == 'number') {
          if (callback.arg === undefined) {
            // Run the wasm function ptr with signature 'v'. If no function
            // with such signature was exported, this call does not need
            // to be emitted (and would confuse Closure)
            getWasmTableEntry(func)();
          } else {
            // If any function with signature 'vi' was exported, run
            // the callback with that signature.
            getWasmTableEntry(func)(callback.arg);
          }
        } else {
          func(callback.arg === undefined ? null : callback.arg);
        }
      }
    }

  function withStackSave(f) {
      var stack = stackSave();
      var ret = f();
      stackRestore(stack);
      return ret;
    }
  function demangle(func) {
      warnOnce('warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling');
      return func;
    }

  function demangleAll(text) {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    }

  
    /**
     * @param {number} ptr
     * @param {string} type
     */
  function getValue(ptr, type = 'i8') {
      if (type.endsWith('*')) type = 'i32';
      switch (type) {
        case 'i1': return HEAP8[((ptr)>>0)];
        case 'i8': return HEAP8[((ptr)>>0)];
        case 'i16': return HEAP16[((ptr)>>1)];
        case 'i32': return HEAP32[((ptr)>>2)];
        case 'i64': return HEAP32[((ptr)>>2)];
        case 'float': return HEAPF32[((ptr)>>2)];
        case 'double': return Number(HEAPF64[((ptr)>>3)]);
        default: abort('invalid type for getValue: ' + type);
      }
      return null;
    }

  function getWasmTableEntry(funcPtr) {
      // In -Os and -Oz builds, do not implement a JS side wasm table mirror for small
      // code size, but directly access wasmTable, which is a bit slower as uncached.
      return wasmTable.get(funcPtr);
    }

  function handleException(e) {
      // Certain exception types we do not treat as errors since they are used for
      // internal control flow.
      // 1. ExitStatus, which is thrown by exit()
      // 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
      //    that wish to return to JS event loop.
      if (e instanceof ExitStatus || e == 'unwind') {
        return EXITSTATUS;
      }
      quit_(1, e);
    }

  function jsStackTrace() {
      var error = new Error();
      if (!error.stack) {
        // IE10+ special cases: It does have callstack info, but it is only
        // populated if an Error object is thrown, so try that as a special-case.
        try {
          throw new Error();
        } catch(e) {
          error = e;
        }
        if (!error.stack) {
          return '(no stack trace available)';
        }
      }
      return error.stack.toString();
    }

  
    /**
     * @param {number} ptr
     * @param {number} value
     * @param {string} type
     */
  function setValue(ptr, value, type = 'i8') {
      if (type.endsWith('*')) type = 'i32';
      switch (type) {
        case 'i1': HEAP8[((ptr)>>0)] = value; break;
        case 'i8': HEAP8[((ptr)>>0)] = value; break;
        case 'i16': HEAP16[((ptr)>>1)] = value; break;
        case 'i32': HEAP32[((ptr)>>2)] = value; break;
        case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;
        case 'float': HEAPF32[((ptr)>>2)] = value; break;
        case 'double': HEAPF64[((ptr)>>3)] = value; break;
        default: abort('invalid type for setValue: ' + type);
      }
    }

  function setWasmTableEntry(idx, func) {
      wasmTable.set(idx, func);
    }

  function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js);
    }

  function _abort() {
      abort('native code called abort()');
    }

  var readAsmConstArgsArray = [];
  function readAsmConstArgs(sigPtr, buf) {
      // Nobody should have mutated _readAsmConstArgsArray underneath us to be something else than an array.
      assert(Array.isArray(readAsmConstArgsArray));
      // The input buffer is allocated on the stack, so it must be stack-aligned.
      assert(buf % 16 == 0);
      readAsmConstArgsArray.length = 0;
      var ch;
      // Most arguments are i32s, so shift the buffer pointer so it is a plain
      // index into HEAP32.
      buf >>= 2;
      while (ch = HEAPU8[sigPtr++]) {
        var chr = String.fromCharCode(ch);
        var validChars = ['d', 'f', 'i'];
        assert(validChars.includes(chr), 'Invalid character ' + ch + '("' + chr + '") in readAsmConstArgs! Use only [' + validChars + '], and do not specify "v" for void return argument.');
        // Floats are always passed as doubles, and doubles and int64s take up 8
        // bytes (two 32-bit slots) in memory, align reads to these:
        buf += (ch != 105/*i*/) & buf;
        readAsmConstArgsArray.push(
          ch == 105/*i*/ ? HEAP32[buf] :
         HEAPF64[buf++ >> 1]
        );
        ++buf;
      }
      return readAsmConstArgsArray;
    }
  function _emscripten_asm_const_int(code, sigPtr, argbuf) {
      var args = readAsmConstArgs(sigPtr, argbuf);
      if (!ASM_CONSTS.hasOwnProperty(code)) abort('No EM_ASM constant found at address ' + code);
      return ASM_CONSTS[code].apply(null, args);
    }
  function _emscripten_asm_const_double(a0,a1,a2
  ) {
  return _emscripten_asm_const_int(a0,a1,a2);
  }


  var SYSCALLS = {varargs:undefined,get:function() {
        assert(SYSCALLS.varargs != undefined);
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      }};
  function _fd_close(fd) {
      abort('fd_close called without SYSCALLS_REQUIRE_FILESYSTEM');
    }

  function convertI32PairToI53Checked(lo, hi) {
      assert(lo == (lo >>> 0) || lo == (lo|0)); // lo should either be a i32 or a u32
      assert(hi === (hi|0));                    // hi should be a i32
      return ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;
    }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
      return 70;
    }

  var printCharBuffers = [null,[],[]];
  function printChar(stream, curr) {
      var buffer = printCharBuffers[stream];
      assert(buffer);
      if (curr === 0 || curr === 10) {
        (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
        buffer.length = 0;
      } else {
        buffer.push(curr);
      }
    }
  function flush_NO_FILESYSTEM() {
      // flush anything remaining in the buffers during shutdown
      _fflush(0);
      if (printCharBuffers[1].length) printChar(1, 10);
      if (printCharBuffers[2].length) printChar(2, 10);
    }
  function _fd_write(fd, iov, iovcnt, pnum) {
      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0
      var num = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        for (var j = 0; j < len; j++) {
          printChar(fd, HEAPU8[ptr+j]);
        }
        num += len;
      }
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    }

  function _setTempRet0(val) {
      setTempRet0(val);
    }
var ASSERTIONS = true;



/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

/**
 * Decodes a base64 string.
 * @param {string} input The string to decode.
 */
var decodeBase64 = typeof atob == 'function' ? atob : function (input) {
  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  var output = '';
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0;
  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  do {
    enc1 = keyStr.indexOf(input.charAt(i++));
    enc2 = keyStr.indexOf(input.charAt(i++));
    enc3 = keyStr.indexOf(input.charAt(i++));
    enc4 = keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 !== 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 !== 64) {
      output = output + String.fromCharCode(chr3);
    }
  } while (i < input.length);
  return output;
};

// Converts a string of base64 into a byte array.
// Throws error on invalid input.
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE == 'boolean' && ENVIRONMENT_IS_NODE) {
    var buf = Buffer.from(s, 'base64');
    return new Uint8Array(buf['buffer'], buf['byteOffset'], buf['byteLength']);
  }

  try {
    var decoded = decodeBase64(s);
    var bytes = new Uint8Array(decoded.length);
    for (var i = 0 ; i < decoded.length ; ++i) {
      bytes[i] = decoded.charCodeAt(i);
    }
    return bytes;
  } catch (_) {
    throw new Error('Converting base64 string to bytes failed.');
  }
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}


function checkIncomingModuleAPI() {
  ignoredModuleProp('fetchSettings');
}
var asmLibraryArg = {
  "abort": _abort,
  "emscripten_asm_const_double": _emscripten_asm_const_double,
  "emscripten_asm_const_int": _emscripten_asm_const_int,
  "emscripten_memcpy_js": emscripten_memcpy_js,
  "fd_close": _fd_close,
  "fd_seek": _fd_seek,
  "fd_write": _fd_write,
  "getTempRet0": getTempRet0,
  "memory": wasmMemory,
  "setTempRet0": setTempRet0
};
var asm = createWasm();
/** @type {function(...*):?} */
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = createExportWrapper("__wasm_call_ctors");

/** @type {function(...*):?} */
var _jshPushIOCharEvent = Module["_jshPushIOCharEvent"] = createExportWrapper("jshPushIOCharEvent");

/** @type {function(...*):?} */
var _jshGetCharToTransmit = Module["_jshGetCharToTransmit"] = createExportWrapper("jshGetCharToTransmit");

/** @type {function(...*):?} */
var _jshGetDeviceToTransmit = Module["_jshGetDeviceToTransmit"] = createExportWrapper("jshGetDeviceToTransmit");

/** @type {function(...*):?} */
var _jsGfxChanged = Module["_jsGfxChanged"] = createExportWrapper("jsGfxChanged");

/** @type {function(...*):?} */
var _jsGfxGetPtr = Module["_jsGfxGetPtr"] = createExportWrapper("jsGfxGetPtr");

/** @type {function(...*):?} */
var _jsInit = Module["_jsInit"] = createExportWrapper("jsInit");

/** @type {function(...*):?} */
var _jsIdle = Module["_jsIdle"] = createExportWrapper("jsIdle");

/** @type {function(...*):?} */
var _jsSendPinWatchEvent = Module["_jsSendPinWatchEvent"] = createExportWrapper("jsSendPinWatchEvent");

/** @type {function(...*):?} */
var _jsSendTouchEvent = Module["_jsSendTouchEvent"] = createExportWrapper("jsSendTouchEvent");

/** @type {function(...*):?} */
var _jsKill = Module["_jsKill"] = createExportWrapper("jsKill");

/** @type {function(...*):?} */
var ___errno_location = Module["___errno_location"] = createExportWrapper("__errno_location");

/** @type {function(...*):?} */
var _fflush = Module["_fflush"] = createExportWrapper("fflush");

/** @type {function(...*):?} */
var _emscripten_stack_init = Module["_emscripten_stack_init"] = function() {
  return (_emscripten_stack_init = Module["_emscripten_stack_init"] = Module["asm"]["emscripten_stack_init"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_stack_get_free = Module["_emscripten_stack_get_free"] = function() {
  return (_emscripten_stack_get_free = Module["_emscripten_stack_get_free"] = Module["asm"]["emscripten_stack_get_free"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_stack_get_base = Module["_emscripten_stack_get_base"] = function() {
  return (_emscripten_stack_get_base = Module["_emscripten_stack_get_base"] = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_stack_get_end = Module["_emscripten_stack_get_end"] = function() {
  return (_emscripten_stack_get_end = Module["_emscripten_stack_get_end"] = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackSave = Module["stackSave"] = createExportWrapper("stackSave");

/** @type {function(...*):?} */
var stackRestore = Module["stackRestore"] = createExportWrapper("stackRestore");

/** @type {function(...*):?} */
var stackAlloc = Module["stackAlloc"] = createExportWrapper("stackAlloc");

/** @type {function(...*):?} */
var dynCall_jiji = Module["dynCall_jiji"] = createExportWrapper("dynCall_jiji");





// === Auto-generated postamble setup entry stuff ===

Module["ccall"] = ccall;
unexportedRuntimeFunction('cwrap', false);
unexportedRuntimeFunction('allocate', false);
unexportedRuntimeFunction('UTF8ArrayToString', false);
unexportedRuntimeFunction('UTF8ToString', false);
unexportedRuntimeFunction('stringToUTF8Array', false);
unexportedRuntimeFunction('stringToUTF8', false);
unexportedRuntimeFunction('lengthBytesUTF8', false);
unexportedRuntimeFunction('addOnPreRun', false);
unexportedRuntimeFunction('addOnInit', false);
unexportedRuntimeFunction('addOnPreMain', false);
unexportedRuntimeFunction('addOnExit', false);
unexportedRuntimeFunction('addOnPostRun', false);
unexportedRuntimeFunction('addRunDependency', true);
unexportedRuntimeFunction('removeRunDependency', true);
unexportedRuntimeFunction('FS_createFolder', false);
unexportedRuntimeFunction('FS_createPath', true);
unexportedRuntimeFunction('FS_createDataFile', true);
unexportedRuntimeFunction('FS_createPreloadedFile', true);
unexportedRuntimeFunction('FS_createLazyFile', true);
unexportedRuntimeFunction('FS_createLink', false);
unexportedRuntimeFunction('FS_createDevice', true);
unexportedRuntimeFunction('FS_unlink', true);
unexportedRuntimeFunction('getLEB', false);
unexportedRuntimeFunction('getFunctionTables', false);
unexportedRuntimeFunction('alignFunctionTables', false);
unexportedRuntimeFunction('registerFunctions', false);
unexportedRuntimeFunction('addFunction', false);
unexportedRuntimeFunction('removeFunction', false);
unexportedRuntimeFunction('prettyPrint', false);
unexportedRuntimeFunction('getCompilerSetting', false);
unexportedRuntimeFunction('print', false);
unexportedRuntimeFunction('printErr', false);
unexportedRuntimeFunction('getTempRet0', false);
unexportedRuntimeFunction('setTempRet0', false);
unexportedRuntimeFunction('callMain', false);
unexportedRuntimeFunction('abort', false);
unexportedRuntimeFunction('keepRuntimeAlive', false);
unexportedRuntimeFunction('wasmMemory', false);
unexportedRuntimeFunction('warnOnce', false);
unexportedRuntimeFunction('stackSave', false);
unexportedRuntimeFunction('stackRestore', false);
unexportedRuntimeFunction('stackAlloc', false);
unexportedRuntimeFunction('AsciiToString', false);
unexportedRuntimeFunction('stringToAscii', false);
unexportedRuntimeFunction('UTF16ToString', false);
unexportedRuntimeFunction('stringToUTF16', false);
unexportedRuntimeFunction('lengthBytesUTF16', false);
unexportedRuntimeFunction('UTF32ToString', false);
unexportedRuntimeFunction('stringToUTF32', false);
unexportedRuntimeFunction('lengthBytesUTF32', false);
unexportedRuntimeFunction('allocateUTF8', false);
unexportedRuntimeFunction('allocateUTF8OnStack', false);
unexportedRuntimeFunction('ExitStatus', false);
unexportedRuntimeFunction('intArrayFromString', false);
unexportedRuntimeFunction('intArrayToString', false);
unexportedRuntimeFunction('writeStringToMemory', false);
unexportedRuntimeFunction('writeArrayToMemory', false);
unexportedRuntimeFunction('writeAsciiToMemory', false);
Module["writeStackCookie"] = writeStackCookie;
Module["checkStackCookie"] = checkStackCookie;
unexportedRuntimeFunction('intArrayFromBase64', false);
unexportedRuntimeFunction('tryParseAsDataURI', false);
unexportedRuntimeFunction('ptrToString', false);
unexportedRuntimeFunction('zeroMemory', false);
unexportedRuntimeFunction('stringToNewUTF8', false);
unexportedRuntimeFunction('getHeapMax', false);
unexportedRuntimeFunction('abortOnCannotGrowMemory', false);
unexportedRuntimeFunction('emscripten_realloc_buffer', false);
unexportedRuntimeFunction('ENV', false);
unexportedRuntimeFunction('ERRNO_CODES', false);
unexportedRuntimeFunction('ERRNO_MESSAGES', false);
unexportedRuntimeFunction('setErrNo', false);
unexportedRuntimeFunction('inetPton4', false);
unexportedRuntimeFunction('inetNtop4', false);
unexportedRuntimeFunction('inetPton6', false);
unexportedRuntimeFunction('inetNtop6', false);
unexportedRuntimeFunction('readSockaddr', false);
unexportedRuntimeFunction('writeSockaddr', false);
unexportedRuntimeFunction('DNS', false);
unexportedRuntimeFunction('getHostByName', false);
unexportedRuntimeFunction('Protocols', false);
unexportedRuntimeFunction('Sockets', false);
unexportedRuntimeFunction('getRandomDevice', false);
unexportedRuntimeFunction('traverseStack', false);
unexportedRuntimeFunction('UNWIND_CACHE', false);
unexportedRuntimeFunction('convertPCtoSourceLocation', false);
unexportedRuntimeFunction('readAsmConstArgsArray', false);
unexportedRuntimeFunction('readAsmConstArgs', false);
unexportedRuntimeFunction('mainThreadEM_ASM', false);
unexportedRuntimeFunction('jstoi_q', false);
unexportedRuntimeFunction('jstoi_s', false);
unexportedRuntimeFunction('getExecutableName', false);
unexportedRuntimeFunction('listenOnce', false);
unexportedRuntimeFunction('autoResumeAudioContext', false);
unexportedRuntimeFunction('dynCallLegacy', false);
unexportedRuntimeFunction('getDynCaller', false);
unexportedRuntimeFunction('dynCall', false);
unexportedRuntimeFunction('setWasmTableEntry', false);
unexportedRuntimeFunction('getWasmTableEntry', false);
unexportedRuntimeFunction('handleException', false);
unexportedRuntimeFunction('runtimeKeepalivePush', false);
unexportedRuntimeFunction('runtimeKeepalivePop', false);
unexportedRuntimeFunction('callUserCallback', false);
unexportedRuntimeFunction('maybeExit', false);
unexportedRuntimeFunction('safeSetTimeout', false);
unexportedRuntimeFunction('asmjsMangle', false);
unexportedRuntimeFunction('asyncLoad', false);
unexportedRuntimeFunction('alignMemory', false);
unexportedRuntimeFunction('mmapAlloc', false);
unexportedRuntimeFunction('writeI53ToI64', false);
unexportedRuntimeFunction('writeI53ToI64Clamped', false);
unexportedRuntimeFunction('writeI53ToI64Signaling', false);
unexportedRuntimeFunction('writeI53ToU64Clamped', false);
unexportedRuntimeFunction('writeI53ToU64Signaling', false);
unexportedRuntimeFunction('readI53FromI64', false);
unexportedRuntimeFunction('readI53FromU64', false);
unexportedRuntimeFunction('convertI32PairToI53', false);
unexportedRuntimeFunction('convertI32PairToI53Checked', false);
unexportedRuntimeFunction('convertU32PairToI53', false);
unexportedRuntimeFunction('reallyNegative', false);
unexportedRuntimeFunction('unSign', false);
unexportedRuntimeFunction('strLen', false);
unexportedRuntimeFunction('reSign', false);
unexportedRuntimeFunction('formatString', false);
unexportedRuntimeFunction('setValue', false);
unexportedRuntimeFunction('getValue', false);
unexportedRuntimeFunction('PATH', false);
unexportedRuntimeFunction('PATH_FS', false);
unexportedRuntimeFunction('SYSCALLS', false);
unexportedRuntimeFunction('getSocketFromFD', false);
unexportedRuntimeFunction('getSocketAddress', false);
unexportedRuntimeFunction('JSEvents', false);
unexportedRuntimeFunction('registerKeyEventCallback', false);
unexportedRuntimeFunction('specialHTMLTargets', false);
unexportedRuntimeFunction('maybeCStringToJsString', false);
unexportedRuntimeFunction('findEventTarget', false);
unexportedRuntimeFunction('findCanvasEventTarget', false);
unexportedRuntimeFunction('getBoundingClientRect', false);
unexportedRuntimeFunction('fillMouseEventData', false);
unexportedRuntimeFunction('registerMouseEventCallback', false);
unexportedRuntimeFunction('registerWheelEventCallback', false);
unexportedRuntimeFunction('registerUiEventCallback', false);
unexportedRuntimeFunction('registerFocusEventCallback', false);
unexportedRuntimeFunction('fillDeviceOrientationEventData', false);
unexportedRuntimeFunction('registerDeviceOrientationEventCallback', false);
unexportedRuntimeFunction('fillDeviceMotionEventData', false);
unexportedRuntimeFunction('registerDeviceMotionEventCallback', false);
unexportedRuntimeFunction('screenOrientation', false);
unexportedRuntimeFunction('fillOrientationChangeEventData', false);
unexportedRuntimeFunction('registerOrientationChangeEventCallback', false);
unexportedRuntimeFunction('fillFullscreenChangeEventData', false);
unexportedRuntimeFunction('registerFullscreenChangeEventCallback', false);
unexportedRuntimeFunction('JSEvents_requestFullscreen', false);
unexportedRuntimeFunction('JSEvents_resizeCanvasForFullscreen', false);
unexportedRuntimeFunction('registerRestoreOldStyle', false);
unexportedRuntimeFunction('hideEverythingExceptGivenElement', false);
unexportedRuntimeFunction('restoreHiddenElements', false);
unexportedRuntimeFunction('setLetterbox', false);
unexportedRuntimeFunction('currentFullscreenStrategy', false);
unexportedRuntimeFunction('restoreOldWindowedStyle', false);
unexportedRuntimeFunction('softFullscreenResizeWebGLRenderTarget', false);
unexportedRuntimeFunction('doRequestFullscreen', false);
unexportedRuntimeFunction('fillPointerlockChangeEventData', false);
unexportedRuntimeFunction('registerPointerlockChangeEventCallback', false);
unexportedRuntimeFunction('registerPointerlockErrorEventCallback', false);
unexportedRuntimeFunction('requestPointerLock', false);
unexportedRuntimeFunction('fillVisibilityChangeEventData', false);
unexportedRuntimeFunction('registerVisibilityChangeEventCallback', false);
unexportedRuntimeFunction('registerTouchEventCallback', false);
unexportedRuntimeFunction('fillGamepadEventData', false);
unexportedRuntimeFunction('registerGamepadEventCallback', false);
unexportedRuntimeFunction('registerBeforeUnloadEventCallback', false);
unexportedRuntimeFunction('fillBatteryEventData', false);
unexportedRuntimeFunction('battery', false);
unexportedRuntimeFunction('registerBatteryEventCallback', false);
unexportedRuntimeFunction('setCanvasElementSize', false);
unexportedRuntimeFunction('getCanvasElementSize', false);
unexportedRuntimeFunction('demangle', false);
unexportedRuntimeFunction('demangleAll', false);
unexportedRuntimeFunction('jsStackTrace', false);
unexportedRuntimeFunction('stackTrace', false);
unexportedRuntimeFunction('getEnvStrings', false);
unexportedRuntimeFunction('checkWasiClock', false);
unexportedRuntimeFunction('flush_NO_FILESYSTEM', false);
unexportedRuntimeFunction('dlopenMissingError', false);
unexportedRuntimeFunction('setImmediateWrapped', false);
unexportedRuntimeFunction('clearImmediateWrapped', false);
unexportedRuntimeFunction('polyfillSetImmediate', false);
unexportedRuntimeFunction('uncaughtExceptionCount', false);
unexportedRuntimeFunction('exceptionLast', false);
unexportedRuntimeFunction('exceptionCaught', false);
unexportedRuntimeFunction('ExceptionInfo', false);
unexportedRuntimeFunction('exception_addRef', false);
unexportedRuntimeFunction('exception_decRef', false);
unexportedRuntimeFunction('Browser', false);
unexportedRuntimeFunction('setMainLoop', false);
unexportedRuntimeFunction('wget', false);
unexportedRuntimeFunction('FS', false);
unexportedRuntimeFunction('MEMFS', false);
unexportedRuntimeFunction('TTY', false);
unexportedRuntimeFunction('PIPEFS', false);
unexportedRuntimeFunction('SOCKFS', false);
unexportedRuntimeFunction('_setNetworkCallback', false);
unexportedRuntimeFunction('tempFixedLengthArray', false);
unexportedRuntimeFunction('miniTempWebGLFloatBuffers', false);
unexportedRuntimeFunction('heapObjectForWebGLType', false);
unexportedRuntimeFunction('heapAccessShiftForWebGLHeap', false);
unexportedRuntimeFunction('GL', false);
unexportedRuntimeFunction('emscriptenWebGLGet', false);
unexportedRuntimeFunction('computeUnpackAlignedImageSize', false);
unexportedRuntimeFunction('emscriptenWebGLGetTexPixelData', false);
unexportedRuntimeFunction('emscriptenWebGLGetUniform', false);
unexportedRuntimeFunction('webglGetUniformLocation', false);
unexportedRuntimeFunction('webglPrepareUniformLocationsBeforeFirstUse', false);
unexportedRuntimeFunction('webglGetLeftBracePos', false);
unexportedRuntimeFunction('emscriptenWebGLGetVertexAttrib', false);
unexportedRuntimeFunction('writeGLArray', false);
unexportedRuntimeFunction('AL', false);
unexportedRuntimeFunction('SDL_unicode', false);
unexportedRuntimeFunction('SDL_ttfContext', false);
unexportedRuntimeFunction('SDL_audio', false);
unexportedRuntimeFunction('SDL', false);
unexportedRuntimeFunction('SDL_gfx', false);
unexportedRuntimeFunction('GLUT', false);
unexportedRuntimeFunction('EGL', false);
unexportedRuntimeFunction('GLFW_Window', false);
unexportedRuntimeFunction('GLFW', false);
unexportedRuntimeFunction('GLEW', false);
unexportedRuntimeFunction('IDBStore', false);
unexportedRuntimeFunction('runAndAbortIfError', false);
unexportedRuntimeSymbol('ALLOC_NORMAL', false);
unexportedRuntimeSymbol('ALLOC_STACK', false);

var calledRun;

/**
 * @constructor
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}

var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

function stackCheckInit() {
  // This is normally called automatically during __wasm_call_ctors but need to
  // get these values before even running any of the ctors so we call it redundantly
  // here.
  _emscripten_stack_init();
  // TODO(sbc): Move writeStackCookie to native to to avoid this.
  writeStackCookie();
}

/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

    stackCheckInit();

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
  checkStackCookie();
}
Module['run'] = run;

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var oldOut = out;
  var oldErr = err;
  var has = false;
  out = err = (x) => {
    has = true;
  }
  try { // it doesn't matter if it fails
    flush_NO_FILESYSTEM();
  } catch(e) {}
  out = oldOut;
  err = oldErr;
  if (has) {
    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');
    warnOnce('(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)');
  }
}

/** @param {boolean|number=} implicit */
function exit(status, implicit) {
  EXITSTATUS = status;

  checkUnflushedContent();

  // if exit() was called explicitly, warn the user if the runtime isn't actually being shut down
  if (keepRuntimeAlive() && !implicit) {
    var msg = 'program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)';
    err(msg);
  }

  procExit(status);
}

function procExit(code) {
  EXITSTATUS = code;
  if (!keepRuntimeAlive()) {
    if (Module['onExit']) Module['onExit'](code);
    ABORT = true;
  }
  quit_(code, new ExitStatus(code));
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

run();





